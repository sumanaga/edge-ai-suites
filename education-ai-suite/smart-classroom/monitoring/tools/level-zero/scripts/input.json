{
    "configs": [
        {
            "name": "core",
            "namespace": "ze",
            "tags": {
                "$OneApi": "'oneAPI'",
                "$x": "ze"
            }
        },
        {
            "name": "tools",
            "namespace": "zet",
            "tags": {
                "$OneApi": "'oneAPI'",
                "$t": "zet",
                "$x": "ze"
            }
        },
        {
            "name": "sysman",
            "namespace": "zes",
            "tags": {
                "$OneApi": "'oneAPI'",
                "$s": "zes",
                "$x": "ze"
            }
        }
    ],
    "meta": {
        "callback": {
            "$x_rtas_geometry_aabbs_cb_exp_t": {
                "class": ""
            }
        },
        "class": {
            "$s": {
                "enum": [
                    "$s_init_flags_t"
                ],
                "function": [
                    "Init"
                ],
                "ordinal": 0
            },
            "$sDevice": {
                "enum": [
                    "$s_overclock_domain_t",
                    "$s_engine_type_flags_t",
                    "$s_repair_status_t",
                    "$s_reset_reason_flags_t",
                    "$s_reset_type_t",
                    "$s_device_type_t",
                    "$s_device_property_flags_t",
                    "$s_pci_link_status_t",
                    "$s_pci_link_qual_issue_flags_t",
                    "$s_pci_link_stab_issue_flags_t",
                    "$s_pci_bar_type_t",
                    "$s_device_ecc_state_t",
                    "$s_device_action_t",
                    "$s_freq_domain_t",
                    "$s_sched_mode_t"
                ],
                "function": [
                    "SetOverclockWaiver",
                    "GetOverclockDomains",
                    "GetOverclockControls",
                    "ResetOverclockSettings",
                    "ReadOverclockState",
                    "EnumOverclockDomains",
                    "Get",
                    "GetProperties",
                    "GetState",
                    "Reset",
                    "ResetExt",
                    "ProcessesGetState",
                    "PciGetProperties",
                    "PciGetState",
                    "PciGetBars",
                    "PciGetStats",
                    "EnumDiagnosticTestSuites",
                    "EccAvailable",
                    "EccConfigurable",
                    "GetEccState",
                    "SetEccState",
                    "EnumEngineGroups",
                    "EventRegister",
                    "EnumFabricPorts",
                    "EnumFans",
                    "EnumFirmwares",
                    "EnumFrequencyDomains",
                    "EnumLeds",
                    "EnumMemoryModules",
                    "EnumPerformanceFactorDomains",
                    "EnumPowerDomains",
                    "GetCardPowerDomain",
                    "EnumPsus",
                    "EnumRasErrorSets",
                    "EnumSchedulers",
                    "EnumStandbyDomains",
                    "EnumTemperatureSensors"
                ],
                "handle": [
                    "$s_device_handle_t"
                ],
                "members": [],
                "ordinal": 2,
                "owns": [
                    "$sOverclock",
                    "$sDiagnostics",
                    "$sEngine",
                    "$sFabricPort",
                    "$sFan",
                    "$sFirmware",
                    "$sFrequency",
                    "$sLed",
                    "$sMemory",
                    "$sPerformanceFactor",
                    "$sPower",
                    "$sPsu",
                    "$sRas",
                    "$sScheduler",
                    "$sStandby",
                    "$sTemperature"
                ],
                "struct": [
                    "$s_device_state_t",
                    "$s_reset_properties_t",
                    "$s_uuid_t",
                    "$s_device_properties_t",
                    "$s_device_ext_properties_t",
                    "$s_process_state_t",
                    "$s_pci_address_t",
                    "$s_pci_speed_t",
                    "$s_pci_properties_t",
                    "$s_pci_state_t",
                    "$s_pci_bar_properties_t",
                    "$s_pci_bar_properties_1_2_t",
                    "$s_pci_stats_t",
                    "$s_device_ecc_desc_t",
                    "$s_device_ecc_properties_t",
                    "$s_sched_timeout_properties_t",
                    "$s_sched_timeslice_properties_t"
                ]
            },
            "$sDiagnostics": {
                "enum": [
                    "$s_diag_result_t"
                ],
                "function": [
                    "GetProperties",
                    "GetTests",
                    "RunTests"
                ],
                "handle": [
                    "$s_diag_handle_t"
                ],
                "members": [
                    "$s_diag_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_diag_test_t",
                    "$s_diag_properties_t"
                ]
            },
            "$sDriver": {
                "enum": [
                    "$s_event_type_flags_t"
                ],
                "function": [
                    "Get",
                    "EventListen",
                    "EventListenEx"
                ],
                "handle": [
                    "$s_driver_handle_t"
                ],
                "members": [],
                "ordinal": 2
            },
            "$sEngine": {
                "enum": [
                    "$s_engine_group_t"
                ],
                "function": [
                    "GetProperties",
                    "GetActivity",
                    "GetActivityExt"
                ],
                "handle": [
                    "$s_engine_handle_t"
                ],
                "members": [
                    "$s_engine_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_engine_properties_t",
                    "$s_engine_stats_t",
                    "$s_engine_ext_properties_t"
                ]
            },
            "$sFabricPort": {
                "enum": [
                    "$s_fabric_port_status_t",
                    "$s_fabric_port_qual_issue_flags_t",
                    "$s_fabric_port_failure_flags_t"
                ],
                "function": [
                    "GetProperties",
                    "GetLinkType",
                    "GetConfig",
                    "SetConfig",
                    "GetState",
                    "GetThroughput",
                    "GetFabricErrorCounters",
                    "GetMultiPortThroughput"
                ],
                "handle": [
                    "$s_fabric_port_handle_t"
                ],
                "members": [
                    "$s_fabric_port_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_fabric_port_id_t",
                    "$s_fabric_port_speed_t",
                    "$s_fabric_port_properties_t",
                    "$s_fabric_link_type_t",
                    "$s_fabric_port_config_t",
                    "$s_fabric_port_state_t",
                    "$s_fabric_port_throughput_t",
                    "$s_fabric_port_error_counters_t"
                ]
            },
            "$sFan": {
                "enum": [
                    "$s_fan_speed_mode_t",
                    "$s_fan_speed_units_t"
                ],
                "function": [
                    "GetProperties",
                    "GetConfig",
                    "SetDefaultMode",
                    "SetFixedSpeedMode",
                    "SetSpeedTableMode",
                    "GetState"
                ],
                "handle": [
                    "$s_fan_handle_t"
                ],
                "members": [
                    "$s_fan_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_fan_speed_t",
                    "$s_fan_temp_speed_t",
                    "$s_fan_speed_table_t",
                    "$s_fan_properties_t",
                    "$s_fan_config_t"
                ]
            },
            "$sFirmware": {
                "function": [
                    "GetProperties",
                    "Flash"
                ],
                "handle": [
                    "$s_firmware_handle_t"
                ],
                "members": [
                    "$s_firmware_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_firmware_properties_t"
                ]
            },
            "$sFrequency": {
                "enum": [
                    "$s_freq_throttle_reason_flags_t",
                    "$s_oc_mode_t"
                ],
                "function": [
                    "GetProperties",
                    "GetAvailableClocks",
                    "GetRange",
                    "SetRange",
                    "GetState",
                    "GetThrottleTime",
                    "OcGetCapabilities",
                    "OcGetFrequencyTarget",
                    "OcSetFrequencyTarget",
                    "OcGetVoltageTarget",
                    "OcSetVoltageTarget",
                    "OcSetMode",
                    "OcGetMode",
                    "OcGetIccMax",
                    "OcSetIccMax",
                    "OcGetTjMax",
                    "OcSetTjMax"
                ],
                "handle": [
                    "$s_freq_handle_t"
                ],
                "members": [
                    "$s_freq_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_freq_properties_t",
                    "$s_freq_range_t",
                    "$s_freq_state_t",
                    "$s_freq_throttle_time_t",
                    "$s_oc_capabilities_t"
                ]
            },
            "$sLed": {
                "function": [
                    "GetProperties",
                    "GetState",
                    "SetState",
                    "SetColor"
                ],
                "handle": [
                    "$s_led_handle_t"
                ],
                "members": [
                    "$s_led_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_led_properties_t",
                    "$s_led_color_t",
                    "$s_led_state_t"
                ]
            },
            "$sMemory": {
                "enum": [
                    "$s_mem_type_t",
                    "$s_mem_loc_t",
                    "$s_mem_health_t"
                ],
                "function": [
                    "GetProperties",
                    "GetState",
                    "GetBandwidth"
                ],
                "handle": [
                    "$s_mem_handle_t"
                ],
                "members": [
                    "$s_mem_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_mem_properties_t",
                    "$s_mem_state_t",
                    "$s_mem_bandwidth_t",
                    "$s_mem_ext_bandwidth_t"
                ]
            },
            "$sOverclock": {
                "enum": [
                    "$s_overclock_control_t",
                    "$s_overclock_mode_t",
                    "$s_control_state_t",
                    "$s_pending_action_t",
                    "$s_vf_program_type_t",
                    "$s_vf_type_t",
                    "$s_vf_array_type_t"
                ],
                "function": [
                    "GetDomainProperties",
                    "GetDomainVFProperties",
                    "GetDomainControlProperties",
                    "GetControlCurrentValue",
                    "GetControlPendingValue",
                    "SetControlUserValue",
                    "GetControlState",
                    "GetVFPointValues",
                    "SetVFPointValues"
                ],
                "handle": [
                    "$s_overclock_handle_t"
                ],
                "members": [
                    "$s_overclock_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_overclock_properties_t",
                    "$s_control_property_t",
                    "$s_vf_property_t"
                ]
            },
            "$sPerformanceFactor": {
                "function": [
                    "GetProperties",
                    "GetConfig",
                    "SetConfig"
                ],
                "handle": [
                    "$s_perf_handle_t"
                ],
                "members": [
                    "$s_perf_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_perf_properties_t"
                ]
            },
            "$sPower": {
                "enum": [
                    "$s_power_domain_t",
                    "$s_power_level_t",
                    "$s_power_source_t",
                    "$s_limit_unit_t"
                ],
                "function": [
                    "GetProperties",
                    "GetEnergyCounter",
                    "GetLimits",
                    "SetLimits",
                    "GetEnergyThreshold",
                    "SetEnergyThreshold",
                    "GetLimitsExt",
                    "SetLimitsExt"
                ],
                "handle": [
                    "$s_pwr_handle_t"
                ],
                "members": [
                    "$s_pwr_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_power_properties_t",
                    "$s_power_energy_counter_t",
                    "$s_power_sustained_limit_t",
                    "$s_power_burst_limit_t",
                    "$s_power_peak_limit_t",
                    "$s_energy_threshold_t",
                    "$s_power_limit_ext_desc_t",
                    "$s_power_ext_properties_t"
                ]
            },
            "$sPsu": {
                "enum": [
                    "$s_psu_voltage_status_t"
                ],
                "function": [
                    "GetProperties",
                    "GetState"
                ],
                "handle": [
                    "$s_psu_handle_t"
                ],
                "members": [
                    "$s_psu_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_psu_properties_t",
                    "$s_psu_state_t"
                ]
            },
            "$sRas": {
                "enum": [
                    "$s_ras_error_type_t",
                    "$s_ras_error_cat_t",
                    "$s_ras_error_category_exp_t"
                ],
                "function": [
                    "GetProperties",
                    "GetConfig",
                    "SetConfig",
                    "GetState",
                    "GetStateExp",
                    "ClearStateExp"
                ],
                "handle": [
                    "$s_ras_handle_t"
                ],
                "members": [
                    "$s_ras_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_ras_properties_t",
                    "$s_ras_state_t",
                    "$s_ras_config_t",
                    "$s_ras_state_exp_t"
                ]
            },
            "$sScheduler": {
                "function": [
                    "GetProperties",
                    "GetCurrentMode",
                    "GetTimeoutModeProperties",
                    "GetTimesliceModeProperties",
                    "SetTimeoutMode",
                    "SetTimesliceMode",
                    "SetExclusiveMode",
                    "SetComputeUnitDebugMode"
                ],
                "handle": [
                    "$s_sched_handle_t"
                ],
                "members": [
                    "$s_sched_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_sched_properties_t"
                ]
            },
            "$sStandby": {
                "enum": [
                    "$s_standby_type_t",
                    "$s_standby_promo_mode_t"
                ],
                "function": [
                    "GetProperties",
                    "GetMode",
                    "SetMode"
                ],
                "handle": [
                    "$s_standby_handle_t"
                ],
                "members": [
                    "$s_standby_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_standby_properties_t"
                ]
            },
            "$sTemperature": {
                "enum": [
                    "$s_temp_sensors_t"
                ],
                "function": [
                    "GetProperties",
                    "GetConfig",
                    "SetConfig",
                    "GetState"
                ],
                "handle": [
                    "$s_temp_handle_t"
                ],
                "members": [
                    "$s_temp_handle_t",
                    "$sDevice*"
                ],
                "ordinal": 1000,
                "owner": "$sDevice",
                "struct": [
                    "$s_temp_properties_t",
                    "$s_temp_threshold_t",
                    "$s_temp_config_t"
                ]
            },
            "$tCommandList": {
                "function": [
                    "AppendMetricStreamerMarker",
                    "AppendMetricQueryBegin",
                    "AppendMetricQueryEnd",
                    "AppendMetricMemoryBarrier"
                ],
                "handle": [
                    "$t_command_list_handle_t"
                ],
                "members": [],
                "ordinal": 5
            },
            "$tContext": {
                "function": [
                    "ActivateMetricGroups"
                ],
                "handle": [
                    "$t_context_handle_t"
                ],
                "members": [],
                "ordinal": 3
            },
            "$tDebug": {
                "enum": [
                    "$t_debug_event_flags_t",
                    "$t_debug_event_type_t",
                    "$t_debug_detach_reason_t",
                    "$t_debug_page_fault_reason_t",
                    "$t_debug_memory_space_type_t",
                    "$t_debug_regset_flags_t"
                ],
                "function": [
                    "Attach",
                    "Detach",
                    "ReadEvent",
                    "AcknowledgeEvent",
                    "Interrupt",
                    "Resume",
                    "ReadMemory",
                    "WriteMemory",
                    "GetRegisterSetProperties",
                    "GetThreadRegisterSetProperties",
                    "ReadRegisters",
                    "WriteRegisters"
                ],
                "handle": [
                    "$t_debug_session_handle_t"
                ],
                "members": [
                    "$t_debug_session_handle_t"
                ],
                "ordinal": 1000,
                "struct": [
                    "$t_debug_config_t",
                    "$t_debug_event_info_detached_t",
                    "$t_debug_event_info_module_t",
                    "$t_debug_event_info_thread_stopped_t",
                    "$t_debug_event_info_page_fault_t",
                    "$t_debug_event_t",
                    "$t_debug_memory_space_desc_t",
                    "$t_debug_regset_properties_t"
                ],
                "union": [
                    "$t_debug_event_info_t"
                ]
            },
            "$tDevice": {
                "enum": [
                    "$t_device_debug_property_flags_t"
                ],
                "function": [
                    "GetDebugProperties"
                ],
                "handle": [
                    "$t_device_handle_t"
                ],
                "members": [],
                "ordinal": 2,
                "owns": [
                    "$tMetricGroup",
                    "$tMetricStreamer",
                    "$tMetricQueryPool",
                    "$tMetricQuery"
                ],
                "struct": [
                    "$t_device_debug_properties_t"
                ]
            },
            "$tDriver": {
                "handle": [
                    "$t_driver_handle_t"
                ],
                "members": [],
                "ordinal": 2,
                "owns": [
                    "$tTracerExp"
                ]
            },
            "$tKernel": {
                "enum": [
                    "$t_profile_flags_t",
                    "$t_profile_token_type_t"
                ],
                "function": [
                    "GetProfileInfo"
                ],
                "handle": [
                    "$t_kernel_handle_t"
                ],
                "members": [],
                "ordinal": 6,
                "struct": [
                    "$t_profile_properties_t",
                    "$t_profile_free_register_token_t",
                    "$t_profile_register_sequence_t"
                ]
            },
            "$tMetric": {
                "enum": [
                    "$t_metric_type_t"
                ],
                "function": [
                    "Get",
                    "GetProperties"
                ],
                "handle": [
                    "$t_metric_handle_t"
                ],
                "members": [
                    "$t_metric_handle_t",
                    "$tMetricGroup*"
                ],
                "ordinal": 1000,
                "owner": "$tMetricGroup",
                "struct": [
                    "$t_metric_global_timestamps_resolution_exp_t",
                    "$t_metric_properties_t",
                    "$t_metric_calculate_exp_desc_t"
                ]
            },
            "$tMetricGroup": {
                "enum": [
                    "$t_metric_group_sampling_type_flags_t",
                    "$t_metric_group_calculation_type_t"
                ],
                "function": [
                    "GetGlobalTimestampsExp",
                    "Get",
                    "GetProperties",
                    "CalculateMetricValues",
                    "GetExportDataExp",
                    "CalculateMetricExportDataExp",
                    "CalculateMultipleMetricValuesExp"
                ],
                "handle": [
                    "$t_metric_group_handle_t"
                ],
                "members": [
                    "$t_metric_group_handle_t",
                    "$tDevice*"
                ],
                "ordinal": 1000,
                "owner": "$tDevice",
                "owns": [
                    "$tMetric"
                ],
                "struct": [
                    "$t_metric_group_properties_t"
                ]
            },
            "$tMetricQuery": {
                "function": [
                    "Create",
                    "Destroy",
                    "Reset",
                    "GetData"
                ],
                "handle": [
                    "$t_metric_query_handle_t"
                ],
                "members": [
                    "$t_metric_query_handle_t",
                    "$tDevice*"
                ],
                "ordinal": 1000,
                "owner": "$tDevice"
            },
            "$tMetricQueryPool": {
                "enum": [
                    "$t_metric_query_pool_type_t"
                ],
                "function": [
                    "Create",
                    "Destroy"
                ],
                "handle": [
                    "$t_metric_query_pool_handle_t"
                ],
                "members": [
                    "$t_metric_query_pool_handle_t",
                    "$tDevice*",
                    "$t_metric_query_pool_desc_t"
                ],
                "ordinal": 1000,
                "owner": "$tDevice",
                "struct": [
                    "$t_metric_query_pool_desc_t"
                ]
            },
            "$tMetricStreamer": {
                "function": [
                    "Open",
                    "Close",
                    "ReadData"
                ],
                "handle": [
                    "$t_metric_streamer_handle_t"
                ],
                "members": [
                    "$t_metric_streamer_handle_t",
                    "$tDevice*",
                    "$t_metric_streamer_desc_t"
                ],
                "ordinal": 1000,
                "owner": "$tDevice",
                "struct": [
                    "$t_metric_streamer_desc_t"
                ]
            },
            "$tModule": {
                "enum": [
                    "$t_module_debug_info_format_t"
                ],
                "function": [
                    "GetDebugInfo"
                ],
                "handle": [
                    "$t_module_handle_t"
                ],
                "members": [],
                "ordinal": 6
            },
            "$tTracerExp": {
                "function": [
                    "Create",
                    "Destroy",
                    "SetPrologues",
                    "SetEpilogues",
                    "SetEnabled"
                ],
                "handle": [
                    "$t_tracer_exp_handle_t"
                ],
                "members": [
                    "$t_tracer_exp_handle_t",
                    "$tDriver*",
                    "$t_tracer_exp_desc_t"
                ],
                "ordinal": 1000,
                "owner": "$tDriver",
                "struct": [
                    "$t_tracer_exp_desc_t"
                ],
                "typedef": [
                    "$t_core_callbacks_t"
                ]
            },
            "$x": {
                "enum": [
                    "$x_init_flags_t"
                ],
                "function": [
                    "Init"
                ],
                "ordinal": 0
            },
            "$xCommandList": {
                "child": [
                    "$tCommandList"
                ],
                "enum": [
                    "$x_command_list_flags_t",
                    "$x_memory_advice_t"
                ],
                "function": [
                    "AppendBarrier",
                    "AppendMemoryRangesBarrier",
                    "Create",
                    "CreateImmediate",
                    "Destroy",
                    "Close",
                    "Reset",
                    "AppendWriteGlobalTimestamp",
                    "HostSynchronize",
                    "AppendMemoryCopy",
                    "AppendMemoryFill",
                    "AppendMemoryCopyRegion",
                    "AppendMemoryCopyFromContext",
                    "AppendImageCopy",
                    "AppendImageCopyRegion",
                    "AppendImageCopyToMemory",
                    "AppendImageCopyFromMemory",
                    "AppendMemoryPrefetch",
                    "AppendMemAdvise",
                    "AppendSignalEvent",
                    "AppendWaitOnEvents",
                    "AppendEventReset",
                    "AppendQueryKernelTimestamps",
                    "AppendImageCopyToMemoryExt",
                    "AppendImageCopyFromMemoryExt",
                    "AppendLaunchKernel",
                    "AppendLaunchCooperativeKernel",
                    "AppendLaunchKernelIndirect",
                    "AppendLaunchMultipleKernelsIndirect"
                ],
                "handle": [
                    "$x_command_list_handle_t"
                ],
                "members": [
                    "$x_command_list_handle_t",
                    "$xDevice*",
                    "$x_command_list_desc_t"
                ],
                "ordinal": 5,
                "owner": "$xDevice",
                "struct": [
                    "$x_command_list_desc_t",
                    "$x_copy_region_t",
                    "$x_image_region_t",
                    "$x_group_count_t"
                ]
            },
            "$xCommandQueue": {
                "enum": [
                    "$x_command_queue_flags_t",
                    "$x_command_queue_mode_t",
                    "$x_command_queue_priority_t"
                ],
                "function": [
                    "Create",
                    "Destroy",
                    "ExecuteCommandLists",
                    "Synchronize"
                ],
                "handle": [
                    "$x_command_queue_handle_t"
                ],
                "members": [
                    "$x_command_queue_handle_t",
                    "$xDevice*",
                    "$x_command_queue_desc_t"
                ],
                "ordinal": 4,
                "owner": "$xDevice",
                "owns": [
                    "$xFence"
                ],
                "struct": [
                    "$x_copy_bandwidth_exp_properties_t",
                    "$x_command_queue_desc_t"
                ]
            },
            "$xContext": {
                "child": [
                    "$tContext"
                ],
                "enum": [
                    "$x_context_flags_t",
                    "$x_power_saving_hint_type_t",
                    "$x_device_raytracing_ext_flags_t",
                    "$x_raytracing_mem_alloc_ext_flags_t"
                ],
                "function": [
                    "SystemBarrier",
                    "Create",
                    "CreateEx",
                    "Destroy",
                    "GetStatus",
                    "MakeMemoryResident",
                    "EvictMemory",
                    "MakeImageResident",
                    "EvictImage"
                ],
                "handle": [
                    "$x_context_handle_t"
                ],
                "members": [
                    "$x_context_handle_t",
                    "$xDriver*"
                ],
                "ordinal": 3,
                "owner": "$xDriver",
                "owns": [
                    "$xEventPool",
                    "$xMem",
                    "$xVirtualMem",
                    "$xPhysicalMem"
                ],
                "struct": [
                    "$x_context_desc_t",
                    "$x_context_power_saving_hint_exp_desc_t",
                    "$x_device_raytracing_ext_properties_t",
                    "$x_raytracing_mem_alloc_ext_desc_t"
                ]
            },
            "$xDevice": {
                "child": [
                    "$tDevice",
                    "$sDevice"
                ],
                "enum": [
                    "$x_rtas_device_exp_flags_t",
                    "$x_rtas_format_exp_t",
                    "$x_cache_ext_region_t",
                    "$x_device_type_t",
                    "$x_device_property_flags_t",
                    "$x_device_module_flags_t",
                    "$x_device_fp_flags_t",
                    "$x_command_queue_group_property_flags_t",
                    "$x_device_memory_property_flags_t",
                    "$x_memory_access_cap_flags_t",
                    "$x_device_cache_property_flags_t",
                    "$x_device_p2p_property_flags_t",
                    "$x_device_fp_atomic_ext_flags_t",
                    "$x_device_memory_ext_type_t"
                ],
                "function": [
                    "PciGetPropertiesExt",
                    "ReserveCacheExt",
                    "SetCacheAdviceExt",
                    "Get",
                    "GetRootDevice",
                    "GetSubDevices",
                    "GetProperties",
                    "GetComputeProperties",
                    "GetModuleProperties",
                    "GetCommandQueueGroupProperties",
                    "GetMemoryProperties",
                    "GetMemoryAccessProperties",
                    "GetCacheProperties",
                    "GetImageProperties",
                    "GetExternalMemoryProperties",
                    "GetP2PProperties",
                    "CanAccessPeer",
                    "GetStatus",
                    "GetGlobalTimestamps",
                    "GetFabricVertexExp"
                ],
                "handle": [
                    "$x_device_handle_t"
                ],
                "members": [
                    "$x_device_handle_t",
                    "$xDriver*"
                ],
                "ordinal": 2,
                "owner": "$xDriver",
                "owns": [
                    "$xCommandList",
                    "$xCommandQueue",
                    "$xImage",
                    "$xModule",
                    "$xSampler"
                ],
                "struct": [
                    "$x_eu_count_ext_t",
                    "$x_pci_address_ext_t",
                    "$x_pci_speed_ext_t",
                    "$x_pci_ext_properties_t",
                    "$x_rtas_device_exp_properties_t",
                    "$x_device_p2p_bandwidth_exp_properties_t",
                    "$x_cache_reservation_ext_desc_t",
                    "$x_device_properties_t",
                    "$x_device_thread_t",
                    "$x_device_compute_properties_t",
                    "$x_native_kernel_uuid_t",
                    "$x_device_module_properties_t",
                    "$x_command_queue_group_properties_t",
                    "$x_device_memory_properties_t",
                    "$x_device_memory_access_properties_t",
                    "$x_device_cache_properties_t",
                    "$x_device_image_properties_t",
                    "$x_device_external_memory_properties_t",
                    "$x_device_p2p_properties_t",
                    "$x_device_luid_ext_properties_t",
                    "$x_device_ip_version_ext_t",
                    "$x_float_atomic_ext_properties_t",
                    "$x_scheduling_hint_exp_properties_t",
                    "$x_device_memory_ext_properties_t"
                ]
            },
            "$xDriver": {
                "child": [
                    "$tDriver",
                    "$sDriver"
                ],
                "enum": [
                    "$x_api_version_t",
                    "$x_ipc_property_flags_t",
                    "$x_driver_memory_free_policy_ext_flags_t"
                ],
                "function": [
                    "RTASFormatCompatibilityCheckExp",
                    "Get",
                    "GetApiVersion",
                    "GetProperties",
                    "GetIpcProperties",
                    "GetExtensionProperties",
                    "GetExtensionFunctionAddress",
                    "GetLastErrorDescription"
                ],
                "handle": [
                    "$x_driver_handle_t"
                ],
                "members": [
                    "$x_driver_handle_t"
                ],
                "ordinal": 1,
                "owns": [
                    "$xContext",
                    "$xDevice",
                    "$xFabricVertex",
                    "$xFabricEdge"
                ],
                "struct": [
                    "$x_driver_properties_t",
                    "$x_driver_ipc_properties_t",
                    "$x_driver_extension_properties_t",
                    "$x_driver_memory_free_ext_properties_t"
                ]
            },
            "$xEvent": {
                "enum": [
                    "$x_event_scope_flags_t",
                    "$x_event_query_kernel_timestamps_ext_flags_t"
                ],
                "function": [
                    "Create",
                    "Destroy",
                    "HostSignal",
                    "HostSynchronize",
                    "QueryStatus",
                    "HostReset",
                    "QueryKernelTimestamp",
                    "QueryKernelTimestampsExt",
                    "QueryTimestampsExp"
                ],
                "handle": [
                    "$x_event_handle_t"
                ],
                "members": [
                    "$x_event_handle_t",
                    "$xEventPool*",
                    "$x_event_desc_t"
                ],
                "ordinal": 1000,
                "owner": "$xEventPool",
                "struct": [
                    "$x_event_desc_t",
                    "$x_kernel_timestamp_data_t",
                    "$x_kernel_timestamp_result_t",
                    "$x_synchronized_timestamp_data_ext_t",
                    "$x_synchronized_timestamp_result_ext_t"
                ]
            },
            "$xEventPool": {
                "enum": [
                    "$x_event_pool_flags_t"
                ],
                "function": [
                    "Create",
                    "Destroy",
                    "GetIpcHandle",
                    "PutIpcHandle",
                    "OpenIpcHandle",
                    "CloseIpcHandle"
                ],
                "handle": [
                    "$x_event_pool_handle_t"
                ],
                "members": [
                    "$x_event_pool_handle_t",
                    "$xContext*",
                    "$x_event_pool_desc_t"
                ],
                "ordinal": 1000,
                "owner": "$xContext",
                "owns": [
                    "$xEvent"
                ],
                "struct": [
                    "$x_event_pool_desc_t"
                ]
            },
            "$xFabricEdge": {
                "enum": [
                    "$x_fabric_edge_exp_duplexity_t"
                ],
                "function": [
                    "GetExp",
                    "GetVerticesExp",
                    "GetPropertiesExp"
                ],
                "handle": [
                    "$x_fabric_edge_handle_t"
                ],
                "members": [
                    "$x_fabric_edge_handle_t",
                    "$xDriver*"
                ],
                "ordinal": 1400,
                "owner": "$xDriver",
                "struct": [
                    "$x_fabric_edge_exp_properties_t"
                ]
            },
            "$xFabricVertex": {
                "enum": [
                    "$x_fabric_vertex_exp_type_t"
                ],
                "function": [
                    "GetExp",
                    "GetSubVerticesExp",
                    "GetPropertiesExp",
                    "GetDeviceExp"
                ],
                "handle": [
                    "$x_fabric_vertex_handle_t"
                ],
                "members": [
                    "$x_fabric_vertex_handle_t",
                    "$xDriver*"
                ],
                "ordinal": 1400,
                "owner": "$xDriver",
                "struct": [
                    "$x_fabric_vertex_pci_exp_address_t",
                    "$x_fabric_vertex_exp_properties_t"
                ]
            },
            "$xFence": {
                "enum": [
                    "$x_fence_flags_t"
                ],
                "function": [
                    "Create",
                    "Destroy",
                    "HostSynchronize",
                    "QueryStatus",
                    "Reset"
                ],
                "handle": [
                    "$x_fence_handle_t"
                ],
                "members": [
                    "$x_fence_handle_t",
                    "$xCommandQueue*",
                    "$x_fence_desc_t"
                ],
                "ordinal": 1000,
                "owner": "$xCommandQueue",
                "struct": [
                    "$x_fence_desc_t"
                ]
            },
            "$xImage": {
                "enum": [
                    "$x_image_flags_t",
                    "$x_image_type_t",
                    "$x_image_format_layout_t",
                    "$x_image_format_type_t",
                    "$x_image_format_swizzle_t",
                    "$x_image_sampler_filter_flags_t"
                ],
                "function": [
                    "GetProperties",
                    "Create",
                    "Destroy",
                    "GetAllocPropertiesExt",
                    "GetMemoryPropertiesExp",
                    "ViewCreateExt",
                    "ViewCreateExp"
                ],
                "handle": [
                    "$x_image_handle_t"
                ],
                "members": [
                    "$x_image_handle_t",
                    "$xDevice*",
                    "$x_image_desc_t"
                ],
                "ordinal": 1000,
                "owner": "$xDevice",
                "struct": [
                    "$x_srgb_ext_desc_t",
                    "$x_image_format_t",
                    "$x_image_desc_t",
                    "$x_image_properties_t",
                    "$x_image_allocation_ext_properties_t",
                    "$x_image_memory_properties_exp_t",
                    "$x_image_view_planar_ext_desc_t",
                    "$x_image_view_planar_exp_desc_t"
                ]
            },
            "$xKernel": {
                "child": [
                    "$tKernel"
                ],
                "enum": [
                    "$x_scheduling_hint_exp_flags_t",
                    "$x_kernel_flags_t",
                    "$x_kernel_indirect_access_flags_t",
                    "$x_cache_config_flags_t"
                ],
                "function": [
                    "SetGlobalOffsetExp",
                    "SchedulingHintExp",
                    "Create",
                    "Destroy",
                    "SetGroupSize",
                    "SuggestGroupSize",
                    "SuggestMaxCooperativeGroupCount",
                    "SetArgumentValue",
                    "SetIndirectAccess",
                    "GetIndirectAccess",
                    "GetSourceAttributes",
                    "SetCacheConfig",
                    "GetProperties",
                    "GetName"
                ],
                "handle": [
                    "$x_kernel_handle_t"
                ],
                "members": [
                    "$x_kernel_handle_t",
                    "$xModule*",
                    "$x_kernel_desc_t"
                ],
                "ordinal": 1000,
                "owner": "$xModule",
                "struct": [
                    "$x_kernel_max_group_size_properties_ext_t",
                    "$x_scheduling_hint_exp_desc_t",
                    "$x_kernel_desc_t",
                    "$x_kernel_properties_t",
                    "$x_kernel_preferred_group_size_properties_t"
                ]
            },
            "$xMem": {
                "enum": [
                    "$x_device_mem_alloc_flags_t",
                    "$x_host_mem_alloc_flags_t",
                    "$x_memory_type_t",
                    "$x_ipc_memory_flags_t",
                    "$x_memory_atomic_attr_exp_flags_t",
                    "$x_memory_compression_hints_ext_flags_t",
                    "$x_relaxed_allocation_limits_exp_flags_t"
                ],
                "function": [
                    "AllocShared",
                    "AllocDevice",
                    "AllocHost",
                    "Free",
                    "GetAllocProperties",
                    "GetAddressRange",
                    "GetIpcHandle",
                    "GetIpcHandleFromFileDescriptorExp",
                    "GetFileDescriptorFromIpcHandleExp",
                    "PutIpcHandle",
                    "OpenIpcHandle",
                    "CloseIpcHandle",
                    "SetAtomicAccessAttributeExp",
                    "GetAtomicAccessAttributeExp",
                    "FreeExt"
                ],
                "members": [],
                "ordinal": 1000,
                "owner": "$xContext",
                "struct": [
                    "$x_device_mem_alloc_desc_t",
                    "$x_host_mem_alloc_desc_t",
                    "$x_memory_allocation_properties_t",
                    "$x_external_memory_export_desc_t",
                    "$x_external_memory_import_fd_t",
                    "$x_external_memory_export_fd_t",
                    "$x_external_memory_import_win32_handle_t",
                    "$x_external_memory_export_win32_handle_t",
                    "$x_memory_compression_hints_ext_desc_t",
                    "$x_memory_free_ext_desc_t",
                    "$x_relaxed_allocation_limits_exp_desc_t",
                    "$x_sub_allocation_t",
                    "$x_memory_sub_allocations_exp_properties_t"
                ]
            },
            "$xModule": {
                "child": [
                    "$tModule"
                ],
                "enum": [
                    "$x_linkage_inspection_ext_flags_t",
                    "$x_module_format_t",
                    "$x_module_property_flags_t"
                ],
                "function": [
                    "InspectLinkageExt",
                    "Create",
                    "Destroy",
                    "DynamicLink",
                    "GetNativeBinary",
                    "GetGlobalPointer",
                    "GetKernelNames",
                    "GetProperties",
                    "GetFunctionPointer"
                ],
                "handle": [
                    "$x_module_handle_t"
                ],
                "members": [
                    "$x_module_handle_t",
                    "$xDevice*",
                    "$x_module_desc_t"
                ],
                "ordinal": 1000,
                "owner": "$xDevice",
                "owns": [
                    "$xModuleBuildLog",
                    "$xKernel"
                ],
                "struct": [
                    "$x_linkage_inspection_ext_desc_t",
                    "$x_module_constants_t",
                    "$x_module_desc_t",
                    "$x_module_properties_t",
                    "$x_module_program_exp_desc_t"
                ]
            },
            "$xModuleBuildLog": {
                "function": [
                    "Destroy",
                    "GetString"
                ],
                "handle": [
                    "$x_module_build_log_handle_t"
                ],
                "members": [
                    "$x_module_build_log_handle_t",
                    "$xModule*"
                ],
                "ordinal": 1000,
                "owner": "$xModule"
            },
            "$xPhysicalMem": {
                "enum": [
                    "$x_physical_mem_flags_t"
                ],
                "function": [
                    "Create",
                    "Destroy"
                ],
                "handle": [
                    "$x_physical_mem_handle_t"
                ],
                "members": [
                    "$x_physical_mem_handle_t",
                    "$xContext*",
                    "$x_physical_mem_desc_t"
                ],
                "ordinal": 1000,
                "owner": "$xContext",
                "struct": [
                    "$x_physical_mem_desc_t"
                ]
            },
            "$xRTASBuilder": {
                "enum": [
                    "$x_rtas_builder_exp_flags_t",
                    "$x_rtas_builder_geometry_exp_flags_t",
                    "$x_rtas_builder_instance_exp_flags_t",
                    "$x_rtas_builder_build_op_exp_flags_t",
                    "$x_rtas_builder_build_quality_hint_exp_t",
                    "$x_rtas_builder_geometry_type_exp_t",
                    "$x_rtas_builder_input_data_format_exp_t"
                ],
                "function": [
                    "CreateExp",
                    "GetBuildPropertiesExp",
                    "BuildExp",
                    "DestroyExp"
                ],
                "handle": [
                    "$x_rtas_builder_exp_handle_t"
                ],
                "ordinal": 0,
                "struct": [
                    "$x_rtas_builder_exp_desc_t",
                    "$x_rtas_builder_exp_properties_t",
                    "$x_rtas_builder_geometry_info_exp_t",
                    "$x_rtas_builder_triangles_geometry_info_exp_t",
                    "$x_rtas_builder_quads_geometry_info_exp_t",
                    "$x_rtas_builder_procedural_geometry_info_exp_t",
                    "$x_rtas_builder_instance_geometry_info_exp_t",
                    "$x_rtas_builder_build_op_exp_desc_t"
                ],
                "typedef": [
                    "$x_rtas_builder_packed_geometry_exp_flags_t",
                    "$x_rtas_builder_packed_instance_exp_flags_t",
                    "$x_rtas_builder_packed_geometry_type_exp_t",
                    "$x_rtas_builder_packed_input_data_format_exp_t"
                ]
            },
            "$xRTASParallelOperation": {
                "enum": [
                    "$x_rtas_parallel_operation_exp_flags_t"
                ],
                "function": [
                    "CreateExp",
                    "GetPropertiesExp",
                    "JoinExp",
                    "DestroyExp"
                ],
                "handle": [
                    "$x_rtas_parallel_operation_exp_handle_t"
                ],
                "ordinal": 0,
                "struct": [
                    "$x_rtas_parallel_operation_exp_properties_t"
                ]
            },
            "$xSampler": {
                "enum": [
                    "$x_sampler_address_mode_t",
                    "$x_sampler_filter_mode_t"
                ],
                "function": [
                    "Create",
                    "Destroy"
                ],
                "handle": [
                    "$x_sampler_handle_t"
                ],
                "members": [
                    "$x_sampler_handle_t",
                    "$xDevice*",
                    "$x_sampler_desc_t"
                ],
                "ordinal": 1000,
                "owner": "$xDevice",
                "struct": [
                    "$x_sampler_desc_t"
                ]
            },
            "$xVirtualMem": {
                "enum": [
                    "$x_memory_access_attribute_t"
                ],
                "function": [
                    "Reserve",
                    "Free",
                    "QueryPageSize",
                    "Map",
                    "Unmap",
                    "SetAccessAttribute",
                    "GetAccessAttribute"
                ],
                "members": [],
                "ordinal": 1000,
                "owner": "$xContext"
            }
        },
        "enum": {
            "$s_control_state_t": {
                "class": "$sOverclock",
                "etors": [
                    "$S_CONTROL_STATE_STATE_UNSET",
                    "$S_CONTROL_STATE_STATE_ACTIVE",
                    "$S_CONTROL_STATE_STATE_DISABLED"
                ],
                "max": "$S_CONTROL_STATE_STATE_DISABLED"
            },
            "$s_device_action_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_DEVICE_ACTION_NONE",
                    "$S_DEVICE_ACTION_WARM_CARD_RESET",
                    "$S_DEVICE_ACTION_COLD_CARD_RESET",
                    "$S_DEVICE_ACTION_COLD_SYSTEM_REBOOT"
                ],
                "max": "$S_DEVICE_ACTION_COLD_SYSTEM_REBOOT"
            },
            "$s_device_ecc_state_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_DEVICE_ECC_STATE_UNAVAILABLE",
                    "$S_DEVICE_ECC_STATE_ENABLED",
                    "$S_DEVICE_ECC_STATE_DISABLED"
                ],
                "max": "$S_DEVICE_ECC_STATE_DISABLED"
            },
            "$s_device_property_flags_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_DEVICE_PROPERTY_FLAG_INTEGRATED",
                    "$S_DEVICE_PROPERTY_FLAG_SUBDEVICE",
                    "$S_DEVICE_PROPERTY_FLAG_ECC",
                    "$S_DEVICE_PROPERTY_FLAG_ONDEMANDPAGING"
                ],
                "max": "0xf"
            },
            "$s_device_type_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_DEVICE_TYPE_GPU",
                    "$S_DEVICE_TYPE_CPU",
                    "$S_DEVICE_TYPE_FPGA",
                    "$S_DEVICE_TYPE_MCA",
                    "$S_DEVICE_TYPE_VPU"
                ],
                "max": "$S_DEVICE_TYPE_VPU"
            },
            "$s_diag_result_t": {
                "class": "$sDiagnostics",
                "etors": [
                    "$S_DIAG_RESULT_NO_ERRORS",
                    "$S_DIAG_RESULT_ABORT",
                    "$S_DIAG_RESULT_FAIL_CANT_REPAIR",
                    "$S_DIAG_RESULT_REBOOT_FOR_REPAIR"
                ],
                "max": "$S_DIAG_RESULT_REBOOT_FOR_REPAIR"
            },
            "$s_engine_activity_ext_version_t": {
                "class": "",
                "etors": [
                    "$S_ENGINE_ACTIVITY_EXT_VERSION_1_0",
                    "$S_ENGINE_ACTIVITY_EXT_VERSION_CURRENT"
                ],
                "max": "$S_ENGINE_ACTIVITY_EXT_VERSION_CURRENT"
            },
            "$s_engine_group_t": {
                "class": "$sEngine",
                "etors": [
                    "$S_ENGINE_GROUP_ALL",
                    "$S_ENGINE_GROUP_COMPUTE_ALL",
                    "$S_ENGINE_GROUP_MEDIA_ALL",
                    "$S_ENGINE_GROUP_COPY_ALL",
                    "$S_ENGINE_GROUP_COMPUTE_SINGLE",
                    "$S_ENGINE_GROUP_RENDER_SINGLE",
                    "$S_ENGINE_GROUP_MEDIA_DECODE_SINGLE",
                    "$S_ENGINE_GROUP_MEDIA_ENCODE_SINGLE",
                    "$S_ENGINE_GROUP_COPY_SINGLE",
                    "$S_ENGINE_GROUP_MEDIA_ENHANCEMENT_SINGLE",
                    "$S_ENGINE_GROUP_3D_SINGLE",
                    "$S_ENGINE_GROUP_3D_RENDER_COMPUTE_ALL",
                    "$S_ENGINE_GROUP_RENDER_ALL",
                    "$S_ENGINE_GROUP_3D_ALL"
                ],
                "max": "$S_ENGINE_GROUP_3D_ALL"
            },
            "$s_engine_type_flags_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_ENGINE_TYPE_FLAG_OTHER",
                    "$S_ENGINE_TYPE_FLAG_COMPUTE",
                    "$S_ENGINE_TYPE_FLAG_3D",
                    "$S_ENGINE_TYPE_FLAG_MEDIA",
                    "$S_ENGINE_TYPE_FLAG_DMA",
                    "$S_ENGINE_TYPE_FLAG_RENDER"
                ],
                "max": "0x3f"
            },
            "$s_event_type_flags_t": {
                "class": "$sDriver",
                "etors": [
                    "$S_EVENT_TYPE_FLAG_DEVICE_DETACH",
                    "$S_EVENT_TYPE_FLAG_DEVICE_ATTACH",
                    "$S_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_ENTER",
                    "$S_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_EXIT",
                    "$S_EVENT_TYPE_FLAG_FREQ_THROTTLED",
                    "$S_EVENT_TYPE_FLAG_ENERGY_THRESHOLD_CROSSED",
                    "$S_EVENT_TYPE_FLAG_TEMP_CRITICAL",
                    "$S_EVENT_TYPE_FLAG_TEMP_THRESHOLD1",
                    "$S_EVENT_TYPE_FLAG_TEMP_THRESHOLD2",
                    "$S_EVENT_TYPE_FLAG_MEM_HEALTH",
                    "$S_EVENT_TYPE_FLAG_FABRIC_PORT_HEALTH",
                    "$S_EVENT_TYPE_FLAG_PCI_LINK_HEALTH",
                    "$S_EVENT_TYPE_FLAG_RAS_CORRECTABLE_ERRORS",
                    "$S_EVENT_TYPE_FLAG_RAS_UNCORRECTABLE_ERRORS",
                    "$S_EVENT_TYPE_FLAG_DEVICE_RESET_REQUIRED"
                ],
                "max": "0x7fff"
            },
            "$s_fabric_port_failure_flags_t": {
                "class": "$sFabricPort",
                "etors": [
                    "$S_FABRIC_PORT_FAILURE_FLAG_FAILED",
                    "$S_FABRIC_PORT_FAILURE_FLAG_TRAINING_TIMEOUT",
                    "$S_FABRIC_PORT_FAILURE_FLAG_FLAPPING"
                ],
                "max": "0x7"
            },
            "$s_fabric_port_qual_issue_flags_t": {
                "class": "$sFabricPort",
                "etors": [
                    "$S_FABRIC_PORT_QUAL_ISSUE_FLAG_LINK_ERRORS",
                    "$S_FABRIC_PORT_QUAL_ISSUE_FLAG_SPEED"
                ],
                "max": "0x3"
            },
            "$s_fabric_port_status_t": {
                "class": "$sFabricPort",
                "etors": [
                    "$S_FABRIC_PORT_STATUS_UNKNOWN",
                    "$S_FABRIC_PORT_STATUS_HEALTHY",
                    "$S_FABRIC_PORT_STATUS_DEGRADED",
                    "$S_FABRIC_PORT_STATUS_FAILED",
                    "$S_FABRIC_PORT_STATUS_DISABLED"
                ],
                "max": "$S_FABRIC_PORT_STATUS_DISABLED"
            },
            "$s_fan_speed_mode_t": {
                "class": "$sFan",
                "etors": [
                    "$S_FAN_SPEED_MODE_DEFAULT",
                    "$S_FAN_SPEED_MODE_FIXED",
                    "$S_FAN_SPEED_MODE_TABLE"
                ],
                "max": "$S_FAN_SPEED_MODE_TABLE"
            },
            "$s_fan_speed_units_t": {
                "class": "$sFan",
                "etors": [
                    "$S_FAN_SPEED_UNITS_RPM",
                    "$S_FAN_SPEED_UNITS_PERCENT"
                ],
                "max": "$S_FAN_SPEED_UNITS_PERCENT"
            },
            "$s_freq_domain_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_FREQ_DOMAIN_GPU",
                    "$S_FREQ_DOMAIN_MEMORY",
                    "$S_FREQ_DOMAIN_MEDIA"
                ],
                "max": "$S_FREQ_DOMAIN_MEDIA"
            },
            "$s_freq_throttle_reason_flags_t": {
                "class": "$sFrequency",
                "etors": [
                    "$S_FREQ_THROTTLE_REASON_FLAG_AVE_PWR_CAP",
                    "$S_FREQ_THROTTLE_REASON_FLAG_BURST_PWR_CAP",
                    "$S_FREQ_THROTTLE_REASON_FLAG_CURRENT_LIMIT",
                    "$S_FREQ_THROTTLE_REASON_FLAG_THERMAL_LIMIT",
                    "$S_FREQ_THROTTLE_REASON_FLAG_PSU_ALERT",
                    "$S_FREQ_THROTTLE_REASON_FLAG_SW_RANGE",
                    "$S_FREQ_THROTTLE_REASON_FLAG_HW_RANGE"
                ],
                "max": "0x7f"
            },
            "$s_init_flags_t": {
                "class": "$s",
                "etors": [
                    "$S_INIT_FLAG_PLACEHOLDER"
                ],
                "max": "0x1"
            },
            "$s_limit_unit_t": {
                "class": "$sPower",
                "etors": [
                    "$S_LIMIT_UNIT_UNKNOWN",
                    "$S_LIMIT_UNIT_CURRENT",
                    "$S_LIMIT_UNIT_POWER"
                ],
                "max": "$S_LIMIT_UNIT_POWER"
            },
            "$s_mem_health_t": {
                "class": "$sMemory",
                "etors": [
                    "$S_MEM_HEALTH_UNKNOWN",
                    "$S_MEM_HEALTH_OK",
                    "$S_MEM_HEALTH_DEGRADED",
                    "$S_MEM_HEALTH_CRITICAL",
                    "$S_MEM_HEALTH_REPLACE"
                ],
                "max": "$S_MEM_HEALTH_REPLACE"
            },
            "$s_mem_loc_t": {
                "class": "$sMemory",
                "etors": [
                    "$S_MEM_LOC_SYSTEM",
                    "$S_MEM_LOC_DEVICE"
                ],
                "max": "$S_MEM_LOC_DEVICE"
            },
            "$s_mem_type_t": {
                "class": "$sMemory",
                "etors": [
                    "$S_MEM_TYPE_HBM",
                    "$S_MEM_TYPE_DDR",
                    "$S_MEM_TYPE_DDR3",
                    "$S_MEM_TYPE_DDR4",
                    "$S_MEM_TYPE_DDR5",
                    "$S_MEM_TYPE_LPDDR",
                    "$S_MEM_TYPE_LPDDR3",
                    "$S_MEM_TYPE_LPDDR4",
                    "$S_MEM_TYPE_LPDDR5",
                    "$S_MEM_TYPE_SRAM",
                    "$S_MEM_TYPE_L1",
                    "$S_MEM_TYPE_L3",
                    "$S_MEM_TYPE_GRF",
                    "$S_MEM_TYPE_SLM",
                    "$S_MEM_TYPE_GDDR4",
                    "$S_MEM_TYPE_GDDR5",
                    "$S_MEM_TYPE_GDDR5X",
                    "$S_MEM_TYPE_GDDR6",
                    "$S_MEM_TYPE_GDDR6X",
                    "$S_MEM_TYPE_GDDR7"
                ],
                "max": "$S_MEM_TYPE_GDDR7"
            },
            "$s_oc_mode_t": {
                "class": "$sFrequency",
                "etors": [
                    "$S_OC_MODE_OFF",
                    "$S_OC_MODE_OVERRIDE",
                    "$S_OC_MODE_INTERPOLATIVE",
                    "$S_OC_MODE_FIXED"
                ],
                "max": "$S_OC_MODE_FIXED"
            },
            "$s_overclock_control_t": {
                "class": "$sOverclock",
                "etors": [
                    "$S_OVERCLOCK_CONTROL_VF",
                    "$S_OVERCLOCK_CONTROL_FREQ_OFFSET",
                    "$S_OVERCLOCK_CONTROL_VMAX_OFFSET",
                    "$S_OVERCLOCK_CONTROL_FREQ",
                    "$S_OVERCLOCK_CONTROL_VOLT_LIMIT",
                    "$S_OVERCLOCK_CONTROL_POWER_SUSTAINED_LIMIT",
                    "$S_OVERCLOCK_CONTROL_POWER_BURST_LIMIT",
                    "$S_OVERCLOCK_CONTROL_POWER_PEAK_LIMIT",
                    "$S_OVERCLOCK_CONTROL_ICCMAX_LIMIT",
                    "$S_OVERCLOCK_CONTROL_TEMP_LIMIT",
                    "$S_OVERCLOCK_CONTROL_ITD_DISABLE",
                    "$S_OVERCLOCK_CONTROL_ACM_DISABLE"
                ],
                "max": "$S_OVERCLOCK_CONTROL_ACM_DISABLE"
            },
            "$s_overclock_domain_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_OVERCLOCK_DOMAIN_CARD",
                    "$S_OVERCLOCK_DOMAIN_PACKAGE",
                    "$S_OVERCLOCK_DOMAIN_GPU_ALL",
                    "$S_OVERCLOCK_DOMAIN_GPU_RENDER_COMPUTE",
                    "$S_OVERCLOCK_DOMAIN_GPU_RENDER",
                    "$S_OVERCLOCK_DOMAIN_GPU_COMPUTE",
                    "$S_OVERCLOCK_DOMAIN_GPU_MEDIA",
                    "$S_OVERCLOCK_DOMAIN_VRAM",
                    "$S_OVERCLOCK_DOMAIN_ADM"
                ],
                "max": "$S_OVERCLOCK_DOMAIN_ADM"
            },
            "$s_overclock_mode_t": {
                "class": "$sOverclock",
                "etors": [
                    "$S_OVERCLOCK_MODE_MODE_OFF",
                    "$S_OVERCLOCK_MODE_MODE_STOCK",
                    "$S_OVERCLOCK_MODE_MODE_ON",
                    "$S_OVERCLOCK_MODE_MODE_UNAVAILABLE",
                    "$S_OVERCLOCK_MODE_MODE_DISABLED"
                ],
                "max": "$S_OVERCLOCK_MODE_MODE_DISABLED"
            },
            "$s_pci_bar_type_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_PCI_BAR_TYPE_MMIO",
                    "$S_PCI_BAR_TYPE_ROM",
                    "$S_PCI_BAR_TYPE_MEM"
                ],
                "max": "$S_PCI_BAR_TYPE_MEM"
            },
            "$s_pci_link_qual_issue_flags_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_PCI_LINK_QUAL_ISSUE_FLAG_REPLAYS",
                    "$S_PCI_LINK_QUAL_ISSUE_FLAG_SPEED"
                ],
                "max": "0x3"
            },
            "$s_pci_link_stab_issue_flags_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_PCI_LINK_STAB_ISSUE_FLAG_RETRAINING"
                ],
                "max": "0x1"
            },
            "$s_pci_link_status_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_PCI_LINK_STATUS_UNKNOWN",
                    "$S_PCI_LINK_STATUS_GOOD",
                    "$S_PCI_LINK_STATUS_QUALITY_ISSUES",
                    "$S_PCI_LINK_STATUS_STABILITY_ISSUES"
                ],
                "max": "$S_PCI_LINK_STATUS_STABILITY_ISSUES"
            },
            "$s_pending_action_t": {
                "class": "$sOverclock",
                "etors": [
                    "$S_PENDING_ACTION_PENDING_NONE",
                    "$S_PENDING_ACTION_PENDING_IMMINENT",
                    "$S_PENDING_ACTION_PENDING_COLD_RESET",
                    "$S_PENDING_ACTION_PENDING_WARM_RESET"
                ],
                "max": "$S_PENDING_ACTION_PENDING_WARM_RESET"
            },
            "$s_power_domain_t": {
                "class": "$sPower",
                "etors": [
                    "$S_POWER_DOMAIN_UNKNOWN",
                    "$S_POWER_DOMAIN_CARD",
                    "$S_POWER_DOMAIN_PACKAGE",
                    "$S_POWER_DOMAIN_STACK"
                ],
                "max": "$S_POWER_DOMAIN_STACK"
            },
            "$s_power_level_t": {
                "class": "$sPower",
                "etors": [
                    "$S_POWER_LEVEL_UNKNOWN",
                    "$S_POWER_LEVEL_SUSTAINED",
                    "$S_POWER_LEVEL_BURST",
                    "$S_POWER_LEVEL_PEAK",
                    "$S_POWER_LEVEL_INSTANTANEOUS"
                ],
                "max": "$S_POWER_LEVEL_INSTANTANEOUS"
            },
            "$s_power_limits_ext_version_t": {
                "class": "",
                "etors": [
                    "$S_POWER_LIMITS_EXT_VERSION_1_0",
                    "$S_POWER_LIMITS_EXT_VERSION_CURRENT"
                ],
                "max": "$S_POWER_LIMITS_EXT_VERSION_CURRENT"
            },
            "$s_power_source_t": {
                "class": "$sPower",
                "etors": [
                    "$S_POWER_SOURCE_ANY",
                    "$S_POWER_SOURCE_MAINS",
                    "$S_POWER_SOURCE_BATTERY"
                ],
                "max": "$S_POWER_SOURCE_BATTERY"
            },
            "$s_psu_voltage_status_t": {
                "class": "$sPsu",
                "etors": [
                    "$S_PSU_VOLTAGE_STATUS_UNKNOWN",
                    "$S_PSU_VOLTAGE_STATUS_NORMAL",
                    "$S_PSU_VOLTAGE_STATUS_OVER",
                    "$S_PSU_VOLTAGE_STATUS_UNDER"
                ],
                "max": "$S_PSU_VOLTAGE_STATUS_UNDER"
            },
            "$s_ras_error_cat_t": {
                "class": "$sRas",
                "etors": [
                    "$S_RAS_ERROR_CAT_RESET",
                    "$S_RAS_ERROR_CAT_PROGRAMMING_ERRORS",
                    "$S_RAS_ERROR_CAT_DRIVER_ERRORS",
                    "$S_RAS_ERROR_CAT_COMPUTE_ERRORS",
                    "$S_RAS_ERROR_CAT_NON_COMPUTE_ERRORS",
                    "$S_RAS_ERROR_CAT_CACHE_ERRORS",
                    "$S_RAS_ERROR_CAT_DISPLAY_ERRORS"
                ],
                "max": "$S_RAS_ERROR_CAT_DISPLAY_ERRORS"
            },
            "$s_ras_error_category_exp_t": {
                "class": "$sRas",
                "etors": [
                    "$S_RAS_ERROR_CATEGORY_EXP_RESET",
                    "$S_RAS_ERROR_CATEGORY_EXP_PROGRAMMING_ERRORS",
                    "$S_RAS_ERROR_CATEGORY_EXP_DRIVER_ERRORS",
                    "$S_RAS_ERROR_CATEGORY_EXP_COMPUTE_ERRORS",
                    "$S_RAS_ERROR_CATEGORY_EXP_NON_COMPUTE_ERRORS",
                    "$S_RAS_ERROR_CATEGORY_EXP_CACHE_ERRORS",
                    "$S_RAS_ERROR_CATEGORY_EXP_DISPLAY_ERRORS",
                    "$S_RAS_ERROR_CATEGORY_EXP_MEMORY_ERRORS",
                    "$S_RAS_ERROR_CATEGORY_EXP_SCALE_ERRORS",
                    "$S_RAS_ERROR_CATEGORY_EXP_L3FABRIC_ERRORS"
                ],
                "max": "$S_RAS_ERROR_CATEGORY_EXP_L3FABRIC_ERRORS"
            },
            "$s_ras_error_type_t": {
                "class": "$sRas",
                "etors": [
                    "$S_RAS_ERROR_TYPE_CORRECTABLE",
                    "$S_RAS_ERROR_TYPE_UNCORRECTABLE"
                ],
                "max": "$S_RAS_ERROR_TYPE_UNCORRECTABLE"
            },
            "$s_ras_state_exp_version_t": {
                "class": "",
                "etors": [
                    "$S_RAS_STATE_EXP_VERSION_1_0",
                    "$S_RAS_STATE_EXP_VERSION_CURRENT"
                ],
                "max": "$S_RAS_STATE_EXP_VERSION_CURRENT"
            },
            "$s_repair_status_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_REPAIR_STATUS_UNSUPPORTED",
                    "$S_REPAIR_STATUS_NOT_PERFORMED",
                    "$S_REPAIR_STATUS_PERFORMED"
                ],
                "max": "$S_REPAIR_STATUS_PERFORMED"
            },
            "$s_reset_reason_flags_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_RESET_REASON_FLAG_WEDGED",
                    "$S_RESET_REASON_FLAG_REPAIR"
                ],
                "max": "0x3"
            },
            "$s_reset_type_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_RESET_TYPE_WARM",
                    "$S_RESET_TYPE_COLD",
                    "$S_RESET_TYPE_FLR"
                ],
                "max": "$S_RESET_TYPE_FLR"
            },
            "$s_sched_mode_t": {
                "class": "$sDevice",
                "etors": [
                    "$S_SCHED_MODE_TIMEOUT",
                    "$S_SCHED_MODE_TIMESLICE",
                    "$S_SCHED_MODE_EXCLUSIVE",
                    "$S_SCHED_MODE_COMPUTE_UNIT_DEBUG"
                ],
                "max": "$S_SCHED_MODE_COMPUTE_UNIT_DEBUG"
            },
            "$s_standby_promo_mode_t": {
                "class": "$sStandby",
                "etors": [
                    "$S_STANDBY_PROMO_MODE_DEFAULT",
                    "$S_STANDBY_PROMO_MODE_NEVER"
                ],
                "max": "$S_STANDBY_PROMO_MODE_NEVER"
            },
            "$s_standby_type_t": {
                "class": "$sStandby",
                "etors": [
                    "$S_STANDBY_TYPE_GLOBAL"
                ],
                "max": "$S_STANDBY_TYPE_GLOBAL"
            },
            "$s_structure_type_t": {
                "class": "",
                "etors": [
                    "$S_STRUCTURE_TYPE_DEVICE_PROPERTIES",
                    "$S_STRUCTURE_TYPE_PCI_PROPERTIES",
                    "$S_STRUCTURE_TYPE_PCI_BAR_PROPERTIES",
                    "$S_STRUCTURE_TYPE_DIAG_PROPERTIES",
                    "$S_STRUCTURE_TYPE_ENGINE_PROPERTIES",
                    "$S_STRUCTURE_TYPE_FABRIC_PORT_PROPERTIES",
                    "$S_STRUCTURE_TYPE_FAN_PROPERTIES",
                    "$S_STRUCTURE_TYPE_FIRMWARE_PROPERTIES",
                    "$S_STRUCTURE_TYPE_FREQ_PROPERTIES",
                    "$S_STRUCTURE_TYPE_LED_PROPERTIES",
                    "$S_STRUCTURE_TYPE_MEM_PROPERTIES",
                    "$S_STRUCTURE_TYPE_PERF_PROPERTIES",
                    "$S_STRUCTURE_TYPE_POWER_PROPERTIES",
                    "$S_STRUCTURE_TYPE_PSU_PROPERTIES",
                    "$S_STRUCTURE_TYPE_RAS_PROPERTIES",
                    "$S_STRUCTURE_TYPE_SCHED_PROPERTIES",
                    "$S_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES",
                    "$S_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES",
                    "$S_STRUCTURE_TYPE_STANDBY_PROPERTIES",
                    "$S_STRUCTURE_TYPE_TEMP_PROPERTIES",
                    "$S_STRUCTURE_TYPE_DEVICE_STATE",
                    "$S_STRUCTURE_TYPE_PROCESS_STATE",
                    "$S_STRUCTURE_TYPE_PCI_STATE",
                    "$S_STRUCTURE_TYPE_FABRIC_PORT_CONFIG",
                    "$S_STRUCTURE_TYPE_FABRIC_PORT_STATE",
                    "$S_STRUCTURE_TYPE_FAN_CONFIG",
                    "$S_STRUCTURE_TYPE_FREQ_STATE",
                    "$S_STRUCTURE_TYPE_OC_CAPABILITIES",
                    "$S_STRUCTURE_TYPE_LED_STATE",
                    "$S_STRUCTURE_TYPE_MEM_STATE",
                    "$S_STRUCTURE_TYPE_PSU_STATE",
                    "$S_STRUCTURE_TYPE_BASE_STATE",
                    "$S_STRUCTURE_TYPE_RAS_CONFIG",
                    "$S_STRUCTURE_TYPE_RAS_STATE",
                    "$S_STRUCTURE_TYPE_TEMP_CONFIG",
                    "$S_STRUCTURE_TYPE_PCI_BAR_PROPERTIES_1_2",
                    "$S_STRUCTURE_TYPE_DEVICE_ECC_DESC",
                    "$S_STRUCTURE_TYPE_DEVICE_ECC_PROPERTIES",
                    "$S_STRUCTURE_TYPE_POWER_LIMIT_EXT_DESC",
                    "$S_STRUCTURE_TYPE_POWER_EXT_PROPERTIES",
                    "$S_STRUCTURE_TYPE_OVERCLOCK_PROPERTIES",
                    "$S_STRUCTURE_TYPE_FABRIC_PORT_ERROR_COUNTERS",
                    "$S_STRUCTURE_TYPE_ENGINE_EXT_PROPERTIES",
                    "$S_STRUCTURE_TYPE_RESET_PROPERTIES",
                    "$S_STRUCTURE_TYPE_DEVICE_EXT_PROPERTIES",
                    "$S_STRUCTURE_TYPE_DEVICE_UUID"
                ],
                "max": "$S_STRUCTURE_TYPE_DEVICE_UUID"
            },
            "$s_temp_sensors_t": {
                "class": "$sTemperature",
                "etors": [
                    "$S_TEMP_SENSORS_GLOBAL",
                    "$S_TEMP_SENSORS_GPU",
                    "$S_TEMP_SENSORS_MEMORY",
                    "$S_TEMP_SENSORS_GLOBAL_MIN",
                    "$S_TEMP_SENSORS_GPU_MIN",
                    "$S_TEMP_SENSORS_MEMORY_MIN"
                ],
                "max": "$S_TEMP_SENSORS_MEMORY_MIN"
            },
            "$s_vf_array_type_t": {
                "class": "$sOverclock",
                "etors": [
                    "$S_VF_ARRAY_TYPE_USER_VF_ARRAY",
                    "$S_VF_ARRAY_TYPE_DEFAULT_VF_ARRAY",
                    "$S_VF_ARRAY_TYPE_LIVE_VF_ARRAY"
                ],
                "max": "$S_VF_ARRAY_TYPE_LIVE_VF_ARRAY"
            },
            "$s_vf_program_type_t": {
                "class": "$sOverclock",
                "etors": [
                    "$S_VF_PROGRAM_TYPE_VF_ARBITRARY",
                    "$S_VF_PROGRAM_TYPE_VF_FREQ_FIXED",
                    "$S_VF_PROGRAM_TYPE_VF_VOLT_FIXED"
                ],
                "max": "$S_VF_PROGRAM_TYPE_VF_VOLT_FIXED"
            },
            "$s_vf_type_t": {
                "class": "$sOverclock",
                "etors": [
                    "$S_VF_TYPE_VOLT",
                    "$S_VF_TYPE_FREQ"
                ],
                "max": "$S_VF_TYPE_FREQ"
            },
            "$t_api_tracing_exp_version_t": {
                "class": "",
                "etors": [
                    "$T_API_TRACING_EXP_VERSION_1_0",
                    "$T_API_TRACING_EXP_VERSION_CURRENT"
                ],
                "max": "$T_API_TRACING_EXP_VERSION_CURRENT"
            },
            "$t_debug_detach_reason_t": {
                "class": "$tDebug",
                "etors": [
                    "$T_DEBUG_DETACH_REASON_INVALID",
                    "$T_DEBUG_DETACH_REASON_HOST_EXIT"
                ],
                "max": "$T_DEBUG_DETACH_REASON_HOST_EXIT"
            },
            "$t_debug_event_flags_t": {
                "class": "$tDebug",
                "etors": [
                    "$T_DEBUG_EVENT_FLAG_NEED_ACK"
                ],
                "max": "0x1"
            },
            "$t_debug_event_type_t": {
                "class": "$tDebug",
                "etors": [
                    "$T_DEBUG_EVENT_TYPE_INVALID",
                    "$T_DEBUG_EVENT_TYPE_DETACHED",
                    "$T_DEBUG_EVENT_TYPE_PROCESS_ENTRY",
                    "$T_DEBUG_EVENT_TYPE_PROCESS_EXIT",
                    "$T_DEBUG_EVENT_TYPE_MODULE_LOAD",
                    "$T_DEBUG_EVENT_TYPE_MODULE_UNLOAD",
                    "$T_DEBUG_EVENT_TYPE_THREAD_STOPPED",
                    "$T_DEBUG_EVENT_TYPE_THREAD_UNAVAILABLE",
                    "$T_DEBUG_EVENT_TYPE_PAGE_FAULT"
                ],
                "max": "$T_DEBUG_EVENT_TYPE_PAGE_FAULT"
            },
            "$t_debug_memory_space_type_t": {
                "class": "$tDebug",
                "etors": [
                    "$T_DEBUG_MEMORY_SPACE_TYPE_DEFAULT",
                    "$T_DEBUG_MEMORY_SPACE_TYPE_SLM"
                ],
                "max": "$T_DEBUG_MEMORY_SPACE_TYPE_SLM"
            },
            "$t_debug_page_fault_reason_t": {
                "class": "$tDebug",
                "etors": [
                    "$T_DEBUG_PAGE_FAULT_REASON_INVALID",
                    "$T_DEBUG_PAGE_FAULT_REASON_MAPPING_ERROR",
                    "$T_DEBUG_PAGE_FAULT_REASON_PERMISSION_ERROR"
                ],
                "max": "$T_DEBUG_PAGE_FAULT_REASON_PERMISSION_ERROR"
            },
            "$t_debug_regset_flags_t": {
                "class": "$tDebug",
                "etors": [
                    "$T_DEBUG_REGSET_FLAG_READABLE",
                    "$T_DEBUG_REGSET_FLAG_WRITEABLE"
                ],
                "max": "0x3"
            },
            "$t_device_debug_property_flags_t": {
                "class": "$tDevice",
                "etors": [
                    "$T_DEVICE_DEBUG_PROPERTY_FLAG_ATTACH"
                ],
                "max": "0x1"
            },
            "$t_export_metric_data_exp_version_t": {
                "class": "",
                "etors": [
                    "$T_EXPORT_METRIC_DATA_EXP_VERSION_1_0",
                    "$T_EXPORT_METRIC_DATA_EXP_VERSION_CURRENT"
                ],
                "max": "$T_EXPORT_METRIC_DATA_EXP_VERSION_CURRENT"
            },
            "$t_metric_group_calculation_type_t": {
                "class": "$tMetricGroup",
                "etors": [
                    "$T_METRIC_GROUP_CALCULATION_TYPE_METRIC_VALUES",
                    "$T_METRIC_GROUP_CALCULATION_TYPE_MAX_METRIC_VALUES"
                ],
                "max": "$T_METRIC_GROUP_CALCULATION_TYPE_MAX_METRIC_VALUES"
            },
            "$t_metric_group_sampling_type_flags_t": {
                "class": "$tMetricGroup",
                "etors": [
                    "$T_METRIC_GROUP_SAMPLING_TYPE_FLAG_EVENT_BASED",
                    "$T_METRIC_GROUP_SAMPLING_TYPE_FLAG_TIME_BASED"
                ],
                "max": "0x3"
            },
            "$t_metric_query_pool_type_t": {
                "class": "$tMetricQueryPool",
                "etors": [
                    "$T_METRIC_QUERY_POOL_TYPE_PERFORMANCE",
                    "$T_METRIC_QUERY_POOL_TYPE_EXECUTION"
                ],
                "max": "$T_METRIC_QUERY_POOL_TYPE_EXECUTION"
            },
            "$t_metric_type_t": {
                "class": "$tMetric",
                "etors": [
                    "$T_METRIC_TYPE_DURATION",
                    "$T_METRIC_TYPE_EVENT",
                    "$T_METRIC_TYPE_EVENT_WITH_RANGE",
                    "$T_METRIC_TYPE_THROUGHPUT",
                    "$T_METRIC_TYPE_TIMESTAMP",
                    "$T_METRIC_TYPE_FLAG",
                    "$T_METRIC_TYPE_RATIO",
                    "$T_METRIC_TYPE_RAW",
                    "$T_METRIC_TYPE_IP_EXP",
                    "$T_METRIC_TYPE_IP"
                ],
                "max": "$T_METRIC_TYPE_IP"
            },
            "$t_module_debug_info_format_t": {
                "class": "$tModule",
                "etors": [
                    "$T_MODULE_DEBUG_INFO_FORMAT_ELF_DWARF"
                ],
                "max": "$T_MODULE_DEBUG_INFO_FORMAT_ELF_DWARF"
            },
            "$t_profile_flags_t": {
                "class": "$tKernel",
                "etors": [
                    "$T_PROFILE_FLAG_REGISTER_REALLOCATION",
                    "$T_PROFILE_FLAG_FREE_REGISTER_INFO"
                ],
                "max": "0x3"
            },
            "$t_profile_token_type_t": {
                "class": "$tKernel",
                "etors": [
                    "$T_PROFILE_TOKEN_TYPE_FREE_REGISTER"
                ],
                "max": "$T_PROFILE_TOKEN_TYPE_FREE_REGISTER"
            },
            "$t_structure_type_t": {
                "class": "",
                "etors": [
                    "$T_STRUCTURE_TYPE_METRIC_GROUP_PROPERTIES",
                    "$T_STRUCTURE_TYPE_METRIC_PROPERTIES",
                    "$T_STRUCTURE_TYPE_METRIC_STREAMER_DESC",
                    "$T_STRUCTURE_TYPE_METRIC_QUERY_POOL_DESC",
                    "$T_STRUCTURE_TYPE_PROFILE_PROPERTIES",
                    "$T_STRUCTURE_TYPE_DEVICE_DEBUG_PROPERTIES",
                    "$T_STRUCTURE_TYPE_DEBUG_MEMORY_SPACE_DESC",
                    "$T_STRUCTURE_TYPE_DEBUG_REGSET_PROPERTIES",
                    "$T_STRUCTURE_TYPE_GLOBAL_METRICS_TIMESTAMPS_EXP_PROPERTIES",
                    "$T_STRUCTURE_TYPE_METRIC_GLOBAL_TIMESTAMPS_RESOLUTION_EXP",
                    "$T_STRUCTURE_TYPE_TRACER_EXP_DESC",
                    "$T_STRUCTURE_TYPE_METRICS_CALCULATE_EXP_DESC",
                    "$T_STRUCTURE_TYPE_METRIC_CALCULATE_EXP_DESC"
                ],
                "max": "$T_STRUCTURE_TYPE_METRIC_CALCULATE_EXP_DESC"
            },
            "$t_value_type_t": {
                "class": "",
                "etors": [
                    "$T_VALUE_TYPE_UINT32",
                    "$T_VALUE_TYPE_UINT64",
                    "$T_VALUE_TYPE_FLOAT32",
                    "$T_VALUE_TYPE_FLOAT64",
                    "$T_VALUE_TYPE_BOOL8",
                    "$T_VALUE_TYPE_STRING",
                    "$T_VALUE_TYPE_UINT8",
                    "$T_VALUE_TYPE_UINT16"
                ],
                "max": "$T_VALUE_TYPE_UINT16"
            },
            "$x_api_version_t": {
                "class": "$xDriver",
                "etors": [
                    "$X_API_VERSION_1_0",
                    "$X_API_VERSION_1_1",
                    "$X_API_VERSION_1_2",
                    "$X_API_VERSION_1_3",
                    "$X_API_VERSION_1_4",
                    "$X_API_VERSION_1_5",
                    "$X_API_VERSION_1_6",
                    "$X_API_VERSION_1_7",
                    "$X_API_VERSION_CURRENT"
                ],
                "max": "$X_API_VERSION_CURRENT"
            },
            "$x_bandwidth_unit_t": {
                "class": "",
                "etors": [
                    "$X_BANDWIDTH_UNIT_UNKNOWN",
                    "$X_BANDWIDTH_UNIT_BYTES_PER_NANOSEC",
                    "$X_BANDWIDTH_UNIT_BYTES_PER_CLOCK"
                ],
                "max": "$X_BANDWIDTH_UNIT_BYTES_PER_CLOCK"
            },
            "$x_bfloat16_conversions_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_BFLOAT16_CONVERSIONS_EXT_VERSION_1_0",
                    "$X_BFLOAT16_CONVERSIONS_EXT_VERSION_CURRENT"
                ],
                "max": "$X_BFLOAT16_CONVERSIONS_EXT_VERSION_CURRENT"
            },
            "$x_cache_config_flags_t": {
                "class": "$xKernel",
                "etors": [
                    "$X_CACHE_CONFIG_FLAG_LARGE_SLM",
                    "$X_CACHE_CONFIG_FLAG_LARGE_DATA"
                ],
                "max": "0x3"
            },
            "$x_cache_ext_region_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_CACHE_EXT_REGION_$X_CACHE_REGION_DEFAULT",
                    "$X_CACHE_EXT_REGION_$X_CACHE_RESERVE_REGION",
                    "$X_CACHE_EXT_REGION_$X_CACHE_NON_RESERVED_REGION",
                    "$X_CACHE_EXT_REGION_DEFAULT",
                    "$X_CACHE_EXT_REGION_RESERVED",
                    "$X_CACHE_EXT_REGION_NON_RESERVED"
                ],
                "max": "$X_CACHE_EXT_REGION_NON_RESERVED"
            },
            "$x_cache_reservation_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_CACHE_RESERVATION_EXT_VERSION_1_0",
                    "$X_CACHE_RESERVATION_EXT_VERSION_CURRENT"
                ],
                "max": "$X_CACHE_RESERVATION_EXT_VERSION_CURRENT"
            },
            "$x_calculate_multiple_metrics_exp_version_t": {
                "class": "",
                "etors": [
                    "$X_CALCULATE_MULTIPLE_METRICS_EXP_VERSION_1_0",
                    "$X_CALCULATE_MULTIPLE_METRICS_EXP_VERSION_CURRENT"
                ],
                "max": "$X_CALCULATE_MULTIPLE_METRICS_EXP_VERSION_CURRENT"
            },
            "$x_command_list_flags_t": {
                "class": "$xCommandList",
                "etors": [
                    "$X_COMMAND_LIST_FLAG_RELAXED_ORDERING",
                    "$X_COMMAND_LIST_FLAG_MAXIMIZE_THROUGHPUT",
                    "$X_COMMAND_LIST_FLAG_EXPLICIT_ONLY",
                    "$X_COMMAND_LIST_FLAG_IN_ORDER"
                ],
                "max": "0xf"
            },
            "$x_command_queue_flags_t": {
                "class": "$xCommandQueue",
                "etors": [
                    "$X_COMMAND_QUEUE_FLAG_EXPLICIT_ONLY",
                    "$X_COMMAND_QUEUE_FLAG_IN_ORDER"
                ],
                "max": "0x3"
            },
            "$x_command_queue_group_property_flags_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COMPUTE",
                    "$X_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COPY",
                    "$X_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COOPERATIVE_KERNELS",
                    "$X_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_METRICS"
                ],
                "max": "0xf"
            },
            "$x_command_queue_mode_t": {
                "class": "$xCommandQueue",
                "etors": [
                    "$X_COMMAND_QUEUE_MODE_DEFAULT",
                    "$X_COMMAND_QUEUE_MODE_SYNCHRONOUS",
                    "$X_COMMAND_QUEUE_MODE_ASYNCHRONOUS"
                ],
                "max": "$X_COMMAND_QUEUE_MODE_ASYNCHRONOUS"
            },
            "$x_command_queue_priority_t": {
                "class": "$xCommandQueue",
                "etors": [
                    "$X_COMMAND_QUEUE_PRIORITY_NORMAL",
                    "$X_COMMAND_QUEUE_PRIORITY_PRIORITY_LOW",
                    "$X_COMMAND_QUEUE_PRIORITY_PRIORITY_HIGH"
                ],
                "max": "$X_COMMAND_QUEUE_PRIORITY_PRIORITY_HIGH"
            },
            "$x_context_flags_t": {
                "class": "$xContext",
                "etors": [
                    "$X_CONTEXT_FLAG_TBD"
                ],
                "max": "0x1"
            },
            "$x_device_cache_property_flags_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_DEVICE_CACHE_PROPERTY_FLAG_USER_CONTROL"
                ],
                "max": "0x1"
            },
            "$x_device_fp_atomic_ext_flags_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_DEVICE_FP_ATOMIC_EXT_FLAG_GLOBAL_LOAD_STORE",
                    "$X_DEVICE_FP_ATOMIC_EXT_FLAG_GLOBAL_ADD",
                    "$X_DEVICE_FP_ATOMIC_EXT_FLAG_GLOBAL_MIN_MAX",
                    "$X_DEVICE_FP_ATOMIC_EXT_FLAG_LOCAL_LOAD_STORE",
                    "$X_DEVICE_FP_ATOMIC_EXT_FLAG_LOCAL_ADD",
                    "$X_DEVICE_FP_ATOMIC_EXT_FLAG_LOCAL_MIN_MAX"
                ],
                "max": "0x7ffff"
            },
            "$x_device_fp_flags_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_DEVICE_FP_FLAG_DENORM",
                    "$X_DEVICE_FP_FLAG_INF_NAN",
                    "$X_DEVICE_FP_FLAG_ROUND_TO_NEAREST",
                    "$X_DEVICE_FP_FLAG_ROUND_TO_ZERO",
                    "$X_DEVICE_FP_FLAG_ROUND_TO_INF",
                    "$X_DEVICE_FP_FLAG_FMA",
                    "$X_DEVICE_FP_FLAG_ROUNDED_DIVIDE_SQRT",
                    "$X_DEVICE_FP_FLAG_SOFT_FLOAT"
                ],
                "max": "0xff"
            },
            "$x_device_ip_version_version_t": {
                "class": "",
                "etors": [
                    "$X_DEVICE_IP_VERSION_VERSION_1_0",
                    "$X_DEVICE_IP_VERSION_VERSION_CURRENT"
                ],
                "max": "$X_DEVICE_IP_VERSION_VERSION_CURRENT"
            },
            "$x_device_luid_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_DEVICE_LUID_EXT_VERSION_1_0",
                    "$X_DEVICE_LUID_EXT_VERSION_CURRENT"
                ],
                "max": "$X_DEVICE_LUID_EXT_VERSION_CURRENT"
            },
            "$x_device_mem_alloc_flags_t": {
                "class": "$xMem",
                "etors": [
                    "$X_DEVICE_MEM_ALLOC_FLAG_BIAS_CACHED",
                    "$X_DEVICE_MEM_ALLOC_FLAG_BIAS_UNCACHED",
                    "$X_DEVICE_MEM_ALLOC_FLAG_BIAS_INITIAL_PLACEMENT"
                ],
                "max": "0x7"
            },
            "$x_device_memory_ext_type_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_DEVICE_MEMORY_EXT_TYPE_HBM",
                    "$X_DEVICE_MEMORY_EXT_TYPE_HBM2",
                    "$X_DEVICE_MEMORY_EXT_TYPE_DDR",
                    "$X_DEVICE_MEMORY_EXT_TYPE_DDR2",
                    "$X_DEVICE_MEMORY_EXT_TYPE_DDR3",
                    "$X_DEVICE_MEMORY_EXT_TYPE_DDR4",
                    "$X_DEVICE_MEMORY_EXT_TYPE_DDR5",
                    "$X_DEVICE_MEMORY_EXT_TYPE_LPDDR",
                    "$X_DEVICE_MEMORY_EXT_TYPE_LPDDR3",
                    "$X_DEVICE_MEMORY_EXT_TYPE_LPDDR4",
                    "$X_DEVICE_MEMORY_EXT_TYPE_LPDDR5",
                    "$X_DEVICE_MEMORY_EXT_TYPE_SRAM",
                    "$X_DEVICE_MEMORY_EXT_TYPE_L1",
                    "$X_DEVICE_MEMORY_EXT_TYPE_L3",
                    "$X_DEVICE_MEMORY_EXT_TYPE_GRF",
                    "$X_DEVICE_MEMORY_EXT_TYPE_SLM",
                    "$X_DEVICE_MEMORY_EXT_TYPE_GDDR4",
                    "$X_DEVICE_MEMORY_EXT_TYPE_GDDR5",
                    "$X_DEVICE_MEMORY_EXT_TYPE_GDDR5X",
                    "$X_DEVICE_MEMORY_EXT_TYPE_GDDR6",
                    "$X_DEVICE_MEMORY_EXT_TYPE_GDDR6X",
                    "$X_DEVICE_MEMORY_EXT_TYPE_GDDR7"
                ],
                "max": "$X_DEVICE_MEMORY_EXT_TYPE_GDDR7"
            },
            "$x_device_memory_properties_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_DEVICE_MEMORY_PROPERTIES_EXT_VERSION_1_0",
                    "$X_DEVICE_MEMORY_PROPERTIES_EXT_VERSION_CURRENT"
                ],
                "max": "$X_DEVICE_MEMORY_PROPERTIES_EXT_VERSION_CURRENT"
            },
            "$x_device_memory_property_flags_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_DEVICE_MEMORY_PROPERTY_FLAG_TBD"
                ],
                "max": "0x1"
            },
            "$x_device_module_flags_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_DEVICE_MODULE_FLAG_FP16",
                    "$X_DEVICE_MODULE_FLAG_FP64",
                    "$X_DEVICE_MODULE_FLAG_INT64_ATOMICS",
                    "$X_DEVICE_MODULE_FLAG_DP4A"
                ],
                "max": "0xf"
            },
            "$x_device_p2p_property_flags_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_DEVICE_P2P_PROPERTY_FLAG_ACCESS",
                    "$X_DEVICE_P2P_PROPERTY_FLAG_ATOMICS"
                ],
                "max": "0x3"
            },
            "$x_device_property_flags_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_DEVICE_PROPERTY_FLAG_INTEGRATED",
                    "$X_DEVICE_PROPERTY_FLAG_SUBDEVICE",
                    "$X_DEVICE_PROPERTY_FLAG_ECC",
                    "$X_DEVICE_PROPERTY_FLAG_ONDEMANDPAGING"
                ],
                "max": "0xf"
            },
            "$x_device_raytracing_ext_flags_t": {
                "class": "$xContext",
                "etors": [
                    "$X_DEVICE_RAYTRACING_EXT_FLAG_RAYQUERY"
                ],
                "max": "0x1"
            },
            "$x_device_type_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_DEVICE_TYPE_GPU",
                    "$X_DEVICE_TYPE_CPU",
                    "$X_DEVICE_TYPE_FPGA",
                    "$X_DEVICE_TYPE_MCA",
                    "$X_DEVICE_TYPE_VPU"
                ],
                "max": "$X_DEVICE_TYPE_VPU"
            },
            "$x_driver_memory_free_policy_ext_flags_t": {
                "class": "$xDriver",
                "etors": [
                    "$X_DRIVER_MEMORY_FREE_POLICY_EXT_FLAG_BLOCKING_FREE",
                    "$X_DRIVER_MEMORY_FREE_POLICY_EXT_FLAG_DEFER_FREE"
                ],
                "max": "0x3"
            },
            "$x_eu_count_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_EU_COUNT_EXT_VERSION_1_0",
                    "$X_EU_COUNT_EXT_VERSION_CURRENT"
                ],
                "max": "$X_EU_COUNT_EXT_VERSION_CURRENT"
            },
            "$x_event_pool_flags_t": {
                "class": "$xEventPool",
                "etors": [
                    "$X_EVENT_POOL_FLAG_HOST_VISIBLE",
                    "$X_EVENT_POOL_FLAG_IPC",
                    "$X_EVENT_POOL_FLAG_KERNEL_TIMESTAMP",
                    "$X_EVENT_POOL_FLAG_KERNEL_MAPPED_TIMESTAMP"
                ],
                "max": "0xf"
            },
            "$x_event_query_kernel_timestamps_ext_flags_t": {
                "class": "$xEvent",
                "etors": [
                    "$X_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_FLAG_KERNEL",
                    "$X_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_FLAG_SYNCHRONIZED"
                ],
                "max": "0x3"
            },
            "$x_event_query_kernel_timestamps_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_VERSION_1_0",
                    "$X_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_VERSION_CURRENT"
                ],
                "max": "$X_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_VERSION_CURRENT"
            },
            "$x_event_query_timestamps_exp_version_t": {
                "class": "",
                "etors": [
                    "$X_EVENT_QUERY_TIMESTAMPS_EXP_VERSION_1_0",
                    "$X_EVENT_QUERY_TIMESTAMPS_EXP_VERSION_CURRENT"
                ],
                "max": "$X_EVENT_QUERY_TIMESTAMPS_EXP_VERSION_CURRENT"
            },
            "$x_event_scope_flags_t": {
                "class": "$xEvent",
                "etors": [
                    "$X_EVENT_SCOPE_FLAG_SUBDEVICE",
                    "$X_EVENT_SCOPE_FLAG_DEVICE",
                    "$X_EVENT_SCOPE_FLAG_HOST"
                ],
                "max": "0x7"
            },
            "$x_external_memory_type_flags_t": {
                "class": "",
                "etors": [
                    "$X_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_FD",
                    "$X_EXTERNAL_MEMORY_TYPE_FLAG_DMA_BUF",
                    "$X_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_WIN32",
                    "$X_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_WIN32_KMT",
                    "$X_EXTERNAL_MEMORY_TYPE_FLAG_D3D11_TEXTURE",
                    "$X_EXTERNAL_MEMORY_TYPE_FLAG_D3D11_TEXTURE_KMT",
                    "$X_EXTERNAL_MEMORY_TYPE_FLAG_D3D12_HEAP",
                    "$X_EXTERNAL_MEMORY_TYPE_FLAG_D3D12_RESOURCE"
                ],
                "max": "0xff"
            },
            "$x_fabric_edge_exp_duplexity_t": {
                "class": "$xFabricEdge",
                "etors": [
                    "$X_FABRIC_EDGE_EXP_DUPLEXITY_UNKNOWN",
                    "$X_FABRIC_EDGE_EXP_DUPLEXITY_HALF_DUPLEX",
                    "$X_FABRIC_EDGE_EXP_DUPLEXITY_FULL_DUPLEX"
                ],
                "max": "$X_FABRIC_EDGE_EXP_DUPLEXITY_FULL_DUPLEX"
            },
            "$x_fabric_vertex_exp_type_t": {
                "class": "$xFabricVertex",
                "etors": [
                    "$X_FABRIC_VERTEX_EXP_TYPE_UNKNOWN",
                    "$X_FABRIC_VERTEX_EXP_TYPE_DEVICE",
                    "$X_FABRIC_VERTEX_EXP_TYPE_SUBDEVICE",
                    "$X_FABRIC_VERTEX_EXP_TYPE_SWITCH"
                ],
                "max": "$X_FABRIC_VERTEX_EXP_TYPE_SWITCH"
            },
            "$x_fence_flags_t": {
                "class": "$xFence",
                "etors": [
                    "$X_FENCE_FLAG_SIGNALED"
                ],
                "max": "0x1"
            },
            "$x_float_atomics_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_FLOAT_ATOMICS_EXT_VERSION_1_0",
                    "$X_FLOAT_ATOMICS_EXT_VERSION_CURRENT"
                ],
                "max": "$X_FLOAT_ATOMICS_EXT_VERSION_CURRENT"
            },
            "$x_global_offset_exp_version_t": {
                "class": "",
                "etors": [
                    "$X_GLOBAL_OFFSET_EXP_VERSION_1_0",
                    "$X_GLOBAL_OFFSET_EXP_VERSION_CURRENT"
                ],
                "max": "$X_GLOBAL_OFFSET_EXP_VERSION_CURRENT"
            },
            "$x_host_mem_alloc_flags_t": {
                "class": "$xMem",
                "etors": [
                    "$X_HOST_MEM_ALLOC_FLAG_BIAS_CACHED",
                    "$X_HOST_MEM_ALLOC_FLAG_BIAS_UNCACHED",
                    "$X_HOST_MEM_ALLOC_FLAG_BIAS_WRITE_COMBINED",
                    "$X_HOST_MEM_ALLOC_FLAG_BIAS_INITIAL_PLACEMENT"
                ],
                "max": "0xf"
            },
            "$x_image_copy_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_IMAGE_COPY_EXT_VERSION_1_0",
                    "$X_IMAGE_COPY_EXT_VERSION_CURRENT"
                ],
                "max": "$X_IMAGE_COPY_EXT_VERSION_CURRENT"
            },
            "$x_image_flags_t": {
                "class": "$xImage",
                "etors": [
                    "$X_IMAGE_FLAG_KERNEL_WRITE",
                    "$X_IMAGE_FLAG_BIAS_UNCACHED"
                ],
                "max": "0x3"
            },
            "$x_image_format_layout_t": {
                "class": "$xImage",
                "etors": [
                    "$X_IMAGE_FORMAT_LAYOUT_8",
                    "$X_IMAGE_FORMAT_LAYOUT_16",
                    "$X_IMAGE_FORMAT_LAYOUT_32",
                    "$X_IMAGE_FORMAT_LAYOUT_8_8",
                    "$X_IMAGE_FORMAT_LAYOUT_8_8_8_8",
                    "$X_IMAGE_FORMAT_LAYOUT_16_16",
                    "$X_IMAGE_FORMAT_LAYOUT_16_16_16_16",
                    "$X_IMAGE_FORMAT_LAYOUT_32_32",
                    "$X_IMAGE_FORMAT_LAYOUT_32_32_32_32",
                    "$X_IMAGE_FORMAT_LAYOUT_10_10_10_2",
                    "$X_IMAGE_FORMAT_LAYOUT_11_11_10",
                    "$X_IMAGE_FORMAT_LAYOUT_5_6_5",
                    "$X_IMAGE_FORMAT_LAYOUT_5_5_5_1",
                    "$X_IMAGE_FORMAT_LAYOUT_4_4_4_4",
                    "$X_IMAGE_FORMAT_LAYOUT_Y8",
                    "$X_IMAGE_FORMAT_LAYOUT_NV12",
                    "$X_IMAGE_FORMAT_LAYOUT_YUYV",
                    "$X_IMAGE_FORMAT_LAYOUT_VYUY",
                    "$X_IMAGE_FORMAT_LAYOUT_YVYU",
                    "$X_IMAGE_FORMAT_LAYOUT_UYVY",
                    "$X_IMAGE_FORMAT_LAYOUT_AYUV",
                    "$X_IMAGE_FORMAT_LAYOUT_P010",
                    "$X_IMAGE_FORMAT_LAYOUT_Y410",
                    "$X_IMAGE_FORMAT_LAYOUT_P012",
                    "$X_IMAGE_FORMAT_LAYOUT_Y16",
                    "$X_IMAGE_FORMAT_LAYOUT_P016",
                    "$X_IMAGE_FORMAT_LAYOUT_Y216",
                    "$X_IMAGE_FORMAT_LAYOUT_P216",
                    "$X_IMAGE_FORMAT_LAYOUT_P8",
                    "$X_IMAGE_FORMAT_LAYOUT_YUY2",
                    "$X_IMAGE_FORMAT_LAYOUT_A8P8",
                    "$X_IMAGE_FORMAT_LAYOUT_IA44",
                    "$X_IMAGE_FORMAT_LAYOUT_AI44",
                    "$X_IMAGE_FORMAT_LAYOUT_Y416",
                    "$X_IMAGE_FORMAT_LAYOUT_Y210",
                    "$X_IMAGE_FORMAT_LAYOUT_I420",
                    "$X_IMAGE_FORMAT_LAYOUT_YV12",
                    "$X_IMAGE_FORMAT_LAYOUT_400P",
                    "$X_IMAGE_FORMAT_LAYOUT_422H",
                    "$X_IMAGE_FORMAT_LAYOUT_422V",
                    "$X_IMAGE_FORMAT_LAYOUT_444P",
                    "$X_IMAGE_FORMAT_LAYOUT_RGBP",
                    "$X_IMAGE_FORMAT_LAYOUT_BRGP"
                ],
                "max": "$X_IMAGE_FORMAT_LAYOUT_BRGP"
            },
            "$x_image_format_swizzle_t": {
                "class": "$xImage",
                "etors": [
                    "$X_IMAGE_FORMAT_SWIZZLE_R",
                    "$X_IMAGE_FORMAT_SWIZZLE_G",
                    "$X_IMAGE_FORMAT_SWIZZLE_B",
                    "$X_IMAGE_FORMAT_SWIZZLE_A",
                    "$X_IMAGE_FORMAT_SWIZZLE_0",
                    "$X_IMAGE_FORMAT_SWIZZLE_1",
                    "$X_IMAGE_FORMAT_SWIZZLE_X"
                ],
                "max": "$X_IMAGE_FORMAT_SWIZZLE_X"
            },
            "$x_image_format_type_t": {
                "class": "$xImage",
                "etors": [
                    "$X_IMAGE_FORMAT_TYPE_UINT",
                    "$X_IMAGE_FORMAT_TYPE_SINT",
                    "$X_IMAGE_FORMAT_TYPE_UNORM",
                    "$X_IMAGE_FORMAT_TYPE_SNORM",
                    "$X_IMAGE_FORMAT_TYPE_FLOAT"
                ],
                "max": "$X_IMAGE_FORMAT_TYPE_FLOAT"
            },
            "$x_image_memory_properties_exp_version_t": {
                "class": "",
                "etors": [
                    "$X_IMAGE_MEMORY_PROPERTIES_EXP_VERSION_1_0",
                    "$X_IMAGE_MEMORY_PROPERTIES_EXP_VERSION_CURRENT"
                ],
                "max": "$X_IMAGE_MEMORY_PROPERTIES_EXP_VERSION_CURRENT"
            },
            "$x_image_query_alloc_properties_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_IMAGE_QUERY_ALLOC_PROPERTIES_EXT_VERSION_1_0",
                    "$X_IMAGE_QUERY_ALLOC_PROPERTIES_EXT_VERSION_CURRENT"
                ],
                "max": "$X_IMAGE_QUERY_ALLOC_PROPERTIES_EXT_VERSION_CURRENT"
            },
            "$x_image_sampler_filter_flags_t": {
                "class": "$xImage",
                "etors": [
                    "$X_IMAGE_SAMPLER_FILTER_FLAG_POINT",
                    "$X_IMAGE_SAMPLER_FILTER_FLAG_LINEAR"
                ],
                "max": "0x3"
            },
            "$x_image_type_t": {
                "class": "$xImage",
                "etors": [
                    "$X_IMAGE_TYPE_1D",
                    "$X_IMAGE_TYPE_1DARRAY",
                    "$X_IMAGE_TYPE_2D",
                    "$X_IMAGE_TYPE_2DARRAY",
                    "$X_IMAGE_TYPE_3D",
                    "$X_IMAGE_TYPE_BUFFER"
                ],
                "max": "$X_IMAGE_TYPE_BUFFER"
            },
            "$x_image_view_exp_version_t": {
                "class": "",
                "etors": [
                    "$X_IMAGE_VIEW_EXP_VERSION_1_0",
                    "$X_IMAGE_VIEW_EXP_VERSION_CURRENT"
                ],
                "max": "$X_IMAGE_VIEW_EXP_VERSION_CURRENT"
            },
            "$x_image_view_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_IMAGE_VIEW_EXT_VERSION_1_0",
                    "$X_IMAGE_VIEW_EXT_VERSION_CURRENT"
                ],
                "max": "$X_IMAGE_VIEW_EXT_VERSION_CURRENT"
            },
            "$x_image_view_planar_exp_version_t": {
                "class": "",
                "etors": [
                    "$X_IMAGE_VIEW_PLANAR_EXP_VERSION_1_0",
                    "$X_IMAGE_VIEW_PLANAR_EXP_VERSION_CURRENT"
                ],
                "max": "$X_IMAGE_VIEW_PLANAR_EXP_VERSION_CURRENT"
            },
            "$x_image_view_planar_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_IMAGE_VIEW_PLANAR_EXT_VERSION_1_0",
                    "$X_IMAGE_VIEW_PLANAR_EXT_VERSION_CURRENT"
                ],
                "max": "$X_IMAGE_VIEW_PLANAR_EXT_VERSION_CURRENT"
            },
            "$x_init_flags_t": {
                "class": "$x",
                "etors": [
                    "$X_INIT_FLAG_GPU_ONLY",
                    "$X_INIT_FLAG_VPU_ONLY"
                ],
                "max": "0x3"
            },
            "$x_ipc_memory_flags_t": {
                "class": "$xMem",
                "etors": [
                    "$X_IPC_MEMORY_FLAG_BIAS_CACHED",
                    "$X_IPC_MEMORY_FLAG_BIAS_UNCACHED"
                ],
                "max": "0x3"
            },
            "$x_ipc_property_flags_t": {
                "class": "$xDriver",
                "etors": [
                    "$X_IPC_PROPERTY_FLAG_MEMORY",
                    "$X_IPC_PROPERTY_FLAG_EVENT_POOL"
                ],
                "max": "0x3"
            },
            "$x_kernel_flags_t": {
                "class": "$xKernel",
                "etors": [
                    "$X_KERNEL_FLAG_FORCE_RESIDENCY",
                    "$X_KERNEL_FLAG_EXPLICIT_RESIDENCY"
                ],
                "max": "0x3"
            },
            "$x_kernel_indirect_access_flags_t": {
                "class": "$xKernel",
                "etors": [
                    "$X_KERNEL_INDIRECT_ACCESS_FLAG_HOST",
                    "$X_KERNEL_INDIRECT_ACCESS_FLAG_DEVICE",
                    "$X_KERNEL_INDIRECT_ACCESS_FLAG_SHARED"
                ],
                "max": "0x7"
            },
            "$x_kernel_max_group_size_properties_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_KERNEL_MAX_GROUP_SIZE_PROPERTIES_EXT_VERSION_1_0",
                    "$X_KERNEL_MAX_GROUP_SIZE_PROPERTIES_EXT_VERSION_CURRENT"
                ],
                "max": "$X_KERNEL_MAX_GROUP_SIZE_PROPERTIES_EXT_VERSION_CURRENT"
            },
            "$x_latency_unit_t": {
                "class": "",
                "etors": [
                    "$X_LATENCY_UNIT_UNKNOWN",
                    "$X_LATENCY_UNIT_NANOSEC",
                    "$X_LATENCY_UNIT_CLOCK",
                    "$X_LATENCY_UNIT_HOP"
                ],
                "max": "$X_LATENCY_UNIT_HOP"
            },
            "$x_linkage_inspection_ext_flags_t": {
                "class": "$xModule",
                "etors": [
                    "$X_LINKAGE_INSPECTION_EXT_FLAG_IMPORTS",
                    "$X_LINKAGE_INSPECTION_EXT_FLAG_UNRESOLVABLE_IMPORTS",
                    "$X_LINKAGE_INSPECTION_EXT_FLAG_EXPORTS"
                ],
                "max": "0x7"
            },
            "$x_linkage_inspection_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_LINKAGE_INSPECTION_EXT_VERSION_1_0",
                    "$X_LINKAGE_INSPECTION_EXT_VERSION_CURRENT"
                ],
                "max": "$X_LINKAGE_INSPECTION_EXT_VERSION_CURRENT"
            },
            "$x_linkonce_odr_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_LINKONCE_ODR_EXT_VERSION_1_0",
                    "$X_LINKONCE_ODR_EXT_VERSION_CURRENT"
                ],
                "max": "$X_LINKONCE_ODR_EXT_VERSION_CURRENT"
            },
            "$x_memory_access_attribute_t": {
                "class": "$xVirtualMem",
                "etors": [
                    "$X_MEMORY_ACCESS_ATTRIBUTE_NONE",
                    "$X_MEMORY_ACCESS_ATTRIBUTE_READWRITE",
                    "$X_MEMORY_ACCESS_ATTRIBUTE_READONLY"
                ],
                "max": "$X_MEMORY_ACCESS_ATTRIBUTE_READONLY"
            },
            "$x_memory_access_cap_flags_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_MEMORY_ACCESS_CAP_FLAG_RW",
                    "$X_MEMORY_ACCESS_CAP_FLAG_ATOMIC",
                    "$X_MEMORY_ACCESS_CAP_FLAG_CONCURRENT",
                    "$X_MEMORY_ACCESS_CAP_FLAG_CONCURRENT_ATOMIC"
                ],
                "max": "0xf"
            },
            "$x_memory_advice_t": {
                "class": "$xCommandList",
                "etors": [
                    "$X_MEMORY_ADVICE_SET_READ_MOSTLY",
                    "$X_MEMORY_ADVICE_CLEAR_READ_MOSTLY",
                    "$X_MEMORY_ADVICE_SET_PREFERRED_LOCATION",
                    "$X_MEMORY_ADVICE_CLEAR_PREFERRED_LOCATION",
                    "$X_MEMORY_ADVICE_SET_NON_ATOMIC_MOSTLY",
                    "$X_MEMORY_ADVICE_CLEAR_NON_ATOMIC_MOSTLY",
                    "$X_MEMORY_ADVICE_BIAS_CACHED",
                    "$X_MEMORY_ADVICE_BIAS_UNCACHED",
                    "$X_MEMORY_ADVICE_SET_SYSTEM_MEMORY_PREFERRED_LOCATION",
                    "$X_MEMORY_ADVICE_CLEAR_SYSTEM_MEMORY_PREFERRED_LOCATION"
                ],
                "max": "$X_MEMORY_ADVICE_CLEAR_SYSTEM_MEMORY_PREFERRED_LOCATION"
            },
            "$x_memory_atomic_attr_exp_flags_t": {
                "class": "$xMem",
                "etors": [
                    "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_NO_ATOMICS",
                    "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_NO_HOST_ATOMICS",
                    "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_HOST_ATOMICS",
                    "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_NO_DEVICE_ATOMICS",
                    "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_DEVICE_ATOMICS",
                    "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_NO_SYSTEM_ATOMICS",
                    "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_SYSTEM_ATOMICS"
                ],
                "max": "0x7f"
            },
            "$x_memory_compression_hints_ext_flags_t": {
                "class": "$xMem",
                "etors": [
                    "$X_MEMORY_COMPRESSION_HINTS_EXT_FLAG_COMPRESSED",
                    "$X_MEMORY_COMPRESSION_HINTS_EXT_FLAG_UNCOMPRESSED"
                ],
                "max": "0x3"
            },
            "$x_memory_compression_hints_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_MEMORY_COMPRESSION_HINTS_EXT_VERSION_1_0",
                    "$X_MEMORY_COMPRESSION_HINTS_EXT_VERSION_CURRENT"
                ],
                "max": "$X_MEMORY_COMPRESSION_HINTS_EXT_VERSION_CURRENT"
            },
            "$x_memory_free_policies_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_MEMORY_FREE_POLICIES_EXT_VERSION_1_0",
                    "$X_MEMORY_FREE_POLICIES_EXT_VERSION_CURRENT"
                ],
                "max": "$X_MEMORY_FREE_POLICIES_EXT_VERSION_CURRENT"
            },
            "$x_memory_type_t": {
                "class": "$xMem",
                "etors": [
                    "$X_MEMORY_TYPE_UNKNOWN",
                    "$X_MEMORY_TYPE_HOST",
                    "$X_MEMORY_TYPE_DEVICE",
                    "$X_MEMORY_TYPE_SHARED"
                ],
                "max": "$X_MEMORY_TYPE_SHARED"
            },
            "$x_metric_global_timestamps_exp_version_t": {
                "class": "",
                "etors": [
                    "$X_METRIC_GLOBAL_TIMESTAMPS_EXP_VERSION_1_0",
                    "$X_METRIC_GLOBAL_TIMESTAMPS_EXP_VERSION_CURRENT"
                ],
                "max": "$X_METRIC_GLOBAL_TIMESTAMPS_EXP_VERSION_CURRENT"
            },
            "$x_module_format_t": {
                "class": "$xModule",
                "etors": [
                    "$X_MODULE_FORMAT_IL_SPIRV",
                    "$X_MODULE_FORMAT_NATIVE"
                ],
                "max": "$X_MODULE_FORMAT_NATIVE"
            },
            "$x_module_program_exp_version_t": {
                "class": "",
                "etors": [
                    "$X_MODULE_PROGRAM_EXP_VERSION_1_0",
                    "$X_MODULE_PROGRAM_EXP_VERSION_CURRENT"
                ],
                "max": "$X_MODULE_PROGRAM_EXP_VERSION_CURRENT"
            },
            "$x_module_property_flags_t": {
                "class": "$xModule",
                "etors": [
                    "$X_MODULE_PROPERTY_FLAG_IMPORTS"
                ],
                "max": "0x1"
            },
            "$x_pci_properties_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_PCI_PROPERTIES_EXT_VERSION_1_0",
                    "$X_PCI_PROPERTIES_EXT_VERSION_CURRENT"
                ],
                "max": "$X_PCI_PROPERTIES_EXT_VERSION_CURRENT"
            },
            "$x_physical_mem_flags_t": {
                "class": "$xPhysicalMem",
                "etors": [
                    "$X_PHYSICAL_MEM_FLAG_TBD"
                ],
                "max": "0x1"
            },
            "$x_power_saving_hint_exp_version_t": {
                "class": "",
                "etors": [
                    "$X_POWER_SAVING_HINT_EXP_VERSION_1_0",
                    "$X_POWER_SAVING_HINT_EXP_VERSION_CURRENT"
                ],
                "max": "$X_POWER_SAVING_HINT_EXP_VERSION_CURRENT"
            },
            "$x_power_saving_hint_type_t": {
                "class": "$xContext",
                "etors": [
                    "$X_POWER_SAVING_HINT_TYPE_MIN",
                    "$X_POWER_SAVING_HINT_TYPE_MAX"
                ],
                "max": "$X_POWER_SAVING_HINT_TYPE_MAX"
            },
            "$x_raytracing_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_RAYTRACING_EXT_VERSION_1_0",
                    "$X_RAYTRACING_EXT_VERSION_CURRENT"
                ],
                "max": "$X_RAYTRACING_EXT_VERSION_CURRENT"
            },
            "$x_raytracing_mem_alloc_ext_flags_t": {
                "class": "$xContext",
                "etors": [
                    "$X_RAYTRACING_MEM_ALLOC_EXT_FLAG_TBD"
                ],
                "max": "0x1"
            },
            "$x_relaxed_allocation_limits_exp_flags_t": {
                "class": "$xMem",
                "etors": [
                    "$X_RELAXED_ALLOCATION_LIMITS_EXP_FLAG_MAX_SIZE"
                ],
                "max": "0x1"
            },
            "$x_relaxed_allocation_limits_exp_version_t": {
                "class": "",
                "etors": [
                    "$X_RELAXED_ALLOCATION_LIMITS_EXP_VERSION_1_0",
                    "$X_RELAXED_ALLOCATION_LIMITS_EXP_VERSION_CURRENT"
                ],
                "max": "$X_RELAXED_ALLOCATION_LIMITS_EXP_VERSION_CURRENT"
            },
            "$x_result_t": {
                "class": "",
                "etors": [
                    "$X_RESULT_SUCCESS",
                    "$X_RESULT_NOT_READY",
                    "$X_RESULT_ERROR_DEVICE_LOST",
                    "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY",
                    "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY",
                    "$X_RESULT_ERROR_MODULE_BUILD_FAILURE",
                    "$X_RESULT_ERROR_MODULE_LINK_FAILURE",
                    "$X_RESULT_ERROR_DEVICE_REQUIRES_RESET",
                    "$X_RESULT_ERROR_DEVICE_IN_LOW_POWER_STATE",
                    "$X_RESULT_EXP_ERROR_DEVICE_IS_NOT_VERTEX",
                    "$X_RESULT_EXP_ERROR_VERTEX_IS_NOT_DEVICE",
                    "$X_RESULT_EXP_ERROR_REMOTE_DEVICE",
                    "$X_RESULT_EXP_ERROR_OPERANDS_INCOMPATIBLE",
                    "$X_RESULT_EXP_RTAS_BUILD_RETRY",
                    "$X_RESULT_EXP_RTAS_BUILD_DEFERRED",
                    "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS",
                    "$X_RESULT_ERROR_NOT_AVAILABLE",
                    "$X_RESULT_ERROR_DEPENDENCY_UNAVAILABLE",
                    "$X_RESULT_WARNING_DROPPED_DATA",
                    "$X_RESULT_ERROR_UNINITIALIZED",
                    "$X_RESULT_ERROR_UNSUPPORTED_VERSION",
                    "$X_RESULT_ERROR_UNSUPPORTED_FEATURE",
                    "$X_RESULT_ERROR_INVALID_ARGUMENT",
                    "$X_RESULT_ERROR_INVALID_NULL_HANDLE",
                    "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE",
                    "$X_RESULT_ERROR_INVALID_NULL_POINTER",
                    "$X_RESULT_ERROR_INVALID_SIZE",
                    "$X_RESULT_ERROR_UNSUPPORTED_SIZE",
                    "$X_RESULT_ERROR_UNSUPPORTED_ALIGNMENT",
                    "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT",
                    "$X_RESULT_ERROR_INVALID_ENUMERATION",
                    "$X_RESULT_ERROR_UNSUPPORTED_ENUMERATION",
                    "$X_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT",
                    "$X_RESULT_ERROR_INVALID_NATIVE_BINARY",
                    "$X_RESULT_ERROR_INVALID_GLOBAL_NAME",
                    "$X_RESULT_ERROR_INVALID_KERNEL_NAME",
                    "$X_RESULT_ERROR_INVALID_FUNCTION_NAME",
                    "$X_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION",
                    "$X_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION",
                    "$X_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX",
                    "$X_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE",
                    "$X_RESULT_ERROR_INVALID_KERNEL_ATTRIBUTE_VALUE",
                    "$X_RESULT_ERROR_INVALID_MODULE_UNLINKED",
                    "$X_RESULT_ERROR_INVALID_COMMAND_LIST_TYPE",
                    "$X_RESULT_ERROR_OVERLAPPING_REGIONS",
                    "$X_RESULT_WARNING_ACTION_REQUIRED",
                    "$X_RESULT_ERROR_UNKNOWN"
                ],
                "max": "$X_RESULT_ERROR_UNKNOWN"
            },
            "$x_rtas_builder_build_op_exp_flags_t": {
                "class": "$xRTASBuilder",
                "etors": [
                    "$X_RTAS_BUILDER_BUILD_OP_EXP_FLAG_COMPACT",
                    "$X_RTAS_BUILDER_BUILD_OP_EXP_FLAG_NO_DUPLICATE_ANYHIT_INVOCATION"
                ],
                "max": "0x3"
            },
            "$x_rtas_builder_build_quality_hint_exp_t": {
                "class": "$xRTASBuilder",
                "etors": [
                    "$X_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_LOW",
                    "$X_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_MEDIUM",
                    "$X_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_HIGH"
                ],
                "max": "$X_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_HIGH"
            },
            "$x_rtas_builder_exp_flags_t": {
                "class": "$xRTASBuilder",
                "etors": [
                    "$X_RTAS_BUILDER_EXP_FLAG_RESERVED"
                ],
                "max": "0x1"
            },
            "$x_rtas_builder_exp_version_t": {
                "class": "",
                "etors": [
                    "$X_RTAS_BUILDER_EXP_VERSION_1_0",
                    "$X_RTAS_BUILDER_EXP_VERSION_CURRENT"
                ],
                "max": "$X_RTAS_BUILDER_EXP_VERSION_CURRENT"
            },
            "$x_rtas_builder_geometry_exp_flags_t": {
                "class": "$xRTASBuilder",
                "etors": [
                    "$X_RTAS_BUILDER_GEOMETRY_EXP_FLAG_NON_OPAQUE"
                ],
                "max": "0x1"
            },
            "$x_rtas_builder_geometry_type_exp_t": {
                "class": "$xRTASBuilder",
                "etors": [
                    "$X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_TRIANGLES",
                    "$X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_QUADS",
                    "$X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_PROCEDURAL",
                    "$X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_INSTANCE"
                ],
                "max": "$X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_INSTANCE"
            },
            "$x_rtas_builder_input_data_format_exp_t": {
                "class": "$xRTASBuilder",
                "etors": [
                    "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3",
                    "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3X4_COLUMN_MAJOR",
                    "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3X4_ALIGNED_COLUMN_MAJOR",
                    "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3X4_ROW_MAJOR",
                    "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_AABB",
                    "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_TRIANGLE_INDICES_UINT32",
                    "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_QUAD_INDICES_UINT32"
                ],
                "max": "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_QUAD_INDICES_UINT32"
            },
            "$x_rtas_builder_instance_exp_flags_t": {
                "class": "$xRTASBuilder",
                "etors": [
                    "$X_RTAS_BUILDER_INSTANCE_EXP_FLAG_TRIANGLE_CULL_DISABLE",
                    "$X_RTAS_BUILDER_INSTANCE_EXP_FLAG_TRIANGLE_FRONT_COUNTERCLOCKWISE",
                    "$X_RTAS_BUILDER_INSTANCE_EXP_FLAG_TRIANGLE_FORCE_OPAQUE",
                    "$X_RTAS_BUILDER_INSTANCE_EXP_FLAG_TRIANGLE_FORCE_NON_OPAQUE"
                ],
                "max": "0xf"
            },
            "$x_rtas_device_exp_flags_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_RTAS_DEVICE_EXP_FLAG_RESERVED"
                ],
                "max": "0x1"
            },
            "$x_rtas_format_exp_t": {
                "class": "$xDevice",
                "etors": [
                    "$X_RTAS_FORMAT_EXP_INVALID"
                ],
                "max": "$X_RTAS_FORMAT_EXP_INVALID"
            },
            "$x_rtas_parallel_operation_exp_flags_t": {
                "class": "$xRTASParallelOperation",
                "etors": [
                    "$X_RTAS_PARALLEL_OPERATION_EXP_FLAG_RESERVED"
                ],
                "max": "0x1"
            },
            "$x_sampler_address_mode_t": {
                "class": "$xSampler",
                "etors": [
                    "$X_SAMPLER_ADDRESS_MODE_NONE",
                    "$X_SAMPLER_ADDRESS_MODE_REPEAT",
                    "$X_SAMPLER_ADDRESS_MODE_CLAMP",
                    "$X_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER",
                    "$X_SAMPLER_ADDRESS_MODE_MIRROR"
                ],
                "max": "$X_SAMPLER_ADDRESS_MODE_MIRROR"
            },
            "$x_sampler_filter_mode_t": {
                "class": "$xSampler",
                "etors": [
                    "$X_SAMPLER_FILTER_MODE_NEAREST",
                    "$X_SAMPLER_FILTER_MODE_LINEAR"
                ],
                "max": "$X_SAMPLER_FILTER_MODE_LINEAR"
            },
            "$x_scheduling_hint_exp_flags_t": {
                "class": "$xKernel",
                "etors": [
                    "$X_SCHEDULING_HINT_EXP_FLAG_OLDEST_FIRST",
                    "$X_SCHEDULING_HINT_EXP_FLAG_ROUND_ROBIN",
                    "$X_SCHEDULING_HINT_EXP_FLAG_STALL_BASED_ROUND_ROBIN"
                ],
                "max": "0x7"
            },
            "$x_scheduling_hints_exp_version_t": {
                "class": "",
                "etors": [
                    "$X_SCHEDULING_HINTS_EXP_VERSION_1_0",
                    "$X_SCHEDULING_HINTS_EXP_VERSION_CURRENT"
                ],
                "max": "$X_SCHEDULING_HINTS_EXP_VERSION_CURRENT"
            },
            "$x_srgb_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_SRGB_EXT_VERSION_1_0",
                    "$X_SRGB_EXT_VERSION_CURRENT"
                ],
                "max": "$X_SRGB_EXT_VERSION_CURRENT"
            },
            "$x_structure_type_t": {
                "class": "",
                "etors": [
                    "$X_STRUCTURE_TYPE_DRIVER_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DRIVER_IPC_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_COMPUTE_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_MODULE_PROPERTIES",
                    "$X_STRUCTURE_TYPE_COMMAND_QUEUE_GROUP_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_MEMORY_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_MEMORY_ACCESS_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_CACHE_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_IMAGE_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_P2P_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_EXTERNAL_MEMORY_PROPERTIES",
                    "$X_STRUCTURE_TYPE_CONTEXT_DESC",
                    "$X_STRUCTURE_TYPE_COMMAND_QUEUE_DESC",
                    "$X_STRUCTURE_TYPE_COMMAND_LIST_DESC",
                    "$X_STRUCTURE_TYPE_EVENT_POOL_DESC",
                    "$X_STRUCTURE_TYPE_EVENT_DESC",
                    "$X_STRUCTURE_TYPE_FENCE_DESC",
                    "$X_STRUCTURE_TYPE_IMAGE_DESC",
                    "$X_STRUCTURE_TYPE_IMAGE_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_MEM_ALLOC_DESC",
                    "$X_STRUCTURE_TYPE_HOST_MEM_ALLOC_DESC",
                    "$X_STRUCTURE_TYPE_MEMORY_ALLOCATION_PROPERTIES",
                    "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_DESC",
                    "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_FD",
                    "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_FD",
                    "$X_STRUCTURE_TYPE_MODULE_DESC",
                    "$X_STRUCTURE_TYPE_MODULE_PROPERTIES",
                    "$X_STRUCTURE_TYPE_KERNEL_DESC",
                    "$X_STRUCTURE_TYPE_KERNEL_PROPERTIES",
                    "$X_STRUCTURE_TYPE_SAMPLER_DESC",
                    "$X_STRUCTURE_TYPE_PHYSICAL_MEM_DESC",
                    "$X_STRUCTURE_TYPE_KERNEL_PREFERRED_GROUP_SIZE_PROPERTIES",
                    "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_WIN32",
                    "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_WIN32",
                    "$X_STRUCTURE_TYPE_DEVICE_RAYTRACING_EXT_PROPERTIES",
                    "$X_STRUCTURE_TYPE_RAYTRACING_MEM_ALLOC_EXT_DESC",
                    "$X_STRUCTURE_TYPE_FLOAT_ATOMIC_EXT_PROPERTIES",
                    "$X_STRUCTURE_TYPE_CACHE_RESERVATION_EXT_DESC",
                    "$X_STRUCTURE_TYPE_EU_COUNT_EXT",
                    "$X_STRUCTURE_TYPE_SRGB_EXT_DESC",
                    "$X_STRUCTURE_TYPE_LINKAGE_INSPECTION_EXT_DESC",
                    "$X_STRUCTURE_TYPE_PCI_EXT_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DRIVER_MEMORY_FREE_EXT_PROPERTIES",
                    "$X_STRUCTURE_TYPE_MEMORY_FREE_EXT_DESC",
                    "$X_STRUCTURE_TYPE_MEMORY_COMPRESSION_HINTS_EXT_DESC",
                    "$X_STRUCTURE_TYPE_IMAGE_ALLOCATION_EXT_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_LUID_EXT_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_MEMORY_EXT_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_IP_VERSION_EXT",
                    "$X_STRUCTURE_TYPE_IMAGE_VIEW_PLANAR_EXT_DESC",
                    "$X_STRUCTURE_TYPE_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_PROPERTIES",
                    "$X_STRUCTURE_TYPE_EVENT_QUERY_KERNEL_TIMESTAMPS_RESULTS_EXT_PROPERTIES",
                    "$X_STRUCTURE_TYPE_KERNEL_MAX_GROUP_SIZE_EXT_PROPERTIES",
                    "$X_STRUCTURE_TYPE_RELAXED_ALLOCATION_LIMITS_EXP_DESC",
                    "$X_STRUCTURE_TYPE_MODULE_PROGRAM_EXP_DESC",
                    "$X_STRUCTURE_TYPE_SCHEDULING_HINT_EXP_PROPERTIES",
                    "$X_STRUCTURE_TYPE_SCHEDULING_HINT_EXP_DESC",
                    "$X_STRUCTURE_TYPE_IMAGE_VIEW_PLANAR_EXP_DESC",
                    "$X_STRUCTURE_TYPE_DEVICE_PROPERTIES_1_2",
                    "$X_STRUCTURE_TYPE_IMAGE_MEMORY_EXP_PROPERTIES",
                    "$X_STRUCTURE_TYPE_POWER_SAVING_HINT_EXP_DESC",
                    "$X_STRUCTURE_TYPE_COPY_BANDWIDTH_EXP_PROPERTIES",
                    "$X_STRUCTURE_TYPE_DEVICE_P2P_BANDWIDTH_EXP_PROPERTIES",
                    "$X_STRUCTURE_TYPE_FABRIC_VERTEX_EXP_PROPERTIES",
                    "$X_STRUCTURE_TYPE_FABRIC_EDGE_EXP_PROPERTIES",
                    "$X_STRUCTURE_TYPE_MEMORY_SUB_ALLOCATIONS_EXP_PROPERTIES",
                    "$X_STRUCTURE_TYPE_RTAS_BUILDER_EXP_DESC",
                    "$X_STRUCTURE_TYPE_RTAS_BUILDER_BUILD_OP_EXP_DESC",
                    "$X_STRUCTURE_TYPE_RTAS_BUILDER_EXP_PROPERTIES",
                    "$X_STRUCTURE_TYPE_RTAS_PARALLEL_OPERATION_EXP_PROPERTIES",
                    "$X_STRUCTURE_TYPE_RTAS_DEVICE_EXP_PROPERTIES",
                    "$X_STRUCTURE_TYPE_RTAS_GEOMETRY_AABBS_EXP_CB_PARAMS"
                ],
                "max": "$X_STRUCTURE_TYPE_RTAS_GEOMETRY_AABBS_EXP_CB_PARAMS"
            },
            "$x_sub_allocations_exp_version_t": {
                "class": "",
                "etors": [
                    "$X_SUB_ALLOCATIONS_EXP_VERSION_1_0",
                    "$X_SUB_ALLOCATIONS_EXP_VERSION_CURRENT"
                ],
                "max": "$X_SUB_ALLOCATIONS_EXP_VERSION_CURRENT"
            },
            "$x_subgroup_ext_version_t": {
                "class": "",
                "etors": [
                    "$X_SUBGROUP_EXT_VERSION_1_0",
                    "$X_SUBGROUP_EXT_VERSION_CURRENT"
                ],
                "max": "$X_SUBGROUP_EXT_VERSION_CURRENT"
            }
        },
        "env": {
            "$T_ENABLE_METRICS": {
                "class": ""
            },
            "$T_ENABLE_PROGRAM_DEBUGGING": {
                "class": ""
            },
            "$T_ENABLE_PROGRAM_INSTRUMENTATION": {
                "class": ""
            },
            "$X_AFFINITY_MASK": {
                "class": ""
            },
            "$X_ENABLE_PCI_ID_DEVICE_ORDER": {
                "class": ""
            },
            "$X_FLAT_DEVICE_HIERARCHY": {
                "class": ""
            },
            "$X_SHARED_FORCE_DEVICE_ALLOC": {
                "class": ""
            }
        },
        "function": {
            "$sDeviceEccAvailable": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$x_bool_t*"
                    }
                ]
            },
            "$sDeviceEccConfigurable": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$x_bool_t*"
                    }
                ]
            },
            "$sDeviceEnumDiagnosticTestSuites": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_diag_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumEngineGroups": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_engine_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumFabricPorts": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_fabric_port_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumFans": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_fan_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumFirmwares": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_firmware_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumFrequencyDomains": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_freq_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumLeds": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_led_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumMemoryModules": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_mem_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumOverclockDomains": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_overclock_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumPerformanceFactorDomains": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_perf_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumPowerDomains": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_pwr_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumPsus": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_psu_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumRasErrorSets": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_ras_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumSchedulers": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_sched_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumStandbyDomains": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_standby_handle_t*"
                    }
                ]
            },
            "$sDeviceEnumTemperatureSensors": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_temp_handle_t*"
                    }
                ]
            },
            "$sDeviceEventRegister": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$s_event_type_flags_t"
                    }
                ]
            },
            "$sDeviceGet": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_driver_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_device_handle_t*"
                    }
                ]
            },
            "$sDeviceGetCardPowerDomain": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$s_pwr_handle_t*"
                    }
                ]
            },
            "$sDeviceGetEccState": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$s_device_ecc_properties_t*"
                    }
                ]
            },
            "$sDeviceGetOverclockControls": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$s_overclock_domain_t"
                    },
                    {
                        "type": "uint32_t*"
                    }
                ]
            },
            "$sDeviceGetOverclockDomains": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    }
                ]
            },
            "$sDeviceGetProperties": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$s_device_properties_t*"
                    }
                ]
            },
            "$sDeviceGetState": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$s_device_state_t*"
                    }
                ]
            },
            "$sDevicePciGetBars": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_pci_bar_properties_t*"
                    }
                ]
            },
            "$sDevicePciGetProperties": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$s_pci_properties_t*"
                    }
                ]
            },
            "$sDevicePciGetState": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$s_pci_state_t*"
                    }
                ]
            },
            "$sDevicePciGetStats": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$s_pci_stats_t*"
                    }
                ]
            },
            "$sDeviceProcessesGetState": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_process_state_t*"
                    }
                ]
            },
            "$sDeviceReadOverclockState": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$s_overclock_mode_t*"
                    },
                    {
                        "type": "$x_bool_t*"
                    },
                    {
                        "type": "$x_bool_t*"
                    },
                    {
                        "type": "$s_pending_action_t*"
                    },
                    {
                        "type": "$x_bool_t*"
                    }
                ]
            },
            "$sDeviceReset": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$x_bool_t"
                    }
                ]
            },
            "$sDeviceResetExt": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$s_reset_properties_t*"
                    }
                ]
            },
            "$sDeviceResetOverclockSettings": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "$x_bool_t"
                    }
                ]
            },
            "$sDeviceSetEccState": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "const $s_device_ecc_desc_t*"
                    },
                    {
                        "type": "$s_device_ecc_properties_t*"
                    }
                ]
            },
            "$sDeviceSetOverclockWaiver": {
                "class": "$sDevice",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    }
                ]
            },
            "$sDiagnosticsGetProperties": {
                "class": "$sDiagnostics",
                "params": [
                    {
                        "type": "$s_diag_handle_t"
                    },
                    {
                        "type": "$s_diag_properties_t*"
                    }
                ]
            },
            "$sDiagnosticsGetTests": {
                "class": "$sDiagnostics",
                "params": [
                    {
                        "type": "$s_diag_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_diag_test_t*"
                    }
                ]
            },
            "$sDiagnosticsRunTests": {
                "class": "$sDiagnostics",
                "params": [
                    {
                        "type": "$s_diag_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$s_diag_result_t*"
                    }
                ]
            },
            "$sDriverEventListen": {
                "class": "$sDriver",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$s_device_handle_t*"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_event_type_flags_t*"
                    }
                ]
            },
            "$sDriverEventListenEx": {
                "class": "$sDriver",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "uint64_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$s_device_handle_t*"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_event_type_flags_t*"
                    }
                ]
            },
            "$sDriverGet": {
                "class": "$sDriver",
                "params": [
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_driver_handle_t*"
                    }
                ]
            },
            "$sEngineGetActivity": {
                "class": "$sEngine",
                "params": [
                    {
                        "type": "$s_engine_handle_t"
                    },
                    {
                        "type": "$s_engine_stats_t*"
                    }
                ]
            },
            "$sEngineGetActivityExt": {
                "class": "$sEngine",
                "params": [
                    {
                        "type": "$s_engine_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_engine_stats_t*"
                    }
                ]
            },
            "$sEngineGetProperties": {
                "class": "$sEngine",
                "params": [
                    {
                        "type": "$s_engine_handle_t"
                    },
                    {
                        "type": "$s_engine_properties_t*"
                    }
                ]
            },
            "$sFabricPortGetConfig": {
                "class": "$sFabricPort",
                "params": [
                    {
                        "type": "$s_fabric_port_handle_t"
                    },
                    {
                        "type": "$s_fabric_port_config_t*"
                    }
                ]
            },
            "$sFabricPortGetFabricErrorCounters": {
                "class": "$sFabricPort",
                "params": [
                    {
                        "type": "$s_fabric_port_handle_t"
                    },
                    {
                        "type": "$s_fabric_port_error_counters_t*"
                    }
                ]
            },
            "$sFabricPortGetLinkType": {
                "class": "$sFabricPort",
                "params": [
                    {
                        "type": "$s_fabric_port_handle_t"
                    },
                    {
                        "type": "$s_fabric_link_type_t*"
                    }
                ]
            },
            "$sFabricPortGetMultiPortThroughput": {
                "class": "$sFabricPort",
                "params": [
                    {
                        "type": "$s_device_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$s_fabric_port_handle_t*"
                    },
                    {
                        "type": "$s_fabric_port_throughput_t**"
                    }
                ]
            },
            "$sFabricPortGetProperties": {
                "class": "$sFabricPort",
                "params": [
                    {
                        "type": "$s_fabric_port_handle_t"
                    },
                    {
                        "type": "$s_fabric_port_properties_t*"
                    }
                ]
            },
            "$sFabricPortGetState": {
                "class": "$sFabricPort",
                "params": [
                    {
                        "type": "$s_fabric_port_handle_t"
                    },
                    {
                        "type": "$s_fabric_port_state_t*"
                    }
                ]
            },
            "$sFabricPortGetThroughput": {
                "class": "$sFabricPort",
                "params": [
                    {
                        "type": "$s_fabric_port_handle_t"
                    },
                    {
                        "type": "$s_fabric_port_throughput_t*"
                    }
                ]
            },
            "$sFabricPortSetConfig": {
                "class": "$sFabricPort",
                "params": [
                    {
                        "type": "$s_fabric_port_handle_t"
                    },
                    {
                        "type": "const $s_fabric_port_config_t*"
                    }
                ]
            },
            "$sFanGetConfig": {
                "class": "$sFan",
                "params": [
                    {
                        "type": "$s_fan_handle_t"
                    },
                    {
                        "type": "$s_fan_config_t*"
                    }
                ]
            },
            "$sFanGetProperties": {
                "class": "$sFan",
                "params": [
                    {
                        "type": "$s_fan_handle_t"
                    },
                    {
                        "type": "$s_fan_properties_t*"
                    }
                ]
            },
            "$sFanGetState": {
                "class": "$sFan",
                "params": [
                    {
                        "type": "$s_fan_handle_t"
                    },
                    {
                        "type": "$s_fan_speed_units_t"
                    },
                    {
                        "type": "int32_t*"
                    }
                ]
            },
            "$sFanSetDefaultMode": {
                "class": "$sFan",
                "params": [
                    {
                        "type": "$s_fan_handle_t"
                    }
                ]
            },
            "$sFanSetFixedSpeedMode": {
                "class": "$sFan",
                "params": [
                    {
                        "type": "$s_fan_handle_t"
                    },
                    {
                        "type": "const $s_fan_speed_t*"
                    }
                ]
            },
            "$sFanSetSpeedTableMode": {
                "class": "$sFan",
                "params": [
                    {
                        "type": "$s_fan_handle_t"
                    },
                    {
                        "type": "const $s_fan_speed_table_t*"
                    }
                ]
            },
            "$sFirmwareFlash": {
                "class": "$sFirmware",
                "params": [
                    {
                        "type": "$s_firmware_handle_t"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "uint32_t"
                    }
                ]
            },
            "$sFirmwareGetProperties": {
                "class": "$sFirmware",
                "params": [
                    {
                        "type": "$s_firmware_handle_t"
                    },
                    {
                        "type": "$s_firmware_properties_t*"
                    }
                ]
            },
            "$sFrequencyGetAvailableClocks": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "double*"
                    }
                ]
            },
            "$sFrequencyGetProperties": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "$s_freq_properties_t*"
                    }
                ]
            },
            "$sFrequencyGetRange": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "$s_freq_range_t*"
                    }
                ]
            },
            "$sFrequencyGetState": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "$s_freq_state_t*"
                    }
                ]
            },
            "$sFrequencyGetThrottleTime": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "$s_freq_throttle_time_t*"
                    }
                ]
            },
            "$sFrequencyOcGetCapabilities": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "$s_oc_capabilities_t*"
                    }
                ]
            },
            "$sFrequencyOcGetFrequencyTarget": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "double*"
                    }
                ]
            },
            "$sFrequencyOcGetIccMax": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "double*"
                    }
                ]
            },
            "$sFrequencyOcGetMode": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "$s_oc_mode_t*"
                    }
                ]
            },
            "$sFrequencyOcGetTjMax": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "double*"
                    }
                ]
            },
            "$sFrequencyOcGetVoltageTarget": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "double*"
                    },
                    {
                        "type": "double*"
                    }
                ]
            },
            "$sFrequencyOcSetFrequencyTarget": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "double"
                    }
                ]
            },
            "$sFrequencyOcSetIccMax": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "double"
                    }
                ]
            },
            "$sFrequencyOcSetMode": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "$s_oc_mode_t"
                    }
                ]
            },
            "$sFrequencyOcSetTjMax": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "double"
                    }
                ]
            },
            "$sFrequencyOcSetVoltageTarget": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "double"
                    },
                    {
                        "type": "double"
                    }
                ]
            },
            "$sFrequencySetRange": {
                "class": "$sFrequency",
                "params": [
                    {
                        "type": "$s_freq_handle_t"
                    },
                    {
                        "type": "const $s_freq_range_t*"
                    }
                ]
            },
            "$sInit": {
                "class": "$s",
                "params": [
                    {
                        "type": "$s_init_flags_t"
                    }
                ]
            },
            "$sLedGetProperties": {
                "class": "$sLed",
                "params": [
                    {
                        "type": "$s_led_handle_t"
                    },
                    {
                        "type": "$s_led_properties_t*"
                    }
                ]
            },
            "$sLedGetState": {
                "class": "$sLed",
                "params": [
                    {
                        "type": "$s_led_handle_t"
                    },
                    {
                        "type": "$s_led_state_t*"
                    }
                ]
            },
            "$sLedSetColor": {
                "class": "$sLed",
                "params": [
                    {
                        "type": "$s_led_handle_t"
                    },
                    {
                        "type": "const $s_led_color_t*"
                    }
                ]
            },
            "$sLedSetState": {
                "class": "$sLed",
                "params": [
                    {
                        "type": "$s_led_handle_t"
                    },
                    {
                        "type": "$x_bool_t"
                    }
                ]
            },
            "$sMemoryGetBandwidth": {
                "class": "$sMemory",
                "params": [
                    {
                        "type": "$s_mem_handle_t"
                    },
                    {
                        "type": "$s_mem_bandwidth_t*"
                    }
                ]
            },
            "$sMemoryGetProperties": {
                "class": "$sMemory",
                "params": [
                    {
                        "type": "$s_mem_handle_t"
                    },
                    {
                        "type": "$s_mem_properties_t*"
                    }
                ]
            },
            "$sMemoryGetState": {
                "class": "$sMemory",
                "params": [
                    {
                        "type": "$s_mem_handle_t"
                    },
                    {
                        "type": "$s_mem_state_t*"
                    }
                ]
            },
            "$sOverclockGetControlCurrentValue": {
                "class": "$sOverclock",
                "params": [
                    {
                        "type": "$s_overclock_handle_t"
                    },
                    {
                        "type": "$s_overclock_control_t"
                    },
                    {
                        "type": "double*"
                    }
                ]
            },
            "$sOverclockGetControlPendingValue": {
                "class": "$sOverclock",
                "params": [
                    {
                        "type": "$s_overclock_handle_t"
                    },
                    {
                        "type": "$s_overclock_control_t"
                    },
                    {
                        "type": "double*"
                    }
                ]
            },
            "$sOverclockGetControlState": {
                "class": "$sOverclock",
                "params": [
                    {
                        "type": "$s_overclock_handle_t"
                    },
                    {
                        "type": "$s_overclock_control_t"
                    },
                    {
                        "type": "$s_control_state_t*"
                    },
                    {
                        "type": "$s_pending_action_t*"
                    }
                ]
            },
            "$sOverclockGetDomainControlProperties": {
                "class": "$sOverclock",
                "params": [
                    {
                        "type": "$s_overclock_handle_t"
                    },
                    {
                        "type": "$s_overclock_control_t"
                    },
                    {
                        "type": "$s_control_property_t*"
                    }
                ]
            },
            "$sOverclockGetDomainProperties": {
                "class": "$sOverclock",
                "params": [
                    {
                        "type": "$s_overclock_handle_t"
                    },
                    {
                        "type": "$s_overclock_properties_t*"
                    }
                ]
            },
            "$sOverclockGetDomainVFProperties": {
                "class": "$sOverclock",
                "params": [
                    {
                        "type": "$s_overclock_handle_t"
                    },
                    {
                        "type": "$s_vf_property_t*"
                    }
                ]
            },
            "$sOverclockGetVFPointValues": {
                "class": "$sOverclock",
                "params": [
                    {
                        "type": "$s_overclock_handle_t"
                    },
                    {
                        "type": "$s_vf_type_t"
                    },
                    {
                        "type": "$s_vf_array_type_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t*"
                    }
                ]
            },
            "$sOverclockSetControlUserValue": {
                "class": "$sOverclock",
                "params": [
                    {
                        "type": "$s_overclock_handle_t"
                    },
                    {
                        "type": "$s_overclock_control_t"
                    },
                    {
                        "type": "double"
                    },
                    {
                        "type": "$s_pending_action_t*"
                    }
                ]
            },
            "$sOverclockSetVFPointValues": {
                "class": "$sOverclock",
                "params": [
                    {
                        "type": "$s_overclock_handle_t"
                    },
                    {
                        "type": "$s_vf_type_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    }
                ]
            },
            "$sPerformanceFactorGetConfig": {
                "class": "$sPerformanceFactor",
                "params": [
                    {
                        "type": "$s_perf_handle_t"
                    },
                    {
                        "type": "double*"
                    }
                ]
            },
            "$sPerformanceFactorGetProperties": {
                "class": "$sPerformanceFactor",
                "params": [
                    {
                        "type": "$s_perf_handle_t"
                    },
                    {
                        "type": "$s_perf_properties_t*"
                    }
                ]
            },
            "$sPerformanceFactorSetConfig": {
                "class": "$sPerformanceFactor",
                "params": [
                    {
                        "type": "$s_perf_handle_t"
                    },
                    {
                        "type": "double"
                    }
                ]
            },
            "$sPowerGetEnergyCounter": {
                "class": "$sPower",
                "params": [
                    {
                        "type": "$s_pwr_handle_t"
                    },
                    {
                        "type": "$s_power_energy_counter_t*"
                    }
                ]
            },
            "$sPowerGetEnergyThreshold": {
                "class": "$sPower",
                "params": [
                    {
                        "type": "$s_pwr_handle_t"
                    },
                    {
                        "type": "$s_energy_threshold_t*"
                    }
                ]
            },
            "$sPowerGetLimits": {
                "class": "$sPower",
                "params": [
                    {
                        "type": "$s_pwr_handle_t"
                    },
                    {
                        "type": "$s_power_sustained_limit_t*"
                    },
                    {
                        "type": "$s_power_burst_limit_t*"
                    },
                    {
                        "type": "$s_power_peak_limit_t*"
                    }
                ]
            },
            "$sPowerGetLimitsExt": {
                "class": "$sPower",
                "params": [
                    {
                        "type": "$s_pwr_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_power_limit_ext_desc_t*"
                    }
                ]
            },
            "$sPowerGetProperties": {
                "class": "$sPower",
                "params": [
                    {
                        "type": "$s_pwr_handle_t"
                    },
                    {
                        "type": "$s_power_properties_t*"
                    }
                ]
            },
            "$sPowerSetEnergyThreshold": {
                "class": "$sPower",
                "params": [
                    {
                        "type": "$s_pwr_handle_t"
                    },
                    {
                        "type": "double"
                    }
                ]
            },
            "$sPowerSetLimits": {
                "class": "$sPower",
                "params": [
                    {
                        "type": "$s_pwr_handle_t"
                    },
                    {
                        "type": "const $s_power_sustained_limit_t*"
                    },
                    {
                        "type": "const $s_power_burst_limit_t*"
                    },
                    {
                        "type": "const $s_power_peak_limit_t*"
                    }
                ]
            },
            "$sPowerSetLimitsExt": {
                "class": "$sPower",
                "params": [
                    {
                        "type": "$s_pwr_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_power_limit_ext_desc_t*"
                    }
                ]
            },
            "$sPsuGetProperties": {
                "class": "$sPsu",
                "params": [
                    {
                        "type": "$s_psu_handle_t"
                    },
                    {
                        "type": "$s_psu_properties_t*"
                    }
                ]
            },
            "$sPsuGetState": {
                "class": "$sPsu",
                "params": [
                    {
                        "type": "$s_psu_handle_t"
                    },
                    {
                        "type": "$s_psu_state_t*"
                    }
                ]
            },
            "$sRasClearStateExp": {
                "class": "$sRas",
                "params": [
                    {
                        "type": "$s_ras_handle_t"
                    },
                    {
                        "type": "$s_ras_error_category_exp_t"
                    }
                ]
            },
            "$sRasGetConfig": {
                "class": "$sRas",
                "params": [
                    {
                        "type": "$s_ras_handle_t"
                    },
                    {
                        "type": "$s_ras_config_t*"
                    }
                ]
            },
            "$sRasGetProperties": {
                "class": "$sRas",
                "params": [
                    {
                        "type": "$s_ras_handle_t"
                    },
                    {
                        "type": "$s_ras_properties_t*"
                    }
                ]
            },
            "$sRasGetState": {
                "class": "$sRas",
                "params": [
                    {
                        "type": "$s_ras_handle_t"
                    },
                    {
                        "type": "$x_bool_t"
                    },
                    {
                        "type": "$s_ras_state_t*"
                    }
                ]
            },
            "$sRasGetStateExp": {
                "class": "$sRas",
                "params": [
                    {
                        "type": "$s_ras_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$s_ras_state_exp_t*"
                    }
                ]
            },
            "$sRasSetConfig": {
                "class": "$sRas",
                "params": [
                    {
                        "type": "$s_ras_handle_t"
                    },
                    {
                        "type": "const $s_ras_config_t*"
                    }
                ]
            },
            "$sSchedulerGetCurrentMode": {
                "class": "$sScheduler",
                "params": [
                    {
                        "type": "$s_sched_handle_t"
                    },
                    {
                        "type": "$s_sched_mode_t*"
                    }
                ]
            },
            "$sSchedulerGetProperties": {
                "class": "$sScheduler",
                "params": [
                    {
                        "type": "$s_sched_handle_t"
                    },
                    {
                        "type": "$s_sched_properties_t*"
                    }
                ]
            },
            "$sSchedulerGetTimeoutModeProperties": {
                "class": "$sScheduler",
                "params": [
                    {
                        "type": "$s_sched_handle_t"
                    },
                    {
                        "type": "$x_bool_t"
                    },
                    {
                        "type": "$s_sched_timeout_properties_t*"
                    }
                ]
            },
            "$sSchedulerGetTimesliceModeProperties": {
                "class": "$sScheduler",
                "params": [
                    {
                        "type": "$s_sched_handle_t"
                    },
                    {
                        "type": "$x_bool_t"
                    },
                    {
                        "type": "$s_sched_timeslice_properties_t*"
                    }
                ]
            },
            "$sSchedulerSetComputeUnitDebugMode": {
                "class": "$sScheduler",
                "params": [
                    {
                        "type": "$s_sched_handle_t"
                    },
                    {
                        "type": "$x_bool_t*"
                    }
                ]
            },
            "$sSchedulerSetExclusiveMode": {
                "class": "$sScheduler",
                "params": [
                    {
                        "type": "$s_sched_handle_t"
                    },
                    {
                        "type": "$x_bool_t*"
                    }
                ]
            },
            "$sSchedulerSetTimeoutMode": {
                "class": "$sScheduler",
                "params": [
                    {
                        "type": "$s_sched_handle_t"
                    },
                    {
                        "type": "$s_sched_timeout_properties_t*"
                    },
                    {
                        "type": "$x_bool_t*"
                    }
                ]
            },
            "$sSchedulerSetTimesliceMode": {
                "class": "$sScheduler",
                "params": [
                    {
                        "type": "$s_sched_handle_t"
                    },
                    {
                        "type": "$s_sched_timeslice_properties_t*"
                    },
                    {
                        "type": "$x_bool_t*"
                    }
                ]
            },
            "$sStandbyGetMode": {
                "class": "$sStandby",
                "params": [
                    {
                        "type": "$s_standby_handle_t"
                    },
                    {
                        "type": "$s_standby_promo_mode_t*"
                    }
                ]
            },
            "$sStandbyGetProperties": {
                "class": "$sStandby",
                "params": [
                    {
                        "type": "$s_standby_handle_t"
                    },
                    {
                        "type": "$s_standby_properties_t*"
                    }
                ]
            },
            "$sStandbySetMode": {
                "class": "$sStandby",
                "params": [
                    {
                        "type": "$s_standby_handle_t"
                    },
                    {
                        "type": "$s_standby_promo_mode_t"
                    }
                ]
            },
            "$sTemperatureGetConfig": {
                "class": "$sTemperature",
                "params": [
                    {
                        "type": "$s_temp_handle_t"
                    },
                    {
                        "type": "$s_temp_config_t*"
                    }
                ]
            },
            "$sTemperatureGetProperties": {
                "class": "$sTemperature",
                "params": [
                    {
                        "type": "$s_temp_handle_t"
                    },
                    {
                        "type": "$s_temp_properties_t*"
                    }
                ]
            },
            "$sTemperatureGetState": {
                "class": "$sTemperature",
                "params": [
                    {
                        "type": "$s_temp_handle_t"
                    },
                    {
                        "type": "double*"
                    }
                ]
            },
            "$sTemperatureSetConfig": {
                "class": "$sTemperature",
                "params": [
                    {
                        "type": "$s_temp_handle_t"
                    },
                    {
                        "type": "const $s_temp_config_t*"
                    }
                ]
            },
            "$tCommandListAppendMetricMemoryBarrier": {
                "class": "$tCommandList",
                "params": [
                    {
                        "type": "$t_command_list_handle_t"
                    }
                ]
            },
            "$tCommandListAppendMetricQueryBegin": {
                "class": "$tCommandList",
                "params": [
                    {
                        "type": "$t_command_list_handle_t"
                    },
                    {
                        "type": "$t_metric_query_handle_t"
                    }
                ]
            },
            "$tCommandListAppendMetricQueryEnd": {
                "class": "$tCommandList",
                "params": [
                    {
                        "type": "$t_command_list_handle_t"
                    },
                    {
                        "type": "$t_metric_query_handle_t"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$tCommandListAppendMetricStreamerMarker": {
                "class": "$tCommandList",
                "params": [
                    {
                        "type": "$t_command_list_handle_t"
                    },
                    {
                        "type": "$t_metric_streamer_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    }
                ]
            },
            "$tContextActivateMetricGroups": {
                "class": "$tContext",
                "params": [
                    {
                        "type": "$t_context_handle_t"
                    },
                    {
                        "type": "$t_device_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$t_metric_group_handle_t*"
                    }
                ]
            },
            "$tDebugAcknowledgeEvent": {
                "class": "$tDebug",
                "params": [
                    {
                        "type": "$t_debug_session_handle_t"
                    },
                    {
                        "type": "const $t_debug_event_t*"
                    }
                ]
            },
            "$tDebugAttach": {
                "class": "$tDebug",
                "params": [
                    {
                        "type": "$t_device_handle_t"
                    },
                    {
                        "type": "const $t_debug_config_t*"
                    },
                    {
                        "type": "$t_debug_session_handle_t*"
                    }
                ]
            },
            "$tDebugDetach": {
                "class": "$tDebug",
                "params": [
                    {
                        "type": "$t_debug_session_handle_t"
                    }
                ]
            },
            "$tDebugGetRegisterSetProperties": {
                "class": "$tDebug",
                "params": [
                    {
                        "type": "$t_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$t_debug_regset_properties_t*"
                    }
                ]
            },
            "$tDebugGetThreadRegisterSetProperties": {
                "class": "$tDebug",
                "params": [
                    {
                        "type": "$t_debug_session_handle_t"
                    },
                    {
                        "type": "$x_device_thread_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$t_debug_regset_properties_t*"
                    }
                ]
            },
            "$tDebugInterrupt": {
                "class": "$tDebug",
                "params": [
                    {
                        "type": "$t_debug_session_handle_t"
                    },
                    {
                        "type": "$x_device_thread_t"
                    }
                ]
            },
            "$tDebugReadEvent": {
                "class": "$tDebug",
                "params": [
                    {
                        "type": "$t_debug_session_handle_t"
                    },
                    {
                        "type": "uint64_t"
                    },
                    {
                        "type": "$t_debug_event_t*"
                    }
                ]
            },
            "$tDebugReadMemory": {
                "class": "$tDebug",
                "params": [
                    {
                        "type": "$t_debug_session_handle_t"
                    },
                    {
                        "type": "$x_device_thread_t"
                    },
                    {
                        "type": "const $t_debug_memory_space_desc_t*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "void*"
                    }
                ]
            },
            "$tDebugReadRegisters": {
                "class": "$tDebug",
                "params": [
                    {
                        "type": "$t_debug_session_handle_t"
                    },
                    {
                        "type": "$x_device_thread_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "void*"
                    }
                ]
            },
            "$tDebugResume": {
                "class": "$tDebug",
                "params": [
                    {
                        "type": "$t_debug_session_handle_t"
                    },
                    {
                        "type": "$x_device_thread_t"
                    }
                ]
            },
            "$tDebugWriteMemory": {
                "class": "$tDebug",
                "params": [
                    {
                        "type": "$t_debug_session_handle_t"
                    },
                    {
                        "type": "$x_device_thread_t"
                    },
                    {
                        "type": "const $t_debug_memory_space_desc_t*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "const void*"
                    }
                ]
            },
            "$tDebugWriteRegisters": {
                "class": "$tDebug",
                "params": [
                    {
                        "type": "$t_debug_session_handle_t"
                    },
                    {
                        "type": "$x_device_thread_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "void*"
                    }
                ]
            },
            "$tDeviceGetDebugProperties": {
                "class": "$tDevice",
                "params": [
                    {
                        "type": "$t_device_handle_t"
                    },
                    {
                        "type": "$t_device_debug_properties_t*"
                    }
                ]
            },
            "$tKernelGetProfileInfo": {
                "class": "$tKernel",
                "params": [
                    {
                        "type": "$t_kernel_handle_t"
                    },
                    {
                        "type": "$t_profile_properties_t*"
                    }
                ]
            },
            "$tMetricGet": {
                "class": "$tMetric",
                "params": [
                    {
                        "type": "$t_metric_group_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$t_metric_handle_t*"
                    }
                ]
            },
            "$tMetricGetProperties": {
                "class": "$tMetric",
                "params": [
                    {
                        "type": "$t_metric_handle_t"
                    },
                    {
                        "type": "$t_metric_properties_t*"
                    }
                ]
            },
            "$tMetricGroupCalculateMetricExportDataExp": {
                "class": "$tMetricGroup",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "$t_metric_group_calculation_type_t"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "const uint8_t*"
                    },
                    {
                        "type": "$t_metric_calculate_exp_desc_t*"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$t_typed_value_t*"
                    }
                ]
            },
            "$tMetricGroupCalculateMetricValues": {
                "class": "$tMetricGroup",
                "params": [
                    {
                        "type": "$t_metric_group_handle_t"
                    },
                    {
                        "type": "$t_metric_group_calculation_type_t"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "const uint8_t*"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$t_typed_value_t*"
                    }
                ]
            },
            "$tMetricGroupCalculateMultipleMetricValuesExp": {
                "class": "$tMetricGroup",
                "params": [
                    {
                        "type": "$t_metric_group_handle_t"
                    },
                    {
                        "type": "$t_metric_group_calculation_type_t"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "const uint8_t*"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$t_typed_value_t*"
                    }
                ]
            },
            "$tMetricGroupGet": {
                "class": "$tMetricGroup",
                "params": [
                    {
                        "type": "$t_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$t_metric_group_handle_t*"
                    }
                ]
            },
            "$tMetricGroupGetExportDataExp": {
                "class": "$tMetricGroup",
                "params": [
                    {
                        "type": "$t_metric_group_handle_t"
                    },
                    {
                        "type": "const uint8_t*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "size_t*"
                    },
                    {
                        "type": "uint8_t *"
                    }
                ]
            },
            "$tMetricGroupGetGlobalTimestampsExp": {
                "class": "$tMetricGroup",
                "params": [
                    {
                        "type": "$t_metric_group_handle_t"
                    },
                    {
                        "type": "$x_bool_t"
                    },
                    {
                        "type": "uint64_t*"
                    },
                    {
                        "type": "uint64_t*"
                    }
                ]
            },
            "$tMetricGroupGetProperties": {
                "class": "$tMetricGroup",
                "params": [
                    {
                        "type": "$t_metric_group_handle_t"
                    },
                    {
                        "type": "$t_metric_group_properties_t*"
                    }
                ]
            },
            "$tMetricQueryCreate": {
                "class": "$tMetricQuery",
                "params": [
                    {
                        "type": "$t_metric_query_pool_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$t_metric_query_handle_t*"
                    }
                ]
            },
            "$tMetricQueryDestroy": {
                "class": "$tMetricQuery",
                "params": [
                    {
                        "type": "$t_metric_query_handle_t"
                    }
                ]
            },
            "$tMetricQueryGetData": {
                "class": "$tMetricQuery",
                "params": [
                    {
                        "type": "$t_metric_query_handle_t"
                    },
                    {
                        "type": "size_t*"
                    },
                    {
                        "type": "uint8_t*"
                    }
                ]
            },
            "$tMetricQueryPoolCreate": {
                "class": "$tMetricQueryPool",
                "params": [
                    {
                        "type": "$t_context_handle_t"
                    },
                    {
                        "type": "$t_device_handle_t"
                    },
                    {
                        "type": "$t_metric_group_handle_t"
                    },
                    {
                        "type": "const $t_metric_query_pool_desc_t*"
                    },
                    {
                        "type": "$t_metric_query_pool_handle_t*"
                    }
                ]
            },
            "$tMetricQueryPoolDestroy": {
                "class": "$tMetricQueryPool",
                "params": [
                    {
                        "type": "$t_metric_query_pool_handle_t"
                    }
                ]
            },
            "$tMetricQueryReset": {
                "class": "$tMetricQuery",
                "params": [
                    {
                        "type": "$t_metric_query_handle_t"
                    }
                ]
            },
            "$tMetricStreamerClose": {
                "class": "$tMetricStreamer",
                "params": [
                    {
                        "type": "$t_metric_streamer_handle_t"
                    }
                ]
            },
            "$tMetricStreamerOpen": {
                "class": "$tMetricStreamer",
                "params": [
                    {
                        "type": "$t_context_handle_t"
                    },
                    {
                        "type": "$t_device_handle_t"
                    },
                    {
                        "type": "$t_metric_group_handle_t"
                    },
                    {
                        "type": "$t_metric_streamer_desc_t*"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "$t_metric_streamer_handle_t*"
                    }
                ]
            },
            "$tMetricStreamerReadData": {
                "class": "$tMetricStreamer",
                "params": [
                    {
                        "type": "$t_metric_streamer_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "size_t*"
                    },
                    {
                        "type": "uint8_t*"
                    }
                ]
            },
            "$tModuleGetDebugInfo": {
                "class": "$tModule",
                "params": [
                    {
                        "type": "$t_module_handle_t"
                    },
                    {
                        "type": "$t_module_debug_info_format_t"
                    },
                    {
                        "type": "size_t*"
                    },
                    {
                        "type": "uint8_t*"
                    }
                ]
            },
            "$tTracerExpCreate": {
                "class": "$tTracerExp",
                "params": [
                    {
                        "type": "$t_context_handle_t"
                    },
                    {
                        "type": "const $t_tracer_exp_desc_t*"
                    },
                    {
                        "type": "$t_tracer_exp_handle_t*"
                    }
                ]
            },
            "$tTracerExpDestroy": {
                "class": "$tTracerExp",
                "params": [
                    {
                        "type": "$t_tracer_exp_handle_t"
                    }
                ]
            },
            "$tTracerExpSetEnabled": {
                "class": "$tTracerExp",
                "params": [
                    {
                        "type": "$t_tracer_exp_handle_t"
                    },
                    {
                        "type": "$x_bool_t"
                    }
                ]
            },
            "$tTracerExpSetEpilogues": {
                "class": "$tTracerExp",
                "params": [
                    {
                        "type": "$t_tracer_exp_handle_t"
                    },
                    {
                        "type": "$t_core_callbacks_t*"
                    }
                ]
            },
            "$tTracerExpSetPrologues": {
                "class": "$tTracerExp",
                "params": [
                    {
                        "type": "$t_tracer_exp_handle_t"
                    },
                    {
                        "type": "$t_core_callbacks_t*"
                    }
                ]
            },
            "$xCommandListAppendBarrier": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendEventReset": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "$x_event_handle_t"
                    }
                ]
            },
            "$xCommandListAppendImageCopy": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "$x_image_handle_t"
                    },
                    {
                        "type": "$x_image_handle_t"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendImageCopyFromMemory": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "$x_image_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "const $x_image_region_t*"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendImageCopyFromMemoryExt": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "$x_image_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "const $x_image_region_t*"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendImageCopyRegion": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "$x_image_handle_t"
                    },
                    {
                        "type": "$x_image_handle_t"
                    },
                    {
                        "type": "const $x_image_region_t*"
                    },
                    {
                        "type": "const $x_image_region_t*"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendImageCopyToMemory": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "$x_image_handle_t"
                    },
                    {
                        "type": "const $x_image_region_t*"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendImageCopyToMemoryExt": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "$x_image_handle_t"
                    },
                    {
                        "type": "const $x_image_region_t*"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendLaunchCooperativeKernel": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "const $x_group_count_t*"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendLaunchKernel": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "const $x_group_count_t*"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendLaunchKernelIndirect": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "const $x_group_count_t*"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendLaunchMultipleKernelsIndirect": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_kernel_handle_t*"
                    },
                    {
                        "type": "const uint32_t*"
                    },
                    {
                        "type": "const $x_group_count_t*"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendMemAdvise": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_memory_advice_t"
                    }
                ]
            },
            "$xCommandListAppendMemoryCopy": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendMemoryCopyFromContext": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendMemoryCopyRegion": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "const $x_copy_region_t*"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "const $x_copy_region_t*"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendMemoryFill": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendMemoryPrefetch": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "size_t"
                    }
                ]
            },
            "$xCommandListAppendMemoryRangesBarrier": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "const size_t*"
                    },
                    {
                        "type": "const void**"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendQueryKernelTimestamps": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "const size_t*"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendSignalEvent": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "$x_event_handle_t"
                    }
                ]
            },
            "$xCommandListAppendWaitOnEvents": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListAppendWriteGlobalTimestamp": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "uint64_t*"
                    },
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xCommandListClose": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    }
                ]
            },
            "$xCommandListCreate": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "const $x_command_list_desc_t*"
                    },
                    {
                        "type": "$x_command_list_handle_t*"
                    }
                ]
            },
            "$xCommandListCreateImmediate": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "const $x_command_queue_desc_t*"
                    },
                    {
                        "type": "$x_command_list_handle_t*"
                    }
                ]
            },
            "$xCommandListDestroy": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    }
                ]
            },
            "$xCommandListHostSynchronize": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    },
                    {
                        "type": "uint64_t"
                    }
                ]
            },
            "$xCommandListReset": {
                "class": "$xCommandList",
                "params": [
                    {
                        "type": "$x_command_list_handle_t"
                    }
                ]
            },
            "$xCommandQueueCreate": {
                "class": "$xCommandQueue",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "const $x_command_queue_desc_t*"
                    },
                    {
                        "type": "$x_command_queue_handle_t*"
                    }
                ]
            },
            "$xCommandQueueDestroy": {
                "class": "$xCommandQueue",
                "params": [
                    {
                        "type": "$x_command_queue_handle_t"
                    }
                ]
            },
            "$xCommandQueueExecuteCommandLists": {
                "class": "$xCommandQueue",
                "params": [
                    {
                        "type": "$x_command_queue_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_command_list_handle_t*"
                    },
                    {
                        "type": "$x_fence_handle_t"
                    }
                ]
            },
            "$xCommandQueueSynchronize": {
                "class": "$xCommandQueue",
                "params": [
                    {
                        "type": "$x_command_queue_handle_t"
                    },
                    {
                        "type": "uint64_t"
                    }
                ]
            },
            "$xContextCreate": {
                "class": "$xContext",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "const $x_context_desc_t*"
                    },
                    {
                        "type": "$x_context_handle_t*"
                    }
                ]
            },
            "$xContextCreateEx": {
                "class": "$xContext",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "const $x_context_desc_t*"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_device_handle_t*"
                    },
                    {
                        "type": "$x_context_handle_t*"
                    }
                ]
            },
            "$xContextDestroy": {
                "class": "$xContext",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    }
                ]
            },
            "$xContextEvictImage": {
                "class": "$xContext",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_image_handle_t"
                    }
                ]
            },
            "$xContextEvictMemory": {
                "class": "$xContext",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "size_t"
                    }
                ]
            },
            "$xContextGetStatus": {
                "class": "$xContext",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    }
                ]
            },
            "$xContextMakeImageResident": {
                "class": "$xContext",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_image_handle_t"
                    }
                ]
            },
            "$xContextMakeMemoryResident": {
                "class": "$xContext",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "size_t"
                    }
                ]
            },
            "$xContextSystemBarrier": {
                "class": "$xContext",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    }
                ]
            },
            "$xDeviceCanAccessPeer": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_bool_t*"
                    }
                ]
            },
            "$xDeviceGet": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$x_device_handle_t*"
                    }
                ]
            },
            "$xDeviceGetCacheProperties": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$x_device_cache_properties_t*"
                    }
                ]
            },
            "$xDeviceGetCommandQueueGroupProperties": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$x_command_queue_group_properties_t*"
                    }
                ]
            },
            "$xDeviceGetComputeProperties": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_device_compute_properties_t*"
                    }
                ]
            },
            "$xDeviceGetExternalMemoryProperties": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_device_external_memory_properties_t*"
                    }
                ]
            },
            "$xDeviceGetFabricVertexExp": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_fabric_vertex_handle_t*"
                    }
                ]
            },
            "$xDeviceGetGlobalTimestamps": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "uint64_t*"
                    },
                    {
                        "type": "uint64_t*"
                    }
                ]
            },
            "$xDeviceGetImageProperties": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_device_image_properties_t*"
                    }
                ]
            },
            "$xDeviceGetMemoryAccessProperties": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_device_memory_access_properties_t*"
                    }
                ]
            },
            "$xDeviceGetMemoryProperties": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$x_device_memory_properties_t*"
                    }
                ]
            },
            "$xDeviceGetModuleProperties": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_device_module_properties_t*"
                    }
                ]
            },
            "$xDeviceGetP2PProperties": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_device_p2p_properties_t*"
                    }
                ]
            },
            "$xDeviceGetProperties": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_device_properties_t*"
                    }
                ]
            },
            "$xDeviceGetRootDevice": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t*"
                    }
                ]
            },
            "$xDeviceGetStatus": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    }
                ]
            },
            "$xDeviceGetSubDevices": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$x_device_handle_t*"
                    }
                ]
            },
            "$xDevicePciGetPropertiesExt": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_pci_ext_properties_t*"
                    }
                ]
            },
            "$xDeviceReserveCacheExt": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "size_t"
                    }
                ]
            },
            "$xDeviceSetCacheAdviceExt": {
                "class": "$xDevice",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_cache_ext_region_t"
                    }
                ]
            },
            "$xDriverGet": {
                "class": "$xDriver",
                "params": [
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$x_driver_handle_t*"
                    }
                ]
            },
            "$xDriverGetApiVersion": {
                "class": "$xDriver",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "$x_api_version_t*"
                    }
                ]
            },
            "$xDriverGetExtensionFunctionAddress": {
                "class": "$xDriver",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "const char*"
                    },
                    {
                        "type": "void**"
                    }
                ]
            },
            "$xDriverGetExtensionProperties": {
                "class": "$xDriver",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$x_driver_extension_properties_t*"
                    }
                ]
            },
            "$xDriverGetIpcProperties": {
                "class": "$xDriver",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "$x_driver_ipc_properties_t*"
                    }
                ]
            },
            "$xDriverGetLastErrorDescription": {
                "class": "$xDriver",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "const char**"
                    }
                ]
            },
            "$xDriverGetProperties": {
                "class": "$xDriver",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "$x_driver_properties_t*"
                    }
                ]
            },
            "$xDriverRTASFormatCompatibilityCheckExp": {
                "class": "$xDriver",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "$x_rtas_format_exp_t"
                    },
                    {
                        "type": "$x_rtas_format_exp_t"
                    }
                ]
            },
            "$xEventCreate": {
                "class": "$xEvent",
                "params": [
                    {
                        "type": "$x_event_pool_handle_t"
                    },
                    {
                        "type": "const $x_event_desc_t*"
                    },
                    {
                        "type": "$x_event_handle_t*"
                    }
                ]
            },
            "$xEventDestroy": {
                "class": "$xEvent",
                "params": [
                    {
                        "type": "$x_event_handle_t"
                    }
                ]
            },
            "$xEventHostReset": {
                "class": "$xEvent",
                "params": [
                    {
                        "type": "$x_event_handle_t"
                    }
                ]
            },
            "$xEventHostSignal": {
                "class": "$xEvent",
                "params": [
                    {
                        "type": "$x_event_handle_t"
                    }
                ]
            },
            "$xEventHostSynchronize": {
                "class": "$xEvent",
                "params": [
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "uint64_t"
                    }
                ]
            },
            "$xEventPoolCloseIpcHandle": {
                "class": "$xEventPool",
                "params": [
                    {
                        "type": "$x_event_pool_handle_t"
                    }
                ]
            },
            "$xEventPoolCreate": {
                "class": "$xEventPool",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const $x_event_pool_desc_t*"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_device_handle_t*"
                    },
                    {
                        "type": "$x_event_pool_handle_t*"
                    }
                ]
            },
            "$xEventPoolDestroy": {
                "class": "$xEventPool",
                "params": [
                    {
                        "type": "$x_event_pool_handle_t"
                    }
                ]
            },
            "$xEventPoolGetIpcHandle": {
                "class": "$xEventPool",
                "params": [
                    {
                        "type": "$x_event_pool_handle_t"
                    },
                    {
                        "type": "$x_ipc_event_pool_handle_t*"
                    }
                ]
            },
            "$xEventPoolOpenIpcHandle": {
                "class": "$xEventPool",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_ipc_event_pool_handle_t"
                    },
                    {
                        "type": "$x_event_pool_handle_t*"
                    }
                ]
            },
            "$xEventPoolPutIpcHandle": {
                "class": "$xEventPool",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_ipc_event_pool_handle_t"
                    }
                ]
            },
            "$xEventQueryKernelTimestamp": {
                "class": "$xEvent",
                "params": [
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "$x_kernel_timestamp_result_t*"
                    }
                ]
            },
            "$xEventQueryKernelTimestampsExt": {
                "class": "$xEvent",
                "params": [
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$x_event_query_kernel_timestamps_results_ext_properties_t*"
                    }
                ]
            },
            "$xEventQueryStatus": {
                "class": "$xEvent",
                "params": [
                    {
                        "type": "$x_event_handle_t"
                    }
                ]
            },
            "$xEventQueryTimestampsExp": {
                "class": "$xEvent",
                "params": [
                    {
                        "type": "$x_event_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$x_kernel_timestamp_result_t*"
                    }
                ]
            },
            "$xFabricEdgeGetExp": {
                "class": "$xFabricEdge",
                "params": [
                    {
                        "type": "$x_fabric_vertex_handle_t"
                    },
                    {
                        "type": "$x_fabric_vertex_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$x_fabric_edge_handle_t*"
                    }
                ]
            },
            "$xFabricEdgeGetPropertiesExp": {
                "class": "$xFabricEdge",
                "params": [
                    {
                        "type": "$x_fabric_edge_handle_t"
                    },
                    {
                        "type": "$x_fabric_edge_exp_properties_t*"
                    }
                ]
            },
            "$xFabricEdgeGetVerticesExp": {
                "class": "$xFabricEdge",
                "params": [
                    {
                        "type": "$x_fabric_edge_handle_t"
                    },
                    {
                        "type": "$x_fabric_vertex_handle_t*"
                    },
                    {
                        "type": "$x_fabric_vertex_handle_t*"
                    }
                ]
            },
            "$xFabricVertexGetDeviceExp": {
                "class": "$xFabricVertex",
                "params": [
                    {
                        "type": "$x_fabric_vertex_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t*"
                    }
                ]
            },
            "$xFabricVertexGetExp": {
                "class": "$xFabricVertex",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$x_fabric_vertex_handle_t*"
                    }
                ]
            },
            "$xFabricVertexGetPropertiesExp": {
                "class": "$xFabricVertex",
                "params": [
                    {
                        "type": "$x_fabric_vertex_handle_t"
                    },
                    {
                        "type": "$x_fabric_vertex_exp_properties_t*"
                    }
                ]
            },
            "$xFabricVertexGetSubVerticesExp": {
                "class": "$xFabricVertex",
                "params": [
                    {
                        "type": "$x_fabric_vertex_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "$x_fabric_vertex_handle_t*"
                    }
                ]
            },
            "$xFenceCreate": {
                "class": "$xFence",
                "params": [
                    {
                        "type": "$x_command_queue_handle_t"
                    },
                    {
                        "type": "const $x_fence_desc_t*"
                    },
                    {
                        "type": "$x_fence_handle_t*"
                    }
                ]
            },
            "$xFenceDestroy": {
                "class": "$xFence",
                "params": [
                    {
                        "type": "$x_fence_handle_t"
                    }
                ]
            },
            "$xFenceHostSynchronize": {
                "class": "$xFence",
                "params": [
                    {
                        "type": "$x_fence_handle_t"
                    },
                    {
                        "type": "uint64_t"
                    }
                ]
            },
            "$xFenceQueryStatus": {
                "class": "$xFence",
                "params": [
                    {
                        "type": "$x_fence_handle_t"
                    }
                ]
            },
            "$xFenceReset": {
                "class": "$xFence",
                "params": [
                    {
                        "type": "$x_fence_handle_t"
                    }
                ]
            },
            "$xImageCreate": {
                "class": "$xImage",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "const $x_image_desc_t*"
                    },
                    {
                        "type": "$x_image_handle_t*"
                    }
                ]
            },
            "$xImageDestroy": {
                "class": "$xImage",
                "params": [
                    {
                        "type": "$x_image_handle_t"
                    }
                ]
            },
            "$xImageGetAllocPropertiesExt": {
                "class": "$xImage",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_image_handle_t"
                    },
                    {
                        "type": "$x_image_allocation_ext_properties_t*"
                    }
                ]
            },
            "$xImageGetMemoryPropertiesExp": {
                "class": "$xImage",
                "params": [
                    {
                        "type": "$x_image_handle_t"
                    },
                    {
                        "type": "$x_image_memory_properties_exp_t*"
                    }
                ]
            },
            "$xImageGetProperties": {
                "class": "$xImage",
                "params": [
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "const $x_image_desc_t*"
                    },
                    {
                        "type": "$x_image_properties_t*"
                    }
                ]
            },
            "$xImageViewCreateExp": {
                "class": "$xImage",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "const $x_image_desc_t*"
                    },
                    {
                        "type": "$x_image_handle_t"
                    },
                    {
                        "type": "$x_image_handle_t*"
                    }
                ]
            },
            "$xImageViewCreateExt": {
                "class": "$xImage",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "const $x_image_desc_t*"
                    },
                    {
                        "type": "$x_image_handle_t"
                    },
                    {
                        "type": "$x_image_handle_t*"
                    }
                ]
            },
            "$xInit": {
                "class": "$x",
                "params": [
                    {
                        "type": "$x_init_flags_t"
                    }
                ]
            },
            "$xKernelCreate": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_module_handle_t"
                    },
                    {
                        "type": "const $x_kernel_desc_t*"
                    },
                    {
                        "type": "$x_kernel_handle_t*"
                    }
                ]
            },
            "$xKernelDestroy": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_kernel_handle_t"
                    }
                ]
            },
            "$xKernelGetIndirectAccess": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "$x_kernel_indirect_access_flags_t*"
                    }
                ]
            },
            "$xKernelGetName": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "size_t*"
                    },
                    {
                        "type": "char*"
                    }
                ]
            },
            "$xKernelGetProperties": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "$x_kernel_properties_t*"
                    }
                ]
            },
            "$xKernelGetSourceAttributes": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "char**"
                    }
                ]
            },
            "$xKernelSchedulingHintExp": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "$x_scheduling_hint_exp_desc_t*"
                    }
                ]
            },
            "$xKernelSetArgumentValue": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "const void*"
                    }
                ]
            },
            "$xKernelSetCacheConfig": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "$x_cache_config_flags_t"
                    }
                ]
            },
            "$xKernelSetGlobalOffsetExp": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    }
                ]
            },
            "$xKernelSetGroupSize": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    }
                ]
            },
            "$xKernelSetIndirectAccess": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "$x_kernel_indirect_access_flags_t"
                    }
                ]
            },
            "$xKernelSuggestGroupSize": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "uint32_t*"
                    }
                ]
            },
            "$xKernelSuggestMaxCooperativeGroupCount": {
                "class": "$xKernel",
                "params": [
                    {
                        "type": "$x_kernel_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    }
                ]
            },
            "$xMemAllocDevice": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const $x_device_mem_alloc_desc_t*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "void**"
                    }
                ]
            },
            "$xMemAllocHost": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const $x_host_mem_alloc_desc_t*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "void**"
                    }
                ]
            },
            "$xMemAllocShared": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const $x_device_mem_alloc_desc_t*"
                    },
                    {
                        "type": "const $x_host_mem_alloc_desc_t*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "void**"
                    }
                ]
            },
            "$xMemCloseIpcHandle": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const void*"
                    }
                ]
            },
            "$xMemFree": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "void*"
                    }
                ]
            },
            "$xMemFreeExt": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const $x_memory_free_ext_desc_t*"
                    },
                    {
                        "type": "void*"
                    }
                ]
            },
            "$xMemGetAddressRange": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "void**"
                    },
                    {
                        "type": "size_t*"
                    }
                ]
            },
            "$xMemGetAllocProperties": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "$x_memory_allocation_properties_t*"
                    },
                    {
                        "type": "$x_device_handle_t*"
                    }
                ]
            },
            "$xMemGetAtomicAccessAttributeExp": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_memory_atomic_attr_exp_flags_t*"
                    }
                ]
            },
            "$xMemGetFileDescriptorFromIpcHandleExp": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_ipc_mem_handle_t"
                    },
                    {
                        "type": "uint64_t*"
                    }
                ]
            },
            "$xMemGetIpcHandle": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "$x_ipc_mem_handle_t*"
                    }
                ]
            },
            "$xMemGetIpcHandleFromFileDescriptorExp": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "uint64_t"
                    },
                    {
                        "type": "$x_ipc_mem_handle_t*"
                    }
                ]
            },
            "$xMemOpenIpcHandle": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_ipc_mem_handle_t"
                    },
                    {
                        "type": "$x_ipc_memory_flags_t"
                    },
                    {
                        "type": "void**"
                    }
                ]
            },
            "$xMemPutIpcHandle": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_ipc_mem_handle_t"
                    }
                ]
            },
            "$xMemSetAtomicAccessAttributeExp": {
                "class": "$xMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_memory_atomic_attr_exp_flags_t"
                    }
                ]
            },
            "$xModuleBuildLogDestroy": {
                "class": "$xModuleBuildLog",
                "params": [
                    {
                        "type": "$x_module_build_log_handle_t"
                    }
                ]
            },
            "$xModuleBuildLogGetString": {
                "class": "$xModuleBuildLog",
                "params": [
                    {
                        "type": "$x_module_build_log_handle_t"
                    },
                    {
                        "type": "size_t*"
                    },
                    {
                        "type": "char*"
                    }
                ]
            },
            "$xModuleCreate": {
                "class": "$xModule",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "const $x_module_desc_t*"
                    },
                    {
                        "type": "$x_module_handle_t*"
                    },
                    {
                        "type": "$x_module_build_log_handle_t*"
                    }
                ]
            },
            "$xModuleDestroy": {
                "class": "$xModule",
                "params": [
                    {
                        "type": "$x_module_handle_t"
                    }
                ]
            },
            "$xModuleDynamicLink": {
                "class": "$xModule",
                "params": [
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_module_handle_t*"
                    },
                    {
                        "type": "$x_module_build_log_handle_t*"
                    }
                ]
            },
            "$xModuleGetFunctionPointer": {
                "class": "$xModule",
                "params": [
                    {
                        "type": "$x_module_handle_t"
                    },
                    {
                        "type": "const char*"
                    },
                    {
                        "type": "void**"
                    }
                ]
            },
            "$xModuleGetGlobalPointer": {
                "class": "$xModule",
                "params": [
                    {
                        "type": "$x_module_handle_t"
                    },
                    {
                        "type": "const char*"
                    },
                    {
                        "type": "size_t*"
                    },
                    {
                        "type": "void**"
                    }
                ]
            },
            "$xModuleGetKernelNames": {
                "class": "$xModule",
                "params": [
                    {
                        "type": "$x_module_handle_t"
                    },
                    {
                        "type": "uint32_t*"
                    },
                    {
                        "type": "const char**"
                    }
                ]
            },
            "$xModuleGetNativeBinary": {
                "class": "$xModule",
                "params": [
                    {
                        "type": "$x_module_handle_t"
                    },
                    {
                        "type": "size_t*"
                    },
                    {
                        "type": "uint8_t*"
                    }
                ]
            },
            "$xModuleGetProperties": {
                "class": "$xModule",
                "params": [
                    {
                        "type": "$x_module_handle_t"
                    },
                    {
                        "type": "$x_module_properties_t*"
                    }
                ]
            },
            "$xModuleInspectLinkageExt": {
                "class": "$xModule",
                "params": [
                    {
                        "type": "$x_linkage_inspection_ext_desc_t*"
                    },
                    {
                        "type": "uint32_t"
                    },
                    {
                        "type": "$x_module_handle_t*"
                    },
                    {
                        "type": "$x_module_build_log_handle_t*"
                    }
                ]
            },
            "$xPhysicalMemCreate": {
                "class": "$xPhysicalMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "$x_physical_mem_desc_t*"
                    },
                    {
                        "type": "$x_physical_mem_handle_t*"
                    }
                ]
            },
            "$xPhysicalMemDestroy": {
                "class": "$xPhysicalMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_physical_mem_handle_t"
                    }
                ]
            },
            "$xRTASBuilderBuildExp": {
                "class": "$xRTASBuilder",
                "params": [
                    {
                        "type": "$x_rtas_builder_exp_handle_t"
                    },
                    {
                        "type": "const $x_rtas_builder_build_op_exp_desc_t*"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_rtas_parallel_operation_exp_handle_t"
                    },
                    {
                        "type": "void*"
                    },
                    {
                        "type": "$x_rtas_aabb_exp_t*"
                    },
                    {
                        "type": "size_t*"
                    }
                ]
            },
            "$xRTASBuilderCreateExp": {
                "class": "$xRTASBuilder",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "const $x_rtas_builder_exp_desc_t*"
                    },
                    {
                        "type": "$x_rtas_builder_exp_handle_t*"
                    }
                ]
            },
            "$xRTASBuilderDestroyExp": {
                "class": "$xRTASBuilder",
                "params": [
                    {
                        "type": "$x_rtas_builder_exp_handle_t"
                    }
                ]
            },
            "$xRTASBuilderGetBuildPropertiesExp": {
                "class": "$xRTASBuilder",
                "params": [
                    {
                        "type": "$x_rtas_builder_exp_handle_t"
                    },
                    {
                        "type": "const $x_rtas_builder_build_op_exp_desc_t*"
                    },
                    {
                        "type": "$x_rtas_builder_exp_properties_t*"
                    }
                ]
            },
            "$xRTASParallelOperationCreateExp": {
                "class": "$xRTASParallelOperation",
                "params": [
                    {
                        "type": "$x_driver_handle_t"
                    },
                    {
                        "type": "$x_rtas_parallel_operation_exp_handle_t*"
                    }
                ]
            },
            "$xRTASParallelOperationDestroyExp": {
                "class": "$xRTASParallelOperation",
                "params": [
                    {
                        "type": "$x_rtas_parallel_operation_exp_handle_t"
                    }
                ]
            },
            "$xRTASParallelOperationGetPropertiesExp": {
                "class": "$xRTASParallelOperation",
                "params": [
                    {
                        "type": "$x_rtas_parallel_operation_exp_handle_t"
                    },
                    {
                        "type": "$x_rtas_parallel_operation_exp_properties_t*"
                    }
                ]
            },
            "$xRTASParallelOperationJoinExp": {
                "class": "$xRTASParallelOperation",
                "params": [
                    {
                        "type": "$x_rtas_parallel_operation_exp_handle_t"
                    }
                ]
            },
            "$xSamplerCreate": {
                "class": "$xSampler",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "const $x_sampler_desc_t*"
                    },
                    {
                        "type": "$x_sampler_handle_t*"
                    }
                ]
            },
            "$xSamplerDestroy": {
                "class": "$xSampler",
                "params": [
                    {
                        "type": "$x_sampler_handle_t"
                    }
                ]
            },
            "$xVirtualMemFree": {
                "class": "$xVirtualMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "size_t"
                    }
                ]
            },
            "$xVirtualMemGetAccessAttribute": {
                "class": "$xVirtualMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_memory_access_attribute_t*"
                    },
                    {
                        "type": "size_t*"
                    }
                ]
            },
            "$xVirtualMemMap": {
                "class": "$xVirtualMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_physical_mem_handle_t"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_memory_access_attribute_t"
                    }
                ]
            },
            "$xVirtualMemQueryPageSize": {
                "class": "$xVirtualMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "$x_device_handle_t"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "size_t*"
                    }
                ]
            },
            "$xVirtualMemReserve": {
                "class": "$xVirtualMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "void**"
                    }
                ]
            },
            "$xVirtualMemSetAccessAttribute": {
                "class": "$xVirtualMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "size_t"
                    },
                    {
                        "type": "$x_memory_access_attribute_t"
                    }
                ]
            },
            "$xVirtualMemUnmap": {
                "class": "$xVirtualMem",
                "params": [
                    {
                        "type": "$x_context_handle_t"
                    },
                    {
                        "type": "const void*"
                    },
                    {
                        "type": "size_t"
                    }
                ]
            }
        },
        "handle": {
            "$s_device_handle_t": {
                "class": "$sDevice"
            },
            "$s_diag_handle_t": {
                "class": "$sDiagnostics"
            },
            "$s_driver_handle_t": {
                "class": "$sDriver"
            },
            "$s_engine_handle_t": {
                "class": "$sEngine"
            },
            "$s_fabric_port_handle_t": {
                "class": "$sFabricPort"
            },
            "$s_fan_handle_t": {
                "class": "$sFan"
            },
            "$s_firmware_handle_t": {
                "class": "$sFirmware"
            },
            "$s_freq_handle_t": {
                "class": "$sFrequency"
            },
            "$s_led_handle_t": {
                "class": "$sLed"
            },
            "$s_mem_handle_t": {
                "class": "$sMemory"
            },
            "$s_overclock_handle_t": {
                "class": "$sOverclock"
            },
            "$s_perf_handle_t": {
                "class": "$sPerformanceFactor"
            },
            "$s_psu_handle_t": {
                "class": "$sPsu"
            },
            "$s_pwr_handle_t": {
                "class": "$sPower"
            },
            "$s_ras_handle_t": {
                "class": "$sRas"
            },
            "$s_sched_handle_t": {
                "class": "$sScheduler"
            },
            "$s_standby_handle_t": {
                "class": "$sStandby"
            },
            "$s_temp_handle_t": {
                "class": "$sTemperature"
            },
            "$t_command_list_handle_t": {
                "class": "$tCommandList"
            },
            "$t_context_handle_t": {
                "class": "$tContext"
            },
            "$t_debug_session_handle_t": {
                "class": "$tDebug"
            },
            "$t_device_handle_t": {
                "class": "$tDevice"
            },
            "$t_driver_handle_t": {
                "class": "$tDriver"
            },
            "$t_kernel_handle_t": {
                "class": "$tKernel"
            },
            "$t_metric_group_handle_t": {
                "class": "$tMetricGroup"
            },
            "$t_metric_handle_t": {
                "class": "$tMetric"
            },
            "$t_metric_query_handle_t": {
                "class": "$tMetricQuery"
            },
            "$t_metric_query_pool_handle_t": {
                "class": "$tMetricQueryPool"
            },
            "$t_metric_streamer_handle_t": {
                "class": "$tMetricStreamer"
            },
            "$t_module_handle_t": {
                "class": "$tModule"
            },
            "$t_tracer_exp_handle_t": {
                "class": "$tTracerExp"
            },
            "$x_command_list_handle_t": {
                "class": "$xCommandList"
            },
            "$x_command_queue_handle_t": {
                "class": "$xCommandQueue"
            },
            "$x_context_handle_t": {
                "class": "$xContext"
            },
            "$x_device_handle_t": {
                "class": "$xDevice"
            },
            "$x_driver_handle_t": {
                "class": "$xDriver"
            },
            "$x_event_handle_t": {
                "class": "$xEvent"
            },
            "$x_event_pool_handle_t": {
                "class": "$xEventPool"
            },
            "$x_fabric_edge_handle_t": {
                "class": "$xFabricEdge"
            },
            "$x_fabric_vertex_handle_t": {
                "class": "$xFabricVertex"
            },
            "$x_fence_handle_t": {
                "class": "$xFence"
            },
            "$x_image_handle_t": {
                "class": "$xImage"
            },
            "$x_kernel_handle_t": {
                "class": "$xKernel"
            },
            "$x_module_build_log_handle_t": {
                "class": "$xModuleBuildLog"
            },
            "$x_module_handle_t": {
                "class": "$xModule"
            },
            "$x_physical_mem_handle_t": {
                "class": "$xPhysicalMem"
            },
            "$x_rtas_builder_exp_handle_t": {
                "class": "$xRTASBuilder"
            },
            "$x_rtas_parallel_operation_exp_handle_t": {
                "class": "$xRTASParallelOperation"
            },
            "$x_sampler_handle_t": {
                "class": "$xSampler"
            }
        },
        "macro": {
            "$S_DIAG_FIRST_TEST_INDEX": {
                "class": "",
                "values": [
                    "0x0"
                ]
            },
            "$S_DIAG_LAST_TEST_INDEX": {
                "class": "",
                "values": [
                    "0xFFFFFFFF"
                ]
            },
            "$S_ENGINE_ACTIVITY_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$XS_extension_engine_activity\""
                ]
            },
            "$S_FAN_TEMP_SPEED_PAIR_COUNT": {
                "class": "",
                "values": [
                    "32"
                ]
            },
            "$S_MAX_FABRIC_LINK_TYPE_SIZE": {
                "class": "",
                "values": [
                    "256"
                ]
            },
            "$S_MAX_FABRIC_PORT_MODEL_SIZE": {
                "class": "",
                "values": [
                    "256"
                ]
            },
            "$S_MAX_RAS_ERROR_CATEGORY_COUNT": {
                "class": "",
                "values": [
                    "7"
                ]
            },
            "$S_MAX_UUID_SIZE": {
                "class": "",
                "values": [
                    "16"
                ]
            },
            "$S_POWER_LIMITS_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$XS_extension_power_limits\""
                ]
            },
            "$S_RAS_GET_STATE_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$XS_extension_ras_state\""
                ]
            },
            "$S_SCHED_WATCHDOG_DISABLE": {
                "class": "",
                "values": [
                    "(~(0ULL))"
                ]
            },
            "$S_STRING_PROPERTY_SIZE": {
                "class": "",
                "values": [
                    "64"
                ]
            },
            "$T_API_TRACING_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$XT_experimental_api_tracing\""
                ]
            },
            "$T_EXPORT_METRICS_DATA_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$XT_experimental_metric_export_data\""
                ]
            },
            "$T_GLOBAL_METRICS_TIMESTAMPS_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$XT_experimental_global_metric_timestamps\""
                ]
            },
            "$T_MAX_METRIC_COMPONENT": {
                "class": "",
                "values": [
                    "256"
                ]
            },
            "$T_MAX_METRIC_DESCRIPTION": {
                "class": "",
                "values": [
                    "256"
                ]
            },
            "$T_MAX_METRIC_EXPORT_DATA_ELEMENT_DESCRIPTION_EXP": {
                "class": "",
                "values": [
                    "256"
                ]
            },
            "$T_MAX_METRIC_EXPORT_DATA_ELEMENT_NAME_EXP": {
                "class": "",
                "values": [
                    "256"
                ]
            },
            "$T_MAX_METRIC_GROUP_DESCRIPTION": {
                "class": "",
                "values": [
                    "256"
                ]
            },
            "$T_MAX_METRIC_GROUP_NAME": {
                "class": "",
                "values": [
                    "256"
                ]
            },
            "$T_MAX_METRIC_NAME": {
                "class": "",
                "values": [
                    "256"
                ]
            },
            "$T_MAX_METRIC_RESULT_UNITS": {
                "class": "",
                "values": [
                    "256"
                ]
            },
            "$T_MULTI_METRICS_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$XT_experimental_calculate_multiple_metrics\""
                ]
            },
            "$X_APICALL": {
                "class": "",
                "values": [
                    "__cdecl",
                    ""
                ]
            },
            "$X_APIEXPORT": {
                "class": "",
                "values": [
                    "__attribute__ ((visibility (\"default\")))",
                    ""
                ]
            },
            "$X_BANDWIDTH_PROPERTIES_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$X_experimental_bandwidth_properties\""
                ]
            },
            "$X_BFLOAT16_CONVERSIONS_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_bfloat16_conversions\""
                ]
            },
            "$X_BIT": {
                "class": "",
                "values": [
                    "( 1 << _i )"
                ]
            },
            "$X_CACHE_RESERVATION_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_cache_reservation\""
                ]
            },
            "$X_CONTEXT_POWER_SAVING_HINT_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$X_experimental_power_saving_hint\""
                ]
            },
            "$X_DEVICE_IP_VERSION_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_device_ip_version\""
                ]
            },
            "$X_DEVICE_LUID_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_device_luid\""
                ]
            },
            "$X_DEVICE_MEMORY_PROPERTIES_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_device_memory_properties\""
                ]
            },
            "$X_DLLEXPORT": {
                "class": "",
                "values": [
                    "__attribute__ ((visibility (\"default\")))",
                    ""
                ]
            },
            "$X_EU_COUNT_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_eu_count\""
                ]
            },
            "$X_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_event_query_kernel_timestamps\""
                ]
            },
            "$X_EVENT_QUERY_TIMESTAMPS_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$X_experimental_event_query_timestamps\""
                ]
            },
            "$X_FABRIC_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$X_experimental_fabric\""
                ]
            },
            "$X_FLOAT_ATOMICS_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_float_atomics\""
                ]
            },
            "$X_GLOBAL_OFFSET_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$X_experimental_global_offset\""
                ]
            },
            "$X_IMAGE_COPY_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_image_copy\""
                ]
            },
            "$X_IMAGE_MEMORY_PROPERTIES_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$X_experimental_image_memory_properties\""
                ]
            },
            "$X_IMAGE_QUERY_ALLOC_PROPERTIES_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_image_query_alloc_properties\""
                ]
            },
            "$X_IMAGE_VIEW_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$X_experimental_image_view\""
                ]
            },
            "$X_IMAGE_VIEW_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_image_view\""
                ]
            },
            "$X_IMAGE_VIEW_PLANAR_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$X_experimental_image_view_planar\""
                ]
            },
            "$X_IMAGE_VIEW_PLANAR_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_image_view_planar\""
                ]
            },
            "$X_KERNEL_MAX_GROUP_SIZE_PROPERTIES_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_kernel_max_group_size_properties\""
                ]
            },
            "$X_KERNEL_SCHEDULING_HINTS_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$X_experimental_scheduling_hints\""
                ]
            },
            "$X_LINKAGE_INSPECTION_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_linkage_inspection\""
                ]
            },
            "$X_LINKONCE_ODR_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_linkonce_odr\""
                ]
            },
            "$X_MAJOR_VERSION": {
                "class": "",
                "values": [
                    "( _ver >> 16 )"
                ]
            },
            "$X_MAKE_VERSION": {
                "class": "",
                "values": [
                    "(( _major << 16 )|( _minor & 0x0000ffff))"
                ]
            },
            "$X_MAX_DEVICE_LUID_SIZE_EXT": {
                "class": "",
                "values": [
                    "8"
                ]
            },
            "$X_MAX_DEVICE_NAME": {
                "class": "",
                "values": [
                    "256"
                ]
            },
            "$X_MAX_DEVICE_UUID_SIZE": {
                "class": "",
                "values": [
                    "16"
                ]
            },
            "$X_MAX_DRIVER_UUID_SIZE": {
                "class": "",
                "values": [
                    "16"
                ]
            },
            "$X_MAX_EXTENSION_NAME": {
                "class": "",
                "values": [
                    "256"
                ]
            },
            "$X_MAX_FABRIC_EDGE_MODEL_EXP_SIZE": {
                "class": "",
                "values": [
                    "256"
                ]
            },
            "$X_MAX_IPC_HANDLE_SIZE": {
                "class": "",
                "values": [
                    "64"
                ]
            },
            "$X_MAX_KERNEL_UUID_SIZE": {
                "class": "",
                "values": [
                    "16"
                ]
            },
            "$X_MAX_MODULE_UUID_SIZE": {
                "class": "",
                "values": [
                    "16"
                ]
            },
            "$X_MAX_NATIVE_KERNEL_UUID_SIZE": {
                "class": "",
                "values": [
                    "16"
                ]
            },
            "$X_MAX_UUID_SIZE": {
                "class": "",
                "values": [
                    "16"
                ]
            },
            "$X_MEMORY_COMPRESSION_HINTS_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_memory_compression_hints\""
                ]
            },
            "$X_MEMORY_FREE_POLICIES_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_memory_free_policies\""
                ]
            },
            "$X_MINOR_VERSION": {
                "class": "",
                "values": [
                    "( _ver & 0x0000ffff )"
                ]
            },
            "$X_MODULE_PROGRAM_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$X_experimental_module_program\""
                ]
            },
            "$X_PCI_PROPERTIES_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_pci_properties\""
                ]
            },
            "$X_RAYTRACING_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_raytracing\""
                ]
            },
            "$X_RELAXED_ALLOCATION_LIMITS_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$X_experimental_relaxed_allocation_limits\""
                ]
            },
            "$X_RTAS_BUILDER_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$X_experimental_rtas_builder\""
                ]
            },
            "$X_SRGB_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_srgb\""
                ]
            },
            "$X_SUBGROUPSIZE_COUNT": {
                "class": "",
                "values": [
                    "8"
                ]
            },
            "$X_SUBGROUPS_EXT_NAME": {
                "class": "",
                "values": [
                    "\"$X_extension_subgroups\""
                ]
            },
            "$X_SUB_ALLOCATIONS_EXP_NAME": {
                "class": "",
                "values": [
                    "\"$X_experimental_sub_allocations\""
                ]
            }
        },
        "struct": {
            "$s_base_capability_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": null,
                        "name": "stype",
                        "type": "$s_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    }
                ]
            },
            "$s_base_config_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": null,
                        "name": "stype",
                        "type": "$s_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    }
                ]
            },
            "$s_base_desc_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": null,
                        "name": "stype",
                        "type": "$s_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    }
                ]
            },
            "$s_base_properties_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": null,
                        "name": "stype",
                        "type": "$s_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    }
                ]
            },
            "$s_base_state_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": null,
                        "name": "stype",
                        "type": "$s_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    }
                ]
            },
            "$s_control_property_t": {
                "class": "$sOverclock",
                "members": [
                    {
                        "desc": "[out]  This provides information about the limits of the control value so that the driver can calculate the set of valid values.",
                        "init": null,
                        "name": "MinValue",
                        "type": "double"
                    },
                    {
                        "desc": "[out]  This provides information about the limits of the control value so that the driver can calculate the set of valid values.",
                        "init": null,
                        "name": "MaxValue",
                        "type": "double"
                    },
                    {
                        "desc": "[out]  This provides information about the limits of the control value so that the driver can calculate the set of valid values.",
                        "init": null,
                        "name": "StepValue",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The reference value provides the anchor point, UIs can combine this with the user offset request to show the anticipated improvement.",
                        "init": null,
                        "name": "RefValue",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The shipped out-of-box position of this control. Driver can request this value at any time to return to the out-of-box behavior.",
                        "init": null,
                        "name": "DefaultValue",
                        "type": "double"
                    }
                ]
            },
            "$s_device_ecc_desc_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] ECC state",
                        "init": null,
                        "name": "state",
                        "type": "$s_device_ecc_state_t"
                    }
                ]
            },
            "$s_device_ecc_properties_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] Current ECC state",
                        "init": null,
                        "name": "currentState",
                        "type": "$s_device_ecc_state_t"
                    },
                    {
                        "desc": "[out] Pending ECC state",
                        "init": null,
                        "name": "pendingState",
                        "type": "$s_device_ecc_state_t"
                    },
                    {
                        "desc": "[out] Pending action",
                        "init": null,
                        "name": "pendingAction",
                        "type": "$s_device_action_t"
                    }
                ]
            },
            "$s_device_ext_properties_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] universal unique identifier. Note: uuid obtained from Sysman API is the same as from core API. Subdevices will have their own uuid.",
                        "init": null,
                        "name": "uuid",
                        "type": "$s_uuid_t"
                    },
                    {
                        "desc": "[out] generic device type",
                        "init": null,
                        "name": "type",
                        "type": "$s_device_type_t"
                    },
                    {
                        "desc": "[out] 0 (none) or a valid combination of $s_device_property_flag_t",
                        "init": null,
                        "name": "flags",
                        "type": "$s_device_property_flags_t"
                    }
                ]
            },
            "$s_device_properties_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] (Deprecated, use $s_uuid_t in the extended structure) Core device properties",
                        "init": null,
                        "name": "core",
                        "type": "$x_device_properties_t"
                    },
                    {
                        "desc": "[out] Number of sub-devices. A value of 0 indicates that this device doesn't have sub-devices.",
                        "init": null,
                        "name": "numSubdevices",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Manufacturing serial number (NULL terminated string value). This value is intended to reflect the Part ID/SoC ID assigned by manufacturer that is unique for a SoC. Will be set to the string \"unknown\" if this cannot be determined for the device.",
                        "init": null,
                        "name": "serialNumber[$S_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] Manufacturing board number (NULL terminated string value). Alternatively \"boardSerialNumber\", this value is intended to reflect the string printed on board label by manufacturer. Will be set to the string \"unknown\" if this cannot be determined for the device.",
                        "init": null,
                        "name": "boardNumber[$S_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] Brand name of the device (NULL terminated string value). Will be set to the string \"unknown\" if this cannot be determined for the device.",
                        "init": null,
                        "name": "brandName[$S_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] Model name of the device (NULL terminated string value). Will be set to the string \"unknown\" if this cannot be determined for the device.",
                        "init": null,
                        "name": "modelName[$S_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] Vendor name of the device (NULL terminated string value). Will be set to the string \"unknown\" if this cannot be determined for the device.",
                        "init": null,
                        "name": "vendorName[$S_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] Installed driver version (NULL terminated string value). Will be set to the string \"unknown\" if this cannot be determined for the device.",
                        "init": null,
                        "name": "driverVersion[$S_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    }
                ]
            },
            "$s_device_state_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] Indicates if the device needs to be reset and for what reasons.\nreturns 0 (none) or combination of $s_reset_reason_flag_t\n",
                        "init": null,
                        "name": "reset",
                        "type": "$s_reset_reason_flags_t"
                    },
                    {
                        "desc": "[out] Indicates if the device has been repaired",
                        "init": null,
                        "name": "repaired",
                        "type": "$s_repair_status_t"
                    }
                ]
            },
            "$s_diag_properties_t": {
                "class": "$sDiagnostics",
                "members": [
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Name of the diagnostics test suite",
                        "init": null,
                        "name": "name[$S_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] Indicates if this test suite has individual tests which can be run separately (use the function $sDiagnosticsGetTests() to get the list of these tests)",
                        "init": null,
                        "name": "haveTests",
                        "type": "$x_bool_t"
                    }
                ]
            },
            "$s_diag_test_t": {
                "class": "$sDiagnostics",
                "members": [
                    {
                        "desc": "[out] Index of the test",
                        "init": null,
                        "name": "index",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Name of the test",
                        "init": null,
                        "name": "name[$S_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    }
                ]
            },
            "$s_energy_threshold_t": {
                "class": "$sPower",
                "members": [
                    {
                        "desc": "[in,out] Indicates if the energy threshold is enabled.",
                        "init": null,
                        "name": "enable",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[in,out] The energy threshold in Joules. Will be 0.0 if no threshold has been set.",
                        "init": null,
                        "name": "threshold",
                        "type": "double"
                    },
                    {
                        "desc": "[in,out] The host process ID that set the energy threshold. Will be 0xFFFFFFFF if no threshold has been set.",
                        "init": null,
                        "name": "processId",
                        "type": "uint32_t"
                    }
                ]
            },
            "$s_engine_ext_properties_t": {
                "class": "$sEngine",
                "members": [
                    {
                        "desc": "[out] Number of Virtual Function(VF) instances associated with engine to monitor the utilization of hardware across all Virtual Function from a Physical Function (PF) instance.\nThese VF-by-VF views should provide engine group and individual engine level granularity.\nThis count represents the number of VF instances that are actively using the resource represented by the engine handle.\n",
                        "init": null,
                        "name": "countOfVirtualFunctionInstance",
                        "type": "uint32_t"
                    }
                ]
            },
            "$s_engine_properties_t": {
                "class": "$sEngine",
                "members": [
                    {
                        "desc": "[out] The engine group",
                        "init": null,
                        "name": "type",
                        "type": "$s_engine_group_t"
                    },
                    {
                        "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    }
                ]
            },
            "$s_engine_stats_t": {
                "class": "$sEngine",
                "members": [
                    {
                        "desc": "[out] Monotonic counter for time in microseconds that this resource is actively running workloads.",
                        "init": null,
                        "name": "activeTime",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic timestamp counter in microseconds when activeTime counter was sampled.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                        "init": null,
                        "name": "timestamp",
                        "type": "uint64_t"
                    }
                ]
            },
            "$s_fabric_link_type_t": {
                "class": "$sFabricPort",
                "members": [
                    {
                        "desc": "[out] Description of link technology. Will be set to the string \"unkown\" if this cannot be determined for this link.",
                        "init": null,
                        "name": "desc[$S_MAX_FABRIC_LINK_TYPE_SIZE]",
                        "type": "char"
                    }
                ]
            },
            "$s_fabric_port_config_t": {
                "class": "$sFabricPort",
                "members": [
                    {
                        "desc": "[in,out] Port is configured up/down",
                        "init": null,
                        "name": "enabled",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[in,out] Beaconing is configured on/off",
                        "init": null,
                        "name": "beaconing",
                        "type": "$x_bool_t"
                    }
                ]
            },
            "$s_fabric_port_error_counters_t": {
                "class": "$sFabricPort",
                "members": [
                    {
                        "desc": "[out] Link Failure Error Count reported per port",
                        "init": null,
                        "name": "linkFailureCount",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Firmware Communication Error Count reported per device",
                        "init": null,
                        "name": "fwCommErrorCount",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Firmware reported Error Count reported per device",
                        "init": null,
                        "name": "fwErrorCount",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Link Degrade Error Count reported per port",
                        "init": null,
                        "name": "linkDegradeCount",
                        "type": "uint64_t"
                    }
                ]
            },
            "$s_fabric_port_id_t": {
                "class": "$sFabricPort",
                "members": [
                    {
                        "desc": "[out] Unique identifier for the fabric end-point",
                        "init": null,
                        "name": "fabricId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Unique identifier for the device attachment point",
                        "init": null,
                        "name": "attachId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] The logical port number (this is typically marked somewhere on the physical device)",
                        "init": null,
                        "name": "portNumber",
                        "type": "uint8_t"
                    }
                ]
            },
            "$s_fabric_port_properties_t": {
                "class": "$sFabricPort",
                "members": [
                    {
                        "desc": "[out] Description of port technology. Will be set to the string \"unkown\" if this cannot be determined for this port.",
                        "init": null,
                        "name": "model[$S_MAX_FABRIC_PORT_MODEL_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] True if the port is located on a sub-device; false means that the port is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] The unique port identifier",
                        "init": null,
                        "name": "portId",
                        "type": "$s_fabric_port_id_t"
                    },
                    {
                        "desc": "[out] Maximum speed supported by the receive side of the port (sum of all lanes)",
                        "init": null,
                        "name": "maxRxSpeed",
                        "type": "$s_fabric_port_speed_t"
                    },
                    {
                        "desc": "[out] Maximum speed supported by the transmit side of the port (sum of all lanes)",
                        "init": null,
                        "name": "maxTxSpeed",
                        "type": "$s_fabric_port_speed_t"
                    }
                ]
            },
            "$s_fabric_port_speed_t": {
                "class": "$sFabricPort",
                "members": [
                    {
                        "desc": "[out] Bits/sec that the link is operating at. A value of -1 means that this property is unknown.",
                        "init": null,
                        "name": "bitRate",
                        "type": "int64_t"
                    },
                    {
                        "desc": "[out] The number of lanes. A value of -1 means that this property is unknown.",
                        "init": null,
                        "name": "width",
                        "type": "int32_t"
                    }
                ]
            },
            "$s_fabric_port_state_t": {
                "class": "$sFabricPort",
                "members": [
                    {
                        "desc": "[out] The current status of the port",
                        "init": null,
                        "name": "status",
                        "type": "$s_fabric_port_status_t"
                    },
                    {
                        "desc": "[out] If status is $S_FABRIC_PORT_STATUS_DEGRADED,\nthen this gives a combination of $s_fabric_port_qual_issue_flag_t for quality issues that have been detected;\notherwise, 0 indicates there are no quality issues with the link at this time.\n",
                        "init": null,
                        "name": "qualityIssues",
                        "type": "$s_fabric_port_qual_issue_flags_t"
                    },
                    {
                        "desc": "[out] If status is $S_FABRIC_PORT_STATUS_FAILED,\nthen this gives a combination of $s_fabric_port_failure_flag_t for reasons for the connection instability;\notherwise, 0 indicates there are no connection stability issues at this time.\n",
                        "init": null,
                        "name": "failureReasons",
                        "type": "$s_fabric_port_failure_flags_t"
                    },
                    {
                        "desc": "[out] The unique port identifier for the remote connection point if status is $S_FABRIC_PORT_STATUS_HEALTHY, $S_FABRIC_PORT_STATUS_DEGRADED or $S_FABRIC_PORT_STATUS_FAILED",
                        "init": null,
                        "name": "remotePortId",
                        "type": "$s_fabric_port_id_t"
                    },
                    {
                        "desc": "[out] Current maximum receive speed (sum of all lanes)",
                        "init": null,
                        "name": "rxSpeed",
                        "type": "$s_fabric_port_speed_t"
                    },
                    {
                        "desc": "[out] Current maximum transmit speed (sum of all lanes)",
                        "init": null,
                        "name": "txSpeed",
                        "type": "$s_fabric_port_speed_t"
                    }
                ]
            },
            "$s_fabric_port_throughput_t": {
                "class": "$sFabricPort",
                "members": [
                    {
                        "desc": "[out] Monotonic timestamp counter in microseconds when the measurement was made.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                        "init": null,
                        "name": "timestamp",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic counter for the number of bytes received (sum of all lanes). This includes all protocol overhead, not only the GPU traffic.",
                        "init": null,
                        "name": "rxCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic counter for the number of bytes transmitted (sum of all lanes). This includes all protocol overhead, not only the GPU traffic.",
                        "init": null,
                        "name": "txCounter",
                        "type": "uint64_t"
                    }
                ]
            },
            "$s_fan_config_t": {
                "class": "$sFan",
                "members": [
                    {
                        "desc": "[in,out] The fan speed mode (fixed, temp-speed table)",
                        "init": null,
                        "name": "mode",
                        "type": "$s_fan_speed_mode_t"
                    },
                    {
                        "desc": "[in,out] The current fixed fan speed setting",
                        "init": null,
                        "name": "speedFixed",
                        "type": "$s_fan_speed_t"
                    },
                    {
                        "desc": "[out] A table containing temperature/speed pairs",
                        "init": null,
                        "name": "speedTable",
                        "type": "$s_fan_speed_table_t"
                    }
                ]
            },
            "$s_fan_properties_t": {
                "class": "$sFan",
                "members": [
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Indicates if software can control the fan speed assuming the user has permissions",
                        "init": null,
                        "name": "canControl",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Bitfield of supported fan configuration modes (1<<$s_fan_speed_mode_t)",
                        "init": null,
                        "name": "supportedModes",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Bitfield of supported fan speed units (1<<$s_fan_speed_units_t)",
                        "init": null,
                        "name": "supportedUnits",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] The maximum RPM of the fan. A value of -1 means that this property is unknown. ",
                        "init": null,
                        "name": "maxRPM",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The maximum number of points in the fan temp/speed table. A value of -1 means that this fan doesn't support providing a temp/speed table.",
                        "init": null,
                        "name": "maxPoints",
                        "type": "int32_t"
                    }
                ]
            },
            "$s_fan_speed_t": {
                "class": "$sFan",
                "members": [
                    {
                        "desc": "[in,out] The speed of the fan. On output, a value of -1 indicates that there is no fixed fan speed setting.",
                        "init": null,
                        "name": "speed",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[in,out] The units that the fan speed is expressed in. On output, if fan speed is -1 then units should be ignored.",
                        "init": null,
                        "name": "units",
                        "type": "$s_fan_speed_units_t"
                    }
                ]
            },
            "$s_fan_speed_table_t": {
                "class": "$sFan",
                "members": [
                    {
                        "desc": "[in,out] The number of valid points in the fan speed table. 0 means that there is no fan speed table configured. -1 means that a fan speed table is not supported by the hardware.",
                        "init": null,
                        "name": "numPoints",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[in,out] Array of temperature/fan speed pairs. The table is ordered based on temperature from lowest to highest.",
                        "init": null,
                        "name": "table[$S_FAN_TEMP_SPEED_PAIR_COUNT]",
                        "type": "$s_fan_temp_speed_t"
                    }
                ]
            },
            "$s_fan_temp_speed_t": {
                "class": "$sFan",
                "members": [
                    {
                        "desc": "[in,out] Temperature in degrees Celsius.",
                        "init": null,
                        "name": "temperature",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out] The speed of the fan",
                        "init": null,
                        "name": "speed",
                        "type": "$s_fan_speed_t"
                    }
                ]
            },
            "$s_firmware_properties_t": {
                "class": "$sFirmware",
                "members": [
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Indicates if software can flash the firmware assuming the user has permissions",
                        "init": null,
                        "name": "canControl",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] NULL terminated string value. The string \"unknown\" will be returned if this property cannot be determined.",
                        "init": null,
                        "name": "name[$S_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] NULL terminated string value. The string \"unknown\" will be returned if this property cannot be determined.",
                        "init": null,
                        "name": "version[$S_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    }
                ]
            },
            "$s_freq_properties_t": {
                "class": "$sFrequency",
                "members": [
                    {
                        "desc": "[out] The hardware block that this frequency domain controls (GPU, memory, ...)",
                        "init": null,
                        "name": "type",
                        "type": "$s_freq_domain_t"
                    },
                    {
                        "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Indicates if software can control the frequency of this domain assuming the user has permissions",
                        "init": null,
                        "name": "canControl",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if software can register to receive event $S_EVENT_TYPE_FLAG_FREQ_THROTTLED",
                        "init": null,
                        "name": "isThrottleEventSupported",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] The minimum hardware clock frequency in units of MHz.",
                        "init": null,
                        "name": "min",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The maximum non-overclock hardware clock frequency in units of MHz.",
                        "init": null,
                        "name": "max",
                        "type": "double"
                    }
                ]
            },
            "$s_freq_range_t": {
                "class": "$sFrequency",
                "members": [
                    {
                        "desc": "[in,out] The min frequency in MHz below which hardware frequency management will not request frequencies. On input, setting to 0 will permit the frequency to go down to the hardware minimum while setting to -1 will return the min frequency limit to the factory value (can be larger than the hardware min). On output, a negative value indicates that no external minimum frequency limit is in effect.",
                        "init": null,
                        "name": "min",
                        "type": "double"
                    },
                    {
                        "desc": "[in,out] The max frequency in MHz above which hardware frequency management will not request frequencies. On input, setting to 0 or a very big number will permit the frequency to go all the way up to the hardware maximum while setting to -1 will return the max frequency to the factory value (which can be less than the hardware max). On output, a negative number indicates that no external maximum frequency limit is in effect.",
                        "init": null,
                        "name": "max",
                        "type": "double"
                    }
                ]
            },
            "$s_freq_state_t": {
                "class": "$sFrequency",
                "members": [
                    {
                        "desc": "[out] Current voltage in Volts. A negative value indicates that this property is not known.",
                        "init": null,
                        "name": "currentVoltage",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The current frequency request in MHz. A negative value indicates that this property is not known.",
                        "init": null,
                        "name": "request",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The maximum frequency in MHz supported under the current TDP conditions. This fluctuates dynamically based on the power and thermal limits of the part. A negative value indicates that this property is not known.",
                        "init": null,
                        "name": "tdp",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The efficient minimum frequency in MHz. A negative value indicates that this property is not known.",
                        "init": null,
                        "name": "efficient",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The resolved frequency in MHz. A negative value indicates that this property is not known.",
                        "init": null,
                        "name": "actual",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The reasons that the frequency is being limited by the hardware.\nReturns 0 (frequency not throttled) or a combination of $s_freq_throttle_reason_flag_t.\n",
                        "init": null,
                        "name": "throttleReasons",
                        "type": "$s_freq_throttle_reason_flags_t"
                    }
                ]
            },
            "$s_freq_throttle_time_t": {
                "class": "$sFrequency",
                "members": [
                    {
                        "desc": "[out] The monotonic counter of time in microseconds that the frequency has been limited by the hardware.",
                        "init": null,
                        "name": "throttleTime",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Microsecond timestamp when throttleTime was captured.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                        "init": null,
                        "name": "timestamp",
                        "type": "uint64_t"
                    }
                ]
            },
            "$s_led_color_t": {
                "class": "$sLed",
                "members": [
                    {
                        "desc": "[in,out][range(0.0, 1.0)] The LED red value. On output, a value less than 0.0 indicates that the color is not known.",
                        "init": null,
                        "name": "red",
                        "type": "double"
                    },
                    {
                        "desc": "[in,out][range(0.0, 1.0)] The LED green value. On output, a value less than 0.0 indicates that the color is not known.",
                        "init": null,
                        "name": "green",
                        "type": "double"
                    },
                    {
                        "desc": "[in,out][range(0.0, 1.0)] The LED blue value. On output, a value less than 0.0 indicates that the color is not known.",
                        "init": null,
                        "name": "blue",
                        "type": "double"
                    }
                ]
            },
            "$s_led_properties_t": {
                "class": "$sLed",
                "members": [
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Indicates if software can control the LED assuming the user has permissions",
                        "init": null,
                        "name": "canControl",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if the LED is RGB capable",
                        "init": null,
                        "name": "haveRGB",
                        "type": "$x_bool_t"
                    }
                ]
            },
            "$s_led_state_t": {
                "class": "$sLed",
                "members": [
                    {
                        "desc": "[out] Indicates if the LED is on or off",
                        "init": null,
                        "name": "isOn",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Color of the LED",
                        "init": null,
                        "name": "color",
                        "type": "$s_led_color_t"
                    }
                ]
            },
            "$s_mem_bandwidth_t": {
                "class": "$sMemory",
                "members": [
                    {
                        "desc": "[out] Total bytes read from memory",
                        "init": null,
                        "name": "readCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Total bytes written to memory",
                        "init": null,
                        "name": "writeCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Current maximum bandwidth in units of bytes/sec",
                        "init": null,
                        "name": "maxBandwidth",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] The timestamp in microseconds when these measurements were sampled.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                        "init": null,
                        "name": "timestamp",
                        "type": "uint64_t"
                    }
                ]
            },
            "$s_mem_ext_bandwidth_t": {
                "class": "$sMemory",
                "members": [
                    {
                        "desc": "[out] Returns the number of valid bits in the timestamp values",
                        "init": null,
                        "name": "memoryTimestampValidBits",
                        "type": "uint32_t"
                    }
                ]
            },
            "$s_mem_properties_t": {
                "class": "$sMemory",
                "members": [
                    {
                        "desc": "[out] The memory type",
                        "init": null,
                        "name": "type",
                        "type": "$s_mem_type_t"
                    },
                    {
                        "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Location of this memory (system, device)",
                        "init": null,
                        "name": "location",
                        "type": "$s_mem_loc_t"
                    },
                    {
                        "desc": "[out] Physical memory size in bytes. A value of 0 indicates that this property is not known. However, a call to $sMemoryGetState() will correctly return the total size of usable memory.",
                        "init": null,
                        "name": "physicalSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Width of the memory bus. A value of -1 means that this property is unknown.",
                        "init": null,
                        "name": "busWidth",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The number of memory channels. A value of -1 means that this property is unknown.",
                        "init": null,
                        "name": "numChannels",
                        "type": "int32_t"
                    }
                ]
            },
            "$s_mem_state_t": {
                "class": "$sMemory",
                "members": [
                    {
                        "desc": "[out] Indicates the health of the memory",
                        "init": null,
                        "name": "health",
                        "type": "$s_mem_health_t"
                    },
                    {
                        "desc": "[out] The free memory in bytes",
                        "init": null,
                        "name": "free",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] The total allocatable memory in bytes (can be less than the `physicalSize` member of $s_mem_properties_t)",
                        "init": null,
                        "name": "size",
                        "type": "uint64_t"
                    }
                ]
            },
            "$s_oc_capabilities_t": {
                "class": "$sFrequency",
                "members": [
                    {
                        "desc": "[out] Indicates if any overclocking features are supported on this frequency domain.",
                        "init": null,
                        "name": "isOcSupported",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Factory default non-overclock maximum frequency in Mhz.",
                        "init": null,
                        "name": "maxFactoryDefaultFrequency",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Factory default voltage used for the non-overclock maximum frequency in MHz.",
                        "init": null,
                        "name": "maxFactoryDefaultVoltage",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Maximum hardware overclocking frequency limit in Mhz.",
                        "init": null,
                        "name": "maxOcFrequency",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The minimum voltage offset that can be applied to the voltage/frequency curve. Note that this number can be negative.",
                        "init": null,
                        "name": "minOcVoltageOffset",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The maximum voltage offset that can be applied to the voltage/frequency curve.",
                        "init": null,
                        "name": "maxOcVoltageOffset",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The maximum overclock voltage that hardware supports.",
                        "init": null,
                        "name": "maxOcVoltage",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Indicates if the maximum temperature limit (TjMax) can be changed for this frequency domain.",
                        "init": null,
                        "name": "isTjMaxSupported",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if the maximum current (IccMax) can be changed for this frequency domain.",
                        "init": null,
                        "name": "isIccMaxSupported",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if this frequency domains supports a feature to set very high voltages.",
                        "init": null,
                        "name": "isHighVoltModeCapable",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if very high voltages are permitted on this frequency domain.",
                        "init": null,
                        "name": "isHighVoltModeEnabled",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if the extended overclocking features are supported. If this is supported, increments are on 1 Mhz basis.",
                        "init": null,
                        "name": "isExtendedModeSupported",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if the fixed mode is supported. In this mode, hardware will disable most frequency throttling and lock the frequency and voltage at the specified overclock values.",
                        "init": null,
                        "name": "isFixedModeSupported",
                        "type": "$x_bool_t"
                    }
                ]
            },
            "$s_overclock_properties_t": {
                "class": "$sOverclock",
                "members": [
                    {
                        "desc": "[out] The hardware block that this overclock domain controls (GPU, VRAM, ...)",
                        "init": null,
                        "name": "domainType",
                        "type": "$s_overclock_domain_t"
                    },
                    {
                        "desc": "[out] Returns the overclock controls that are supported (a bit for each of enum $s_overclock_control_t). If no bits are set, the domain doesn't support overclocking.",
                        "init": null,
                        "name": "AvailableControls",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Type of V-F curve programming that is permitted:.",
                        "init": null,
                        "name": "VFProgramType",
                        "type": "$s_vf_program_type_t"
                    },
                    {
                        "desc": "[out] Number of VF points that can be programmed - max_num_points",
                        "init": null,
                        "name": "NumberOfVFPoints",
                        "type": "uint32_t"
                    }
                ]
            },
            "$s_pci_address_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] BDF domain",
                        "init": null,
                        "name": "domain",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] BDF bus",
                        "init": null,
                        "name": "bus",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] BDF device",
                        "init": null,
                        "name": "device",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] BDF function",
                        "init": null,
                        "name": "function",
                        "type": "uint32_t"
                    }
                ]
            },
            "$s_pci_bar_properties_1_2_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] The type of bar",
                        "init": null,
                        "name": "type",
                        "type": "$s_pci_bar_type_t"
                    },
                    {
                        "desc": "[out] The index of the bar",
                        "init": null,
                        "name": "index",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Base address of the bar.",
                        "init": null,
                        "name": "base",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Size of the bar.",
                        "init": null,
                        "name": "size",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Support for Resizable Bar on this device.",
                        "init": null,
                        "name": "resizableBarSupported",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Resizable Bar enabled on this device",
                        "init": null,
                        "name": "resizableBarEnabled",
                        "type": "$x_bool_t"
                    }
                ]
            },
            "$s_pci_bar_properties_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] The type of bar",
                        "init": null,
                        "name": "type",
                        "type": "$s_pci_bar_type_t"
                    },
                    {
                        "desc": "[out] The index of the bar",
                        "init": null,
                        "name": "index",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Base address of the bar.",
                        "init": null,
                        "name": "base",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Size of the bar.",
                        "init": null,
                        "name": "size",
                        "type": "uint64_t"
                    }
                ]
            },
            "$s_pci_properties_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] The BDF address",
                        "init": null,
                        "name": "address",
                        "type": "$s_pci_address_t"
                    },
                    {
                        "desc": "[out] Fastest port configuration supported by the device (sum of all lanes)",
                        "init": null,
                        "name": "maxSpeed",
                        "type": "$s_pci_speed_t"
                    },
                    {
                        "desc": "[out] Indicates whether the `rxCounter` and `txCounter` members of $s_pci_stats_t will have valid values",
                        "init": null,
                        "name": "haveBandwidthCounters",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Indicates whether the `packetCounter` member of $s_pci_stats_t will have a valid value",
                        "init": null,
                        "name": "havePacketCounters",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Indicates whether the `replayCounter` member of $s_pci_stats_t will have a valid value",
                        "init": null,
                        "name": "haveReplayCounters",
                        "type": "$x_bool_t"
                    }
                ]
            },
            "$s_pci_speed_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] The link generation. A value of -1 means that this property is unknown.",
                        "init": null,
                        "name": "gen",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The number of lanes. A value of -1 means that this property is unknown.",
                        "init": null,
                        "name": "width",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The maximum bandwidth in bytes/sec (sum of all lanes). A value of -1 means that this property is unknown.",
                        "init": null,
                        "name": "maxBandwidth",
                        "type": "int64_t"
                    }
                ]
            },
            "$s_pci_state_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] The current status of the port",
                        "init": null,
                        "name": "status",
                        "type": "$s_pci_link_status_t"
                    },
                    {
                        "desc": "[out] If status is $S_PCI_LINK_STATUS_QUALITY_ISSUES, \nthen this gives a combination of $s_pci_link_qual_issue_flag_t for quality issues that have been detected;\notherwise, 0 indicates there are no quality issues with the link at this time.\"\n",
                        "init": null,
                        "name": "qualityIssues",
                        "type": "$s_pci_link_qual_issue_flags_t"
                    },
                    {
                        "desc": "[out] If status is $S_PCI_LINK_STATUS_STABILITY_ISSUES, \nthen this gives a combination of $s_pci_link_stab_issue_flag_t for reasons for the connection instability;\notherwise, 0 indicates there are no connection stability issues at this time.\"\n",
                        "init": null,
                        "name": "stabilityIssues",
                        "type": "$s_pci_link_stab_issue_flags_t"
                    },
                    {
                        "desc": "[out] The current port configure speed",
                        "init": null,
                        "name": "speed",
                        "type": "$s_pci_speed_t"
                    }
                ]
            },
            "$s_pci_stats_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] Monotonic timestamp counter in microseconds when the measurement was made.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                        "init": null,
                        "name": "timestamp",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic counter for the number of replay packets (sum of all lanes). Will always be 0 when the `haveReplayCounters` member of $s_pci_properties_t is FALSE.",
                        "init": null,
                        "name": "replayCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic counter for the number of packets (sum of all lanes). Will always be 0 when the `havePacketCounters` member of $s_pci_properties_t is FALSE.",
                        "init": null,
                        "name": "packetCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic counter for the number of bytes received (sum of all lanes). Will always be 0 when the `haveBandwidthCounters` member of $s_pci_properties_t is FALSE.",
                        "init": null,
                        "name": "rxCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic counter for the number of bytes transmitted (including replays) (sum of all lanes). Will always be 0 when the `haveBandwidthCounters` member of $s_pci_properties_t is FALSE.",
                        "init": null,
                        "name": "txCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] The current speed of the link (sum of all lanes)",
                        "init": null,
                        "name": "speed",
                        "type": "$s_pci_speed_t"
                    }
                ]
            },
            "$s_perf_properties_t": {
                "class": "$sPerformanceFactor",
                "members": [
                    {
                        "desc": "[out] True if this Performance Factor affects accelerators located on a sub-device",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Bitfield of accelerator engine types that are affected by this Performance Factor.",
                        "init": null,
                        "name": "engines",
                        "type": "$s_engine_type_flags_t"
                    }
                ]
            },
            "$s_power_burst_limit_t": {
                "class": "$sPower",
                "members": [
                    {
                        "desc": "[in,out] indicates if the limit is enabled (true) or ignored (false)",
                        "init": null,
                        "name": "enabled",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[in,out] power limit in milliwatts",
                        "init": null,
                        "name": "power",
                        "type": "int32_t"
                    }
                ]
            },
            "$s_power_energy_counter_t": {
                "class": "$sPower",
                "members": [
                    {
                        "desc": "[out] The monotonic energy counter in microjoules.",
                        "init": null,
                        "name": "energy",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Microsecond timestamp when energy was captured.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                        "init": null,
                        "name": "timestamp",
                        "type": "uint64_t"
                    }
                ]
            },
            "$s_power_ext_properties_t": {
                "class": "$sPower",
                "members": [
                    {
                        "desc": "[out] domain that the power limit belongs to.",
                        "init": null,
                        "name": "domain",
                        "type": "$s_power_domain_t"
                    },
                    {
                        "desc": "[out] the factory default limit of the part.",
                        "init": null,
                        "name": "defaultLimit",
                        "type": "$s_power_limit_ext_desc_t*"
                    }
                ]
            },
            "$s_power_limit_ext_desc_t": {
                "class": "$sPower",
                "members": [
                    {
                        "desc": "[in,out] duration type over which the power draw is measured, i.e. sustained, burst, peak, or critical.",
                        "init": null,
                        "name": "level",
                        "type": "$s_power_level_t"
                    },
                    {
                        "desc": "[out] source of power used by the system, i.e. AC or DC.",
                        "init": null,
                        "name": "source",
                        "type": "$s_power_source_t"
                    },
                    {
                        "desc": "[out] unit used for specifying limit, i.e. current units (milliamps) or power units (milliwatts).",
                        "init": null,
                        "name": "limitUnit",
                        "type": "$s_limit_unit_t"
                    },
                    {
                        "desc": "[out] indicates if the power limit state (enabled/ignored) can be set (false) or is locked (true).",
                        "init": null,
                        "name": "enabledStateLocked",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] indicates if the limit is enabled (true) or ignored (false). If enabledStateIsLocked is True, this value is ignored.",
                        "init": null,
                        "name": "enabled",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] indicates if the interval can be modified (false) or is fixed (true).",
                        "init": null,
                        "name": "intervalValueLocked",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] power averaging window in milliseconds. If intervalValueLocked is true, this value is ignored.",
                        "init": null,
                        "name": "interval",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] indicates if the limit can be set (false) or if the limit is fixed (true).",
                        "init": null,
                        "name": "limitValueLocked",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] limit value. If limitValueLocked is true, this value is ignored. The value should be provided in the unit specified by limitUnit.",
                        "init": null,
                        "name": "limit",
                        "type": "int32_t"
                    }
                ]
            },
            "$s_power_peak_limit_t": {
                "class": "$sPower",
                "members": [
                    {
                        "desc": "[in,out] power limit in milliwatts for the AC power source.",
                        "init": null,
                        "name": "powerAC",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[in,out] power limit in milliwatts for the DC power source. On input, this is ignored if the product does not have a battery. On output, this will be -1 if the product does not have a battery.",
                        "init": null,
                        "name": "powerDC",
                        "type": "int32_t"
                    }
                ]
            },
            "$s_power_properties_t": {
                "class": "$sPower",
                "members": [
                    {
                        "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Software can change the power limits of this domain assuming the user has permissions.",
                        "init": null,
                        "name": "canControl",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if this power domain supports the energy threshold event ($S_EVENT_TYPE_FLAG_ENERGY_THRESHOLD_CROSSED).",
                        "init": null,
                        "name": "isEnergyThresholdSupported",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] (Deprecated) The factory default TDP power limit of the part in milliwatts. A value of -1 means that this is not known.",
                        "init": null,
                        "name": "defaultLimit",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] (Deprecated) The minimum power limit in milliwatts that can be requested. A value of -1 means that this is not known.",
                        "init": null,
                        "name": "minLimit",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] (Deprecated) The maximum power limit in milliwatts that can be requested. A value of -1 means that this is not known.",
                        "init": null,
                        "name": "maxLimit",
                        "type": "int32_t"
                    }
                ]
            },
            "$s_power_sustained_limit_t": {
                "class": "$sPower",
                "members": [
                    {
                        "desc": "[in,out] indicates if the limit is enabled (true) or ignored (false)",
                        "init": null,
                        "name": "enabled",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[in,out] power limit in milliwatts",
                        "init": null,
                        "name": "power",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[in,out] power averaging window (Tau) in milliseconds",
                        "init": null,
                        "name": "interval",
                        "type": "int32_t"
                    }
                ]
            },
            "$s_process_state_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] Host OS process ID.",
                        "init": null,
                        "name": "processId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Device memory size in bytes allocated by this process (may not necessarily be resident on the device at the time of reading).",
                        "init": null,
                        "name": "memSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] The size of shared device memory mapped into this process (may not necessarily be resident on the device at the time of reading).",
                        "init": null,
                        "name": "sharedSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Bitfield of accelerator engine types being used by this process.",
                        "init": null,
                        "name": "engines",
                        "type": "$s_engine_type_flags_t"
                    }
                ]
            },
            "$s_psu_properties_t": {
                "class": "$sPsu",
                "members": [
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] True if the power supply has a fan",
                        "init": null,
                        "name": "haveFan",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] The maximum electrical current in milliamperes that can be drawn. A value of -1 indicates that this property cannot be determined.",
                        "init": null,
                        "name": "ampLimit",
                        "type": "int32_t"
                    }
                ]
            },
            "$s_psu_state_t": {
                "class": "$sPsu",
                "members": [
                    {
                        "desc": "[out] The current PSU voltage status",
                        "init": null,
                        "name": "voltStatus",
                        "type": "$s_psu_voltage_status_t"
                    },
                    {
                        "desc": "[out] Indicates if the fan has failed",
                        "init": null,
                        "name": "fanFailed",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Read the current heatsink temperature in degrees Celsius. A value of -1 indicates that this property cannot be determined.",
                        "init": null,
                        "name": "temperature",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The amps being drawn in milliamperes. A value of -1 indicates that this property cannot be determined.",
                        "init": null,
                        "name": "current",
                        "type": "int32_t"
                    }
                ]
            },
            "$s_ras_config_t": {
                "class": "$sRas",
                "members": [
                    {
                        "desc": "[in,out] If the total RAS errors exceeds this threshold, the event will be triggered. A value of 0ULL disables triggering the event based on the total counter.",
                        "init": null,
                        "name": "totalThreshold",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[in,out] If the RAS errors for each category exceed the threshold for that category, the event will be triggered. A value of 0ULL will disable an event being triggered for that category.",
                        "init": null,
                        "name": "detailedThresholds",
                        "type": "$s_ras_state_t"
                    }
                ]
            },
            "$s_ras_properties_t": {
                "class": "$sRas",
                "members": [
                    {
                        "desc": "[out] The type of RAS error",
                        "init": null,
                        "name": "type",
                        "type": "$s_ras_error_type_t"
                    },
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    }
                ]
            },
            "$s_ras_state_exp_t": {
                "class": "$sRas",
                "members": [
                    {
                        "desc": "[out] category for which error counter is provided.",
                        "init": null,
                        "name": "category",
                        "type": "$s_ras_error_category_exp_t"
                    },
                    {
                        "desc": "[out] Current value of RAS counter for specific error category.",
                        "init": null,
                        "name": "errorCounter",
                        "type": "uint64_t"
                    }
                ]
            },
            "$s_ras_state_t": {
                "class": "$sRas",
                "members": [
                    {
                        "desc": "[in][out] Breakdown of error by category",
                        "init": null,
                        "name": "category[$S_MAX_RAS_ERROR_CATEGORY_COUNT]",
                        "type": "uint64_t"
                    }
                ]
            },
            "$s_reset_properties_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[in] If set to true, all applications that are currently using the device will be forcibly killed.\n",
                        "init": null,
                        "name": "force",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in] Type of reset needs to be performed",
                        "init": null,
                        "name": "resetType",
                        "type": "$s_reset_type_t"
                    }
                ]
            },
            "$s_sched_properties_t": {
                "class": "$sScheduler",
                "members": [
                    {
                        "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Software can change the scheduler component configuration assuming the user has permissions.",
                        "init": null,
                        "name": "canControl",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Bitfield of accelerator engine types that are managed by this scheduler component. Note that there can be more than one scheduler component for the same type of accelerator engine.",
                        "init": null,
                        "name": "engines",
                        "type": "$s_engine_type_flags_t"
                    },
                    {
                        "desc": "[out] Bitfield of scheduler modes that can be configured for this scheduler component (bitfield of 1<<$s_sched_mode_t).",
                        "init": null,
                        "name": "supportedModes",
                        "type": "uint32_t"
                    }
                ]
            },
            "$s_sched_timeout_properties_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[in,out] The maximum time in microseconds that the scheduler will wait for a batch of work submitted to a hardware engine to complete or to be preempted so as to run another context.\nIf this time is exceeded, the hardware engine is reset and the context terminated.\nIf set to $S_SCHED_WATCHDOG_DISABLE, a running workload can run as long as it wants without being terminated, but preemption attempts to run other contexts are permitted but not enforced.\n",
                        "init": null,
                        "name": "watchdogTimeout",
                        "type": "uint64_t"
                    }
                ]
            },
            "$s_sched_timeslice_properties_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[in,out] The average interval in microseconds that a submission for a context will run on a hardware engine before being preempted out to run a pending submission for another context.",
                        "init": null,
                        "name": "interval",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[in,out] The maximum time in microseconds that the scheduler will wait to preempt a workload running on an engine before deciding to reset the hardware engine and terminating the associated context.",
                        "init": null,
                        "name": "yieldTimeout",
                        "type": "uint64_t"
                    }
                ]
            },
            "$s_standby_properties_t": {
                "class": "$sStandby",
                "members": [
                    {
                        "desc": "[out] Which standby hardware component this controls",
                        "init": null,
                        "name": "type",
                        "type": "$s_standby_type_t"
                    },
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    }
                ]
            },
            "$s_temp_config_t": {
                "class": "$sTemperature",
                "members": [
                    {
                        "desc": "[in,out] Indicates if event $S_EVENT_TYPE_FLAG_TEMP_CRITICAL should be triggered by the driver.",
                        "init": null,
                        "name": "enableCritical",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[in,out] Configuration controlling if and when event $S_EVENT_TYPE_FLAG_TEMP_THRESHOLD1 should be triggered by the driver.",
                        "init": null,
                        "name": "threshold1",
                        "type": "$s_temp_threshold_t"
                    },
                    {
                        "desc": "[in,out] Configuration controlling if and when event $S_EVENT_TYPE_FLAG_TEMP_THRESHOLD2 should be triggered by the driver.",
                        "init": null,
                        "name": "threshold2",
                        "type": "$s_temp_threshold_t"
                    }
                ]
            },
            "$s_temp_properties_t": {
                "class": "$sTemperature",
                "members": [
                    {
                        "desc": "[out] Which part of the device the temperature sensor measures",
                        "init": null,
                        "name": "type",
                        "type": "$s_temp_sensors_t"
                    },
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "init": null,
                        "name": "onSubdevice",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Will contain the maximum temperature for the specific device in degrees Celsius.",
                        "init": null,
                        "name": "maxTemperature",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Indicates if the critical temperature event $S_EVENT_TYPE_FLAG_TEMP_CRITICAL is supported",
                        "init": null,
                        "name": "isCriticalTempSupported",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if the temperature threshold 1 event $S_EVENT_TYPE_FLAG_TEMP_THRESHOLD1 is supported",
                        "init": null,
                        "name": "isThreshold1Supported",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if the temperature threshold 2 event $S_EVENT_TYPE_FLAG_TEMP_THRESHOLD2 is supported",
                        "init": null,
                        "name": "isThreshold2Supported",
                        "type": "$x_bool_t"
                    }
                ]
            },
            "$s_temp_threshold_t": {
                "class": "$sTemperature",
                "members": [
                    {
                        "desc": "[in,out] Trigger an event when the temperature crosses from below the threshold to above.",
                        "init": null,
                        "name": "enableLowToHigh",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[in,out] Trigger an event when the temperature crosses from above the threshold to below.",
                        "init": null,
                        "name": "enableHighToLow",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[in,out] The threshold in degrees Celsius.",
                        "init": null,
                        "name": "threshold",
                        "type": "double"
                    }
                ]
            },
            "$s_uuid_t": {
                "class": "$sDevice",
                "members": [
                    {
                        "desc": "[out] opaque data representing a device UUID",
                        "init": null,
                        "name": "id[$S_MAX_UUID_SIZE]",
                        "type": "uint8_t"
                    }
                ]
            },
            "$s_vf_property_t": {
                "class": "$sOverclock",
                "members": [
                    {
                        "desc": "[out] Read the minimum frequency that can be be programmed in the custom V-F point..",
                        "init": null,
                        "name": "MinFreq",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Read the maximum frequency that can be be programmed in the custom V-F point..",
                        "init": null,
                        "name": "MaxFreq",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Read the frequency step that can be be programmed in the custom V-F point..",
                        "init": null,
                        "name": "StepFreq",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Read the minimum voltage that can be be programmed in the custom V-F point..",
                        "init": null,
                        "name": "MinVolt",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Read the maximum voltage that can be be programmed in the custom V-F point..",
                        "init": null,
                        "name": "MaxVolt",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Read the voltage step that can be be programmed in the custom V-F point.",
                        "init": null,
                        "name": "StepVolt",
                        "type": "double"
                    }
                ]
            },
            "$t_base_desc_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": null,
                        "name": "stype",
                        "type": "$t_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    }
                ]
            },
            "$t_base_properties_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": null,
                        "name": "stype",
                        "type": "$t_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    }
                ]
            },
            "$t_debug_config_t": {
                "class": "$tDebug",
                "members": [
                    {
                        "desc": "[in] the host process identifier",
                        "init": null,
                        "name": "pid",
                        "type": "uint32_t"
                    }
                ]
            },
            "$t_debug_event_info_detached_t": {
                "class": "$tDebug",
                "members": [
                    {
                        "desc": "[out] the detach reason",
                        "init": null,
                        "name": "reason",
                        "type": "$t_debug_detach_reason_t"
                    }
                ]
            },
            "$t_debug_event_info_module_t": {
                "class": "$tDebug",
                "members": [
                    {
                        "desc": "[out] the module format",
                        "init": null,
                        "name": "format",
                        "type": "$t_module_debug_info_format_t"
                    },
                    {
                        "desc": "[out] the begin address of the in-memory module (inclusive)",
                        "init": null,
                        "name": "moduleBegin",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] the end address of the in-memory module (exclusive)",
                        "init": null,
                        "name": "moduleEnd",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] the load address of the module on the device",
                        "init": null,
                        "name": "load",
                        "type": "uint64_t"
                    }
                ]
            },
            "$t_debug_event_info_page_fault_t": {
                "class": "$tDebug",
                "members": [
                    {
                        "desc": "[out] the faulting address",
                        "init": null,
                        "name": "address",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] the alignment mask",
                        "init": null,
                        "name": "mask",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] the page fault reason",
                        "init": null,
                        "name": "reason",
                        "type": "$t_debug_page_fault_reason_t"
                    }
                ]
            },
            "$t_debug_event_info_thread_stopped_t": {
                "class": "$tDebug",
                "members": [
                    {
                        "desc": "[out] the stopped/unavailable thread",
                        "init": null,
                        "name": "thread",
                        "type": "$x_device_thread_t"
                    }
                ]
            },
            "$t_debug_event_t": {
                "class": "$tDebug",
                "members": [
                    {
                        "desc": "[out] the event type",
                        "init": null,
                        "name": "type",
                        "type": "$t_debug_event_type_t"
                    },
                    {
                        "desc": "[out] returns 0 (none) or a combination of $t_debug_event_flag_t",
                        "init": null,
                        "name": "flags",
                        "type": "$t_debug_event_flags_t"
                    },
                    {
                        "desc": "[out] event type specific information",
                        "init": null,
                        "name": "info",
                        "type": "$t_debug_event_info_t"
                    }
                ]
            },
            "$t_debug_memory_space_desc_t": {
                "class": "$tDebug",
                "members": [
                    {
                        "desc": "[in] type of memory space",
                        "init": null,
                        "name": "type",
                        "type": "$t_debug_memory_space_type_t"
                    },
                    {
                        "desc": "[in] the virtual address within the memory space",
                        "init": null,
                        "name": "address",
                        "type": "uint64_t"
                    }
                ]
            },
            "$t_debug_regset_properties_t": {
                "class": "$tDebug",
                "members": [
                    {
                        "desc": "[out] device-specific register set type",
                        "init": null,
                        "name": "type",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] device-specific version of this register set",
                        "init": null,
                        "name": "version",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] general register set flags",
                        "init": null,
                        "name": "generalFlags",
                        "type": "$t_debug_regset_flags_t"
                    },
                    {
                        "desc": "[out] device-specific register set flags",
                        "init": null,
                        "name": "deviceFlags",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] number of registers in the set",
                        "init": null,
                        "name": "count",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] the size of a register in bits",
                        "init": null,
                        "name": "bitSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] the size required for reading or writing a register in bytes",
                        "init": null,
                        "name": "byteSize",
                        "type": "uint32_t"
                    }
                ]
            },
            "$t_device_debug_properties_t": {
                "class": "$tDevice",
                "members": [
                    {
                        "desc": "[out] returns 0 (none) or a valid combination of $t_device_debug_property_flag_t",
                        "init": null,
                        "name": "flags",
                        "type": "$t_device_debug_property_flags_t"
                    }
                ]
            },
            "$t_metric_calculate_exp_desc_t": {
                "class": "$tMetric",
                "members": [
                    {
                        "desc": "[in] number of reports to skip during calculation",
                        "init": null,
                        "name": "rawReportSkipCount",
                        "type": "uint32_t"
                    }
                ]
            },
            "$t_metric_global_timestamps_resolution_exp_t": {
                "class": "$tMetric",
                "members": [
                    {
                        "desc": "[out] Returns the resolution of metrics timer (used for timestamps) in cycles/sec.",
                        "init": null,
                        "name": "timerResolution",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Returns the number of valid bits in the timestamp value.",
                        "init": null,
                        "name": "timestampValidBits",
                        "type": "uint64_t"
                    }
                ]
            },
            "$t_metric_group_properties_t": {
                "class": "$tMetricGroup",
                "members": [
                    {
                        "desc": "[out] metric group name",
                        "init": null,
                        "name": "name[$T_MAX_METRIC_GROUP_NAME]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] metric group description",
                        "init": null,
                        "name": "description[$T_MAX_METRIC_GROUP_DESCRIPTION]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] metric group sampling type.\nreturns a combination of $t_metric_group_sampling_type_flag_t.\n",
                        "init": null,
                        "name": "samplingType",
                        "type": "$t_metric_group_sampling_type_flags_t"
                    },
                    {
                        "desc": "[out] metric group domain number. Cannot use multiple, simultaneous metric groups from the same domain.",
                        "init": null,
                        "name": "domain",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] metric count belonging to this group",
                        "init": null,
                        "name": "metricCount",
                        "type": "uint32_t"
                    }
                ]
            },
            "$t_metric_properties_t": {
                "class": "$tMetric",
                "members": [
                    {
                        "desc": "[out] metric name",
                        "init": null,
                        "name": "name[$T_MAX_METRIC_NAME]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] metric description",
                        "init": null,
                        "name": "description[$T_MAX_METRIC_DESCRIPTION]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] metric component",
                        "init": null,
                        "name": "component[$T_MAX_METRIC_COMPONENT]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] number of tier",
                        "init": null,
                        "name": "tierNumber",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] metric type",
                        "init": null,
                        "name": "metricType",
                        "type": "$t_metric_type_t"
                    },
                    {
                        "desc": "[out] metric result type",
                        "init": null,
                        "name": "resultType",
                        "type": "$t_value_type_t"
                    },
                    {
                        "desc": "[out] metric result units",
                        "init": null,
                        "name": "resultUnits[$T_MAX_METRIC_RESULT_UNITS]",
                        "type": "char"
                    }
                ]
            },
            "$t_metric_query_pool_desc_t": {
                "class": "$tMetricQueryPool",
                "members": [
                    {
                        "desc": "[in] Query pool type.",
                        "init": "$T_METRIC_QUERY_POOL_TYPE_PERFORMANCE",
                        "name": "type",
                        "type": "$t_metric_query_pool_type_t"
                    },
                    {
                        "desc": "[in] Internal slots count within query pool object.",
                        "init": null,
                        "name": "count",
                        "type": "uint32_t"
                    }
                ]
            },
            "$t_metric_streamer_desc_t": {
                "class": "$tMetricStreamer",
                "members": [
                    {
                        "desc": "[in,out] number of collected reports after which notification event will be signaled. If the requested value is not supported exactly, then the driver may use a value that is the closest supported approximation and shall update this member during $tMetricStreamerOpen.\n",
                        "init": null,
                        "name": "notifyEveryNReports",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out] streamer sampling period in nanoseconds. If the requested value is not supported exactly, then the driver may use a value that is the closest supported approximation and shall update this member during $tMetricStreamerOpen.\n",
                        "init": null,
                        "name": "samplingPeriod",
                        "type": "uint32_t"
                    }
                ]
            },
            "$t_profile_free_register_token_t": {
                "class": "$tKernel",
                "members": [
                    {
                        "desc": "[out] type of token",
                        "init": null,
                        "name": "type",
                        "type": "$t_profile_token_type_t"
                    },
                    {
                        "desc": "[out] total size of the token, in bytes",
                        "init": null,
                        "name": "size",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] number of register sequences immediately following this structure",
                        "init": null,
                        "name": "count",
                        "type": "uint32_t"
                    }
                ]
            },
            "$t_profile_properties_t": {
                "class": "$tKernel",
                "members": [
                    {
                        "desc": "[out] indicates which flags were enabled during compilation.\nreturns 0 (none) or a combination of $t_profile_flag_t\n",
                        "init": null,
                        "name": "flags",
                        "type": "$t_profile_flags_t"
                    },
                    {
                        "desc": "[out] number of tokens immediately following this structure",
                        "init": null,
                        "name": "numTokens",
                        "type": "uint32_t"
                    }
                ]
            },
            "$t_profile_register_sequence_t": {
                "class": "$tKernel",
                "members": [
                    {
                        "desc": "[out] starting byte in the register table, representing the start of unused bytes in the current function",
                        "init": null,
                        "name": "start",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] number of consecutive bytes in the sequence, starting from start",
                        "init": null,
                        "name": "count",
                        "type": "uint32_t"
                    }
                ]
            },
            "$t_tracer_exp_desc_t": {
                "class": "$tTracerExp",
                "members": [
                    {
                        "desc": "[in] pointer passed to every tracer's callbacks",
                        "init": null,
                        "name": "pUserData",
                        "type": "void*"
                    }
                ]
            },
            "$t_typed_value_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[out] type of value",
                        "init": null,
                        "name": "type",
                        "type": "$t_value_type_t"
                    },
                    {
                        "desc": "[out] value",
                        "init": null,
                        "name": "value",
                        "type": "$t_value_t"
                    }
                ]
            },
            "$x_base_cb_params_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": null,
                        "name": "stype",
                        "type": "$x_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    }
                ]
            },
            "$x_base_desc_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": null,
                        "name": "stype",
                        "type": "$x_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    }
                ]
            },
            "$x_base_properties_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": null,
                        "name": "stype",
                        "type": "$x_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    }
                ]
            },
            "$x_cache_reservation_ext_desc_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] max cache reservation size",
                        "init": null,
                        "name": "maxCacheReservationSize",
                        "type": "size_t"
                    }
                ]
            },
            "$x_command_list_desc_t": {
                "class": "$xCommandList",
                "members": [
                    {
                        "desc": "[in] command queue group ordinal to which this command list will be submitted",
                        "init": null,
                        "name": "commandQueueGroupOrdinal",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] usage flags.\nmust be 0 (default) or a valid combination of $x_command_list_flag_t;\ndefault behavior may use implicit driver-based heuristics to balance latency and throughput.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_command_list_flags_t"
                    }
                ]
            },
            "$x_command_queue_desc_t": {
                "class": "$xCommandQueue",
                "members": [
                    {
                        "desc": "[in] command queue group ordinal",
                        "init": null,
                        "name": "ordinal",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] command queue index within the group;\nmust be zero if $X_COMMAND_QUEUE_FLAG_EXPLICIT_ONLY is not set\n",
                        "init": null,
                        "name": "index",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] usage flags.\nmust be 0 (default) or a valid combination of $x_command_queue_flag_t;\ndefault behavior may use implicit driver-based heuristics to balance latency and throughput.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_command_queue_flags_t"
                    },
                    {
                        "desc": "[in] operation mode",
                        "init": "$X_COMMAND_QUEUE_MODE_DEFAULT",
                        "name": "mode",
                        "type": "$x_command_queue_mode_t"
                    },
                    {
                        "desc": "[in] priority",
                        "init": "$X_COMMAND_QUEUE_PRIORITY_NORMAL",
                        "name": "priority",
                        "type": "$x_command_queue_priority_t"
                    }
                ]
            },
            "$x_command_queue_group_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] 0 (none) or a valid combination of $x_command_queue_group_property_flag_t",
                        "init": null,
                        "name": "flags",
                        "type": "$x_command_queue_group_property_flags_t"
                    },
                    {
                        "desc": "[out] maximum `pattern_size` supported by command queue group.\nSee $xCommandListAppendMemoryFill for more details.\n",
                        "init": null,
                        "name": "maxMemoryFillPatternSize",
                        "type": "size_t"
                    },
                    {
                        "desc": "[out] the number of physical engines within the group.",
                        "init": null,
                        "name": "numQueues",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_context_desc_t": {
                "class": "$xContext",
                "members": [
                    {
                        "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of $x_context_flag_t;\ndefault behavior may use implicit driver-based heuristics.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_context_flags_t"
                    }
                ]
            },
            "$x_context_power_saving_hint_exp_desc_t": {
                "class": "$xContext",
                "members": [
                    {
                        "desc": "[in] power saving hint (default value = 0). This is value from [0,100] and can use pre-defined settings from $x_power_saving_hint_type_t.\n",
                        "init": "0",
                        "name": "hint",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_copy_bandwidth_exp_properties_t": {
                "class": "$xCommandQueue",
                "members": [
                    {
                        "desc": "[out] design bandwidth supported by this engine type for copy operations",
                        "init": null,
                        "name": "copyBandwidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] copy bandwidth unit",
                        "init": null,
                        "name": "copyBandwidthUnit",
                        "type": "$x_bandwidth_unit_t"
                    }
                ]
            },
            "$x_copy_region_t": {
                "class": "$xCommandList",
                "members": [
                    {
                        "desc": "[in] The origin x offset for region in bytes",
                        "init": null,
                        "name": "originX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The origin y offset for region in rows",
                        "init": null,
                        "name": "originY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The origin z offset for region in slices",
                        "init": null,
                        "name": "originZ",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The region width relative to origin in bytes",
                        "init": null,
                        "name": "width",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The region height relative to origin in rows",
                        "init": null,
                        "name": "height",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The region depth relative to origin in slices. Set this to 0 for 2D copy.",
                        "init": null,
                        "name": "depth",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_device_cache_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] 0 (none) or a valid combination of $x_device_cache_property_flag_t",
                        "init": null,
                        "name": "flags",
                        "type": "$x_device_cache_property_flags_t"
                    },
                    {
                        "desc": "[out] Per-cache size, in bytes",
                        "init": null,
                        "name": "cacheSize",
                        "type": "size_t"
                    }
                ]
            },
            "$x_device_compute_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] Maximum items per compute group. (groupSizeX * groupSizeY * groupSizeZ) <= maxTotalGroupSize",
                        "init": null,
                        "name": "maxTotalGroupSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum items for X dimension in group",
                        "init": null,
                        "name": "maxGroupSizeX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum items for Y dimension in group",
                        "init": null,
                        "name": "maxGroupSizeY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum items for Z dimension in group",
                        "init": null,
                        "name": "maxGroupSizeZ",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum groups that can be launched for x dimension",
                        "init": null,
                        "name": "maxGroupCountX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum groups that can be launched for y dimension",
                        "init": null,
                        "name": "maxGroupCountY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum groups that can be launched for z dimension",
                        "init": null,
                        "name": "maxGroupCountZ",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum shared local memory per group.",
                        "init": null,
                        "name": "maxSharedLocalMemory",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Number of subgroup sizes supported. This indicates number of entries in subGroupSizes.",
                        "init": null,
                        "name": "numSubGroupSizes",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Size group sizes supported.",
                        "init": null,
                        "name": "subGroupSizes[$X_SUBGROUPSIZE_COUNT]",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_device_external_memory_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] Supported external memory import types for memory allocations.",
                        "init": null,
                        "name": "memoryAllocationImportTypes",
                        "type": "$x_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[out] Supported external memory export types for memory allocations.",
                        "init": null,
                        "name": "memoryAllocationExportTypes",
                        "type": "$x_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[out] Supported external memory import types for images.",
                        "init": null,
                        "name": "imageImportTypes",
                        "type": "$x_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[out] Supported external memory export types for images.",
                        "init": null,
                        "name": "imageExportTypes",
                        "type": "$x_external_memory_type_flags_t"
                    }
                ]
            },
            "$x_device_image_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] Maximum image dimensions for 1D resources. if 0, then 1D images are unsupported.",
                        "init": null,
                        "name": "maxImageDims1D",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum image dimensions for 2D resources. if 0, then 2D images are unsupported.",
                        "init": null,
                        "name": "maxImageDims2D",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum image dimensions for 3D resources. if 0, then 3D images are unsupported.",
                        "init": null,
                        "name": "maxImageDims3D",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum image buffer size in bytes. if 0, then buffer images are unsupported.",
                        "init": null,
                        "name": "maxImageBufferSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Maximum image array slices. if 0, then image arrays are unsupported.",
                        "init": null,
                        "name": "maxImageArraySlices",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Max samplers that can be used in kernel. if 0, then sampling is unsupported.",
                        "init": null,
                        "name": "maxSamplers",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Returns the maximum number of simultaneous image objects that can be read from by a kernel. if 0, then reading images is unsupported.",
                        "init": null,
                        "name": "maxReadImageArgs",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Returns the maximum number of simultaneous image objects that can be written to by a kernel. if 0, then writing images is unsupported.",
                        "init": null,
                        "name": "maxWriteImageArgs",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_device_ip_version_ext_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] Device IP version. The meaning of the device IP version is\nimplementation-defined, but newer devices should have a higher\nversion than older devices.\n",
                        "init": null,
                        "name": "ipVersion",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_device_luid_ext_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] locally unique identifier (LUID).\nThe returned LUID can be cast to a LUID object and must be equal to the locally\nunique identifier of an IDXGIAdapter1 object that corresponds to the device.\n",
                        "init": null,
                        "name": "luid",
                        "type": "$x_device_luid_ext_t"
                    },
                    {
                        "desc": "[out] node mask.\nThe returned node mask must contain exactly one bit.\nIf the device is running on an operating system that supports the Direct3D 12 API\nand the device corresponds to an individual device in a linked device adapter, the\nreturned node mask identifies the Direct3D 12 node corresponding to the device.\nOtherwise, the returned node mask must be 1.\n",
                        "init": null,
                        "name": "nodeMask",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_device_luid_ext_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[out] opaque data representing a device LUID",
                        "init": null,
                        "name": "id[$X_MAX_DEVICE_LUID_SIZE_EXT]",
                        "type": "uint8_t"
                    }
                ]
            },
            "$x_device_mem_alloc_desc_t": {
                "class": "$xMem",
                "members": [
                    {
                        "desc": "[in] flags specifying additional allocation controls.\nmust be 0 (default) or a valid combination of $x_device_mem_alloc_flag_t;\ndefault behavior may use implicit driver-based heuristics.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_device_mem_alloc_flags_t"
                    },
                    {
                        "desc": "[in] ordinal of the device's local memory to allocate from.\nmust be less than the count returned from $xDeviceGetMemoryProperties.\n",
                        "init": "0",
                        "name": "ordinal",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_device_memory_access_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] host memory capabilities.\nreturns 0 (unsupported) or a combination of $x_memory_access_cap_flag_t.\n",
                        "init": null,
                        "name": "hostAllocCapabilities",
                        "type": "$x_memory_access_cap_flags_t"
                    },
                    {
                        "desc": "[out] device memory capabilities.\nreturns 0 (unsupported) or a combination of $x_memory_access_cap_flag_t.\n",
                        "init": null,
                        "name": "deviceAllocCapabilities",
                        "type": "$x_memory_access_cap_flags_t"
                    },
                    {
                        "desc": "[out] shared, single-device memory capabilities.\nreturns 0 (unsupported) or a combination of $x_memory_access_cap_flag_t.\n",
                        "init": null,
                        "name": "sharedSingleDeviceAllocCapabilities",
                        "type": "$x_memory_access_cap_flags_t"
                    },
                    {
                        "desc": "[out] shared, cross-device memory capabilities.\nreturns 0 (unsupported) or a combination of $x_memory_access_cap_flag_t.\n",
                        "init": null,
                        "name": "sharedCrossDeviceAllocCapabilities",
                        "type": "$x_memory_access_cap_flags_t"
                    },
                    {
                        "desc": "[out] shared, system memory capabilities.\nreturns 0 (unsupported) or a combination of $x_memory_access_cap_flag_t.\n",
                        "init": null,
                        "name": "sharedSystemAllocCapabilities",
                        "type": "$x_memory_access_cap_flags_t"
                    }
                ]
            },
            "$x_device_memory_ext_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] The memory type",
                        "init": null,
                        "name": "type",
                        "type": "$x_device_memory_ext_type_t"
                    },
                    {
                        "desc": "[out] Physical memory size in bytes. A value of 0 indicates that this property is not known. However, a call to $sMemoryGetState() will correctly return the total size of usable memory.",
                        "init": null,
                        "name": "physicalSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Design bandwidth for reads",
                        "init": null,
                        "name": "readBandwidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Design bandwidth for writes",
                        "init": null,
                        "name": "writeBandwidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] bandwidth unit",
                        "init": null,
                        "name": "bandwidthUnit",
                        "type": "$x_bandwidth_unit_t"
                    }
                ]
            },
            "$x_device_memory_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] 0 (none) or a valid combination of $x_device_memory_property_flag_t",
                        "init": null,
                        "name": "flags",
                        "type": "$x_device_memory_property_flags_t"
                    },
                    {
                        "desc": "[out] Maximum clock rate for device memory.",
                        "init": null,
                        "name": "maxClockRate",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum bus width between device and memory.",
                        "init": null,
                        "name": "maxBusWidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Total memory size in bytes that is available to the device.",
                        "init": null,
                        "name": "totalSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Memory name",
                        "init": null,
                        "name": "name[$X_MAX_DEVICE_NAME]",
                        "type": "char"
                    }
                ]
            },
            "$x_device_module_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] Maximum supported SPIR-V version.\nReturns zero if SPIR-V is not supported.\nContains major and minor attributes, use $X_MAJOR_VERSION and $X_MINOR_VERSION.\n",
                        "init": null,
                        "name": "spirvVersionSupported",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] 0 or a valid combination of $x_device_module_flag_t",
                        "init": null,
                        "name": "flags",
                        "type": "$x_device_module_flags_t"
                    },
                    {
                        "desc": "[out] Capabilities for half-precision floating-point operations.\nreturns 0 (if $X_DEVICE_MODULE_FLAG_FP16 is not set) or a combination of $x_device_fp_flag_t.\n",
                        "init": null,
                        "name": "fp16flags",
                        "type": "$x_device_fp_flags_t"
                    },
                    {
                        "desc": "[out] Capabilities for single-precision floating-point operations.\nreturns a combination of $x_device_fp_flag_t.\n",
                        "init": null,
                        "name": "fp32flags",
                        "type": "$x_device_fp_flags_t"
                    },
                    {
                        "desc": "[out] Capabilities for double-precision floating-point operations.\nreturns 0 (if $X_DEVICE_MODULE_FLAG_FP64 is not set) or a combination of $x_device_fp_flag_t.\n",
                        "init": null,
                        "name": "fp64flags",
                        "type": "$x_device_fp_flags_t"
                    },
                    {
                        "desc": "[out] Maximum kernel argument size that is supported.",
                        "init": null,
                        "name": "maxArgumentsSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum size of internal buffer that holds output of printf calls from kernel.",
                        "init": null,
                        "name": "printfBufferSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Compatibility UUID of supported native kernel.\nUUID may or may not be the same across driver release, devices, or operating systems.\nApplication is responsible for ensuring UUID matches before creating module using\npreviously created native kernel.\n",
                        "init": null,
                        "name": "nativeKernelSupported",
                        "type": "$x_native_kernel_uuid_t"
                    }
                ]
            },
            "$x_device_p2p_bandwidth_exp_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] total logical design bandwidth for all links connecting the two devices",
                        "init": null,
                        "name": "logicalBandwidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] total physical design bandwidth for all links connecting the two devices",
                        "init": null,
                        "name": "physicalBandwidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] bandwidth unit",
                        "init": null,
                        "name": "bandwidthUnit",
                        "type": "$x_bandwidth_unit_t"
                    },
                    {
                        "desc": "[out] average logical design latency for all links connecting the two devices",
                        "init": null,
                        "name": "logicalLatency",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] average physical design latency for all links connecting the two devices",
                        "init": null,
                        "name": "physicalLatency",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] latency unit",
                        "init": null,
                        "name": "latencyUnit",
                        "type": "$x_latency_unit_t"
                    }
                ]
            },
            "$x_device_p2p_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] 0 (none) or a valid combination of $x_device_p2p_property_flag_t",
                        "init": null,
                        "name": "flags",
                        "type": "$x_device_p2p_property_flags_t"
                    }
                ]
            },
            "$x_device_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] generic device type",
                        "init": null,
                        "name": "type",
                        "type": "$x_device_type_t"
                    },
                    {
                        "desc": "[out] vendor id from PCI configuration",
                        "init": null,
                        "name": "vendorId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] device id from PCI configuration\nNote, the device id uses little-endian format.\n",
                        "init": null,
                        "name": "deviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] 0 (none) or a valid combination of $x_device_property_flag_t",
                        "init": null,
                        "name": "flags",
                        "type": "$x_device_property_flags_t"
                    },
                    {
                        "desc": "[out] sub-device id. Only valid if $X_DEVICE_PROPERTY_FLAG_SUBDEVICE is set.",
                        "init": null,
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Clock rate for device core.",
                        "init": null,
                        "name": "coreClockRate",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum memory allocation size.",
                        "init": null,
                        "name": "maxMemAllocSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Maximum number of logical hardware contexts.",
                        "init": null,
                        "name": "maxHardwareContexts",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum priority for command queues. Higher value is higher priority.",
                        "init": null,
                        "name": "maxCommandQueuePriority",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum number of threads per EU.",
                        "init": null,
                        "name": "numThreadsPerEU",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] The physical EU simd width.",
                        "init": null,
                        "name": "physicalEUSimdWidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum number of EUs per sub-slice.",
                        "init": null,
                        "name": "numEUsPerSubslice",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum number of sub-slices per slice.",
                        "init": null,
                        "name": "numSubslicesPerSlice",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum number of slices.",
                        "init": null,
                        "name": "numSlices",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Returns the resolution of device timer used for profiling, timestamps, etc. When stype==$X_STRUCTURE_TYPE_DEVICE_PROPERTIES the units are in nanoseconds. When stype==$X_STRUCTURE_TYPE_DEVICE_PROPERTIES_1_2 units are in cycles/sec",
                        "init": null,
                        "name": "timerResolution",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Returns the number of valid bits in the timestamp value.",
                        "init": null,
                        "name": "timestampValidBits",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Returns the number of valid bits in the kernel timestamp values",
                        "init": null,
                        "name": "kernelTimestampValidBits",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] universal unique identifier. Note: Subdevices will have their own uuid.",
                        "init": null,
                        "name": "uuid",
                        "type": "$x_device_uuid_t"
                    },
                    {
                        "desc": "[out] Device name",
                        "init": null,
                        "name": "name[$X_MAX_DEVICE_NAME]",
                        "type": "char"
                    }
                ]
            },
            "$x_device_raytracing_ext_properties_t": {
                "class": "$xContext",
                "members": [
                    {
                        "desc": "[out] 0 or a valid combination of $x_device_raytracing_ext_flags_t",
                        "init": null,
                        "name": "flags",
                        "type": "$x_device_raytracing_ext_flags_t"
                    },
                    {
                        "desc": "[out] Maximum number of BVH levels supported",
                        "init": null,
                        "name": "maxBVHLevels",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_device_thread_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[in,out] the slice number.\nMust be `UINT32_MAX` (all) or less than the `numSlices` member of $x_device_properties_t.\n",
                        "init": null,
                        "name": "slice",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out] the sub-slice number within its slice.\nMust be `UINT32_MAX` (all) or less than the `numSubslicesPerSlice` member of $x_device_properties_t.\n",
                        "init": null,
                        "name": "subslice",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out] the EU number within its sub-slice.\nMust be `UINT32_MAX` (all) or less than the `numEUsPerSubslice` member of $x_device_properties_t.\n",
                        "init": null,
                        "name": "eu",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out] the thread number within its EU.\nMust be `UINT32_MAX` (all) or less than the `numThreadsPerEU` member of $x_device_properties_t.\n",
                        "init": null,
                        "name": "thread",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_device_uuid_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[out] opaque data representing a device UUID",
                        "init": null,
                        "name": "id[$X_MAX_DEVICE_UUID_SIZE]",
                        "type": "uint8_t"
                    }
                ]
            },
            "$x_driver_extension_properties_t": {
                "class": "$xDriver",
                "members": [
                    {
                        "desc": "[out] extension name",
                        "init": null,
                        "name": "name[$X_MAX_EXTENSION_NAME]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] extension version using $X_MAKE_VERSION",
                        "init": null,
                        "name": "version",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_driver_ipc_properties_t": {
                "class": "$xDriver",
                "members": [
                    {
                        "desc": "[out] 0 (none) or a valid combination of $x_ipc_property_flag_t",
                        "init": null,
                        "name": "flags",
                        "type": "$x_ipc_property_flags_t"
                    }
                ]
            },
            "$x_driver_memory_free_ext_properties_t": {
                "class": "$xDriver",
                "members": [
                    {
                        "desc": "[out] Supported memory free policies.\nmust be 0 or a combination of $x_driver_memory_free_policy_ext_flag_t.\n",
                        "init": null,
                        "name": "freePolicies",
                        "type": "$x_driver_memory_free_policy_ext_flags_t"
                    }
                ]
            },
            "$x_driver_properties_t": {
                "class": "$xDriver",
                "members": [
                    {
                        "desc": "[out] universal unique identifier.",
                        "init": null,
                        "name": "uuid",
                        "type": "$x_driver_uuid_t"
                    },
                    {
                        "desc": "[out] driver version\nThe driver version is a non-zero, monotonically increasing value where higher values always indicate a more recent version.\n",
                        "init": null,
                        "name": "driverVersion",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_driver_uuid_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[out] opaque data representing a driver UUID",
                        "init": null,
                        "name": "id[$X_MAX_DRIVER_UUID_SIZE]",
                        "type": "uint8_t"
                    }
                ]
            },
            "$x_eu_count_ext_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] Total number of EUs available",
                        "init": null,
                        "name": "numTotalEUs",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_event_desc_t": {
                "class": "$xEvent",
                "members": [
                    {
                        "desc": "[in] index of the event within the pool; must be less than the count specified during pool creation",
                        "init": null,
                        "name": "index",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] defines the scope of relevant cache hierarchies to flush on a signal action before the event is triggered.\nmust be 0 (default) or a valid combination of $x_event_scope_flag_t;\ndefault behavior is synchronization within the command list only, no additional cache hierarchies are flushed.\n",
                        "init": "0",
                        "name": "signal",
                        "type": "$x_event_scope_flags_t"
                    },
                    {
                        "desc": "[in] defines the scope of relevant cache hierarchies to invalidate on a wait action after the event is complete.\nmust be 0 (default) or a valid combination of $x_event_scope_flag_t;\ndefault behavior is synchronization within the command list only, no additional cache hierarchies are invalidated.\n",
                        "init": "0",
                        "name": "wait",
                        "type": "$x_event_scope_flags_t"
                    }
                ]
            },
            "$x_event_pool_desc_t": {
                "class": "$xEventPool",
                "members": [
                    {
                        "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of $x_event_pool_flag_t;\ndefault behavior is signals and waits are visible to the entire device and peer devices.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_event_pool_flags_t"
                    },
                    {
                        "desc": "[in] number of events within the pool; must be greater than 0",
                        "init": null,
                        "name": "count",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_event_query_kernel_timestamps_ext_properties_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[out] 0 or some combination of $x_event_query_kernel_timestamps_ext_flag_t flags",
                        "init": null,
                        "name": "flags",
                        "type": "$x_event_query_kernel_timestamps_ext_flags_t"
                    }
                ]
            },
            "$x_event_query_kernel_timestamps_results_ext_properties_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] pointer to destination buffer of kernel timestamp results",
                        "init": "nullptr",
                        "name": "pKernelTimestampsBuffer",
                        "type": "$x_kernel_timestamp_result_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] pointer to destination buffer of synchronized timestamp results",
                        "init": "nullptr",
                        "name": "pSynchronizedTimestampsBuffer",
                        "type": "$x_synchronized_timestamp_result_ext_t*"
                    }
                ]
            },
            "$x_external_memory_export_desc_t": {
                "class": "$xMem",
                "members": [
                    {
                        "desc": "[in] flags specifying memory export types for this allocation.\nmust be 0 (default) or a valid combination of $x_external_memory_type_flags_t\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_external_memory_type_flags_t"
                    }
                ]
            },
            "$x_external_memory_export_fd_t": {
                "class": "$xMem",
                "members": [
                    {
                        "desc": "[in] flags specifying the memory export type for the file descriptor.\nmust be 0 (default) or a valid combination of $x_external_memory_type_flags_t\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[out] the exported file descriptor handle representing the allocation.",
                        "init": null,
                        "name": "fd",
                        "type": "int"
                    }
                ]
            },
            "$x_external_memory_export_win32_handle_t": {
                "class": "$xMem",
                "members": [
                    {
                        "desc": "[in] flags specifying the memory export type for the Win32 handle.\nmust be 0 (default) or a valid combination of $x_external_memory_type_flags_t\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[out] the exported Win32 handle representing the allocation.",
                        "init": null,
                        "name": "handle",
                        "type": "void*"
                    }
                ]
            },
            "$x_external_memory_import_fd_t": {
                "class": "$xMem",
                "members": [
                    {
                        "desc": "[in] flags specifying the memory import type for the file descriptor.\nmust be 0 (default) or a valid combination of $x_external_memory_type_flags_t\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[in] the file descriptor handle to import",
                        "init": null,
                        "name": "fd",
                        "type": "int"
                    }
                ]
            },
            "$x_external_memory_import_win32_handle_t": {
                "class": "$xMem",
                "members": [
                    {
                        "desc": "[in] flags specifying the memory import type for the Win32 handle.\nmust be 0 (default) or a valid combination of $x_external_memory_type_flags_t\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[in][optional] the Win32 handle to import",
                        "init": null,
                        "name": "handle",
                        "type": "void*"
                    },
                    {
                        "desc": "[in][optional] name of a memory object to import",
                        "init": null,
                        "name": "name",
                        "type": "const void*"
                    }
                ]
            },
            "$x_fabric_edge_exp_properties_t": {
                "class": "$xFabricEdge",
                "members": [
                    {
                        "desc": "[out] universal unique identifier.",
                        "init": null,
                        "name": "uuid",
                        "type": "$x_uuid_t"
                    },
                    {
                        "desc": "[out] Description of fabric edge technology. Will be set to the string \"unkown\" if this cannot be determined for this edge",
                        "init": null,
                        "name": "model[$X_MAX_FABRIC_EDGE_MODEL_EXP_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] design bandwidth",
                        "init": null,
                        "name": "bandwidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] bandwidth unit",
                        "init": null,
                        "name": "bandwidthUnit",
                        "type": "$x_bandwidth_unit_t"
                    },
                    {
                        "desc": "[out] design latency",
                        "init": null,
                        "name": "latency",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] latency unit",
                        "init": null,
                        "name": "latencyUnit",
                        "type": "$x_latency_unit_t"
                    },
                    {
                        "desc": "[out] Duplexity of the fabric edge",
                        "init": null,
                        "name": "duplexity",
                        "type": "$x_fabric_edge_exp_duplexity_t"
                    }
                ]
            },
            "$x_fabric_vertex_exp_properties_t": {
                "class": "$xFabricVertex",
                "members": [
                    {
                        "desc": "[out] universal unique identifier. If the vertex is co-located with a device/subdevice, then this uuid will match that of the corresponding device/subdevice",
                        "init": null,
                        "name": "uuid",
                        "type": "$x_uuid_t"
                    },
                    {
                        "desc": "[out] does the fabric vertex represent a device, subdevice, or switch?",
                        "init": null,
                        "name": "type",
                        "type": "$x_fabric_vertex_exp_type_t"
                    },
                    {
                        "desc": "[out] does the fabric vertex live on the local node or on a remote node?",
                        "init": null,
                        "name": "remote",
                        "type": "$x_bool_t"
                    },
                    {
                        "desc": "[out] B/D/F address of fabric vertex & associated device/subdevice if available",
                        "init": null,
                        "name": "address",
                        "type": "$x_fabric_vertex_pci_exp_address_t"
                    }
                ]
            },
            "$x_fabric_vertex_pci_exp_address_t": {
                "class": "$xFabricVertex",
                "members": [
                    {
                        "desc": "[out] PCI domain number",
                        "init": null,
                        "name": "domain",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] PCI BDF bus number",
                        "init": null,
                        "name": "bus",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] PCI BDF device number",
                        "init": null,
                        "name": "device",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] PCI BDF function number",
                        "init": null,
                        "name": "function",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_fence_desc_t": {
                "class": "$xFence",
                "members": [
                    {
                        "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of $x_fence_flag_t.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_fence_flags_t"
                    }
                ]
            },
            "$x_float_atomic_ext_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] Capabilities for half-precision floating-point atomic operations",
                        "init": null,
                        "name": "fp16Flags",
                        "type": "$x_device_fp_atomic_ext_flags_t"
                    },
                    {
                        "desc": "[out] Capabilities for single-precision floating-point atomic operations",
                        "init": null,
                        "name": "fp32Flags",
                        "type": "$x_device_fp_atomic_ext_flags_t"
                    },
                    {
                        "desc": "[out] Capabilities for double-precision floating-point atomic operations",
                        "init": null,
                        "name": "fp64Flags",
                        "type": "$x_device_fp_atomic_ext_flags_t"
                    }
                ]
            },
            "$x_group_count_t": {
                "class": "$xCommandList",
                "members": [
                    {
                        "desc": "[in] number of thread groups in X dimension",
                        "init": "0",
                        "name": "groupCountX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] number of thread groups in Y dimension",
                        "init": "0",
                        "name": "groupCountY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] number of thread groups in Z dimension",
                        "init": "0",
                        "name": "groupCountZ",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_host_mem_alloc_desc_t": {
                "class": "$xMem",
                "members": [
                    {
                        "desc": "[in] flags specifying additional allocation controls.\nmust be 0 (default) or a valid combination of $x_host_mem_alloc_flag_t;\ndefault behavior may use implicit driver-based heuristics.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_host_mem_alloc_flags_t"
                    }
                ]
            },
            "$x_image_allocation_ext_properties_t": {
                "class": "$xImage",
                "members": [
                    {
                        "desc": "[out] identifier for this allocation",
                        "init": null,
                        "name": "id",
                        "type": "uint64_t"
                    }
                ]
            },
            "$x_image_desc_t": {
                "class": "$xImage",
                "members": [
                    {
                        "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of $x_image_flag_t;\ndefault is read-only, cached access.\n",
                        "init": null,
                        "name": "flags",
                        "type": "$x_image_flags_t"
                    },
                    {
                        "desc": "[in] image type. Media format layouts are unsupported for $X_IMAGE_TYPE_BUFFER",
                        "init": null,
                        "name": "type",
                        "type": "$x_image_type_t"
                    },
                    {
                        "desc": "[in] image format",
                        "init": null,
                        "name": "format",
                        "type": "$x_image_format_t"
                    },
                    {
                        "desc": "[in] width dimension.\n$X_IMAGE_TYPE_BUFFER: size in bytes; see the `maxImageBufferSize` member of $x_device_image_properties_t for limits.\n$X_IMAGE_TYPE_1D, $X_IMAGE_TYPE_1DARRAY: width in pixels; see the `maxImageDims1D` member of $x_device_image_properties_t for limits.\n$X_IMAGE_TYPE_2D, $X_IMAGE_TYPE_2DARRAY: width in pixels; see the `maxImageDims2D` member of $x_device_image_properties_t for limits.\n$X_IMAGE_TYPE_3D: width in pixels; see the `maxImageDims3D` member of $x_device_image_properties_t for limits.\n",
                        "init": "0",
                        "name": "width",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[in] height dimension.\n$X_IMAGE_TYPE_2D, $X_IMAGE_TYPE_2DARRAY: height in pixels; see the `maxImageDims2D` member of $x_device_image_properties_t for limits.\n$X_IMAGE_TYPE_3D: height in pixels; see the `maxImageDims3D` member of $x_device_image_properties_t for limits.\nother: ignored.\n",
                        "init": "0",
                        "name": "height",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] depth dimension.\n$X_IMAGE_TYPE_3D: depth in pixels; see the `maxImageDims3D` member of $x_device_image_properties_t for limits.\nother: ignored.\n",
                        "init": "0",
                        "name": "depth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] array levels.\n$X_IMAGE_TYPE_1DARRAY, $X_IMAGE_TYPE_2DARRAY: see the `maxImageArraySlices` member of $x_device_image_properties_t for limits.\nother: ignored.\n",
                        "init": "1",
                        "name": "arraylevels",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] mipmap levels (must be 0)",
                        "init": "0",
                        "name": "miplevels",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_image_format_t": {
                "class": "$xImage",
                "members": [
                    {
                        "desc": "[in] image format component layout (e.g. N-component layouts and media formats)",
                        "init": null,
                        "name": "layout",
                        "type": "$x_image_format_layout_t"
                    },
                    {
                        "desc": "[in] image format type",
                        "init": null,
                        "name": "type",
                        "type": "$x_image_format_type_t"
                    },
                    {
                        "desc": "[in] image component swizzle into channel x",
                        "init": null,
                        "name": "x",
                        "type": "$x_image_format_swizzle_t"
                    },
                    {
                        "desc": "[in] image component swizzle into channel y",
                        "init": null,
                        "name": "y",
                        "type": "$x_image_format_swizzle_t"
                    },
                    {
                        "desc": "[in] image component swizzle into channel z",
                        "init": null,
                        "name": "z",
                        "type": "$x_image_format_swizzle_t"
                    },
                    {
                        "desc": "[in] image component swizzle into channel w",
                        "init": null,
                        "name": "w",
                        "type": "$x_image_format_swizzle_t"
                    }
                ]
            },
            "$x_image_memory_properties_exp_t": {
                "class": "$xImage",
                "members": [
                    {
                        "desc": "[out] size of image allocation in bytes.",
                        "init": null,
                        "name": "size",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] size of image row in bytes.",
                        "init": null,
                        "name": "rowPitch",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] size of image slice in bytes.",
                        "init": null,
                        "name": "slicePitch",
                        "type": "uint64_t"
                    }
                ]
            },
            "$x_image_properties_t": {
                "class": "$xImage",
                "members": [
                    {
                        "desc": "[out] supported sampler filtering.\nreturns 0 (unsupported) or a combination of $x_image_sampler_filter_flag_t.\n",
                        "init": null,
                        "name": "samplerFilterFlags",
                        "type": "$x_image_sampler_filter_flags_t"
                    }
                ]
            },
            "$x_image_region_t": {
                "class": "$xCommandList",
                "members": [
                    {
                        "desc": "[in] The origin x offset for region in pixels",
                        "init": null,
                        "name": "originX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The origin y offset for region in pixels",
                        "init": null,
                        "name": "originY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The origin z offset for region in pixels",
                        "init": null,
                        "name": "originZ",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The region width relative to origin in pixels",
                        "init": null,
                        "name": "width",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The region height relative to origin in pixels",
                        "init": null,
                        "name": "height",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The region depth relative to origin. For 1D or 2D images, set this to 1.",
                        "init": null,
                        "name": "depth",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_image_view_planar_exp_desc_t": {
                "class": "$xImage",
                "members": [
                    {
                        "desc": "[in] the 0-based plane index (e.g. NV12 is 0 = Y plane, 1 UV plane)",
                        "init": null,
                        "name": "planeIndex",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_image_view_planar_ext_desc_t": {
                "class": "$xImage",
                "members": [
                    {
                        "desc": "[in] the 0-based plane index (e.g. NV12 is 0 = Y plane, 1 UV plane)",
                        "init": null,
                        "name": "planeIndex",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_ipc_event_pool_handle_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[out] Opaque data representing an IPC handle",
                        "init": null,
                        "name": "data[$X_MAX_IPC_HANDLE_SIZE]",
                        "type": "char"
                    }
                ]
            },
            "$x_ipc_mem_handle_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[out] Opaque data representing an IPC handle",
                        "init": null,
                        "name": "data[$X_MAX_IPC_HANDLE_SIZE]",
                        "type": "char"
                    }
                ]
            },
            "$x_kernel_desc_t": {
                "class": "$xKernel",
                "members": [
                    {
                        "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of $x_kernel_flag_t;\ndefault behavior may use driver-based residency.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_kernel_flags_t"
                    },
                    {
                        "desc": "[in] null-terminated name of kernel in module",
                        "init": "nullptr",
                        "name": "pKernelName",
                        "type": "const char*"
                    }
                ]
            },
            "$x_kernel_max_group_size_properties_ext_t": {
                "class": "$xKernel",
                "members": [
                    {
                        "desc": "[out] maximum group size that can be used to execute the kernel. This value may be less than or equal to the `maxTotalGroupSize` member of $x_device_compute_properties_t.",
                        "init": null,
                        "name": "maxGroupSize",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_kernel_preferred_group_size_properties_t": {
                "class": "$xKernel",
                "members": [
                    {
                        "desc": "[out] preferred group size multiple",
                        "init": null,
                        "name": "preferredMultiple",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_kernel_properties_t": {
                "class": "$xKernel",
                "members": [
                    {
                        "desc": "[out] number of kernel arguments.",
                        "init": null,
                        "name": "numKernelArgs",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] required group size in the X dimension,\nor zero if there is no required group size\n",
                        "init": null,
                        "name": "requiredGroupSizeX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] required group size in the Y dimension,\nor zero if there is no required group size\n",
                        "init": null,
                        "name": "requiredGroupSizeY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] required group size in the Z dimension,\nor zero if there is no required group size\n",
                        "init": null,
                        "name": "requiredGroupSizeZ",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] required number of subgroups per thread group,\nor zero if there is no required number of subgroups\n",
                        "init": null,
                        "name": "requiredNumSubGroups",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] required subgroup size,\nor zero if there is no required subgroup size\n",
                        "init": null,
                        "name": "requiredSubgroupSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] maximum subgroup size",
                        "init": null,
                        "name": "maxSubgroupSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] maximum number of subgroups per thread group",
                        "init": null,
                        "name": "maxNumSubgroups",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] local memory size used by each thread group",
                        "init": null,
                        "name": "localMemSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] private memory size allocated by compiler used by each thread",
                        "init": null,
                        "name": "privateMemSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] spill memory size allocated by compiler",
                        "init": null,
                        "name": "spillMemSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] universal unique identifier.",
                        "init": null,
                        "name": "uuid",
                        "type": "$x_kernel_uuid_t"
                    }
                ]
            },
            "$x_kernel_timestamp_data_t": {
                "class": "$xEvent",
                "members": [
                    {
                        "desc": "[out] device clock at start of kernel execution",
                        "init": null,
                        "name": "kernelStart",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] device clock at end of kernel execution",
                        "init": null,
                        "name": "kernelEnd",
                        "type": "uint64_t"
                    }
                ]
            },
            "$x_kernel_timestamp_result_t": {
                "class": "$xEvent",
                "members": [
                    {
                        "desc": "[out] wall-clock data",
                        "init": null,
                        "name": "global",
                        "type": "$x_kernel_timestamp_data_t"
                    },
                    {
                        "desc": "[out] context-active data; only includes clocks while device context was actively executing.",
                        "init": null,
                        "name": "context",
                        "type": "$x_kernel_timestamp_data_t"
                    }
                ]
            },
            "$x_kernel_uuid_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[out] opaque data representing a kernel UUID",
                        "init": null,
                        "name": "kid[$X_MAX_KERNEL_UUID_SIZE]",
                        "type": "uint8_t"
                    },
                    {
                        "desc": "[out] opaque data representing the kernel's module UUID",
                        "init": null,
                        "name": "mid[$X_MAX_MODULE_UUID_SIZE]",
                        "type": "uint8_t"
                    }
                ]
            },
            "$x_linkage_inspection_ext_desc_t": {
                "class": "$xModule",
                "members": [
                    {
                        "desc": "[in] flags specifying module linkage inspection.\nmust be 0 (default) or a valid combination of $x_linkage_inspection_ext_flag_t.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_linkage_inspection_ext_flags_t"
                    }
                ]
            },
            "$x_memory_allocation_properties_t": {
                "class": "$xMem",
                "members": [
                    {
                        "desc": "[out] type of allocated memory",
                        "init": null,
                        "name": "type",
                        "type": "$x_memory_type_t"
                    },
                    {
                        "desc": "[out] identifier for this allocation",
                        "init": null,
                        "name": "id",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] page size used for allocation",
                        "init": null,
                        "name": "pageSize",
                        "type": "uint64_t"
                    }
                ]
            },
            "$x_memory_compression_hints_ext_desc_t": {
                "class": "$xMem",
                "members": [
                    {
                        "desc": "[in] flags specifying if allocation should be compressible or not.\nMust be set to one of the $x_memory_compression_hints_ext_flag_t;\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_memory_compression_hints_ext_flags_t"
                    }
                ]
            },
            "$x_memory_free_ext_desc_t": {
                "class": "$xMem",
                "members": [
                    {
                        "desc": "[in] flags specifying the memory free policy.\nmust be 0 (default) or a supported $x_driver_memory_free_policy_ext_flag_t;\ndefault behavior is to free immediately.\n",
                        "init": null,
                        "name": "freePolicy",
                        "type": "$x_driver_memory_free_policy_ext_flags_t"
                    }
                ]
            },
            "$x_memory_sub_allocations_exp_properties_t": {
                "class": "$xMem",
                "members": [
                    {
                        "desc": "[in,out] pointer to the number of sub-allocations.\nif count is zero, then the driver shall update the value with the total number of sub-allocations on which the allocation has been divided.\nif count is greater than the number of sub-allocations, then the driver shall update the value with the correct number of sub-allocations.\n",
                        "init": null,
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of properties for sub-allocations.\nif count is less than the number of sub-allocations available, then driver shall only retrieve properties for that number of sub-allocations.\n",
                        "init": null,
                        "name": "pSubAllocations",
                        "type": "$x_sub_allocation_t*"
                    }
                ]
            },
            "$x_module_constants_t": {
                "class": "$xModule",
                "members": [
                    {
                        "desc": "[in] Number of specialization constants.",
                        "init": null,
                        "name": "numConstants",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, numConstants)] Array of IDs that is sized to numConstants.",
                        "init": null,
                        "name": "pConstantIds",
                        "type": "const uint32_t*"
                    },
                    {
                        "desc": "[in][range(0, numConstants)] Array of pointers to values that is sized to numConstants.",
                        "init": null,
                        "name": "pConstantValues",
                        "type": "const void**"
                    }
                ]
            },
            "$x_module_desc_t": {
                "class": "$xModule",
                "members": [
                    {
                        "desc": "[in] Module format passed in with pInputModule",
                        "init": null,
                        "name": "format",
                        "type": "$x_module_format_t"
                    },
                    {
                        "desc": "[in] size of input IL or ISA from pInputModule.",
                        "init": "0",
                        "name": "inputSize",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] pointer to IL or ISA",
                        "init": "nullptr",
                        "name": "pInputModule",
                        "type": "const uint8_t*"
                    },
                    {
                        "desc": "[in][optional] string containing one or more (comma-separated) compiler flags. If unsupported, flag is ignored with a warning.\n  - \"-$x-opt-disable\"\n       - Disable optimizations\n  - \"-$x-opt-level\"\n       - Specifies optimization level for compiler. Levels are implementation specific.\n           - 0 is no optimizations (equivalent to -$x-opt-disable)\n           - 1 is optimize minimally (may be the same as 2)\n           - 2 is optimize more (default)\n  - \"-$x-opt-greater-than-4GB-buffer-required\"\n       - Use 64-bit offset calculations for buffers.\n  - \"-$x-opt-large-register-file\"\n       - Increase number of registers available to threads.\n  - \"-$x-opt-has-buffer-offset-arg\"\n       - Extend stateless to stateful optimization to more\n         cases with the use of additional offset (e.g. 64-bit\n         pointer to binding table with 32-bit offset).\n  - \"-g\"\n       - Include debugging information.\n",
                        "init": "nullptr",
                        "name": "pBuildFlags",
                        "type": "const char*"
                    },
                    {
                        "desc": "[in][optional] pointer to specialization constants. Valid only for SPIR-V input. This must be set to nullptr if no specialization constants are provided.",
                        "init": "nullptr",
                        "name": "pConstants",
                        "type": "const $x_module_constants_t*"
                    }
                ]
            },
            "$x_module_program_exp_desc_t": {
                "class": "$xModule",
                "members": [
                    {
                        "desc": "[in] Count of input modules",
                        "init": null,
                        "name": "count",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, count)] sizes of each input IL module in pInputModules.",
                        "init": null,
                        "name": "inputSizes",
                        "type": "const size_t*"
                    },
                    {
                        "desc": "[in][range(0, count)] pointer to an array of IL (e.g. SPIR-V modules). Valid only for SPIR-V input.",
                        "init": "nullptr",
                        "name": "pInputModules",
                        "type": "const uint8_t**"
                    },
                    {
                        "desc": "[in][optional][range(0, count)] array of strings containing build flags. See pBuildFlags in $x_module_desc_t.",
                        "init": "nullptr",
                        "name": "pBuildFlags",
                        "type": "const char**"
                    },
                    {
                        "desc": "[in][optional][range(0, count)] pointer to array of specialization constant strings. Valid only for SPIR-V input. This must be set to nullptr if no specialization constants are provided.",
                        "init": "nullptr",
                        "name": "pConstants",
                        "type": "const $x_module_constants_t**"
                    }
                ]
            },
            "$x_module_properties_t": {
                "class": "$xModule",
                "members": [
                    {
                        "desc": "[out] 0 (none) or a valid combination of $x_module_property_flag_t",
                        "init": null,
                        "name": "flags",
                        "type": "$x_module_property_flags_t"
                    }
                ]
            },
            "$x_native_kernel_uuid_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] opaque data representing a native kernel UUID",
                        "init": null,
                        "name": "id[$X_MAX_NATIVE_KERNEL_UUID_SIZE]",
                        "type": "uint8_t"
                    }
                ]
            },
            "$x_pci_address_ext_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] PCI domain number",
                        "init": null,
                        "name": "domain",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] PCI BDF bus number",
                        "init": null,
                        "name": "bus",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] PCI BDF device number",
                        "init": null,
                        "name": "device",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] PCI BDF function number",
                        "init": null,
                        "name": "function",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_pci_ext_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] The BDF address",
                        "init": null,
                        "name": "address",
                        "type": "$x_pci_address_ext_t"
                    },
                    {
                        "desc": "[out] Fastest port configuration supported by the device (sum of all lanes)",
                        "init": null,
                        "name": "maxSpeed",
                        "type": "$x_pci_speed_ext_t"
                    }
                ]
            },
            "$x_pci_speed_ext_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] The link generation. A value of -1 means that this property is unknown.",
                        "init": null,
                        "name": "genVersion",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The number of lanes. A value of -1 means that this property is unknown.",
                        "init": null,
                        "name": "width",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The theoretical maximum bandwidth in bytes/sec (sum of all lanes). A value of -1 means that this property is unknown.",
                        "init": null,
                        "name": "maxBandwidth",
                        "type": "int64_t"
                    }
                ]
            },
            "$x_physical_mem_desc_t": {
                "class": "$xPhysicalMem",
                "members": [
                    {
                        "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of $x_physical_mem_flag_t.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_physical_mem_flags_t"
                    },
                    {
                        "desc": "[in] size in bytes to reserve; must be page aligned.",
                        "init": null,
                        "name": "size",
                        "type": "size_t"
                    }
                ]
            },
            "$x_raytracing_mem_alloc_ext_desc_t": {
                "class": "$xContext",
                "members": [
                    {
                        "desc": "[in] flags specifying additional allocation controls.\nmust be 0 (default) or a valid combination of $x_raytracing_mem_alloc_ext_flag_t;\ndefault behavior may use implicit driver-based heuristics.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_raytracing_mem_alloc_ext_flags_t"
                    }
                ]
            },
            "$x_relaxed_allocation_limits_exp_desc_t": {
                "class": "$xMem",
                "members": [
                    {
                        "desc": "[in] flags specifying allocation limits to relax.\nmust be 0 (default) or a valid combination of $x_relaxed_allocation_limits_exp_flag_t;\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_relaxed_allocation_limits_exp_flags_t"
                    }
                ]
            },
            "$x_rtas_aabb_exp_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] lower bounds of AABB",
                        "init": null,
                        "name": "lower",
                        "type": "$x_rtas_float3_exp_t"
                    },
                    {
                        "desc": "[in] upper bounds of AABB",
                        "init": null,
                        "name": "upper",
                        "type": "$x_rtas_float3_exp_t"
                    }
                ]
            },
            "$x_rtas_builder_build_op_exp_desc_t": {
                "class": "$xRTASBuilder",
                "members": [
                    {
                        "desc": "[in] ray tracing acceleration structure format",
                        "init": null,
                        "name": "rtasFormat",
                        "type": "$x_rtas_format_exp_t"
                    },
                    {
                        "desc": "[in] acceleration structure build quality hint",
                        "init": null,
                        "name": "buildQuality",
                        "type": "$x_rtas_builder_build_quality_hint_exp_t"
                    },
                    {
                        "desc": "[in] 0 or some combination of $x_rtas_builder_build_op_exp_flag_t flags",
                        "init": null,
                        "name": "buildFlags",
                        "type": "$x_rtas_builder_build_op_exp_flags_t"
                    },
                    {
                        "desc": "[in][optional][range(0, `numGeometries`)] NULL or a valid array of pointers to geometry infos",
                        "init": null,
                        "name": "ppGeometries",
                        "type": "const $x_rtas_builder_geometry_info_exp_t**"
                    },
                    {
                        "desc": "[in] number of geometries in geometry infos array, can be zero when `ppGeometries` is NULL",
                        "init": null,
                        "name": "numGeometries",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_rtas_builder_exp_desc_t": {
                "class": "$xRTASBuilder",
                "members": [
                    {
                        "desc": "[in] ray tracing acceleration structure builder version",
                        "init": null,
                        "name": "builderVersion",
                        "type": "$x_rtas_builder_exp_version_t"
                    }
                ]
            },
            "$x_rtas_builder_exp_properties_t": {
                "class": "$xRTASBuilder",
                "members": [
                    {
                        "desc": "[out] ray tracing acceleration structure builder flags",
                        "init": null,
                        "name": "flags",
                        "type": "$x_rtas_builder_exp_flags_t"
                    },
                    {
                        "desc": "[out] expected size (in bytes) required for acceleration structure buffer\n    - When using an acceleration structure buffer of this size, the build is expected to succeed; however, it is possible that the build may fail with $X_RESULT_EXP_RTAS_BUILD_RETRY\n",
                        "init": null,
                        "name": "rtasBufferSizeBytesExpected",
                        "type": "size_t"
                    },
                    {
                        "desc": "[out] worst-case size (in bytes) required for acceleration structure buffer\n    - When using an acceleration structure buffer of this size, the build is guaranteed to not run out of memory.\n",
                        "init": null,
                        "name": "rtasBufferSizeBytesMaxRequired",
                        "type": "size_t"
                    },
                    {
                        "desc": "[out] scratch buffer size (in bytes) required for acceleration structure build.",
                        "init": null,
                        "name": "scratchBufferSizeBytes",
                        "type": "size_t"
                    }
                ]
            },
            "$x_rtas_builder_geometry_info_exp_t": {
                "class": "$xRTASBuilder",
                "members": [
                    {
                        "desc": "[in] geometry type",
                        "init": null,
                        "name": "geometryType",
                        "type": "$x_rtas_builder_packed_geometry_type_exp_t"
                    }
                ]
            },
            "$x_rtas_builder_instance_geometry_info_exp_t": {
                "class": "$xRTASBuilder",
                "members": [
                    {
                        "desc": "[in] geometry type, must be $X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_INSTANCE",
                        "init": null,
                        "name": "geometryType",
                        "type": "$x_rtas_builder_packed_geometry_type_exp_t"
                    },
                    {
                        "desc": "[in] 0 or some combination of $x_rtas_builder_geometry_exp_flag_t bits representing the geometry flags for all primitives of this geometry",
                        "init": null,
                        "name": "instanceFlags",
                        "type": "$x_rtas_builder_packed_instance_exp_flags_t"
                    },
                    {
                        "desc": "[in] 8-bit geometry mask for ray masking",
                        "init": null,
                        "name": "geometryMask",
                        "type": "uint8_t"
                    },
                    {
                        "desc": "[in] format of the specified transformation",
                        "init": null,
                        "name": "transformFormat",
                        "type": "$x_rtas_builder_packed_input_data_format_exp_t"
                    },
                    {
                        "desc": "[in] user-specified identifier for the instance",
                        "init": null,
                        "name": "instanceUserID",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] object-to-world instance transformation in specified format",
                        "init": null,
                        "name": "pTransform",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] object-space axis-aligned bounding-box of the instanced acceleration structure",
                        "init": null,
                        "name": "pBounds",
                        "type": "$x_rtas_aabb_exp_t*"
                    },
                    {
                        "desc": "[in] pointer to acceleration structure to instantiate",
                        "init": null,
                        "name": "pAccelerationStructure",
                        "type": "void*"
                    }
                ]
            },
            "$x_rtas_builder_procedural_geometry_info_exp_t": {
                "class": "$xRTASBuilder",
                "members": [
                    {
                        "desc": "[in] geometry type, must be $X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_PROCEDURAL",
                        "init": null,
                        "name": "geometryType",
                        "type": "$x_rtas_builder_packed_geometry_type_exp_t"
                    },
                    {
                        "desc": "[in] 0 or some combination of $x_rtas_builder_geometry_exp_flag_t bits representing the geometry flags for all primitives of this geometry",
                        "init": null,
                        "name": "geometryFlags",
                        "type": "$x_rtas_builder_packed_geometry_exp_flags_t"
                    },
                    {
                        "desc": "[in] 8-bit geometry mask for ray masking",
                        "init": null,
                        "name": "geometryMask",
                        "type": "uint8_t"
                    },
                    {
                        "desc": "[in] reserved for future use",
                        "init": null,
                        "name": "reserved",
                        "type": "uint8_t"
                    },
                    {
                        "desc": "[in] number of primitives in geometry",
                        "init": null,
                        "name": "primCount",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] pointer to callback function to get the axis-aligned bounding-box for a range of primitives",
                        "init": null,
                        "name": "pfnGetBoundsCb",
                        "type": "$x_rtas_geometry_aabbs_cb_exp_t"
                    },
                    {
                        "desc": "[in] user data pointer passed to callback",
                        "init": null,
                        "name": "pGeomUserPtr",
                        "type": "void*"
                    }
                ]
            },
            "$x_rtas_builder_quads_geometry_info_exp_t": {
                "class": "$xRTASBuilder",
                "members": [
                    {
                        "desc": "[in] geometry type, must be $X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_QUADS",
                        "init": null,
                        "name": "geometryType",
                        "type": "$x_rtas_builder_packed_geometry_type_exp_t"
                    },
                    {
                        "desc": "[in] 0 or some combination of $x_rtas_builder_geometry_exp_flag_t bits representing the geometry flags for all primitives of this geometry",
                        "init": null,
                        "name": "geometryFlags",
                        "type": "$x_rtas_builder_packed_geometry_exp_flags_t"
                    },
                    {
                        "desc": "[in] 8-bit geometry mask for ray masking",
                        "init": null,
                        "name": "geometryMask",
                        "type": "uint8_t"
                    },
                    {
                        "desc": "[in] format of quad buffer data, must be $X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_QUAD_INDICES_UINT32",
                        "init": null,
                        "name": "quadFormat",
                        "type": "$x_rtas_builder_packed_input_data_format_exp_t"
                    },
                    {
                        "desc": "[in] format of vertex buffer data, must be $X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3",
                        "init": null,
                        "name": "vertexFormat",
                        "type": "$x_rtas_builder_packed_input_data_format_exp_t"
                    },
                    {
                        "desc": "[in] number of quads in quad buffer",
                        "init": null,
                        "name": "quadCount",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] number of vertices in vertex buffer",
                        "init": null,
                        "name": "vertexCount",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] stride (in bytes) of quads in quad buffer",
                        "init": null,
                        "name": "quadStride",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] stride (in bytes) of vertices in vertex buffer",
                        "init": null,
                        "name": "vertexStride",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] pointer to array of quad indices in specified format",
                        "init": null,
                        "name": "pQuadBuffer",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] pointer to array of quad vertices in specified format",
                        "init": null,
                        "name": "pVertexBuffer",
                        "type": "void*"
                    }
                ]
            },
            "$x_rtas_builder_triangles_geometry_info_exp_t": {
                "class": "$xRTASBuilder",
                "members": [
                    {
                        "desc": "[in] geometry type, must be $X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_TRIANGLES",
                        "init": null,
                        "name": "geometryType",
                        "type": "$x_rtas_builder_packed_geometry_type_exp_t"
                    },
                    {
                        "desc": "[in] 0 or some combination of $x_rtas_builder_geometry_exp_flag_t bits representing the geometry flags for all primitives of this geometry",
                        "init": null,
                        "name": "geometryFlags",
                        "type": "$x_rtas_builder_packed_geometry_exp_flags_t"
                    },
                    {
                        "desc": "[in] 8-bit geometry mask for ray masking",
                        "init": null,
                        "name": "geometryMask",
                        "type": "uint8_t"
                    },
                    {
                        "desc": "[in] format of triangle buffer data, must be $X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_TRIANGLE_INDICES_UINT32",
                        "init": null,
                        "name": "triangleFormat",
                        "type": "$x_rtas_builder_packed_input_data_format_exp_t"
                    },
                    {
                        "desc": "[in] format of vertex buffer data, must be $X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3",
                        "init": null,
                        "name": "vertexFormat",
                        "type": "$x_rtas_builder_packed_input_data_format_exp_t"
                    },
                    {
                        "desc": "[in] number of triangles in triangle buffer",
                        "init": null,
                        "name": "triangleCount",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] number of vertices in vertex buffer",
                        "init": null,
                        "name": "vertexCount",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] stride (in bytes) of triangles in triangle buffer",
                        "init": null,
                        "name": "triangleStride",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] stride (in bytes) of vertices in vertex buffer",
                        "init": null,
                        "name": "vertexStride",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] pointer to array of triangle indices in specified format",
                        "init": null,
                        "name": "pTriangleBuffer",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] pointer to array of triangle vertices in specified format",
                        "init": null,
                        "name": "pVertexBuffer",
                        "type": "void*"
                    }
                ]
            },
            "$x_rtas_device_exp_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] ray tracing acceleration structure device flags",
                        "init": null,
                        "name": "flags",
                        "type": "$x_rtas_device_exp_flags_t"
                    },
                    {
                        "desc": "[out] ray tracing acceleration structure format",
                        "init": null,
                        "name": "rtasFormat",
                        "type": "$x_rtas_format_exp_t"
                    },
                    {
                        "desc": "[out] required alignment of acceleration structure buffer",
                        "init": null,
                        "name": "rtasBufferAlignment",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_rtas_float3_exp_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] x-coordinate of float3 vector",
                        "init": null,
                        "name": "x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] y-coordinate of float3 vector",
                        "init": null,
                        "name": "y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] z-coordinate of float3 vector",
                        "init": null,
                        "name": "z",
                        "type": "float"
                    }
                ]
            },
            "$x_rtas_geometry_aabbs_exp_cb_params_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] first primitive to return bounds for",
                        "init": null,
                        "name": "primID",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] number of primitives to return bounds for",
                        "init": null,
                        "name": "primIDCount",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] pointer provided through geometry descriptor",
                        "init": null,
                        "name": "pGeomUserPtr",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] pointer provided through $xRTASBuilderBuildExp function",
                        "init": null,
                        "name": "pBuildUserPtr",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] destination buffer to write AABB bounds to",
                        "init": null,
                        "name": "pBoundsOut",
                        "type": "$x_rtas_aabb_exp_t*"
                    }
                ]
            },
            "$x_rtas_parallel_operation_exp_properties_t": {
                "class": "$xRTASParallelOperation",
                "members": [
                    {
                        "desc": "[out] ray tracing acceleration structure builder parallel operation flags",
                        "init": null,
                        "name": "flags",
                        "type": "$x_rtas_parallel_operation_exp_flags_t"
                    },
                    {
                        "desc": "[out] maximum number of threads that may join the parallel operation",
                        "init": null,
                        "name": "maxConcurrency",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_rtas_quad_indices_uint32_exp_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] first index pointing to the first quad vertex in vertex array",
                        "init": null,
                        "name": "v0",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] second index pointing to the second quad vertex in vertex array",
                        "init": null,
                        "name": "v1",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] third index pointing to the third quad vertex in vertex array",
                        "init": null,
                        "name": "v2",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] fourth index pointing to the fourth quad vertex in vertex array",
                        "init": null,
                        "name": "v3",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_rtas_transform_float3x4_aligned_column_major_exp_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] element 0 of column 0 of 3x4 matrix",
                        "init": null,
                        "name": "vx_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 0 of 3x4 matrix",
                        "init": null,
                        "name": "vx_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 0 of 3x4 matrix",
                        "init": null,
                        "name": "vx_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] ignored padding",
                        "init": null,
                        "name": "pad0",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of column 1 of 3x4 matrix",
                        "init": null,
                        "name": "vy_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 1 of 3x4 matrix",
                        "init": null,
                        "name": "vy_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 1 of 3x4 matrix",
                        "init": null,
                        "name": "vy_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] ignored padding",
                        "init": null,
                        "name": "pad1",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of column 2 of 3x4 matrix",
                        "init": null,
                        "name": "vz_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 2 of 3x4 matrix",
                        "init": null,
                        "name": "vz_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 2 of 3x4 matrix",
                        "init": null,
                        "name": "vz_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] ignored padding",
                        "init": null,
                        "name": "pad2",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of column 3 of 3x4 matrix",
                        "init": null,
                        "name": "p_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 3 of 3x4 matrix",
                        "init": null,
                        "name": "p_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 3 of 3x4 matrix",
                        "init": null,
                        "name": "p_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] ignored padding",
                        "init": null,
                        "name": "pad3",
                        "type": "float"
                    }
                ]
            },
            "$x_rtas_transform_float3x4_column_major_exp_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] element 0 of column 0 of 3x4 matrix",
                        "init": null,
                        "name": "vx_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 0 of 3x4 matrix",
                        "init": null,
                        "name": "vx_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 0 of 3x4 matrix",
                        "init": null,
                        "name": "vx_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of column 1 of 3x4 matrix",
                        "init": null,
                        "name": "vy_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 1 of 3x4 matrix",
                        "init": null,
                        "name": "vy_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 1 of 3x4 matrix",
                        "init": null,
                        "name": "vy_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of column 2 of 3x4 matrix",
                        "init": null,
                        "name": "vz_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 2 of 3x4 matrix",
                        "init": null,
                        "name": "vz_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 2 of 3x4 matrix",
                        "init": null,
                        "name": "vz_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of column 3 of 3x4 matrix",
                        "init": null,
                        "name": "p_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 3 of 3x4 matrix",
                        "init": null,
                        "name": "p_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 3 of 3x4 matrix",
                        "init": null,
                        "name": "p_z",
                        "type": "float"
                    }
                ]
            },
            "$x_rtas_transform_float3x4_row_major_exp_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] element 0 of row 0 of 3x4 matrix",
                        "init": null,
                        "name": "vx_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of row 0 of 3x4 matrix",
                        "init": null,
                        "name": "vy_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of row 0 of 3x4 matrix",
                        "init": null,
                        "name": "vz_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 3 of row 0 of 3x4 matrix",
                        "init": null,
                        "name": "p_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of row 1 of 3x4 matrix",
                        "init": null,
                        "name": "vx_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of row 1 of 3x4 matrix",
                        "init": null,
                        "name": "vy_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of row 1 of 3x4 matrix",
                        "init": null,
                        "name": "vz_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 3 of row 1 of 3x4 matrix",
                        "init": null,
                        "name": "p_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of row 2 of 3x4 matrix",
                        "init": null,
                        "name": "vx_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of row 2 of 3x4 matrix",
                        "init": null,
                        "name": "vy_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of row 2 of 3x4 matrix",
                        "init": null,
                        "name": "vz_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 3 of row 2 of 3x4 matrix",
                        "init": null,
                        "name": "p_z",
                        "type": "float"
                    }
                ]
            },
            "$x_rtas_triangle_indices_uint32_exp_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[in] first index pointing to the first triangle vertex in vertex array",
                        "init": null,
                        "name": "v0",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] second index pointing to the second triangle vertex in vertex array",
                        "init": null,
                        "name": "v1",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] third index pointing to the third triangle vertex in vertex array",
                        "init": null,
                        "name": "v2",
                        "type": "uint32_t"
                    }
                ]
            },
            "$x_sampler_desc_t": {
                "class": "$xSampler",
                "members": [
                    {
                        "desc": "[in] Sampler addressing mode to determine how out-of-bounds coordinates are handled.",
                        "init": "$X_SAMPLER_ADDRESS_MODE_NONE",
                        "name": "addressMode",
                        "type": "$x_sampler_address_mode_t"
                    },
                    {
                        "desc": "[in] Sampler filter mode to determine how samples are filtered.",
                        "init": "$X_SAMPLER_FILTER_MODE_NEAREST",
                        "name": "filterMode",
                        "type": "$x_sampler_filter_mode_t"
                    },
                    {
                        "desc": "[in] Are coordinates normalized [0, 1] or not.",
                        "init": "true",
                        "name": "isNormalized",
                        "type": "$x_bool_t"
                    }
                ]
            },
            "$x_scheduling_hint_exp_desc_t": {
                "class": "$xKernel",
                "members": [
                    {
                        "desc": "[in] flags specifying kernel scheduling hints.\nmust be 0 (default) or a valid combination of $x_scheduling_hint_exp_flag_t.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "$x_scheduling_hint_exp_flags_t"
                    }
                ]
            },
            "$x_scheduling_hint_exp_properties_t": {
                "class": "$xDevice",
                "members": [
                    {
                        "desc": "[out] Supported kernel scheduling hints.\nMay be 0 (none) or a valid combination of $x_scheduling_hint_exp_flag_t.\n",
                        "init": null,
                        "name": "schedulingHintFlags",
                        "type": "$x_scheduling_hint_exp_flags_t"
                    }
                ]
            },
            "$x_srgb_ext_desc_t": {
                "class": "$xImage",
                "members": [
                    {
                        "desc": "[in] Is sRGB.",
                        "init": null,
                        "name": "sRGB",
                        "type": "ze_bool_t"
                    }
                ]
            },
            "$x_sub_allocation_t": {
                "class": "$xMem",
                "members": [
                    {
                        "desc": "[in,out][optional] base address of the sub-allocation",
                        "init": null,
                        "name": "base",
                        "type": "void*"
                    },
                    {
                        "desc": "[in,out][optional] size of the allocation",
                        "init": null,
                        "name": "size",
                        "type": "size_t"
                    }
                ]
            },
            "$x_synchronized_timestamp_data_ext_t": {
                "class": "$xEvent",
                "members": [
                    {
                        "desc": "[out] synchronized clock at start of kernel execution",
                        "init": null,
                        "name": "kernelStart",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] synchronized clock at end of kernel execution",
                        "init": null,
                        "name": "kernelEnd",
                        "type": "uint64_t"
                    }
                ]
            },
            "$x_synchronized_timestamp_result_ext_t": {
                "class": "$xEvent",
                "members": [
                    {
                        "desc": "[out] wall-clock data",
                        "init": null,
                        "name": "global",
                        "type": "$x_synchronized_timestamp_data_ext_t"
                    },
                    {
                        "desc": "[out] context-active data; only includes clocks while device context was actively executing.",
                        "init": null,
                        "name": "context",
                        "type": "$x_synchronized_timestamp_data_ext_t"
                    }
                ]
            },
            "$x_uuid_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[out] opaque data representing a UUID",
                        "init": null,
                        "name": "id[$X_MAX_UUID_SIZE]",
                        "type": "uint8_t"
                    }
                ]
            }
        },
        "typedef": {
            "$t_core_callbacks_t": {
                "class": "$tTracerExp"
            },
            "$x_bool_t": {
                "class": ""
            },
            "$x_kernel_max_group_size_ext_properties_t": {
                "class": ""
            },
            "$x_rtas_builder_packed_geometry_exp_flags_t": {
                "class": "$xRTASBuilder"
            },
            "$x_rtas_builder_packed_geometry_type_exp_t": {
                "class": "$xRTASBuilder"
            },
            "$x_rtas_builder_packed_input_data_format_exp_t": {
                "class": "$xRTASBuilder"
            },
            "$x_rtas_builder_packed_instance_exp_flags_t": {
                "class": "$xRTASBuilder"
            }
        },
        "union": {
            "$t_debug_event_info_t": {
                "class": "$tDebug",
                "members": [
                    {
                        "desc": "[out] type == $T_DEBUG_EVENT_TYPE_DETACHED",
                        "init": null,
                        "name": "detached",
                        "type": "$t_debug_event_info_detached_t"
                    },
                    {
                        "desc": "[out] type == $T_DEBUG_EVENT_TYPE_MODULE_LOAD or $T_DEBUG_EVENT_TYPE_MODULE_UNLOAD",
                        "init": null,
                        "name": "module",
                        "type": "$t_debug_event_info_module_t"
                    },
                    {
                        "desc": "[out] type == $T_DEBUG_EVENT_TYPE_THREAD_STOPPED or $T_DEBUG_EVENT_TYPE_THREAD_UNAVAILABLE",
                        "init": null,
                        "name": "thread",
                        "type": "$t_debug_event_info_thread_stopped_t"
                    },
                    {
                        "desc": "[out] type == $T_DEBUG_EVENT_TYPE_PAGE_FAULT",
                        "init": null,
                        "name": "page_fault",
                        "type": "$t_debug_event_info_page_fault_t"
                    }
                ]
            },
            "$t_value_t": {
                "class": "",
                "members": [
                    {
                        "desc": "[out] 32-bit unsigned-integer",
                        "init": null,
                        "name": "ui32",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] 32-bit unsigned-integer",
                        "init": null,
                        "name": "ui64",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] 32-bit floating-point",
                        "init": null,
                        "name": "fp32",
                        "type": "float"
                    },
                    {
                        "desc": "[out] 64-bit floating-point",
                        "init": null,
                        "name": "fp64",
                        "type": "double"
                    },
                    {
                        "desc": "[out] 8-bit boolean",
                        "init": null,
                        "name": "b8",
                        "type": "$x_bool_t"
                    }
                ]
            }
        }
    },
    "ref": {
        "callback": {
            "ze_rtas_geometry_aabbs_cb_exp_t": {
                "desc": "Callback function pointer type to return AABBs for a range of procedural primitives",
                "name": "ze_rtas_geometry_aabbs_cb_exp_t",
                "params": [
                    {
                        "desc": "[in] callback function parameters structure",
                        "name": "params",
                        "type": "ze_rtas_geometry_aabbs_exp_cb_params_t*"
                    }
                ],
                "returntype": "void",
                "type": "callback",
                "version": "1.7"
            }
        },
        "class": {
            "zeCommandList": {
                "desc": "C++ wrapper for command list",
                "members": [
                    {
                        "desc": "[in] handle of command list object",
                        "name": "handle",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zeDevice*"
                    },
                    {
                        "desc": "[in] descriptor of the command list object",
                        "name": "desc",
                        "type": "ze_command_list_desc_t"
                    }
                ],
                "name": "zeCommandList",
                "owner": "zeDevice",
                "type": "class"
            },
            "zeCommandQueue": {
                "desc": "C++ wrapper for command queue",
                "members": [
                    {
                        "desc": "[in] handle of command queue object",
                        "name": "handle",
                        "type": "ze_command_queue_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zeDevice*"
                    },
                    {
                        "desc": "[in] descriptor of the command queue object",
                        "name": "desc",
                        "type": "ze_command_queue_desc_t"
                    }
                ],
                "name": "zeCommandQueue",
                "owner": "zeDevice",
                "type": "class"
            },
            "zeContext": {
                "desc": "C++ wrapper for context",
                "members": [
                    {
                        "desc": "[in] handle of context object",
                        "name": "handle",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDriver",
                        "type": "zeDriver*"
                    }
                ],
                "name": "zeContext",
                "owner": "zeDriver",
                "type": "class"
            },
            "zeDevice": {
                "attribute": "singleton",
                "desc": "C++ wrapper for a device",
                "members": [
                    {
                        "desc": "[in] handle of device object",
                        "name": "handle",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDriver",
                        "type": "zeDriver*"
                    }
                ],
                "name": "zeDevice",
                "owner": "zeDriver",
                "type": "class"
            },
            "zeDriver": {
                "attribute": "singleton",
                "desc": "C++ wrapper for a driver instance handle",
                "members": [
                    {
                        "desc": "[in] handle of the driver instance",
                        "name": "handle",
                        "type": "ze_driver_handle_t"
                    }
                ],
                "name": "zeDriver",
                "type": "class"
            },
            "zeEvent": {
                "desc": "C++ wrapper for event",
                "members": [
                    {
                        "desc": "[in] handle of event object",
                        "name": "handle",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pEventPool",
                        "type": "zeEventPool*"
                    },
                    {
                        "desc": "[in] descriptor of the event object",
                        "name": "desc",
                        "type": "ze_event_desc_t"
                    }
                ],
                "name": "zeEvent",
                "owner": "zeEventPool",
                "type": "class"
            },
            "zeEventPool": {
                "desc": "C++ wrapper for event pool",
                "members": [
                    {
                        "desc": "[in] handle of event pool object",
                        "name": "handle",
                        "type": "ze_event_pool_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pContext",
                        "type": "zeContext*"
                    },
                    {
                        "desc": "[in] descriptor of the event pool object",
                        "name": "desc",
                        "type": "ze_event_pool_desc_t"
                    }
                ],
                "name": "zeEventPool",
                "owner": "zeContext",
                "type": "class"
            },
            "zeFabricEdge": {
                "desc": "C++ wrapper for fabric edge",
                "members": [
                    {
                        "desc": "[in] handle of fabric edge object",
                        "name": "handle",
                        "type": "ze_fabric_edge_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDriver",
                        "type": "zeDriver*"
                    }
                ],
                "name": "zeFabricEdge",
                "owner": "zeDriver",
                "type": "class"
            },
            "zeFabricVertex": {
                "desc": "C++ wrapper for fabric vertex",
                "members": [
                    {
                        "desc": "[in] handle of fabric vertex object",
                        "name": "handle",
                        "type": "ze_fabric_vertex_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDriver",
                        "type": "zeDriver*"
                    }
                ],
                "name": "zeFabricVertex",
                "owner": "zeDriver",
                "type": "class"
            },
            "zeFence": {
                "desc": "C++ wrapper for fence",
                "members": [
                    {
                        "desc": "[in] handle of fence object",
                        "name": "handle",
                        "type": "ze_fence_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pCommandQueue",
                        "type": "zeCommandQueue*"
                    },
                    {
                        "desc": "[in] descriptor of the fence object",
                        "name": "desc",
                        "type": "ze_fence_desc_t"
                    }
                ],
                "name": "zeFence",
                "owner": "zeCommandQueue",
                "type": "class"
            },
            "zeImage": {
                "desc": "C++ wrapper for image",
                "members": [
                    {
                        "desc": "[in] handle of image object",
                        "name": "handle",
                        "type": "ze_image_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zeDevice*"
                    },
                    {
                        "desc": "[in] descriptor of the image object",
                        "name": "desc",
                        "type": "ze_image_desc_t"
                    }
                ],
                "name": "zeImage",
                "owner": "zeDevice",
                "type": "class"
            },
            "zeKernel": {
                "desc": "C++ wrapper for kernel",
                "members": [
                    {
                        "desc": "[in] handle of kernel object",
                        "name": "handle",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pModule",
                        "type": "zeModule*"
                    },
                    {
                        "desc": "[in] descriptor of the kernel object",
                        "name": "desc",
                        "type": "ze_kernel_desc_t"
                    }
                ],
                "name": "zeKernel",
                "owner": "zeModule",
                "type": "class"
            },
            "zeMem": {
                "desc": "C++ wrapper for memory allocation",
                "members": [],
                "name": "zeMem",
                "owner": "zeContext",
                "type": "class"
            },
            "zeModule": {
                "desc": "C++ wrapper for module",
                "members": [
                    {
                        "desc": "[in] handle of module object",
                        "name": "handle",
                        "type": "ze_module_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zeDevice*"
                    },
                    {
                        "desc": "[in] descriptor of the module object",
                        "name": "desc",
                        "type": "ze_module_desc_t"
                    }
                ],
                "name": "zeModule",
                "owner": "zeDevice",
                "type": "class"
            },
            "zeModuleBuildLog": {
                "desc": "C++ wrapper for buildlog",
                "members": [
                    {
                        "desc": "[in] handle of the buildlog object",
                        "name": "handle",
                        "type": "ze_module_build_log_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pModule",
                        "type": "zeModule*"
                    }
                ],
                "name": "zeModuleBuildLog",
                "owner": "zeModule",
                "type": "class"
            },
            "zePhysicalMem": {
                "desc": "C++ wrapper for physical memory allocation",
                "members": [
                    {
                        "desc": "[in] handle of physical memory object",
                        "name": "handle",
                        "type": "ze_physical_mem_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pContext",
                        "type": "zeContext*"
                    },
                    {
                        "desc": "[in] descriptor of the physical memory object",
                        "name": "desc",
                        "type": "ze_physical_mem_desc_t"
                    }
                ],
                "name": "zePhysicalMem",
                "owner": "zeContext",
                "type": "class"
            },
            "zeSampler": {
                "desc": "c++ wrapper for sampler",
                "members": [
                    {
                        "desc": "[in] handle of the sample object",
                        "name": "handle",
                        "type": "ze_sampler_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zeDevice*"
                    },
                    {
                        "desc": "[in] sampler descriptor",
                        "name": "desc",
                        "type": "ze_sampler_desc_t"
                    }
                ],
                "name": "zeSampler",
                "owner": "zeDevice",
                "type": "class"
            },
            "zeVirtualMem": {
                "desc": "C++ wrapper for virtual memory allocation",
                "members": [],
                "name": "zeVirtualMem",
                "owner": "zeContext",
                "type": "class"
            },
            "zesDevice": {
                "base": "zeDevice",
                "desc": "C++ wrapper for device",
                "members": [],
                "name": "zesDevice",
                "type": "class"
            },
            "zesDiagnostics": {
                "desc": "C++ wrapper for a Sysman device diagnostic test suite",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_diag_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesDiagnostics",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesDriver": {
                "base": "zeDriver",
                "desc": "C++ wrapper for driver instance",
                "members": [],
                "name": "zesDriver",
                "type": "class"
            },
            "zesEngine": {
                "desc": "C++ wrapper for a Sysman device engine group",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_engine_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesEngine",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesFabricPort": {
                "desc": "C++ wrapper for a Sysman device Fabric port",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_fabric_port_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesFabricPort",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesFan": {
                "desc": "C++ wrapper for a Sysman device fan",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_fan_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesFan",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesFirmware": {
                "desc": "C++ wrapper for a Sysman device firmware",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_firmware_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesFirmware",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesFrequency": {
                "desc": "C++ wrapper for a Sysman device frequency domain",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesFrequency",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesLed": {
                "desc": "C++ wrapper for a Sysman device LED",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_led_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesLed",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesMemory": {
                "desc": "C++ wrapper for a Sysman device memory module",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_mem_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesMemory",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesOverclock": {
                "desc": "C++ wrapper for a Sysman device overclock domain",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_overclock_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesOverclock",
                "owner": "zesDevice",
                "type": "class",
                "version": "1.5"
            },
            "zesPerformanceFactor": {
                "desc": "C++ wrapper for a Sysman device performance factor",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_perf_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesPerformanceFactor",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesPower": {
                "desc": "C++ wrapper for a Sysman device power domain",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_pwr_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesPower",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesPsu": {
                "desc": "C++ wrapper for a Sysman device power supply",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_psu_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesPsu",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesRas": {
                "desc": "C++ wrapper for a Sysman device RAS error set",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_ras_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesRas",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesScheduler": {
                "desc": "C++ wrapper for a Sysman device scheduler queue",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_sched_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesScheduler",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesStandby": {
                "desc": "C++ wrapper for a Sysman standby control",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_standby_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesStandby",
                "owner": "zesDevice",
                "type": "class"
            },
            "zesTemperature": {
                "desc": "C++ wrapper for a Sysman device temperature sensor",
                "members": [
                    {
                        "desc": "[in] handle of Sysman object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zes_temp_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zesDevice*"
                    }
                ],
                "name": "zesTemperature",
                "owner": "zesDevice",
                "type": "class"
            },
            "zetCommandList": {
                "base": "zeCommandList",
                "desc": "C++ wrapper for command list",
                "members": [],
                "name": "zetCommandList",
                "type": "class"
            },
            "zetContext": {
                "base": "zeContext",
                "desc": "C++ wrapper for context",
                "members": [],
                "name": "zetContext",
                "type": "class"
            },
            "zetDebug": {
                "desc": "C++ wrapper for Debug API",
                "members": [
                    {
                        "desc": "[in] debug session handle",
                        "name": "handle",
                        "type": "zet_debug_session_handle_t"
                    }
                ],
                "name": "zetDebug",
                "type": "class"
            },
            "zetDevice": {
                "base": "zeDevice",
                "desc": "C++ wrapper for device",
                "members": [],
                "name": "zetDevice",
                "type": "class"
            },
            "zetDriver": {
                "base": "zeDriver",
                "desc": "C++ wrapper for driver instance",
                "members": [],
                "name": "zetDriver",
                "type": "class"
            },
            "zetKernel": {
                "base": "zeKernel",
                "desc": "C++ wrapper for kernel",
                "members": [],
                "name": "zetKernel",
                "type": "class"
            },
            "zetMetric": {
                "attribute": "singleton",
                "desc": "C++ wrapper for metric",
                "members": [
                    {
                        "desc": "[in] handle of metric object",
                        "name": "handle",
                        "type": "zet_metric_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pMetricGroup",
                        "type": "zetMetricGroup*"
                    }
                ],
                "name": "zetMetric",
                "owner": "zetMetricGroup",
                "type": "class"
            },
            "zetMetricGroup": {
                "attribute": "singleton",
                "desc": "C++ wrapper for metric group",
                "members": [
                    {
                        "desc": "[in] handle of metric group object",
                        "init": "nullptr",
                        "name": "handle",
                        "type": "zet_metric_group_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zetDevice*"
                    }
                ],
                "name": "zetMetricGroup",
                "owner": "zetDevice",
                "type": "class"
            },
            "zetMetricQuery": {
                "desc": "C++ wrapper for metric query",
                "members": [
                    {
                        "desc": "[in] handle of metric query object",
                        "name": "handle",
                        "type": "zet_metric_query_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zetDevice*"
                    }
                ],
                "name": "zetMetricQuery",
                "owner": "zetDevice",
                "type": "class"
            },
            "zetMetricQueryPool": {
                "desc": "C++ wrapper for metric query pool",
                "members": [
                    {
                        "desc": "[in] handle of metric query pool object",
                        "name": "handle",
                        "type": "zet_metric_query_pool_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zetDevice*"
                    },
                    {
                        "desc": "[in] descriptor of the metric query pool",
                        "name": "desc",
                        "type": "zet_metric_query_pool_desc_t"
                    }
                ],
                "name": "zetMetricQueryPool",
                "owner": "zetDevice",
                "type": "class"
            },
            "zetMetricStreamer": {
                "desc": "C++ wrapper for metric streamer",
                "members": [
                    {
                        "desc": "[in] handle of metric streamer object",
                        "name": "handle",
                        "type": "zet_metric_streamer_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDevice",
                        "type": "zetDevice*"
                    },
                    {
                        "desc": "[in] descriptor of the metric streamer",
                        "name": "desc",
                        "type": "zet_metric_streamer_desc_t"
                    }
                ],
                "name": "zetMetricStreamer",
                "owner": "zetDevice",
                "type": "class"
            },
            "zetModule": {
                "base": "zeModule",
                "desc": "C++ wrapper for module",
                "members": [],
                "name": "zetModule",
                "type": "class"
            },
            "zetTracerExp": {
                "desc": "C++ wrapper for tracer",
                "members": [
                    {
                        "desc": "[in] handle of tracer object",
                        "name": "handle",
                        "type": "zet_tracer_exp_handle_t"
                    },
                    {
                        "desc": "[in] pointer to owner object",
                        "name": "pDriver",
                        "type": "zetDriver*"
                    },
                    {
                        "desc": "[in] descriptor of the tracer object",
                        "name": "desc",
                        "type": "zet_tracer_exp_desc_t"
                    }
                ],
                "name": "zetTracerExp",
                "owner": "zetDriver",
                "type": "class"
            }
        },
        "enum": {
            "ze_api_version_t": {
                "class": "zeDriver",
                "desc": "Supported API versions",
                "details": [
                    "API versions contain major and minor attributes, use ZE_MAJOR_VERSION and ZE_MINOR_VERSION"
                ],
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_API_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "version 1.1",
                        "name": "ZE_API_VERSION_1_1",
                        "value": "ZE_MAKE_VERSION( 1, 1 )",
                        "version": "1.1"
                    },
                    {
                        "desc": "version 1.2",
                        "name": "ZE_API_VERSION_1_2",
                        "value": "ZE_MAKE_VERSION( 1, 2 )",
                        "version": "1.2"
                    },
                    {
                        "desc": "version 1.3",
                        "name": "ZE_API_VERSION_1_3",
                        "value": "ZE_MAKE_VERSION( 1, 3 )",
                        "version": "1.3"
                    },
                    {
                        "desc": "version 1.4",
                        "name": "ZE_API_VERSION_1_4",
                        "value": "ZE_MAKE_VERSION( 1, 4 )",
                        "version": "1.4"
                    },
                    {
                        "desc": "version 1.5",
                        "name": "ZE_API_VERSION_1_5",
                        "value": "ZE_MAKE_VERSION( 1, 5 )",
                        "version": "1.5"
                    },
                    {
                        "desc": "version 1.6",
                        "name": "ZE_API_VERSION_1_6",
                        "value": "ZE_MAKE_VERSION( 1, 6 )",
                        "version": "1.6"
                    },
                    {
                        "desc": "version 1.7",
                        "name": "ZE_API_VERSION_1_7",
                        "value": "ZE_MAKE_VERSION( 1, 7 )",
                        "version": "1.7"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_API_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 7 )"
                    }
                ],
                "name": "ze_api_version_t",
                "type": "enum"
            },
            "ze_bandwidth_unit_t": {
                "desc": "Bandwidth unit",
                "etors": [
                    {
                        "desc": "The unit used for bandwidth is unknown",
                        "name": "ZE_BANDWIDTH_UNIT_UNKNOWN",
                        "value": "0"
                    },
                    {
                        "desc": "Bandwidth is provided in bytes/nanosec",
                        "name": "ZE_BANDWIDTH_UNIT_BYTES_PER_NANOSEC",
                        "value": "1"
                    },
                    {
                        "desc": "Bandwidth is provided in bytes/clock",
                        "name": "ZE_BANDWIDTH_UNIT_BYTES_PER_CLOCK",
                        "value": "2"
                    }
                ],
                "name": "ze_bandwidth_unit_t",
                "type": "enum",
                "version": "1.4"
            },
            "ze_bfloat16_conversions_ext_version_t": {
                "desc": "Bfloat16 Conversions Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_BFLOAT16_CONVERSIONS_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_BFLOAT16_CONVERSIONS_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_bfloat16_conversions_ext_version_t",
                "type": "enum",
                "version": "1.5"
            },
            "ze_cache_config_flags_t": {
                "class": "zeKernel",
                "desc": "Supported Cache Config flags",
                "etors": [
                    {
                        "desc": "Large SLM size",
                        "name": "ZE_CACHE_CONFIG_FLAG_LARGE_SLM",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Large General Data size",
                        "name": "ZE_CACHE_CONFIG_FLAG_LARGE_DATA",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "ze_cache_config_flags_t",
                "type": "enum"
            },
            "ze_cache_ext_region_t": {
                "class": "zeDevice",
                "desc": "Cache Reservation Region",
                "etors": [
                    {
                        "desc": "[DEPRECATED] utilize driver default scheme. Use ZE_CACHE_EXT_REGION_DEFAULT.",
                        "name": "ZE_CACHE_EXT_REGION_ZE_CACHE_REGION_DEFAULT",
                        "value": "0"
                    },
                    {
                        "desc": "[DEPRECATED] utilize reserved region. Use ZE_CACHE_EXT_REGION_RESERVED.",
                        "name": "ZE_CACHE_EXT_REGION_ZE_CACHE_RESERVE_REGION",
                        "value": "1"
                    },
                    {
                        "desc": "[DEPRECATED] utilize non-reserverd region. Use ZE_CACHE_EXT_REGION_NON_RESERVED.",
                        "name": "ZE_CACHE_EXT_REGION_ZE_CACHE_NON_RESERVED_REGION",
                        "value": "2"
                    },
                    {
                        "desc": "utilize driver default scheme",
                        "name": "ZE_CACHE_EXT_REGION_DEFAULT",
                        "value": "0",
                        "version": "1.7"
                    },
                    {
                        "desc": "utilize reserved region",
                        "name": "ZE_CACHE_EXT_REGION_RESERVED",
                        "value": "1",
                        "version": "1.7"
                    },
                    {
                        "desc": "utilize non-reserverd region",
                        "name": "ZE_CACHE_EXT_REGION_NON_RESERVED",
                        "value": "2",
                        "version": "1.7"
                    }
                ],
                "name": "ze_cache_ext_region_t",
                "type": "enum",
                "version": "1.2"
            },
            "ze_cache_reservation_ext_version_t": {
                "desc": "Cache_Reservation Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_CACHE_RESERVATION_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_CACHE_RESERVATION_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_cache_reservation_ext_version_t",
                "type": "enum",
                "version": "1.2"
            },
            "ze_calculate_multiple_metrics_exp_version_t": {
                "desc": "Calculating Multiple Metrics Experimental Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_CALCULATE_MULTIPLE_METRICS_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_CALCULATE_MULTIPLE_METRICS_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_calculate_multiple_metrics_exp_version_t",
                "type": "enum",
                "version": "1.2"
            },
            "ze_command_list_flags_t": {
                "class": "zeCommandList",
                "desc": "Supported command list creation flags",
                "etors": [
                    {
                        "desc": "driver may reorder commands (e.g., kernels, copies) between barriers and synchronization primitives.\nusing this flag may increase Host overhead of zeCommandListClose.\ntherefore, this flag should **not** be set for low-latency usage-models.\n",
                        "name": "ZE_COMMAND_LIST_FLAG_RELAXED_ORDERING",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "driver may perform additional optimizations that increase execution throughput. \nusing this flag may increase Host overhead of zeCommandListClose and zeCommandQueueExecuteCommandLists.\ntherefore, this flag should **not** be set for low-latency usage-models.\n",
                        "name": "ZE_COMMAND_LIST_FLAG_MAXIMIZE_THROUGHPUT",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "command list should be optimized for submission to a single command queue and device engine.\ndriver **must** disable any implicit optimizations for distributing work across multiple engines.\nthis flag should be used when applications want full control over multi-engine submission and scheduling.\n",
                        "name": "ZE_COMMAND_LIST_FLAG_EXPLICIT_ONLY",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "commands appended to this command list are executed in-order, with driver implementation\nenforcing dependencies between them. Application is not required to have the signal event\nof a given command being the wait event of the next to define an in-order list, and\napplication is allowed to pass signal and wait events to each appended command to implement\nmore complex dependency graphs. Cannot be combined with ZE_COMMAND_LIST_FLAG_RELAXED_ORDERING.\n",
                        "name": "ZE_COMMAND_LIST_FLAG_IN_ORDER",
                        "value": "ZE_BIT(3)",
                        "version": "1.7"
                    }
                ],
                "name": "ze_command_list_flags_t",
                "type": "enum"
            },
            "ze_command_queue_flags_t": {
                "class": "zeCommandQueue",
                "desc": "Supported command queue flags",
                "etors": [
                    {
                        "desc": "command queue should be optimized for submission to a single device engine.\ndriver **must** disable any implicit optimizations for distributing work across multiple engines.\nthis flag should be used when applications want full control over multi-engine submission and scheduling.\n",
                        "name": "ZE_COMMAND_QUEUE_FLAG_EXPLICIT_ONLY",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "To be used only when creating immediate command lists. Commands appended to the immediate command\nlist are executed in-order, with driver implementation enforcing dependencies between them.\nApplication is not required to have the signal event of a given command being the wait event of\nthe next to define an in-order list, and application is allowed to pass signal and wait events\nto each appended command to implement more complex dependency graphs.\n",
                        "name": "ZE_COMMAND_QUEUE_FLAG_IN_ORDER",
                        "value": "ZE_BIT(1)",
                        "version": "1.7"
                    }
                ],
                "name": "ze_command_queue_flags_t",
                "type": "enum"
            },
            "ze_command_queue_group_property_flags_t": {
                "class": "zeDevice",
                "desc": "Supported command queue group property flags",
                "etors": [
                    {
                        "desc": "Command queue group supports enqueing compute commands.",
                        "name": "ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COMPUTE",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Command queue group supports enqueing copy commands.",
                        "name": "ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COPY",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Command queue group supports cooperative kernels.\nSee zeCommandListAppendLaunchCooperativeKernel for more details.\n",
                        "name": "ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COOPERATIVE_KERNELS",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "Command queue groups supports metric queries.",
                        "name": "ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_METRICS",
                        "value": "ZE_BIT(3)"
                    }
                ],
                "name": "ze_command_queue_group_property_flags_t",
                "type": "enum"
            },
            "ze_command_queue_mode_t": {
                "class": "zeCommandQueue",
                "desc": "Supported command queue modes",
                "etors": [
                    {
                        "desc": "implicit default behavior; uses driver-based heuristics",
                        "name": "ZE_COMMAND_QUEUE_MODE_DEFAULT",
                        "value": "0"
                    },
                    {
                        "desc": "Device execution always completes immediately on execute;\nHost thread is blocked using wait on implicit synchronization object\n",
                        "name": "ZE_COMMAND_QUEUE_MODE_SYNCHRONOUS",
                        "value": "1"
                    },
                    {
                        "desc": "Device execution is scheduled and will complete in future;\nexplicit synchronization object must be used to determine completeness\n",
                        "name": "ZE_COMMAND_QUEUE_MODE_ASYNCHRONOUS",
                        "value": "2"
                    }
                ],
                "name": "ze_command_queue_mode_t",
                "type": "enum"
            },
            "ze_command_queue_priority_t": {
                "class": "zeCommandQueue",
                "desc": "Supported command queue priorities",
                "etors": [
                    {
                        "desc": "[default] normal priority",
                        "name": "ZE_COMMAND_QUEUE_PRIORITY_NORMAL",
                        "value": "0"
                    },
                    {
                        "desc": "lower priority than normal",
                        "name": "ZE_COMMAND_QUEUE_PRIORITY_PRIORITY_LOW",
                        "value": "1"
                    },
                    {
                        "desc": "higher priority than normal",
                        "name": "ZE_COMMAND_QUEUE_PRIORITY_PRIORITY_HIGH",
                        "value": "2"
                    }
                ],
                "name": "ze_command_queue_priority_t",
                "type": "enum"
            },
            "ze_context_flags_t": {
                "class": "zeContext",
                "desc": "Supported context creation flags",
                "etors": [
                    {
                        "desc": "reserved for future use",
                        "name": "ZE_CONTEXT_FLAG_TBD",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "ze_context_flags_t",
                "type": "enum"
            },
            "ze_device_cache_property_flags_t": {
                "class": "zeDevice",
                "desc": "Supported cache control property flags",
                "etors": [
                    {
                        "desc": "Device support User Cache Control (i.e. SLM section vs Generic Cache)",
                        "name": "ZE_DEVICE_CACHE_PROPERTY_FLAG_USER_CONTROL",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "ze_device_cache_property_flags_t",
                "type": "enum"
            },
            "ze_device_fp_atomic_ext_flags_t": {
                "class": "zeDevice",
                "desc": "Supported floating-point atomic capability flags",
                "etors": [
                    {
                        "desc": "Supports atomic load, store, and exchange",
                        "name": "ZE_DEVICE_FP_ATOMIC_EXT_FLAG_GLOBAL_LOAD_STORE",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Supports atomic add and subtract",
                        "name": "ZE_DEVICE_FP_ATOMIC_EXT_FLAG_GLOBAL_ADD",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Supports atomic min and max",
                        "name": "ZE_DEVICE_FP_ATOMIC_EXT_FLAG_GLOBAL_MIN_MAX",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "Supports atomic load, store, and exchange",
                        "name": "ZE_DEVICE_FP_ATOMIC_EXT_FLAG_LOCAL_LOAD_STORE",
                        "value": "ZE_BIT(16)"
                    },
                    {
                        "desc": "Supports atomic add and subtract",
                        "name": "ZE_DEVICE_FP_ATOMIC_EXT_FLAG_LOCAL_ADD",
                        "value": "ZE_BIT(17)"
                    },
                    {
                        "desc": "Supports atomic min and max",
                        "name": "ZE_DEVICE_FP_ATOMIC_EXT_FLAG_LOCAL_MIN_MAX",
                        "value": "ZE_BIT(18)"
                    }
                ],
                "name": "ze_device_fp_atomic_ext_flags_t",
                "type": "enum",
                "version": "1.1"
            },
            "ze_device_fp_flags_t": {
                "class": "zeDevice",
                "desc": "Supported floating-Point capability flags",
                "etors": [
                    {
                        "desc": "Supports denorms",
                        "name": "ZE_DEVICE_FP_FLAG_DENORM",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Supports INF and quiet NaNs",
                        "name": "ZE_DEVICE_FP_FLAG_INF_NAN",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Supports rounding to nearest even rounding mode",
                        "name": "ZE_DEVICE_FP_FLAG_ROUND_TO_NEAREST",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "Supports rounding to zero.",
                        "name": "ZE_DEVICE_FP_FLAG_ROUND_TO_ZERO",
                        "value": "ZE_BIT(3)"
                    },
                    {
                        "desc": "Supports rounding to both positive and negative INF.",
                        "name": "ZE_DEVICE_FP_FLAG_ROUND_TO_INF",
                        "value": "ZE_BIT(4)"
                    },
                    {
                        "desc": "Supports IEEE754-2008 fused multiply-add.",
                        "name": "ZE_DEVICE_FP_FLAG_FMA",
                        "value": "ZE_BIT(5)"
                    },
                    {
                        "desc": "Supports rounding as defined by IEEE754 for divide and sqrt operations.",
                        "name": "ZE_DEVICE_FP_FLAG_ROUNDED_DIVIDE_SQRT",
                        "value": "ZE_BIT(6)"
                    },
                    {
                        "desc": "Uses software implementation for basic floating-point operations.",
                        "name": "ZE_DEVICE_FP_FLAG_SOFT_FLOAT",
                        "value": "ZE_BIT(7)"
                    }
                ],
                "name": "ze_device_fp_flags_t",
                "type": "enum"
            },
            "ze_device_ip_version_version_t": {
                "desc": "Device IP Version Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_DEVICE_IP_VERSION_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_DEVICE_IP_VERSION_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_device_ip_version_version_t",
                "type": "enum",
                "version": "1.5"
            },
            "ze_device_luid_ext_version_t": {
                "desc": "Device Local Identifier (LUID) Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_DEVICE_LUID_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_DEVICE_LUID_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_device_luid_ext_version_t",
                "type": "enum",
                "version": "1.4"
            },
            "ze_device_mem_alloc_flags_t": {
                "class": "zeMem",
                "desc": "Supported memory allocation flags",
                "etors": [
                    {
                        "desc": "device should cache allocation",
                        "name": "ZE_DEVICE_MEM_ALLOC_FLAG_BIAS_CACHED",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "device should not cache allocation (UC)",
                        "name": "ZE_DEVICE_MEM_ALLOC_FLAG_BIAS_UNCACHED",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "optimize shared allocation for first access on the device",
                        "name": "ZE_DEVICE_MEM_ALLOC_FLAG_BIAS_INITIAL_PLACEMENT",
                        "value": "ZE_BIT(2)",
                        "version": "1.2"
                    }
                ],
                "name": "ze_device_mem_alloc_flags_t",
                "type": "enum"
            },
            "ze_device_memory_ext_type_t": {
                "class": "zeDevice",
                "desc": "Memory module types",
                "etors": [
                    {
                        "desc": "HBM memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_HBM",
                        "value": "0"
                    },
                    {
                        "desc": "HBM2 memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_HBM2",
                        "value": "1"
                    },
                    {
                        "desc": "DDR memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_DDR",
                        "value": "2"
                    },
                    {
                        "desc": "DDR2 memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_DDR2",
                        "value": "3"
                    },
                    {
                        "desc": "DDR3 memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_DDR3",
                        "value": "4"
                    },
                    {
                        "desc": "DDR4 memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_DDR4",
                        "value": "5"
                    },
                    {
                        "desc": "DDR5 memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_DDR5",
                        "value": "6"
                    },
                    {
                        "desc": "LPDDR memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_LPDDR",
                        "value": "7"
                    },
                    {
                        "desc": "LPDDR3 memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_LPDDR3",
                        "value": "8"
                    },
                    {
                        "desc": "LPDDR4 memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_LPDDR4",
                        "value": "9"
                    },
                    {
                        "desc": "LPDDR5 memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_LPDDR5",
                        "value": "10"
                    },
                    {
                        "desc": "SRAM memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_SRAM",
                        "value": "11"
                    },
                    {
                        "desc": "L1 cache",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_L1",
                        "value": "12"
                    },
                    {
                        "desc": "L3 cache",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_L3",
                        "value": "13"
                    },
                    {
                        "desc": "Execution unit register file",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_GRF",
                        "value": "14"
                    },
                    {
                        "desc": "Execution unit shared local memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_SLM",
                        "value": "15"
                    },
                    {
                        "desc": "GDDR4 memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_GDDR4",
                        "value": "16"
                    },
                    {
                        "desc": "GDDR5 memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_GDDR5",
                        "value": "17"
                    },
                    {
                        "desc": "GDDR5X memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_GDDR5X",
                        "value": "18"
                    },
                    {
                        "desc": "GDDR6 memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_GDDR6",
                        "value": "19"
                    },
                    {
                        "desc": "GDDR6X memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_GDDR6X",
                        "value": "20"
                    },
                    {
                        "desc": "GDDR7 memory",
                        "name": "ZE_DEVICE_MEMORY_EXT_TYPE_GDDR7",
                        "value": "21"
                    }
                ],
                "name": "ze_device_memory_ext_type_t",
                "type": "enum",
                "version": "1.4"
            },
            "ze_device_memory_properties_ext_version_t": {
                "desc": "Device Memory Properties Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_DEVICE_MEMORY_PROPERTIES_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_DEVICE_MEMORY_PROPERTIES_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_device_memory_properties_ext_version_t",
                "type": "enum",
                "version": "1.4"
            },
            "ze_device_memory_property_flags_t": {
                "class": "zeDevice",
                "desc": "Supported device memory property flags",
                "etors": [
                    {
                        "desc": "reserved for future use",
                        "name": "ZE_DEVICE_MEMORY_PROPERTY_FLAG_TBD",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "ze_device_memory_property_flags_t",
                "type": "enum"
            },
            "ze_device_module_flags_t": {
                "class": "zeDevice",
                "desc": "Supported device module flags",
                "etors": [
                    {
                        "desc": "Device supports 16-bit floating-point operations",
                        "name": "ZE_DEVICE_MODULE_FLAG_FP16",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Device supports 64-bit floating-point operations",
                        "name": "ZE_DEVICE_MODULE_FLAG_FP64",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Device supports 64-bit atomic operations",
                        "name": "ZE_DEVICE_MODULE_FLAG_INT64_ATOMICS",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "Device supports four component dot product and accumulate operations",
                        "name": "ZE_DEVICE_MODULE_FLAG_DP4A",
                        "value": "ZE_BIT(3)"
                    }
                ],
                "name": "ze_device_module_flags_t",
                "type": "enum"
            },
            "ze_device_p2p_property_flags_t": {
                "class": "zeDevice",
                "desc": "Supported device peer-to-peer property flags",
                "etors": [
                    {
                        "desc": "Device supports access between peer devices.",
                        "name": "ZE_DEVICE_P2P_PROPERTY_FLAG_ACCESS",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Device supports atomics between peer devices.",
                        "name": "ZE_DEVICE_P2P_PROPERTY_FLAG_ATOMICS",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "ze_device_p2p_property_flags_t",
                "type": "enum"
            },
            "ze_device_property_flags_t": {
                "class": "zeDevice",
                "desc": "Supported device property flags",
                "etors": [
                    {
                        "desc": "Device is integrated with the Host.",
                        "name": "ZE_DEVICE_PROPERTY_FLAG_INTEGRATED",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Device handle used for query represents a sub-device.",
                        "name": "ZE_DEVICE_PROPERTY_FLAG_SUBDEVICE",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Device supports error correction memory access.",
                        "name": "ZE_DEVICE_PROPERTY_FLAG_ECC",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "Device supports on-demand page-faulting.",
                        "name": "ZE_DEVICE_PROPERTY_FLAG_ONDEMANDPAGING",
                        "value": "ZE_BIT(3)"
                    }
                ],
                "name": "ze_device_property_flags_t",
                "type": "enum"
            },
            "ze_device_raytracing_ext_flags_t": {
                "class": "zeContext",
                "desc": "Supported raytracing capability flags",
                "etors": [
                    {
                        "desc": "Supports rayquery",
                        "name": "ZE_DEVICE_RAYTRACING_EXT_FLAG_RAYQUERY",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "ze_device_raytracing_ext_flags_t",
                "type": "enum",
                "version": "1.0"
            },
            "ze_device_type_t": {
                "class": "zeDevice",
                "desc": "Supported device types",
                "etors": [
                    {
                        "desc": "Graphics Processing Unit",
                        "name": "ZE_DEVICE_TYPE_GPU",
                        "value": "1"
                    },
                    {
                        "desc": "Central Processing Unit",
                        "name": "ZE_DEVICE_TYPE_CPU",
                        "value": "2"
                    },
                    {
                        "desc": "Field Programmable Gate Array",
                        "name": "ZE_DEVICE_TYPE_FPGA",
                        "value": "3"
                    },
                    {
                        "desc": "Memory Copy Accelerator",
                        "name": "ZE_DEVICE_TYPE_MCA",
                        "value": "4"
                    },
                    {
                        "desc": "Vision Processing Unit",
                        "name": "ZE_DEVICE_TYPE_VPU",
                        "value": "5"
                    }
                ],
                "name": "ze_device_type_t",
                "type": "enum"
            },
            "ze_driver_memory_free_policy_ext_flags_t": {
                "class": "zeDriver",
                "desc": "Supported memory free policy capability flags",
                "etors": [
                    {
                        "desc": "blocks until all commands using the memory are complete before freeing",
                        "name": "ZE_DRIVER_MEMORY_FREE_POLICY_EXT_FLAG_BLOCKING_FREE",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "schedules the memory to be freed but does not free immediately",
                        "name": "ZE_DRIVER_MEMORY_FREE_POLICY_EXT_FLAG_DEFER_FREE",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "ze_driver_memory_free_policy_ext_flags_t",
                "type": "enum",
                "version": "1.3"
            },
            "ze_eu_count_ext_version_t": {
                "desc": "EU Count Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_EU_COUNT_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_EU_COUNT_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_eu_count_ext_version_t",
                "type": "enum",
                "version": "1.3"
            },
            "ze_event_pool_flags_t": {
                "class": "zeEventPool",
                "desc": "Supported event pool creation flags",
                "etors": [
                    {
                        "desc": "signals and waits are also visible to host",
                        "name": "ZE_EVENT_POOL_FLAG_HOST_VISIBLE",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "signals and waits may be shared across processes",
                        "name": "ZE_EVENT_POOL_FLAG_IPC",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Indicates all events in pool will contain kernel timestamps",
                        "name": "ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "Indicates all events in pool will contain kernel timestamps synchronized to host time domain; cannot be combined with ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP",
                        "name": "ZE_EVENT_POOL_FLAG_KERNEL_MAPPED_TIMESTAMP",
                        "value": "ZE_BIT(3)",
                        "version": "1.6"
                    }
                ],
                "name": "ze_event_pool_flags_t",
                "type": "enum"
            },
            "ze_event_query_kernel_timestamps_ext_flags_t": {
                "class": "zeEvent",
                "desc": "Event query kernel timestamps flags",
                "etors": [
                    {
                        "desc": "Kernel timestamp results",
                        "name": "ZE_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_FLAG_KERNEL",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Device event timestamps synchronized to the host time domain",
                        "name": "ZE_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_FLAG_SYNCHRONIZED",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "ze_event_query_kernel_timestamps_ext_flags_t",
                "type": "enum",
                "version": "1.6"
            },
            "ze_event_query_kernel_timestamps_ext_version_t": {
                "desc": "Event Query Kernel Timestamps Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_event_query_kernel_timestamps_ext_version_t",
                "type": "enum",
                "version": "1.6"
            },
            "ze_event_query_timestamps_exp_version_t": {
                "desc": "Event Query Timestamps Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_EVENT_QUERY_TIMESTAMPS_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_EVENT_QUERY_TIMESTAMPS_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_event_query_timestamps_exp_version_t",
                "type": "enum",
                "version": "1.2"
            },
            "ze_event_scope_flags_t": {
                "class": "zeEvent",
                "desc": "Supported event scope flags",
                "etors": [
                    {
                        "desc": "cache hierarchies are flushed or invalidated sufficient for local sub-device access",
                        "name": "ZE_EVENT_SCOPE_FLAG_SUBDEVICE",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "cache hierarchies are flushed or invalidated sufficient for global device access and peer device access",
                        "name": "ZE_EVENT_SCOPE_FLAG_DEVICE",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "cache hierarchies are flushed or invalidated sufficient for device and host access",
                        "name": "ZE_EVENT_SCOPE_FLAG_HOST",
                        "value": "ZE_BIT(2)"
                    }
                ],
                "name": "ze_event_scope_flags_t",
                "type": "enum"
            },
            "ze_external_memory_type_flags_t": {
                "desc": "External memory type flags",
                "etors": [
                    {
                        "desc": "an opaque POSIX file descriptor handle",
                        "name": "ZE_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_FD",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "a file descriptor handle for a Linux dma_buf",
                        "name": "ZE_EXTERNAL_MEMORY_TYPE_FLAG_DMA_BUF",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "an NT handle",
                        "name": "ZE_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_WIN32",
                        "value": "ZE_BIT(2)",
                        "version": "1.2"
                    },
                    {
                        "desc": "a global share (KMT) handle",
                        "name": "ZE_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_WIN32_KMT",
                        "value": "ZE_BIT(3)",
                        "version": "1.2"
                    },
                    {
                        "desc": "an NT handle referring to a Direct3D 10 or 11 texture resource",
                        "name": "ZE_EXTERNAL_MEMORY_TYPE_FLAG_D3D11_TEXTURE",
                        "value": "ZE_BIT(4)",
                        "version": "1.2"
                    },
                    {
                        "desc": "a global share (KMT) handle referring to a Direct3D 10 or 11 texture resource",
                        "name": "ZE_EXTERNAL_MEMORY_TYPE_FLAG_D3D11_TEXTURE_KMT",
                        "value": "ZE_BIT(5)",
                        "version": "1.2"
                    },
                    {
                        "desc": "an NT handle referring to a Direct3D 12 heap resource",
                        "name": "ZE_EXTERNAL_MEMORY_TYPE_FLAG_D3D12_HEAP",
                        "value": "ZE_BIT(6)",
                        "version": "1.2"
                    },
                    {
                        "desc": "an NT handle referring to a Direct3D 12 committed resource",
                        "name": "ZE_EXTERNAL_MEMORY_TYPE_FLAG_D3D12_RESOURCE",
                        "value": "ZE_BIT(7)",
                        "version": "1.2"
                    }
                ],
                "name": "ze_external_memory_type_flags_t",
                "type": "enum"
            },
            "ze_fabric_edge_exp_duplexity_t": {
                "class": "zeFabricEdge",
                "desc": "Fabric edge duplexity",
                "etors": [
                    {
                        "desc": "Fabric edge duplexity is unknown",
                        "name": "ZE_FABRIC_EDGE_EXP_DUPLEXITY_UNKNOWN",
                        "value": "0"
                    },
                    {
                        "desc": "Fabric edge is half duplex, i.e. stated bandwidth is obtained in only one direction at time",
                        "name": "ZE_FABRIC_EDGE_EXP_DUPLEXITY_HALF_DUPLEX",
                        "value": "1"
                    },
                    {
                        "desc": "Fabric edge is full duplex, i.e. stated bandwidth is supported in both directions simultaneously",
                        "name": "ZE_FABRIC_EDGE_EXP_DUPLEXITY_FULL_DUPLEX",
                        "value": "2"
                    }
                ],
                "name": "ze_fabric_edge_exp_duplexity_t",
                "type": "enum",
                "version": "1.4"
            },
            "ze_fabric_vertex_exp_type_t": {
                "class": "zeFabricVertex",
                "desc": "Fabric Vertex types",
                "etors": [
                    {
                        "desc": "Fabric vertex type is unknown",
                        "name": "ZE_FABRIC_VERTEX_EXP_TYPE_UNKNOWN",
                        "value": "0"
                    },
                    {
                        "desc": "Fabric vertex represents a device",
                        "name": "ZE_FABRIC_VERTEX_EXP_TYPE_DEVICE",
                        "value": "1"
                    },
                    {
                        "desc": "Fabric vertex represents a subdevice",
                        "name": "ZE_FABRIC_VERTEX_EXP_TYPE_SUBDEVICE",
                        "value": "2"
                    },
                    {
                        "desc": "Fabric vertex represents a switch",
                        "name": "ZE_FABRIC_VERTEX_EXP_TYPE_SWITCH",
                        "value": "3"
                    }
                ],
                "name": "ze_fabric_vertex_exp_type_t",
                "type": "enum",
                "version": "1.4"
            },
            "ze_fence_flags_t": {
                "class": "zeFence",
                "desc": "Supported fence creation flags",
                "etors": [
                    {
                        "desc": "fence is created in the signaled state, otherwise not signaled.",
                        "name": "ZE_FENCE_FLAG_SIGNALED",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "ze_fence_flags_t",
                "type": "enum"
            },
            "ze_float_atomics_ext_version_t": {
                "desc": "Floating-Point Atomics Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_FLOAT_ATOMICS_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_FLOAT_ATOMICS_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_float_atomics_ext_version_t",
                "type": "enum",
                "version": "1.1"
            },
            "ze_global_offset_exp_version_t": {
                "desc": "Global Offset Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_GLOBAL_OFFSET_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_GLOBAL_OFFSET_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_global_offset_exp_version_t",
                "type": "enum",
                "version": "1.1"
            },
            "ze_host_mem_alloc_flags_t": {
                "class": "zeMem",
                "desc": "Supported host memory allocation flags",
                "etors": [
                    {
                        "desc": "host should cache allocation",
                        "name": "ZE_HOST_MEM_ALLOC_FLAG_BIAS_CACHED",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "host should not cache allocation (UC)",
                        "name": "ZE_HOST_MEM_ALLOC_FLAG_BIAS_UNCACHED",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "host memory should be allocated write-combined (WC)",
                        "name": "ZE_HOST_MEM_ALLOC_FLAG_BIAS_WRITE_COMBINED",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "optimize shared allocation for first access on the host",
                        "name": "ZE_HOST_MEM_ALLOC_FLAG_BIAS_INITIAL_PLACEMENT",
                        "value": "ZE_BIT(3)",
                        "version": "1.2"
                    }
                ],
                "name": "ze_host_mem_alloc_flags_t",
                "type": "enum"
            },
            "ze_image_copy_ext_version_t": {
                "desc": "Image Copy Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_IMAGE_COPY_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_IMAGE_COPY_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_image_copy_ext_version_t",
                "type": "enum",
                "version": "1.3"
            },
            "ze_image_flags_t": {
                "class": "zeImage",
                "desc": "Supported image creation flags",
                "etors": [
                    {
                        "desc": "kernels will write contents",
                        "name": "ZE_IMAGE_FLAG_KERNEL_WRITE",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "device should not cache contents",
                        "name": "ZE_IMAGE_FLAG_BIAS_UNCACHED",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "ze_image_flags_t",
                "type": "enum"
            },
            "ze_image_format_layout_t": {
                "class": "zeImage",
                "desc": "Supported image format layouts",
                "etors": [
                    {
                        "desc": "8-bit single component layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_8",
                        "value": "0"
                    },
                    {
                        "desc": "16-bit single component layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_16",
                        "value": "1"
                    },
                    {
                        "desc": "32-bit single component layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_32",
                        "value": "2"
                    },
                    {
                        "desc": "2-component 8-bit layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_8_8",
                        "value": "3"
                    },
                    {
                        "desc": "4-component 8-bit layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_8_8_8_8",
                        "value": "4"
                    },
                    {
                        "desc": "2-component 16-bit layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_16_16",
                        "value": "5"
                    },
                    {
                        "desc": "4-component 16-bit layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_16_16_16_16",
                        "value": "6"
                    },
                    {
                        "desc": "2-component 32-bit layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_32_32",
                        "value": "7"
                    },
                    {
                        "desc": "4-component 32-bit layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_32_32_32_32",
                        "value": "8"
                    },
                    {
                        "desc": "4-component 10_10_10_2 layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_10_10_10_2",
                        "value": "9"
                    },
                    {
                        "desc": "3-component 11_11_10 layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_11_11_10",
                        "value": "10"
                    },
                    {
                        "desc": "3-component 5_6_5 layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_5_6_5",
                        "value": "11"
                    },
                    {
                        "desc": "4-component 5_5_5_1 layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_5_5_5_1",
                        "value": "12"
                    },
                    {
                        "desc": "4-component 4_4_4_4 layout",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_4_4_4_4",
                        "value": "13"
                    },
                    {
                        "desc": "Media Format: Y8. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_Y8",
                        "value": "14"
                    },
                    {
                        "desc": "Media Format: NV12. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_NV12",
                        "value": "15"
                    },
                    {
                        "desc": "Media Format: YUYV. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_YUYV",
                        "value": "16"
                    },
                    {
                        "desc": "Media Format: VYUY. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_VYUY",
                        "value": "17"
                    },
                    {
                        "desc": "Media Format: YVYU. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_YVYU",
                        "value": "18"
                    },
                    {
                        "desc": "Media Format: UYVY. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_UYVY",
                        "value": "19"
                    },
                    {
                        "desc": "Media Format: AYUV. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_AYUV",
                        "value": "20"
                    },
                    {
                        "desc": "Media Format: P010. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_P010",
                        "value": "21"
                    },
                    {
                        "desc": "Media Format: Y410. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_Y410",
                        "value": "22"
                    },
                    {
                        "desc": "Media Format: P012. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_P012",
                        "value": "23"
                    },
                    {
                        "desc": "Media Format: Y16. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_Y16",
                        "value": "24"
                    },
                    {
                        "desc": "Media Format: P016. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_P016",
                        "value": "25"
                    },
                    {
                        "desc": "Media Format: Y216. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_Y216",
                        "value": "26"
                    },
                    {
                        "desc": "Media Format: P216. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_P216",
                        "value": "27"
                    },
                    {
                        "desc": "Media Format: P8. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_P8",
                        "value": "28"
                    },
                    {
                        "desc": "Media Format: YUY2. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_YUY2",
                        "value": "29"
                    },
                    {
                        "desc": "Media Format: A8P8. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_A8P8",
                        "value": "30"
                    },
                    {
                        "desc": "Media Format: IA44. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_IA44",
                        "value": "31"
                    },
                    {
                        "desc": "Media Format: AI44. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_AI44",
                        "value": "32"
                    },
                    {
                        "desc": "Media Format: Y416. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_Y416",
                        "value": "33"
                    },
                    {
                        "desc": "Media Format: Y210. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_Y210",
                        "value": "34"
                    },
                    {
                        "desc": "Media Format: I420. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_I420",
                        "value": "35"
                    },
                    {
                        "desc": "Media Format: YV12. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_YV12",
                        "value": "36"
                    },
                    {
                        "desc": "Media Format: 400P. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_400P",
                        "value": "37"
                    },
                    {
                        "desc": "Media Format: 422H. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_422H",
                        "value": "38"
                    },
                    {
                        "desc": "Media Format: 422V. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_422V",
                        "value": "39"
                    },
                    {
                        "desc": "Media Format: 444P. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_444P",
                        "value": "40"
                    },
                    {
                        "desc": "Media Format: RGBP. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_RGBP",
                        "value": "41"
                    },
                    {
                        "desc": "Media Format: BRGP. Format type and swizzle is ignored for this.",
                        "name": "ZE_IMAGE_FORMAT_LAYOUT_BRGP",
                        "value": "42"
                    }
                ],
                "name": "ze_image_format_layout_t",
                "type": "enum"
            },
            "ze_image_format_swizzle_t": {
                "class": "zeImage",
                "desc": "Supported image format component swizzle into channel",
                "etors": [
                    {
                        "desc": "Red component",
                        "name": "ZE_IMAGE_FORMAT_SWIZZLE_R",
                        "value": "0"
                    },
                    {
                        "desc": "Green component",
                        "name": "ZE_IMAGE_FORMAT_SWIZZLE_G",
                        "value": "1"
                    },
                    {
                        "desc": "Blue component",
                        "name": "ZE_IMAGE_FORMAT_SWIZZLE_B",
                        "value": "2"
                    },
                    {
                        "desc": "Alpha component",
                        "name": "ZE_IMAGE_FORMAT_SWIZZLE_A",
                        "value": "3"
                    },
                    {
                        "desc": "Zero",
                        "name": "ZE_IMAGE_FORMAT_SWIZZLE_0",
                        "value": "4"
                    },
                    {
                        "desc": "One",
                        "name": "ZE_IMAGE_FORMAT_SWIZZLE_1",
                        "value": "5"
                    },
                    {
                        "desc": "Don't care",
                        "name": "ZE_IMAGE_FORMAT_SWIZZLE_X",
                        "value": "6"
                    }
                ],
                "name": "ze_image_format_swizzle_t",
                "type": "enum"
            },
            "ze_image_format_type_t": {
                "class": "zeImage",
                "desc": "Supported image format types",
                "etors": [
                    {
                        "desc": "Unsigned integer",
                        "name": "ZE_IMAGE_FORMAT_TYPE_UINT",
                        "value": "0"
                    },
                    {
                        "desc": "Signed integer",
                        "name": "ZE_IMAGE_FORMAT_TYPE_SINT",
                        "value": "1"
                    },
                    {
                        "desc": "Unsigned normalized integer",
                        "name": "ZE_IMAGE_FORMAT_TYPE_UNORM",
                        "value": "2"
                    },
                    {
                        "desc": "Signed normalized integer",
                        "name": "ZE_IMAGE_FORMAT_TYPE_SNORM",
                        "value": "3"
                    },
                    {
                        "desc": "Float",
                        "name": "ZE_IMAGE_FORMAT_TYPE_FLOAT",
                        "value": "4"
                    }
                ],
                "name": "ze_image_format_type_t",
                "type": "enum"
            },
            "ze_image_memory_properties_exp_version_t": {
                "desc": "Image Memory Properties Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_IMAGE_MEMORY_PROPERTIES_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_IMAGE_MEMORY_PROPERTIES_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_image_memory_properties_exp_version_t",
                "type": "enum",
                "version": "1.2"
            },
            "ze_image_query_alloc_properties_ext_version_t": {
                "desc": "Image Query Allocation Properties Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_IMAGE_QUERY_ALLOC_PROPERTIES_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_IMAGE_QUERY_ALLOC_PROPERTIES_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_image_query_alloc_properties_ext_version_t",
                "type": "enum",
                "version": "1.3"
            },
            "ze_image_sampler_filter_flags_t": {
                "class": "zeImage",
                "desc": "Supported sampler filtering flags",
                "etors": [
                    {
                        "desc": "device supports point filtering",
                        "name": "ZE_IMAGE_SAMPLER_FILTER_FLAG_POINT",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "device supports linear filtering",
                        "name": "ZE_IMAGE_SAMPLER_FILTER_FLAG_LINEAR",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "ze_image_sampler_filter_flags_t",
                "type": "enum"
            },
            "ze_image_type_t": {
                "class": "zeImage",
                "desc": "Supported image types",
                "etors": [
                    {
                        "desc": "1D",
                        "name": "ZE_IMAGE_TYPE_1D",
                        "value": "0"
                    },
                    {
                        "desc": "1D array",
                        "name": "ZE_IMAGE_TYPE_1DARRAY",
                        "value": "1"
                    },
                    {
                        "desc": "2D",
                        "name": "ZE_IMAGE_TYPE_2D",
                        "value": "2"
                    },
                    {
                        "desc": "2D array",
                        "name": "ZE_IMAGE_TYPE_2DARRAY",
                        "value": "3"
                    },
                    {
                        "desc": "3D",
                        "name": "ZE_IMAGE_TYPE_3D",
                        "value": "4"
                    },
                    {
                        "desc": "Buffer",
                        "name": "ZE_IMAGE_TYPE_BUFFER",
                        "value": "5"
                    }
                ],
                "name": "ze_image_type_t",
                "type": "enum"
            },
            "ze_image_view_exp_version_t": {
                "desc": "Image View Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_IMAGE_VIEW_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_IMAGE_VIEW_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_image_view_exp_version_t",
                "type": "enum",
                "version": "1.2"
            },
            "ze_image_view_ext_version_t": {
                "desc": "Image View Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_IMAGE_VIEW_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_IMAGE_VIEW_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_image_view_ext_version_t",
                "type": "enum",
                "version": "1.5"
            },
            "ze_image_view_planar_exp_version_t": {
                "desc": "Image View Planar Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_IMAGE_VIEW_PLANAR_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_IMAGE_VIEW_PLANAR_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_image_view_planar_exp_version_t",
                "type": "enum",
                "version": "1.2"
            },
            "ze_image_view_planar_ext_version_t": {
                "desc": "Image View Planar Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_IMAGE_VIEW_PLANAR_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_IMAGE_VIEW_PLANAR_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_image_view_planar_ext_version_t",
                "type": "enum",
                "version": "1.5"
            },
            "ze_init_flags_t": {
                "class": "ze",
                "desc": "Supported initialization flags",
                "etors": [
                    {
                        "desc": "only initialize GPU drivers",
                        "name": "ZE_INIT_FLAG_GPU_ONLY",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "only initialize VPU drivers",
                        "name": "ZE_INIT_FLAG_VPU_ONLY",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "ze_init_flags_t",
                "type": "enum"
            },
            "ze_ipc_memory_flags_t": {
                "class": "zeMem",
                "desc": "Supported IPC memory flags",
                "etors": [
                    {
                        "desc": "device should cache allocation",
                        "name": "ZE_IPC_MEMORY_FLAG_BIAS_CACHED",
                        "value": "ZE_BIT(0)",
                        "version": "1.2"
                    },
                    {
                        "desc": "device should not cache allocation (UC)",
                        "name": "ZE_IPC_MEMORY_FLAG_BIAS_UNCACHED",
                        "value": "ZE_BIT(1)",
                        "version": "1.2"
                    }
                ],
                "name": "ze_ipc_memory_flags_t",
                "type": "enum"
            },
            "ze_ipc_property_flags_t": {
                "class": "zeDriver",
                "desc": "Supported IPC property flags",
                "etors": [
                    {
                        "desc": "Supports passing memory allocations between processes. See zeMemGetIpcHandle.",
                        "name": "ZE_IPC_PROPERTY_FLAG_MEMORY",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Supports passing event pools between processes. See zeEventPoolGetIpcHandle.",
                        "name": "ZE_IPC_PROPERTY_FLAG_EVENT_POOL",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "ze_ipc_property_flags_t",
                "type": "enum"
            },
            "ze_kernel_flags_t": {
                "class": "zeKernel",
                "desc": "Supported kernel creation flags",
                "etors": [
                    {
                        "desc": "force all device allocations to be resident during execution",
                        "name": "ZE_KERNEL_FLAG_FORCE_RESIDENCY",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "application is responsible for all residency of device allocations.\ndriver may disable implicit residency management.\n",
                        "name": "ZE_KERNEL_FLAG_EXPLICIT_RESIDENCY",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "ze_kernel_flags_t",
                "type": "enum"
            },
            "ze_kernel_indirect_access_flags_t": {
                "class": "zeKernel",
                "desc": "Kernel indirect access flags",
                "etors": [
                    {
                        "desc": "Indicates that the kernel accesses host allocations indirectly.",
                        "name": "ZE_KERNEL_INDIRECT_ACCESS_FLAG_HOST",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Indicates that the kernel accesses device allocations indirectly.",
                        "name": "ZE_KERNEL_INDIRECT_ACCESS_FLAG_DEVICE",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Indicates that the kernel accesses shared allocations indirectly.",
                        "name": "ZE_KERNEL_INDIRECT_ACCESS_FLAG_SHARED",
                        "value": "ZE_BIT(2)"
                    }
                ],
                "name": "ze_kernel_indirect_access_flags_t",
                "type": "enum"
            },
            "ze_kernel_max_group_size_properties_ext_version_t": {
                "desc": "Kernel Max Group Size Properties Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_KERNEL_MAX_GROUP_SIZE_PROPERTIES_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_KERNEL_MAX_GROUP_SIZE_PROPERTIES_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_kernel_max_group_size_properties_ext_version_t",
                "type": "enum",
                "version": "1.5"
            },
            "ze_latency_unit_t": {
                "desc": "Latency unit",
                "etors": [
                    {
                        "desc": "The unit used for latency is unknown",
                        "name": "ZE_LATENCY_UNIT_UNKNOWN",
                        "value": "0"
                    },
                    {
                        "desc": "Latency is provided in nanosecs",
                        "name": "ZE_LATENCY_UNIT_NANOSEC",
                        "value": "1"
                    },
                    {
                        "desc": "Latency is provided in clocks",
                        "name": "ZE_LATENCY_UNIT_CLOCK",
                        "value": "2"
                    },
                    {
                        "desc": "Latency is provided in hops (normalized so that the lowest latency link has a latency of 1 hop)",
                        "name": "ZE_LATENCY_UNIT_HOP",
                        "value": "3"
                    }
                ],
                "name": "ze_latency_unit_t",
                "type": "enum",
                "version": "1.4"
            },
            "ze_linkage_inspection_ext_flags_t": {
                "class": "zeModule",
                "desc": "Supported module linkage inspection flags",
                "etors": [
                    {
                        "desc": "List all imports of modules",
                        "name": "ZE_LINKAGE_INSPECTION_EXT_FLAG_IMPORTS",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "List all imports of modules that do not have a corresponding export",
                        "name": "ZE_LINKAGE_INSPECTION_EXT_FLAG_UNRESOLVABLE_IMPORTS",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "List all exports of modules",
                        "name": "ZE_LINKAGE_INSPECTION_EXT_FLAG_EXPORTS",
                        "value": "ZE_BIT(2)"
                    }
                ],
                "name": "ze_linkage_inspection_ext_flags_t",
                "type": "enum",
                "version": "1.3"
            },
            "ze_linkage_inspection_ext_version_t": {
                "desc": "Linkage Inspection Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_LINKAGE_INSPECTION_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_LINKAGE_INSPECTION_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_linkage_inspection_ext_version_t",
                "type": "enum",
                "version": "1.3"
            },
            "ze_linkonce_odr_ext_version_t": {
                "desc": "Linkonce ODR Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_LINKONCE_ODR_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_LINKONCE_ODR_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_linkonce_odr_ext_version_t",
                "type": "enum",
                "version": "1.2"
            },
            "ze_memory_access_attribute_t": {
                "class": "zeVirtualMem",
                "desc": "Virtual memory page access attributes",
                "etors": [
                    {
                        "desc": "Indicates the memory page is inaccessible.",
                        "name": "ZE_MEMORY_ACCESS_ATTRIBUTE_NONE",
                        "value": "0"
                    },
                    {
                        "desc": "Indicates the memory page supports read write access.",
                        "name": "ZE_MEMORY_ACCESS_ATTRIBUTE_READWRITE",
                        "value": "1"
                    },
                    {
                        "desc": "Indicates the memory page supports read-only access.",
                        "name": "ZE_MEMORY_ACCESS_ATTRIBUTE_READONLY",
                        "value": "2"
                    }
                ],
                "name": "ze_memory_access_attribute_t",
                "type": "enum"
            },
            "ze_memory_access_cap_flags_t": {
                "class": "zeDevice",
                "desc": "Memory access capability flags",
                "details": [
                    "Supported access capabilities for different types of memory allocations"
                ],
                "etors": [
                    {
                        "desc": "Supports load/store access",
                        "name": "ZE_MEMORY_ACCESS_CAP_FLAG_RW",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Supports atomic access",
                        "name": "ZE_MEMORY_ACCESS_CAP_FLAG_ATOMIC",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Supports concurrent access",
                        "name": "ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "Supports concurrent atomic access",
                        "name": "ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT_ATOMIC",
                        "value": "ZE_BIT(3)"
                    }
                ],
                "name": "ze_memory_access_cap_flags_t",
                "type": "enum"
            },
            "ze_memory_advice_t": {
                "class": "zeCommandList",
                "desc": "Supported memory advice hints",
                "etors": [
                    {
                        "desc": "hint that memory will be read from frequently and written to rarely",
                        "name": "ZE_MEMORY_ADVICE_SET_READ_MOSTLY",
                        "value": "0"
                    },
                    {
                        "desc": "removes the effect of ZE_MEMORY_ADVICE_SET_READ_MOSTLY",
                        "name": "ZE_MEMORY_ADVICE_CLEAR_READ_MOSTLY",
                        "value": "1"
                    },
                    {
                        "desc": "hint that the preferred memory location is the specified device",
                        "name": "ZE_MEMORY_ADVICE_SET_PREFERRED_LOCATION",
                        "value": "2"
                    },
                    {
                        "desc": "removes the effect of ZE_MEMORY_ADVICE_SET_PREFERRED_LOCATION",
                        "name": "ZE_MEMORY_ADVICE_CLEAR_PREFERRED_LOCATION",
                        "value": "3"
                    },
                    {
                        "desc": "hints that memory will mostly be accessed non-atomically",
                        "name": "ZE_MEMORY_ADVICE_SET_NON_ATOMIC_MOSTLY",
                        "value": "4"
                    },
                    {
                        "desc": "removes the effect of ZE_MEMORY_ADVICE_SET_NON_ATOMIC_MOSTLY",
                        "name": "ZE_MEMORY_ADVICE_CLEAR_NON_ATOMIC_MOSTLY",
                        "value": "5"
                    },
                    {
                        "desc": "hints that memory should be cached",
                        "name": "ZE_MEMORY_ADVICE_BIAS_CACHED",
                        "value": "6"
                    },
                    {
                        "desc": "hints that memory should be not be cached",
                        "name": "ZE_MEMORY_ADVICE_BIAS_UNCACHED",
                        "value": "7"
                    },
                    {
                        "desc": "hint that the preferred memory location is host memory",
                        "name": "ZE_MEMORY_ADVICE_SET_SYSTEM_MEMORY_PREFERRED_LOCATION",
                        "value": "8",
                        "version": "1.7"
                    },
                    {
                        "desc": "removes the effect of ZE_MEMORY_ADVICE_SET_SYSTEM_MEMORY_PREFERRED_LOCATION",
                        "name": "ZE_MEMORY_ADVICE_CLEAR_SYSTEM_MEMORY_PREFERRED_LOCATION",
                        "value": "9",
                        "version": "1.7"
                    }
                ],
                "name": "ze_memory_advice_t",
                "type": "enum"
            },
            "ze_memory_atomic_attr_exp_flags_t": {
                "class": "zeMem",
                "desc": "atomic access attribute flags",
                "etors": [
                    {
                        "desc": "Atomics on the pointer are not allowed",
                        "name": "ZE_MEMORY_ATOMIC_ATTR_EXP_FLAG_NO_ATOMICS",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Host atomics on the pointer are not allowed",
                        "name": "ZE_MEMORY_ATOMIC_ATTR_EXP_FLAG_NO_HOST_ATOMICS",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Host atomics on the pointer are allowed. Requires ZE_MEMORY_ACCESS_CAP_FLAG_ATOMIC returned by zeDeviceGetMemoryAccessProperties.",
                        "name": "ZE_MEMORY_ATOMIC_ATTR_EXP_FLAG_HOST_ATOMICS",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "Device atomics on the pointer are not allowed",
                        "name": "ZE_MEMORY_ATOMIC_ATTR_EXP_FLAG_NO_DEVICE_ATOMICS",
                        "value": "ZE_BIT(3)"
                    },
                    {
                        "desc": "Device atomics on the pointer are allowed. Requires ZE_MEMORY_ACCESS_CAP_FLAG_ATOMIC returned by zeDeviceGetMemoryAccessProperties.",
                        "name": "ZE_MEMORY_ATOMIC_ATTR_EXP_FLAG_DEVICE_ATOMICS",
                        "value": "ZE_BIT(4)"
                    },
                    {
                        "desc": "Concurrent atomics on the pointer from both host and device are not allowed",
                        "name": "ZE_MEMORY_ATOMIC_ATTR_EXP_FLAG_NO_SYSTEM_ATOMICS",
                        "value": "ZE_BIT(5)"
                    },
                    {
                        "desc": "Concurrent atomics on the pointer from both host and device are allowed. Requires ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT_ATOMIC returned by zeDeviceGetMemoryAccessProperties.",
                        "name": "ZE_MEMORY_ATOMIC_ATTR_EXP_FLAG_SYSTEM_ATOMICS",
                        "value": "ZE_BIT(6)"
                    }
                ],
                "name": "ze_memory_atomic_attr_exp_flags_t",
                "type": "enum",
                "version": "1.7"
            },
            "ze_memory_compression_hints_ext_flags_t": {
                "class": "zeMem",
                "desc": "Supported memory compression hints flags",
                "etors": [
                    {
                        "desc": "Hint Driver implementation to make allocation compressible",
                        "name": "ZE_MEMORY_COMPRESSION_HINTS_EXT_FLAG_COMPRESSED",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Hint Driver implementation to make allocation not compressible",
                        "name": "ZE_MEMORY_COMPRESSION_HINTS_EXT_FLAG_UNCOMPRESSED",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "ze_memory_compression_hints_ext_flags_t",
                "type": "enum",
                "version": "1.3"
            },
            "ze_memory_compression_hints_ext_version_t": {
                "desc": "Memory Compression Hints Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_MEMORY_COMPRESSION_HINTS_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_MEMORY_COMPRESSION_HINTS_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_memory_compression_hints_ext_version_t",
                "type": "enum",
                "version": "1.3"
            },
            "ze_memory_free_policies_ext_version_t": {
                "desc": "Memory Free Policies Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_MEMORY_FREE_POLICIES_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_MEMORY_FREE_POLICIES_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_memory_free_policies_ext_version_t",
                "type": "enum",
                "version": "1.3"
            },
            "ze_memory_type_t": {
                "class": "zeMem",
                "desc": "Memory allocation type",
                "etors": [
                    {
                        "desc": "the memory pointed to is of unknown type",
                        "name": "ZE_MEMORY_TYPE_UNKNOWN",
                        "value": "0"
                    },
                    {
                        "desc": "the memory pointed to is a host allocation",
                        "name": "ZE_MEMORY_TYPE_HOST",
                        "value": "1"
                    },
                    {
                        "desc": "the memory pointed to is a device allocation",
                        "name": "ZE_MEMORY_TYPE_DEVICE",
                        "value": "2"
                    },
                    {
                        "desc": "the memory pointed to is a shared ownership allocation",
                        "name": "ZE_MEMORY_TYPE_SHARED",
                        "value": "3"
                    }
                ],
                "name": "ze_memory_type_t",
                "type": "enum"
            },
            "ze_metric_global_timestamps_exp_version_t": {
                "desc": "Global Metric Timestamps Experimental Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_METRIC_GLOBAL_TIMESTAMPS_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_METRIC_GLOBAL_TIMESTAMPS_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_metric_global_timestamps_exp_version_t",
                "type": "enum",
                "version": "1.5"
            },
            "ze_module_format_t": {
                "class": "zeModule",
                "desc": "Supported module creation input formats",
                "etors": [
                    {
                        "desc": "Format is SPIRV IL format",
                        "name": "ZE_MODULE_FORMAT_IL_SPIRV",
                        "value": "0"
                    },
                    {
                        "desc": "Format is device native format",
                        "name": "ZE_MODULE_FORMAT_NATIVE",
                        "value": "1"
                    }
                ],
                "name": "ze_module_format_t",
                "type": "enum"
            },
            "ze_module_program_exp_version_t": {
                "desc": "Module Program Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_MODULE_PROGRAM_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_MODULE_PROGRAM_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_module_program_exp_version_t",
                "type": "enum",
                "version": "1.0"
            },
            "ze_module_property_flags_t": {
                "class": "zeModule",
                "desc": "Supported module property flags",
                "etors": [
                    {
                        "desc": "Module has imports (i.e. imported global variables and/or kernels). See zeModuleDynamicLink.",
                        "name": "ZE_MODULE_PROPERTY_FLAG_IMPORTS",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "ze_module_property_flags_t",
                "type": "enum"
            },
            "ze_pci_properties_ext_version_t": {
                "desc": "PCI Properties Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_PCI_PROPERTIES_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_PCI_PROPERTIES_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_pci_properties_ext_version_t",
                "type": "enum",
                "version": "1.3"
            },
            "ze_physical_mem_flags_t": {
                "class": "zePhysicalMem",
                "desc": "Supported physical memory creation flags",
                "etors": [
                    {
                        "desc": "reserved for future use.",
                        "name": "ZE_PHYSICAL_MEM_FLAG_TBD",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "ze_physical_mem_flags_t",
                "type": "enum"
            },
            "ze_power_saving_hint_exp_version_t": {
                "desc": "Power Saving Hint Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_POWER_SAVING_HINT_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_POWER_SAVING_HINT_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_power_saving_hint_exp_version_t",
                "type": "enum",
                "version": "1.2"
            },
            "ze_power_saving_hint_type_t": {
                "class": "zeContext",
                "desc": "Supported device types",
                "etors": [
                    {
                        "desc": "Minumum power savings. The device will make no attempt to save power while executing work submitted to this context.",
                        "name": "ZE_POWER_SAVING_HINT_TYPE_MIN",
                        "value": "0"
                    },
                    {
                        "desc": "Maximum power savings. The device will do everything to bring power to a minimum while executing work submitted to this context.",
                        "name": "ZE_POWER_SAVING_HINT_TYPE_MAX",
                        "value": "100"
                    }
                ],
                "name": "ze_power_saving_hint_type_t",
                "type": "enum",
                "version": "1.2"
            },
            "ze_raytracing_ext_version_t": {
                "desc": "Raytracing Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_RAYTRACING_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_RAYTRACING_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_raytracing_ext_version_t",
                "type": "enum",
                "version": "1.0"
            },
            "ze_raytracing_mem_alloc_ext_flags_t": {
                "class": "zeContext",
                "desc": "Supported raytracing memory allocation flags",
                "etors": [
                    {
                        "desc": "reserved for future use",
                        "name": "ZE_RAYTRACING_MEM_ALLOC_EXT_FLAG_TBD",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "ze_raytracing_mem_alloc_ext_flags_t",
                "type": "enum",
                "version": "1.0"
            },
            "ze_relaxed_allocation_limits_exp_flags_t": {
                "class": "zeMem",
                "desc": "Supported relaxed memory allocation flags",
                "etors": [
                    {
                        "desc": "Allocation size may exceed the `maxMemAllocSize` member of ze_device_properties_t.",
                        "name": "ZE_RELAXED_ALLOCATION_LIMITS_EXP_FLAG_MAX_SIZE",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "ze_relaxed_allocation_limits_exp_flags_t",
                "type": "enum",
                "version": "1.1"
            },
            "ze_relaxed_allocation_limits_exp_version_t": {
                "desc": "Relaxed Allocation Limits Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_RELAXED_ALLOCATION_LIMITS_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_RELAXED_ALLOCATION_LIMITS_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_relaxed_allocation_limits_exp_version_t",
                "type": "enum",
                "version": "1.1"
            },
            "ze_result_t": {
                "desc": "Defines Return/Error codes",
                "etors": [
                    {
                        "desc": "[Core] success",
                        "name": "ZE_RESULT_SUCCESS",
                        "value": "0"
                    },
                    {
                        "desc": "[Core] synchronization primitive not signaled",
                        "name": "ZE_RESULT_NOT_READY",
                        "value": "1"
                    },
                    {
                        "desc": "[Core] device hung, reset, was removed, or driver update occurred",
                        "name": "ZE_RESULT_ERROR_DEVICE_LOST",
                        "value": "0x70000001"
                    },
                    {
                        "desc": "[Core] insufficient host memory to satisfy call",
                        "name": "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY",
                        "value": "0x70000002"
                    },
                    {
                        "desc": "[Core] insufficient device memory to satisfy call",
                        "name": "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY",
                        "value": "0x70000003"
                    },
                    {
                        "desc": "[Core] error occurred when building module, see build log for details",
                        "name": "ZE_RESULT_ERROR_MODULE_BUILD_FAILURE",
                        "value": "0x70000004"
                    },
                    {
                        "desc": "[Core] error occurred when linking modules, see build log for details",
                        "name": "ZE_RESULT_ERROR_MODULE_LINK_FAILURE",
                        "value": "0x70000005"
                    },
                    {
                        "desc": "[Core] device requires a reset",
                        "name": "ZE_RESULT_ERROR_DEVICE_REQUIRES_RESET",
                        "value": "0x70000006",
                        "version": "1.2"
                    },
                    {
                        "desc": "[Core] device currently in low power state",
                        "name": "ZE_RESULT_ERROR_DEVICE_IN_LOW_POWER_STATE",
                        "value": "0x70000007",
                        "version": "1.2"
                    },
                    {
                        "desc": "[Core, Experimental] device is not represented by a fabric vertex",
                        "name": "ZE_RESULT_EXP_ERROR_DEVICE_IS_NOT_VERTEX",
                        "value": "0x7ff00001",
                        "version": "1.4"
                    },
                    {
                        "desc": "[Core, Experimental] fabric vertex does not represent a device",
                        "name": "ZE_RESULT_EXP_ERROR_VERTEX_IS_NOT_DEVICE",
                        "value": "0x7ff00002",
                        "version": "1.4"
                    },
                    {
                        "desc": "[Core, Experimental] fabric vertex represents a remote device or subdevice",
                        "name": "ZE_RESULT_EXP_ERROR_REMOTE_DEVICE",
                        "value": "0x7ff00003",
                        "version": "1.4"
                    },
                    {
                        "desc": "[Core, Experimental] operands of comparison are not compatible",
                        "name": "ZE_RESULT_EXP_ERROR_OPERANDS_INCOMPATIBLE",
                        "value": "0x7ff00004",
                        "version": "1.7"
                    },
                    {
                        "desc": "[Core, Experimental] ray tracing acceleration structure build operation failed due to insufficient resources, retry with a larger acceleration structure buffer allocation",
                        "name": "ZE_RESULT_EXP_RTAS_BUILD_RETRY",
                        "value": "0x7ff00005",
                        "version": "1.7"
                    },
                    {
                        "desc": "[Core, Experimental] ray tracing acceleration structure build operation deferred to parallel operation join",
                        "name": "ZE_RESULT_EXP_RTAS_BUILD_DEFERRED",
                        "value": "0x7ff00006",
                        "version": "1.7"
                    },
                    {
                        "desc": "[Sysman] access denied due to permission level",
                        "name": "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS",
                        "value": "0x70010000"
                    },
                    {
                        "desc": "[Sysman] resource already in use and simultaneous access not allowed or resource was removed",
                        "name": "ZE_RESULT_ERROR_NOT_AVAILABLE",
                        "value": "0x70010001"
                    },
                    {
                        "desc": "[Common] external required dependency is unavailable or missing",
                        "name": "ZE_RESULT_ERROR_DEPENDENCY_UNAVAILABLE",
                        "value": "0x70020000"
                    },
                    {
                        "desc": "[Tools] data may have been dropped",
                        "name": "ZE_RESULT_WARNING_DROPPED_DATA",
                        "value": "0x70020001",
                        "version": "1.4"
                    },
                    {
                        "desc": "[Validation] driver is not initialized",
                        "name": "ZE_RESULT_ERROR_UNINITIALIZED",
                        "value": "0x78000001"
                    },
                    {
                        "desc": "[Validation] generic error code for unsupported versions",
                        "name": "ZE_RESULT_ERROR_UNSUPPORTED_VERSION",
                        "value": "0x78000002"
                    },
                    {
                        "desc": "[Validation] generic error code for unsupported features",
                        "name": "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE",
                        "value": "0x78000003"
                    },
                    {
                        "desc": "[Validation] generic error code for invalid arguments",
                        "name": "ZE_RESULT_ERROR_INVALID_ARGUMENT",
                        "value": "0x78000004"
                    },
                    {
                        "desc": "[Validation] handle argument is not valid",
                        "name": "ZE_RESULT_ERROR_INVALID_NULL_HANDLE",
                        "value": "0x78000005"
                    },
                    {
                        "desc": "[Validation] object pointed to by handle still in-use by device",
                        "name": "ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE",
                        "value": "0x78000006"
                    },
                    {
                        "desc": "[Validation] pointer argument may not be nullptr",
                        "name": "ZE_RESULT_ERROR_INVALID_NULL_POINTER",
                        "value": "0x78000007"
                    },
                    {
                        "desc": "[Validation] size argument is invalid (e.g., must not be zero)",
                        "name": "ZE_RESULT_ERROR_INVALID_SIZE",
                        "value": "0x78000008"
                    },
                    {
                        "desc": "[Validation] size argument is not supported by the device (e.g., too large)",
                        "name": "ZE_RESULT_ERROR_UNSUPPORTED_SIZE",
                        "value": "0x78000009"
                    },
                    {
                        "desc": "[Validation] alignment argument is not supported by the device (e.g., too small)",
                        "name": "ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT",
                        "value": "0x7800000a"
                    },
                    {
                        "desc": "[Validation] synchronization object in invalid state",
                        "name": "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT",
                        "value": "0x7800000b"
                    },
                    {
                        "desc": "[Validation] enumerator argument is not valid",
                        "name": "ZE_RESULT_ERROR_INVALID_ENUMERATION",
                        "value": "0x7800000c"
                    },
                    {
                        "desc": "[Validation] enumerator argument is not supported by the device",
                        "name": "ZE_RESULT_ERROR_UNSUPPORTED_ENUMERATION",
                        "value": "0x7800000d"
                    },
                    {
                        "desc": "[Validation] image format is not supported by the device",
                        "name": "ZE_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT",
                        "value": "0x7800000e"
                    },
                    {
                        "desc": "[Validation] native binary is not supported by the device",
                        "name": "ZE_RESULT_ERROR_INVALID_NATIVE_BINARY",
                        "value": "0x7800000f"
                    },
                    {
                        "desc": "[Validation] global variable is not found in the module",
                        "name": "ZE_RESULT_ERROR_INVALID_GLOBAL_NAME",
                        "value": "0x78000010"
                    },
                    {
                        "desc": "[Validation] kernel name is not found in the module",
                        "name": "ZE_RESULT_ERROR_INVALID_KERNEL_NAME",
                        "value": "0x78000011"
                    },
                    {
                        "desc": "[Validation] function name is not found in the module",
                        "name": "ZE_RESULT_ERROR_INVALID_FUNCTION_NAME",
                        "value": "0x78000012"
                    },
                    {
                        "desc": "[Validation] group size dimension is not valid for the kernel or device",
                        "name": "ZE_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION",
                        "value": "0x78000013"
                    },
                    {
                        "desc": "[Validation] global width dimension is not valid for the kernel or device",
                        "name": "ZE_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION",
                        "value": "0x78000014"
                    },
                    {
                        "desc": "[Validation] kernel argument index is not valid for kernel",
                        "name": "ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX",
                        "value": "0x78000015"
                    },
                    {
                        "desc": "[Validation] kernel argument size does not match kernel",
                        "name": "ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE",
                        "value": "0x78000016"
                    },
                    {
                        "desc": "[Validation] value of kernel attribute is not valid for the kernel or device",
                        "name": "ZE_RESULT_ERROR_INVALID_KERNEL_ATTRIBUTE_VALUE",
                        "value": "0x78000017"
                    },
                    {
                        "desc": "[Validation] module with imports needs to be linked before kernels can be created from it.",
                        "name": "ZE_RESULT_ERROR_INVALID_MODULE_UNLINKED",
                        "value": "0x78000018"
                    },
                    {
                        "desc": "[Validation] command list type does not match command queue type",
                        "name": "ZE_RESULT_ERROR_INVALID_COMMAND_LIST_TYPE",
                        "value": "0x78000019"
                    },
                    {
                        "desc": "[Validation] copy operations do not support overlapping regions of memory",
                        "name": "ZE_RESULT_ERROR_OVERLAPPING_REGIONS",
                        "value": "0x7800001a"
                    },
                    {
                        "desc": "[Sysman] an action is required to complete the desired operation",
                        "name": "ZE_RESULT_WARNING_ACTION_REQUIRED",
                        "value": "0x7800001b"
                    },
                    {
                        "desc": "[Core] unknown or internal error",
                        "name": "ZE_RESULT_ERROR_UNKNOWN",
                        "value": "0x7ffffffe"
                    }
                ],
                "name": "ze_result_t",
                "type": "enum"
            },
            "ze_rtas_builder_build_op_exp_flags_t": {
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure builder build operation flags",
                "details": [
                    "These flags allow the application to tune the acceleration structure build operation.",
                    "The acceleration structure builder implementation might choose to use spatial splitting to split large or long primitives into smaller pieces. This may result in any-hit shaders being invoked multiple times for non-opaque primitives, unless ZE_RTAS_BUILDER_BUILD_OP_EXP_FLAG_NO_DUPLICATE_ANYHIT_INVOCATION is specified.\n",
                    "Usage of any of these flags may reduce ray tracing performance."
                ],
                "etors": [
                    {
                        "desc": "build more compact acceleration structure",
                        "name": "ZE_RTAS_BUILDER_BUILD_OP_EXP_FLAG_COMPACT",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "guarantees single any-hit shader invocation per primitive",
                        "name": "ZE_RTAS_BUILDER_BUILD_OP_EXP_FLAG_NO_DUPLICATE_ANYHIT_INVOCATION",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "ze_rtas_builder_build_op_exp_flags_t",
                "type": "enum",
                "version": "1.7"
            },
            "ze_rtas_builder_build_quality_hint_exp_t": {
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure builder build quality hint",
                "details": [
                    "Depending on use case different quality modes for acceleration structure build are supported.",
                    "A low-quality build builds an acceleration structure fast, but at the cost of some reduction in ray tracing performance. This mode is recommended for dynamic content, such as animated characters.\n",
                    "A medium-quality build uses a compromise between build quality and ray tracing performance. This mode should be used by default.\n",
                    "Higher ray tracing performance can be achieved by using a high-quality build, but acceleration structure build performance might be significantly reduced.\n"
                ],
                "etors": [
                    {
                        "desc": "build low-quality acceleration structure (fast)",
                        "name": "ZE_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_LOW",
                        "value": "0"
                    },
                    {
                        "desc": "build medium-quality acceleration structure (slower)",
                        "name": "ZE_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_MEDIUM",
                        "value": "1"
                    },
                    {
                        "desc": "build high-quality acceleration structure (slow)",
                        "name": "ZE_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_HIGH",
                        "value": "2"
                    }
                ],
                "name": "ze_rtas_builder_build_quality_hint_exp_t",
                "type": "enum",
                "version": "1.7"
            },
            "ze_rtas_builder_exp_flags_t": {
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure builder flags",
                "etors": [
                    {
                        "desc": "Reserved for future use",
                        "name": "ZE_RTAS_BUILDER_EXP_FLAG_RESERVED",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "ze_rtas_builder_exp_flags_t",
                "type": "enum",
                "version": "1.7"
            },
            "ze_rtas_builder_exp_version_t": {
                "desc": "Ray Tracing Acceleration Structure Builder Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_RTAS_BUILDER_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_RTAS_BUILDER_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_rtas_builder_exp_version_t",
                "type": "enum",
                "version": "1.7"
            },
            "ze_rtas_builder_geometry_exp_flags_t": {
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure builder geometry flags",
                "etors": [
                    {
                        "desc": "non-opaque geometries invoke an any-hit shader",
                        "name": "ZE_RTAS_BUILDER_GEOMETRY_EXP_FLAG_NON_OPAQUE",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "ze_rtas_builder_geometry_exp_flags_t",
                "type": "enum",
                "version": "1.7"
            },
            "ze_rtas_builder_geometry_type_exp_t": {
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure builder geometry type",
                "etors": [
                    {
                        "desc": "triangle mesh geometry type",
                        "name": "ZE_RTAS_BUILDER_GEOMETRY_TYPE_EXP_TRIANGLES",
                        "value": "0"
                    },
                    {
                        "desc": "quad mesh geometry type",
                        "name": "ZE_RTAS_BUILDER_GEOMETRY_TYPE_EXP_QUADS",
                        "value": "1"
                    },
                    {
                        "desc": "procedural geometry type",
                        "name": "ZE_RTAS_BUILDER_GEOMETRY_TYPE_EXP_PROCEDURAL",
                        "value": "2"
                    },
                    {
                        "desc": "instance geometry type",
                        "name": "ZE_RTAS_BUILDER_GEOMETRY_TYPE_EXP_INSTANCE",
                        "value": "3"
                    }
                ],
                "name": "ze_rtas_builder_geometry_type_exp_t",
                "type": "enum",
                "version": "1.7"
            },
            "ze_rtas_builder_input_data_format_exp_t": {
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure data buffer element format",
                "details": [
                    "Specifies the format of data buffer elements.",
                    "Data buffers may contain instancing transform matrices, triangle/quad vertex indices, etc..."
                ],
                "etors": [
                    {
                        "desc": "3-component float vector (see ze_rtas_float3_exp_t)",
                        "name": "ZE_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3",
                        "value": "0"
                    },
                    {
                        "desc": "3x4 affine transformation in column-major format (see ze_rtas_transform_float3x4_column_major_exp_t)",
                        "name": "ZE_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3X4_COLUMN_MAJOR",
                        "value": "1"
                    },
                    {
                        "desc": "3x4 affine transformation in column-major format (see ze_rtas_transform_float3x4_aligned_column_major_exp_t)",
                        "name": "ZE_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3X4_ALIGNED_COLUMN_MAJOR",
                        "value": "2"
                    },
                    {
                        "desc": "3x4 affine transformation in row-major format (see ze_rtas_transform_float3x4_row_major_exp_t)",
                        "name": "ZE_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3X4_ROW_MAJOR",
                        "value": "3"
                    },
                    {
                        "desc": "3-dimensional axis-aligned bounding-box (see ze_rtas_aabb_exp_t)",
                        "name": "ZE_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_AABB",
                        "value": "4"
                    },
                    {
                        "desc": "Unsigned 32-bit triangle indices (see ze_rtas_triangle_indices_uint32_exp_t)",
                        "name": "ZE_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_TRIANGLE_INDICES_UINT32",
                        "value": "5"
                    },
                    {
                        "desc": "Unsigned 32-bit quad indices (see ze_rtas_quad_indices_uint32_exp_t)",
                        "name": "ZE_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_QUAD_INDICES_UINT32",
                        "value": "6"
                    }
                ],
                "name": "ze_rtas_builder_input_data_format_exp_t",
                "type": "enum",
                "version": "1.7"
            },
            "ze_rtas_builder_instance_exp_flags_t": {
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure builder instance flags",
                "etors": [
                    {
                        "desc": "disables culling of front-facing and back-facing triangles",
                        "name": "ZE_RTAS_BUILDER_INSTANCE_EXP_FLAG_TRIANGLE_CULL_DISABLE",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "reverses front and back face of triangles",
                        "name": "ZE_RTAS_BUILDER_INSTANCE_EXP_FLAG_TRIANGLE_FRONT_COUNTERCLOCKWISE",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "forces instanced geometry to be opaque, unless ray flag forces it to be non-opaque",
                        "name": "ZE_RTAS_BUILDER_INSTANCE_EXP_FLAG_TRIANGLE_FORCE_OPAQUE",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "forces instanced geometry to be non-opaque, unless ray flag forces it to be opaque",
                        "name": "ZE_RTAS_BUILDER_INSTANCE_EXP_FLAG_TRIANGLE_FORCE_NON_OPAQUE",
                        "value": "ZE_BIT(3)"
                    }
                ],
                "name": "ze_rtas_builder_instance_exp_flags_t",
                "type": "enum",
                "version": "1.7"
            },
            "ze_rtas_device_exp_flags_t": {
                "class": "zeDevice",
                "desc": "Ray tracing acceleration structure device flags",
                "etors": [
                    {
                        "desc": "reserved for future use",
                        "name": "ZE_RTAS_DEVICE_EXP_FLAG_RESERVED",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "ze_rtas_device_exp_flags_t",
                "type": "enum",
                "version": "1.7"
            },
            "ze_rtas_format_exp_t": {
                "class": "zeDevice",
                "desc": "Ray tracing acceleration structure format",
                "details": [
                    "This is an opaque ray tracing acceleration structure format identifier."
                ],
                "etors": [
                    {
                        "desc": "Invalid acceleration structure format",
                        "name": "ZE_RTAS_FORMAT_EXP_INVALID",
                        "value": "0"
                    }
                ],
                "name": "ze_rtas_format_exp_t",
                "type": "enum",
                "version": "1.7"
            },
            "ze_rtas_parallel_operation_exp_flags_t": {
                "class": "zeRTASParallelOperation",
                "desc": "Ray tracing acceleration structure builder parallel operation flags",
                "etors": [
                    {
                        "desc": "Reserved for future use",
                        "name": "ZE_RTAS_PARALLEL_OPERATION_EXP_FLAG_RESERVED",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "ze_rtas_parallel_operation_exp_flags_t",
                "type": "enum",
                "version": "1.7"
            },
            "ze_sampler_address_mode_t": {
                "class": "zeSampler",
                "desc": "Sampler addressing modes",
                "etors": [
                    {
                        "desc": "No coordinate modifications for out-of-bounds image access.",
                        "name": "ZE_SAMPLER_ADDRESS_MODE_NONE",
                        "value": "0"
                    },
                    {
                        "desc": "Out-of-bounds coordinates are wrapped back around.",
                        "name": "ZE_SAMPLER_ADDRESS_MODE_REPEAT",
                        "value": "1"
                    },
                    {
                        "desc": "Out-of-bounds coordinates are clamped to edge.",
                        "name": "ZE_SAMPLER_ADDRESS_MODE_CLAMP",
                        "value": "2"
                    },
                    {
                        "desc": "Out-of-bounds coordinates are clamped to border color which is (0.0f, 0.0f, 0.0f, 0.0f) if image format swizzle contains alpha, otherwise (0.0f, 0.0f, 0.0f, 1.0f).",
                        "name": "ZE_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER",
                        "value": "3"
                    },
                    {
                        "desc": "Out-of-bounds coordinates are mirrored starting from edge.",
                        "name": "ZE_SAMPLER_ADDRESS_MODE_MIRROR",
                        "value": "4"
                    }
                ],
                "name": "ze_sampler_address_mode_t",
                "type": "enum"
            },
            "ze_sampler_filter_mode_t": {
                "class": "zeSampler",
                "desc": "Sampler filtering modes",
                "etors": [
                    {
                        "desc": "No coordinate modifications for out of bounds image access.",
                        "name": "ZE_SAMPLER_FILTER_MODE_NEAREST",
                        "value": "0"
                    },
                    {
                        "desc": "Out-of-bounds coordinates are wrapped back around.",
                        "name": "ZE_SAMPLER_FILTER_MODE_LINEAR",
                        "value": "1"
                    }
                ],
                "name": "ze_sampler_filter_mode_t",
                "type": "enum"
            },
            "ze_scheduling_hint_exp_flags_t": {
                "class": "zeKernel",
                "desc": "Supported kernel scheduling hint flags",
                "etors": [
                    {
                        "desc": "Hint that the kernel prefers oldest-first scheduling",
                        "name": "ZE_SCHEDULING_HINT_EXP_FLAG_OLDEST_FIRST",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Hint that the kernel prefers round-robin scheduling",
                        "name": "ZE_SCHEDULING_HINT_EXP_FLAG_ROUND_ROBIN",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Hint that the kernel prefers stall-based round-robin scheduling",
                        "name": "ZE_SCHEDULING_HINT_EXP_FLAG_STALL_BASED_ROUND_ROBIN",
                        "value": "ZE_BIT(2)"
                    }
                ],
                "name": "ze_scheduling_hint_exp_flags_t",
                "type": "enum",
                "version": "1.2"
            },
            "ze_scheduling_hints_exp_version_t": {
                "desc": "Kernel Scheduling Hints Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_SCHEDULING_HINTS_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_SCHEDULING_HINTS_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_scheduling_hints_exp_version_t",
                "type": "enum",
                "version": "1.2"
            },
            "ze_srgb_ext_version_t": {
                "desc": "sRGB Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_SRGB_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_SRGB_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_srgb_ext_version_t",
                "type": "enum",
                "version": "1.3"
            },
            "ze_structure_type_t": {
                "desc": "Defines structure types",
                "etors": [
                    {
                        "desc": "ze_driver_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DRIVER_PROPERTIES",
                        "value": "0x1"
                    },
                    {
                        "desc": "ze_driver_ipc_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DRIVER_IPC_PROPERTIES",
                        "value": "0x2"
                    },
                    {
                        "desc": "ze_device_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES",
                        "value": "0x3"
                    },
                    {
                        "desc": "ze_device_compute_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_COMPUTE_PROPERTIES",
                        "value": "0x4"
                    },
                    {
                        "desc": "ze_device_module_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_MODULE_PROPERTIES",
                        "value": "0x5"
                    },
                    {
                        "desc": "ze_command_queue_group_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_COMMAND_QUEUE_GROUP_PROPERTIES",
                        "value": "0x6"
                    },
                    {
                        "desc": "ze_device_memory_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_MEMORY_PROPERTIES",
                        "value": "0x7"
                    },
                    {
                        "desc": "ze_device_memory_access_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_MEMORY_ACCESS_PROPERTIES",
                        "value": "0x8"
                    },
                    {
                        "desc": "ze_device_cache_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_CACHE_PROPERTIES",
                        "value": "0x9"
                    },
                    {
                        "desc": "ze_device_image_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_IMAGE_PROPERTIES",
                        "value": "0xa"
                    },
                    {
                        "desc": "ze_device_p2p_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_P2P_PROPERTIES",
                        "value": "0xb"
                    },
                    {
                        "desc": "ze_device_external_memory_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_EXTERNAL_MEMORY_PROPERTIES",
                        "value": "0xc"
                    },
                    {
                        "desc": "ze_context_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_CONTEXT_DESC",
                        "value": "0xd"
                    },
                    {
                        "desc": "ze_command_queue_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_COMMAND_QUEUE_DESC",
                        "value": "0xe"
                    },
                    {
                        "desc": "ze_command_list_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_COMMAND_LIST_DESC",
                        "value": "0xf"
                    },
                    {
                        "desc": "ze_event_pool_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_EVENT_POOL_DESC",
                        "value": "0x10"
                    },
                    {
                        "desc": "ze_event_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_EVENT_DESC",
                        "value": "0x11"
                    },
                    {
                        "desc": "ze_fence_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_FENCE_DESC",
                        "value": "0x12"
                    },
                    {
                        "desc": "ze_image_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_IMAGE_DESC",
                        "value": "0x13"
                    },
                    {
                        "desc": "ze_image_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_IMAGE_PROPERTIES",
                        "value": "0x14"
                    },
                    {
                        "desc": "ze_device_mem_alloc_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_MEM_ALLOC_DESC",
                        "value": "0x15"
                    },
                    {
                        "desc": "ze_host_mem_alloc_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_HOST_MEM_ALLOC_DESC",
                        "value": "0x16"
                    },
                    {
                        "desc": "ze_memory_allocation_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_MEMORY_ALLOCATION_PROPERTIES",
                        "value": "0x17"
                    },
                    {
                        "desc": "ze_external_memory_export_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_DESC",
                        "value": "0x18"
                    },
                    {
                        "desc": "ze_external_memory_import_fd_t",
                        "name": "ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_FD",
                        "value": "0x19"
                    },
                    {
                        "desc": "ze_external_memory_export_fd_t",
                        "name": "ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_FD",
                        "value": "0x1a"
                    },
                    {
                        "desc": "ze_module_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_MODULE_DESC",
                        "value": "0x1b"
                    },
                    {
                        "desc": "ze_module_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_MODULE_PROPERTIES",
                        "value": "0x1c"
                    },
                    {
                        "desc": "ze_kernel_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_KERNEL_DESC",
                        "value": "0x1d"
                    },
                    {
                        "desc": "ze_kernel_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_KERNEL_PROPERTIES",
                        "value": "0x1e"
                    },
                    {
                        "desc": "ze_sampler_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_SAMPLER_DESC",
                        "value": "0x1f"
                    },
                    {
                        "desc": "ze_physical_mem_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_PHYSICAL_MEM_DESC",
                        "value": "0x20"
                    },
                    {
                        "desc": "ze_kernel_preferred_group_size_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_KERNEL_PREFERRED_GROUP_SIZE_PROPERTIES",
                        "value": "0x21",
                        "version": "1.2"
                    },
                    {
                        "desc": "ze_external_memory_import_win32_handle_t",
                        "name": "ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_WIN32",
                        "value": "0x22",
                        "version": "1.2"
                    },
                    {
                        "desc": "ze_external_memory_export_win32_handle_t",
                        "name": "ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_WIN32",
                        "value": "0x23",
                        "version": "1.2"
                    },
                    {
                        "desc": "ze_device_raytracing_ext_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_RAYTRACING_EXT_PROPERTIES",
                        "value": "0x00010001",
                        "version": "1.0"
                    },
                    {
                        "desc": "ze_raytracing_mem_alloc_ext_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_RAYTRACING_MEM_ALLOC_EXT_DESC",
                        "value": "0x10002",
                        "version": "1.0"
                    },
                    {
                        "desc": "ze_float_atomic_ext_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_FLOAT_ATOMIC_EXT_PROPERTIES",
                        "value": "0x10003",
                        "version": "1.1"
                    },
                    {
                        "desc": "ze_cache_reservation_ext_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_CACHE_RESERVATION_EXT_DESC",
                        "value": "0x10004",
                        "version": "1.2"
                    },
                    {
                        "desc": "ze_eu_count_ext_t",
                        "name": "ZE_STRUCTURE_TYPE_EU_COUNT_EXT",
                        "value": "0x10005",
                        "version": "1.3"
                    },
                    {
                        "desc": "ze_srgb_ext_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_SRGB_EXT_DESC",
                        "value": "0x10006",
                        "version": "1.3"
                    },
                    {
                        "desc": "ze_linkage_inspection_ext_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_LINKAGE_INSPECTION_EXT_DESC",
                        "value": "0x10007",
                        "version": "1.3"
                    },
                    {
                        "desc": "ze_pci_ext_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_PCI_EXT_PROPERTIES",
                        "value": "0x10008",
                        "version": "1.3"
                    },
                    {
                        "desc": "ze_driver_memory_free_ext_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DRIVER_MEMORY_FREE_EXT_PROPERTIES",
                        "value": "0x10009",
                        "version": "1.3"
                    },
                    {
                        "desc": "ze_memory_free_ext_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_MEMORY_FREE_EXT_DESC",
                        "value": "0x1000a",
                        "version": "1.3"
                    },
                    {
                        "desc": "ze_memory_compression_hints_ext_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_MEMORY_COMPRESSION_HINTS_EXT_DESC",
                        "value": "0x1000b",
                        "version": "1.3"
                    },
                    {
                        "desc": "ze_image_allocation_ext_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_IMAGE_ALLOCATION_EXT_PROPERTIES",
                        "value": "0x1000c",
                        "version": "1.3"
                    },
                    {
                        "desc": "ze_device_luid_ext_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_LUID_EXT_PROPERTIES",
                        "value": "0x1000d",
                        "version": "1.4"
                    },
                    {
                        "desc": "ze_device_memory_ext_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_MEMORY_EXT_PROPERTIES",
                        "value": "0x1000e",
                        "version": "1.4"
                    },
                    {
                        "desc": "ze_device_ip_version_ext_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_IP_VERSION_EXT",
                        "value": "0x1000f",
                        "version": "1.5"
                    },
                    {
                        "desc": "ze_image_view_planar_ext_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_IMAGE_VIEW_PLANAR_EXT_DESC",
                        "value": "0x10010",
                        "version": "1.5"
                    },
                    {
                        "desc": "ze_event_query_kernel_timestamps_ext_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_PROPERTIES",
                        "value": "0x10011",
                        "version": "1.6"
                    },
                    {
                        "desc": "ze_event_query_kernel_timestamps_results_ext_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_EVENT_QUERY_KERNEL_TIMESTAMPS_RESULTS_EXT_PROPERTIES",
                        "value": "0x10012",
                        "version": "1.6"
                    },
                    {
                        "desc": "ze_kernel_max_group_size_ext_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_KERNEL_MAX_GROUP_SIZE_EXT_PROPERTIES",
                        "value": "0x10013",
                        "version": "1.7"
                    },
                    {
                        "desc": "ze_relaxed_allocation_limits_exp_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_RELAXED_ALLOCATION_LIMITS_EXP_DESC",
                        "value": "0x00020001",
                        "version": "1.1"
                    },
                    {
                        "desc": "ze_module_program_exp_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_MODULE_PROGRAM_EXP_DESC",
                        "value": "0x00020002",
                        "version": "1.0"
                    },
                    {
                        "desc": "ze_scheduling_hint_exp_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_SCHEDULING_HINT_EXP_PROPERTIES",
                        "value": "0x00020003",
                        "version": "1.2"
                    },
                    {
                        "desc": "ze_scheduling_hint_exp_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_SCHEDULING_HINT_EXP_DESC",
                        "value": "0x00020004",
                        "version": "1.2"
                    },
                    {
                        "desc": "ze_image_view_planar_exp_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_IMAGE_VIEW_PLANAR_EXP_DESC",
                        "value": "0x00020005",
                        "version": "1.2"
                    },
                    {
                        "desc": "ze_device_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES_1_2",
                        "value": "0x00020006",
                        "version": "1.2"
                    },
                    {
                        "desc": "ze_image_memory_properties_exp_t",
                        "name": "ZE_STRUCTURE_TYPE_IMAGE_MEMORY_EXP_PROPERTIES",
                        "value": "0x00020007",
                        "version": "1.2"
                    },
                    {
                        "desc": "ze_context_power_saving_hint_exp_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_POWER_SAVING_HINT_EXP_DESC",
                        "value": "0x00020008",
                        "version": "1.2"
                    },
                    {
                        "desc": "ze_copy_bandwidth_exp_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_COPY_BANDWIDTH_EXP_PROPERTIES",
                        "value": "0x00020009",
                        "version": "1.4"
                    },
                    {
                        "desc": "ze_device_p2p_bandwidth_exp_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_DEVICE_P2P_BANDWIDTH_EXP_PROPERTIES",
                        "value": "0x0002000A",
                        "version": "1.4"
                    },
                    {
                        "desc": "ze_fabric_vertex_exp_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_FABRIC_VERTEX_EXP_PROPERTIES",
                        "value": "0x0002000B",
                        "version": "1.4"
                    },
                    {
                        "desc": "ze_fabric_edge_exp_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_FABRIC_EDGE_EXP_PROPERTIES",
                        "value": "0x0002000C",
                        "version": "1.4"
                    },
                    {
                        "desc": "ze_memory_sub_allocations_exp_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_MEMORY_SUB_ALLOCATIONS_EXP_PROPERTIES",
                        "value": "0x0002000D",
                        "version": "1.5"
                    },
                    {
                        "desc": "ze_rtas_builder_exp_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_RTAS_BUILDER_EXP_DESC",
                        "value": "0x0002000E",
                        "version": "1.7"
                    },
                    {
                        "desc": "ze_rtas_builder_build_op_exp_desc_t",
                        "name": "ZE_STRUCTURE_TYPE_RTAS_BUILDER_BUILD_OP_EXP_DESC",
                        "value": "0x0002000F",
                        "version": "1.7"
                    },
                    {
                        "desc": "ze_rtas_builder_exp_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_RTAS_BUILDER_EXP_PROPERTIES",
                        "value": "0x00020010",
                        "version": "1.7"
                    },
                    {
                        "desc": "ze_rtas_parallel_operation_exp_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_RTAS_PARALLEL_OPERATION_EXP_PROPERTIES",
                        "value": "0x00020011",
                        "version": "1.7"
                    },
                    {
                        "desc": "ze_rtas_device_exp_properties_t",
                        "name": "ZE_STRUCTURE_TYPE_RTAS_DEVICE_EXP_PROPERTIES",
                        "value": "0x00020012",
                        "version": "1.7"
                    },
                    {
                        "desc": "ze_rtas_geometry_aabbs_exp_cb_params_t",
                        "name": "ZE_STRUCTURE_TYPE_RTAS_GEOMETRY_AABBS_EXP_CB_PARAMS",
                        "value": "0x00020013",
                        "version": "1.7"
                    }
                ],
                "name": "ze_structure_type_t",
                "type": "enum"
            },
            "ze_sub_allocations_exp_version_t": {
                "desc": "Sub-Allocations Properties Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_SUB_ALLOCATIONS_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_SUB_ALLOCATIONS_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_sub_allocations_exp_version_t",
                "type": "enum",
                "version": "1.5"
            },
            "ze_subgroup_ext_version_t": {
                "desc": "Subgroups Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZE_SUBGROUP_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZE_SUBGROUP_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "ze_subgroup_ext_version_t",
                "type": "enum",
                "version": "1.2"
            },
            "zes_control_state_t": {
                "class": "zesOverclock",
                "desc": "Overclock control states.",
                "etors": [
                    {
                        "desc": "No overclock control has not been changed by the driver since the last boot/reset.",
                        "name": "ZES_CONTROL_STATE_STATE_UNSET",
                        "value": "0"
                    },
                    {
                        "desc": "The overclock control has been set and it is active.",
                        "name": "ZES_CONTROL_STATE_STATE_ACTIVE",
                        "value": "2"
                    },
                    {
                        "desc": "The overclock control value has been disabled due to the current power configuration (typically when running on DC).",
                        "name": "ZES_CONTROL_STATE_STATE_DISABLED",
                        "value": "3"
                    }
                ],
                "name": "zes_control_state_t",
                "type": "enum",
                "version": "1.5"
            },
            "zes_device_action_t": {
                "class": "zesDevice",
                "desc": "State Change Requirements",
                "etors": [
                    {
                        "desc": "No action.",
                        "name": "ZES_DEVICE_ACTION_NONE",
                        "value": "0"
                    },
                    {
                        "desc": "Warm reset of the card.",
                        "name": "ZES_DEVICE_ACTION_WARM_CARD_RESET",
                        "value": "1"
                    },
                    {
                        "desc": "Cold reset of the card.",
                        "name": "ZES_DEVICE_ACTION_COLD_CARD_RESET",
                        "value": "2"
                    },
                    {
                        "desc": "Cold reboot of the system.",
                        "name": "ZES_DEVICE_ACTION_COLD_SYSTEM_REBOOT",
                        "value": "3"
                    }
                ],
                "name": "zes_device_action_t",
                "type": "enum",
                "version": "1.4"
            },
            "zes_device_ecc_state_t": {
                "class": "zesDevice",
                "desc": "ECC State",
                "etors": [
                    {
                        "desc": "None",
                        "name": "ZES_DEVICE_ECC_STATE_UNAVAILABLE",
                        "value": "0"
                    },
                    {
                        "desc": "ECC enabled.",
                        "name": "ZES_DEVICE_ECC_STATE_ENABLED",
                        "value": "1"
                    },
                    {
                        "desc": "ECC disabled.",
                        "name": "ZES_DEVICE_ECC_STATE_DISABLED",
                        "value": "2"
                    }
                ],
                "name": "zes_device_ecc_state_t",
                "type": "enum",
                "version": "1.4"
            },
            "zes_device_property_flags_t": {
                "class": "zesDevice",
                "desc": "Supported device property flags",
                "etors": [
                    {
                        "desc": "Device is integrated with the Host.",
                        "name": "ZES_DEVICE_PROPERTY_FLAG_INTEGRATED",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Device handle used for query represents a sub-device.",
                        "name": "ZES_DEVICE_PROPERTY_FLAG_SUBDEVICE",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Device supports error correction memory access.",
                        "name": "ZES_DEVICE_PROPERTY_FLAG_ECC",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "Device supports on-demand page-faulting.",
                        "name": "ZES_DEVICE_PROPERTY_FLAG_ONDEMANDPAGING",
                        "value": "ZE_BIT(3)"
                    }
                ],
                "name": "zes_device_property_flags_t",
                "type": "enum",
                "version": "1.7"
            },
            "zes_device_type_t": {
                "class": "zesDevice",
                "desc": "Supported device types",
                "etors": [
                    {
                        "desc": "Graphics Processing Unit",
                        "name": "ZES_DEVICE_TYPE_GPU",
                        "value": "1"
                    },
                    {
                        "desc": "Central Processing Unit",
                        "name": "ZES_DEVICE_TYPE_CPU",
                        "value": "2"
                    },
                    {
                        "desc": "Field Programmable Gate Array",
                        "name": "ZES_DEVICE_TYPE_FPGA",
                        "value": "3"
                    },
                    {
                        "desc": "Memory Copy Accelerator",
                        "name": "ZES_DEVICE_TYPE_MCA",
                        "value": "4"
                    },
                    {
                        "desc": "Vision Processing Unit",
                        "name": "ZES_DEVICE_TYPE_VPU",
                        "value": "5"
                    }
                ],
                "name": "zes_device_type_t",
                "type": "enum",
                "version": "1.7"
            },
            "zes_diag_result_t": {
                "class": "zesDiagnostics",
                "desc": "Diagnostic results",
                "etors": [
                    {
                        "desc": "Diagnostic completed without finding errors to repair",
                        "name": "ZES_DIAG_RESULT_NO_ERRORS",
                        "value": "0"
                    },
                    {
                        "desc": "Diagnostic had problems running tests",
                        "name": "ZES_DIAG_RESULT_ABORT",
                        "value": "1"
                    },
                    {
                        "desc": "Diagnostic had problems setting up repairs",
                        "name": "ZES_DIAG_RESULT_FAIL_CANT_REPAIR",
                        "value": "2"
                    },
                    {
                        "desc": "Diagnostics found errors, setup for repair and reboot is required to complete the process",
                        "name": "ZES_DIAG_RESULT_REBOOT_FOR_REPAIR",
                        "value": "3"
                    }
                ],
                "name": "zes_diag_result_t",
                "type": "enum"
            },
            "zes_engine_activity_ext_version_t": {
                "desc": "Engine Activity Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZES_ENGINE_ACTIVITY_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZES_ENGINE_ACTIVITY_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "zes_engine_activity_ext_version_t",
                "type": "enum",
                "version": "1.7"
            },
            "zes_engine_group_t": {
                "class": "zesEngine",
                "desc": "Accelerator engine groups",
                "etors": [
                    {
                        "desc": "Access information about all engines combined.",
                        "name": "ZES_ENGINE_GROUP_ALL",
                        "value": "0"
                    },
                    {
                        "desc": "Access information about all compute engines combined. Compute engines can only process compute kernels (no 3D content).",
                        "name": "ZES_ENGINE_GROUP_COMPUTE_ALL",
                        "value": "1"
                    },
                    {
                        "desc": "Access information about all media engines combined.",
                        "name": "ZES_ENGINE_GROUP_MEDIA_ALL",
                        "value": "2"
                    },
                    {
                        "desc": "Access information about all copy (blitter) engines combined.",
                        "name": "ZES_ENGINE_GROUP_COPY_ALL",
                        "value": "3"
                    },
                    {
                        "desc": "Access information about a single compute engine - this is an engine that can process compute kernels. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use ZES_ENGINE_GROUP_3D_RENDER_COMPUTE_ALL for that.",
                        "name": "ZES_ENGINE_GROUP_COMPUTE_SINGLE",
                        "value": "4"
                    },
                    {
                        "desc": "Access information about a single render engine - this is an engine that can process both 3D content and compute kernels. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use ZES_ENGINE_GROUP_3D_RENDER_COMPUTE_ALL for that.",
                        "name": "ZES_ENGINE_GROUP_RENDER_SINGLE",
                        "value": "5"
                    },
                    {
                        "desc": "Access information about a single media decode engine. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use ZES_ENGINE_GROUP_MEDIA_ALL for that.",
                        "name": "ZES_ENGINE_GROUP_MEDIA_DECODE_SINGLE",
                        "value": "6"
                    },
                    {
                        "desc": "Access information about a single media encode engine. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use ZES_ENGINE_GROUP_MEDIA_ALL for that.",
                        "name": "ZES_ENGINE_GROUP_MEDIA_ENCODE_SINGLE",
                        "value": "7"
                    },
                    {
                        "desc": "Access information about a single media encode engine. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use ZES_ENGINE_GROUP_COPY_ALL for that.",
                        "name": "ZES_ENGINE_GROUP_COPY_SINGLE",
                        "value": "8"
                    },
                    {
                        "desc": "Access information about a single media enhancement engine. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use ZES_ENGINE_GROUP_MEDIA_ALL for that.",
                        "name": "ZES_ENGINE_GROUP_MEDIA_ENHANCEMENT_SINGLE",
                        "value": "9"
                    },
                    {
                        "desc": "Access information about a single 3D engine - this is an engine that can process 3D content only. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use ZES_ENGINE_GROUP_3D_RENDER_COMPUTE_ALL for that.",
                        "name": "ZES_ENGINE_GROUP_3D_SINGLE",
                        "value": "10"
                    },
                    {
                        "desc": "Access information about all 3D/render/compute engines combined.",
                        "name": "ZES_ENGINE_GROUP_3D_RENDER_COMPUTE_ALL",
                        "value": "11"
                    },
                    {
                        "desc": "Access information about all render engines combined. Render engines are those than process both 3D content and compute kernels.",
                        "name": "ZES_ENGINE_GROUP_RENDER_ALL",
                        "value": "12"
                    },
                    {
                        "desc": "Access information about all 3D engines combined. 3D engines can process 3D content only (no compute kernels).",
                        "name": "ZES_ENGINE_GROUP_3D_ALL",
                        "value": "13"
                    }
                ],
                "name": "zes_engine_group_t",
                "type": "enum"
            },
            "zes_engine_type_flags_t": {
                "class": "zesDevice",
                "desc": "Types of accelerator engines",
                "etors": [
                    {
                        "desc": "Undefined types of accelerators.",
                        "name": "ZES_ENGINE_TYPE_FLAG_OTHER",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Engines that process compute kernels only (no 3D content).",
                        "name": "ZES_ENGINE_TYPE_FLAG_COMPUTE",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Engines that process 3D content only (no compute kernels).",
                        "name": "ZES_ENGINE_TYPE_FLAG_3D",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "Engines that process media workloads.",
                        "name": "ZES_ENGINE_TYPE_FLAG_MEDIA",
                        "value": "ZE_BIT(3)"
                    },
                    {
                        "desc": "Engines that copy blocks of data.",
                        "name": "ZES_ENGINE_TYPE_FLAG_DMA",
                        "value": "ZE_BIT(4)"
                    },
                    {
                        "desc": "Engines that can process both 3D content and compute kernels.",
                        "name": "ZES_ENGINE_TYPE_FLAG_RENDER",
                        "value": "ZE_BIT(5)"
                    }
                ],
                "name": "zes_engine_type_flags_t",
                "type": "enum"
            },
            "zes_event_type_flags_t": {
                "class": "zesDriver",
                "desc": "Event types",
                "etors": [
                    {
                        "desc": "Event is triggered when the device is no longer available (due to a reset or being disabled).",
                        "name": "ZES_EVENT_TYPE_FLAG_DEVICE_DETACH",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Event is triggered after the device is available again.",
                        "name": "ZES_EVENT_TYPE_FLAG_DEVICE_ATTACH",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Event is triggered when the driver is about to put the device into a deep sleep state",
                        "name": "ZES_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_ENTER",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "Event is triggered when the driver is waking the device up from a deep sleep state",
                        "name": "ZES_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_EXIT",
                        "value": "ZE_BIT(3)"
                    },
                    {
                        "desc": "Event is triggered when the frequency starts being throttled",
                        "name": "ZES_EVENT_TYPE_FLAG_FREQ_THROTTLED",
                        "value": "ZE_BIT(4)"
                    },
                    {
                        "desc": "Event is triggered when the energy consumption threshold is reached (use zesPowerSetEnergyThreshold() to configure).",
                        "name": "ZES_EVENT_TYPE_FLAG_ENERGY_THRESHOLD_CROSSED",
                        "value": "ZE_BIT(5)"
                    },
                    {
                        "desc": "Event is triggered when the critical temperature is reached (use zesTemperatureSetConfig() to configure - disabled by default).",
                        "name": "ZES_EVENT_TYPE_FLAG_TEMP_CRITICAL",
                        "value": "ZE_BIT(6)"
                    },
                    {
                        "desc": "Event is triggered when the temperature crosses threshold 1 (use zesTemperatureSetConfig() to configure - disabled by default).",
                        "name": "ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD1",
                        "value": "ZE_BIT(7)"
                    },
                    {
                        "desc": "Event is triggered when the temperature crosses threshold 2 (use zesTemperatureSetConfig() to configure - disabled by default).",
                        "name": "ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD2",
                        "value": "ZE_BIT(8)"
                    },
                    {
                        "desc": "Event is triggered when the health of device memory changes.",
                        "name": "ZES_EVENT_TYPE_FLAG_MEM_HEALTH",
                        "value": "ZE_BIT(9)"
                    },
                    {
                        "desc": "Event is triggered when the health of fabric ports change.",
                        "name": "ZES_EVENT_TYPE_FLAG_FABRIC_PORT_HEALTH",
                        "value": "ZE_BIT(10)"
                    },
                    {
                        "desc": "Event is triggered when the health of the PCI link changes.",
                        "name": "ZES_EVENT_TYPE_FLAG_PCI_LINK_HEALTH",
                        "value": "ZE_BIT(11)"
                    },
                    {
                        "desc": "Event is triggered when accelerator RAS correctable errors cross thresholds (use zesRasSetConfig() to configure - disabled by default).",
                        "name": "ZES_EVENT_TYPE_FLAG_RAS_CORRECTABLE_ERRORS",
                        "value": "ZE_BIT(12)"
                    },
                    {
                        "desc": "Event is triggered when accelerator RAS uncorrectable errors cross thresholds (use zesRasSetConfig() to configure - disabled by default).",
                        "name": "ZES_EVENT_TYPE_FLAG_RAS_UNCORRECTABLE_ERRORS",
                        "value": "ZE_BIT(13)"
                    },
                    {
                        "desc": "Event is triggered when the device needs to be reset (use zesDeviceGetState() to determine the reasons for the reset).",
                        "name": "ZES_EVENT_TYPE_FLAG_DEVICE_RESET_REQUIRED",
                        "value": "ZE_BIT(14)"
                    }
                ],
                "name": "zes_event_type_flags_t",
                "type": "enum"
            },
            "zes_fabric_port_failure_flags_t": {
                "class": "zesFabricPort",
                "desc": "Fabric port failure reasons",
                "etors": [
                    {
                        "desc": "A previously operating link has failed. Hardware will automatically retrain this port. This state will persist until either the physical connection is removed or the link trains successfully.",
                        "name": "ZES_FABRIC_PORT_FAILURE_FLAG_FAILED",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "A connection has not been established within an expected time. Hardware will continue to attempt port training. This status will persist until either the physical connection is removed or the link successfully trains.",
                        "name": "ZES_FABRIC_PORT_FAILURE_FLAG_TRAINING_TIMEOUT",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "Port has excessively trained and then transitioned down for some period of time. Driver will allow port to continue to train, but will not enable the port for use until the port has been disabled and subsequently re-enabled using zesFabricPortSetConfig().",
                        "name": "ZES_FABRIC_PORT_FAILURE_FLAG_FLAPPING",
                        "value": "ZE_BIT(2)"
                    }
                ],
                "name": "zes_fabric_port_failure_flags_t",
                "type": "enum"
            },
            "zes_fabric_port_qual_issue_flags_t": {
                "class": "zesFabricPort",
                "desc": "Fabric port quality degradation reasons",
                "etors": [
                    {
                        "desc": "Excessive link errors are occurring",
                        "name": "ZES_FABRIC_PORT_QUAL_ISSUE_FLAG_LINK_ERRORS",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "There is a degradation in the bitrate and/or width of the link",
                        "name": "ZES_FABRIC_PORT_QUAL_ISSUE_FLAG_SPEED",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "zes_fabric_port_qual_issue_flags_t",
                "type": "enum"
            },
            "zes_fabric_port_status_t": {
                "class": "zesFabricPort",
                "desc": "Fabric port status",
                "etors": [
                    {
                        "desc": "The port status cannot be determined",
                        "name": "ZES_FABRIC_PORT_STATUS_UNKNOWN",
                        "value": "0"
                    },
                    {
                        "desc": "The port is up and operating as expected",
                        "name": "ZES_FABRIC_PORT_STATUS_HEALTHY",
                        "value": "1"
                    },
                    {
                        "desc": "The port is up but has quality and/or speed degradation",
                        "name": "ZES_FABRIC_PORT_STATUS_DEGRADED",
                        "value": "2"
                    },
                    {
                        "desc": "Port connection instabilities are preventing workloads making forward progress",
                        "name": "ZES_FABRIC_PORT_STATUS_FAILED",
                        "value": "3"
                    },
                    {
                        "desc": "The port is configured down",
                        "name": "ZES_FABRIC_PORT_STATUS_DISABLED",
                        "value": "4"
                    }
                ],
                "name": "zes_fabric_port_status_t",
                "type": "enum"
            },
            "zes_fan_speed_mode_t": {
                "class": "zesFan",
                "desc": "Fan resource speed mode",
                "etors": [
                    {
                        "desc": "The fan speed is operating using the hardware default settings",
                        "name": "ZES_FAN_SPEED_MODE_DEFAULT",
                        "value": "0"
                    },
                    {
                        "desc": "The fan speed is currently set to a fixed value",
                        "name": "ZES_FAN_SPEED_MODE_FIXED",
                        "value": "1"
                    },
                    {
                        "desc": "The fan speed is currently controlled dynamically by hardware based on a temp/speed table",
                        "name": "ZES_FAN_SPEED_MODE_TABLE",
                        "value": "2"
                    }
                ],
                "name": "zes_fan_speed_mode_t",
                "type": "enum"
            },
            "zes_fan_speed_units_t": {
                "class": "zesFan",
                "desc": "Fan speed units",
                "etors": [
                    {
                        "desc": "The fan speed is in units of revolutions per minute (rpm)",
                        "name": "ZES_FAN_SPEED_UNITS_RPM",
                        "value": "0"
                    },
                    {
                        "desc": "The fan speed is a percentage of the maximum speed of the fan",
                        "name": "ZES_FAN_SPEED_UNITS_PERCENT",
                        "value": "1"
                    }
                ],
                "name": "zes_fan_speed_units_t",
                "type": "enum"
            },
            "zes_freq_domain_t": {
                "class": "zesDevice",
                "desc": "Frequency domains.",
                "etors": [
                    {
                        "desc": "GPU Core Domain.",
                        "name": "ZES_FREQ_DOMAIN_GPU",
                        "value": "0"
                    },
                    {
                        "desc": "Local Memory Domain.",
                        "name": "ZES_FREQ_DOMAIN_MEMORY",
                        "value": "1"
                    },
                    {
                        "desc": "GPU Media Domain.",
                        "name": "ZES_FREQ_DOMAIN_MEDIA",
                        "value": "2",
                        "version": "1.6"
                    }
                ],
                "name": "zes_freq_domain_t",
                "type": "enum"
            },
            "zes_freq_throttle_reason_flags_t": {
                "class": "zesFrequency",
                "desc": "Frequency throttle reasons",
                "etors": [
                    {
                        "desc": "frequency throttled due to average power excursion (PL1)",
                        "name": "ZES_FREQ_THROTTLE_REASON_FLAG_AVE_PWR_CAP",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "frequency throttled due to burst power excursion (PL2)",
                        "name": "ZES_FREQ_THROTTLE_REASON_FLAG_BURST_PWR_CAP",
                        "value": "ZE_BIT(1)"
                    },
                    {
                        "desc": "frequency throttled due to current excursion (PL4)",
                        "name": "ZES_FREQ_THROTTLE_REASON_FLAG_CURRENT_LIMIT",
                        "value": "ZE_BIT(2)"
                    },
                    {
                        "desc": "frequency throttled due to thermal excursion (T > TjMax)",
                        "name": "ZES_FREQ_THROTTLE_REASON_FLAG_THERMAL_LIMIT",
                        "value": "ZE_BIT(3)"
                    },
                    {
                        "desc": "frequency throttled due to power supply assertion",
                        "name": "ZES_FREQ_THROTTLE_REASON_FLAG_PSU_ALERT",
                        "value": "ZE_BIT(4)"
                    },
                    {
                        "desc": "frequency throttled due to software supplied frequency range",
                        "name": "ZES_FREQ_THROTTLE_REASON_FLAG_SW_RANGE",
                        "value": "ZE_BIT(5)"
                    },
                    {
                        "desc": "frequency throttled due to a sub block that has a lower frequency range when it receives clocks",
                        "name": "ZES_FREQ_THROTTLE_REASON_FLAG_HW_RANGE",
                        "value": "ZE_BIT(6)"
                    }
                ],
                "name": "zes_freq_throttle_reason_flags_t",
                "type": "enum"
            },
            "zes_init_flags_t": {
                "class": "zes",
                "desc": "Supported sysman initialization flags",
                "etors": [
                    {
                        "desc": "placeholder for future use",
                        "name": "ZES_INIT_FLAG_PLACEHOLDER",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "zes_init_flags_t",
                "type": "enum",
                "version": "1.5"
            },
            "zes_limit_unit_t": {
                "class": "zesPower",
                "desc": "Limit Unit",
                "etors": [
                    {
                        "desc": "The PUnit power monitoring unit cannot be determined.",
                        "name": "ZES_LIMIT_UNIT_UNKNOWN",
                        "value": "0"
                    },
                    {
                        "desc": "The limit is specified in milliamperes of current drawn.",
                        "name": "ZES_LIMIT_UNIT_CURRENT",
                        "value": "1"
                    },
                    {
                        "desc": "The limit is specified in milliwatts of power generated.",
                        "name": "ZES_LIMIT_UNIT_POWER",
                        "value": "2"
                    }
                ],
                "name": "zes_limit_unit_t",
                "type": "enum",
                "version": "1.4"
            },
            "zes_mem_health_t": {
                "class": "zesMemory",
                "desc": "Memory health",
                "etors": [
                    {
                        "desc": "The memory health cannot be determined.",
                        "name": "ZES_MEM_HEALTH_UNKNOWN",
                        "value": "0"
                    },
                    {
                        "desc": "All memory channels are healthy.",
                        "name": "ZES_MEM_HEALTH_OK",
                        "value": "1"
                    },
                    {
                        "desc": "Excessive correctable errors have been detected on one or more channels. Device should be reset.",
                        "name": "ZES_MEM_HEALTH_DEGRADED",
                        "value": "2"
                    },
                    {
                        "desc": "Operating with reduced memory to cover banks with too many uncorrectable errors.",
                        "name": "ZES_MEM_HEALTH_CRITICAL",
                        "value": "3"
                    },
                    {
                        "desc": "Device should be replaced due to excessive uncorrectable errors.",
                        "name": "ZES_MEM_HEALTH_REPLACE",
                        "value": "4"
                    }
                ],
                "name": "zes_mem_health_t",
                "type": "enum"
            },
            "zes_mem_loc_t": {
                "class": "zesMemory",
                "desc": "Memory module location",
                "etors": [
                    {
                        "desc": "System memory",
                        "name": "ZES_MEM_LOC_SYSTEM",
                        "value": "0"
                    },
                    {
                        "desc": "On board local device memory",
                        "name": "ZES_MEM_LOC_DEVICE",
                        "value": "1"
                    }
                ],
                "name": "zes_mem_loc_t",
                "type": "enum"
            },
            "zes_mem_type_t": {
                "class": "zesMemory",
                "desc": "Memory module types",
                "etors": [
                    {
                        "desc": "HBM memory",
                        "name": "ZES_MEM_TYPE_HBM",
                        "value": "0"
                    },
                    {
                        "desc": "DDR memory",
                        "name": "ZES_MEM_TYPE_DDR",
                        "value": "1"
                    },
                    {
                        "desc": "DDR3 memory",
                        "name": "ZES_MEM_TYPE_DDR3",
                        "value": "2"
                    },
                    {
                        "desc": "DDR4 memory",
                        "name": "ZES_MEM_TYPE_DDR4",
                        "value": "3"
                    },
                    {
                        "desc": "DDR5 memory",
                        "name": "ZES_MEM_TYPE_DDR5",
                        "value": "4"
                    },
                    {
                        "desc": "LPDDR memory",
                        "name": "ZES_MEM_TYPE_LPDDR",
                        "value": "5"
                    },
                    {
                        "desc": "LPDDR3 memory",
                        "name": "ZES_MEM_TYPE_LPDDR3",
                        "value": "6"
                    },
                    {
                        "desc": "LPDDR4 memory",
                        "name": "ZES_MEM_TYPE_LPDDR4",
                        "value": "7"
                    },
                    {
                        "desc": "LPDDR5 memory",
                        "name": "ZES_MEM_TYPE_LPDDR5",
                        "value": "8"
                    },
                    {
                        "desc": "SRAM memory",
                        "name": "ZES_MEM_TYPE_SRAM",
                        "value": "9"
                    },
                    {
                        "desc": "L1 cache",
                        "name": "ZES_MEM_TYPE_L1",
                        "value": "10"
                    },
                    {
                        "desc": "L3 cache",
                        "name": "ZES_MEM_TYPE_L3",
                        "value": "11"
                    },
                    {
                        "desc": "Execution unit register file",
                        "name": "ZES_MEM_TYPE_GRF",
                        "value": "12"
                    },
                    {
                        "desc": "Execution unit shared local memory",
                        "name": "ZES_MEM_TYPE_SLM",
                        "value": "13"
                    },
                    {
                        "desc": "GDDR4 memory",
                        "name": "ZES_MEM_TYPE_GDDR4",
                        "value": "14"
                    },
                    {
                        "desc": "GDDR5 memory",
                        "name": "ZES_MEM_TYPE_GDDR5",
                        "value": "15"
                    },
                    {
                        "desc": "GDDR5X memory",
                        "name": "ZES_MEM_TYPE_GDDR5X",
                        "value": "16"
                    },
                    {
                        "desc": "GDDR6 memory",
                        "name": "ZES_MEM_TYPE_GDDR6",
                        "value": "17"
                    },
                    {
                        "desc": "GDDR6X memory",
                        "name": "ZES_MEM_TYPE_GDDR6X",
                        "value": "18"
                    },
                    {
                        "desc": "GDDR7 memory",
                        "name": "ZES_MEM_TYPE_GDDR7",
                        "value": "19"
                    }
                ],
                "name": "zes_mem_type_t",
                "type": "enum"
            },
            "zes_oc_mode_t": {
                "class": "zesFrequency",
                "desc": "Overclocking modes",
                "etors": [
                    {
                        "desc": "Overclocking if off - hardware is running using factory default voltages/frequencies.",
                        "name": "ZES_OC_MODE_OFF",
                        "value": "0"
                    },
                    {
                        "desc": "Overclock override mode - In this mode, a fixed user-supplied voltage is applied independent of the frequency request. The maximum permitted frequency can also be increased. This mode disables INTERPOLATIVE and FIXED modes.",
                        "name": "ZES_OC_MODE_OVERRIDE",
                        "value": "1"
                    },
                    {
                        "desc": "Overclock interpolative mode - In this mode, the voltage/frequency curve can be extended with a new voltage/frequency point that will be interpolated. The existing voltage/frequency points can also be offset (up or down) by a fixed voltage. This mode disables FIXED and OVERRIDE modes.",
                        "name": "ZES_OC_MODE_INTERPOLATIVE",
                        "value": "2"
                    },
                    {
                        "desc": "Overclocking fixed Mode - In this mode, hardware will disable most frequency throttling and lock the frequency and voltage at the specified overclock values. This mode disables OVERRIDE and INTERPOLATIVE modes. This mode can damage the part, most of the protections are disabled on this mode.",
                        "name": "ZES_OC_MODE_FIXED",
                        "value": "3"
                    }
                ],
                "name": "zes_oc_mode_t",
                "type": "enum"
            },
            "zes_overclock_control_t": {
                "class": "zesOverclock",
                "desc": "Overclock controls.",
                "etors": [
                    {
                        "desc": "This control permits setting a custom V-F curve.",
                        "name": "ZES_OVERCLOCK_CONTROL_VF",
                        "value": "1"
                    },
                    {
                        "desc": "The V-F curve of the overclock domain can be shifted up or down using this control.",
                        "name": "ZES_OVERCLOCK_CONTROL_FREQ_OFFSET",
                        "value": "2"
                    },
                    {
                        "desc": "This control is used to increase the permitted voltage above the shipped voltage maximum.",
                        "name": "ZES_OVERCLOCK_CONTROL_VMAX_OFFSET",
                        "value": "4"
                    },
                    {
                        "desc": "This control permits direct changes to the operating frequency.",
                        "name": "ZES_OVERCLOCK_CONTROL_FREQ",
                        "value": "8"
                    },
                    {
                        "desc": "This control prevents frequencies that would push the voltage above this value, typically used by V-F scanners.",
                        "name": "ZES_OVERCLOCK_CONTROL_VOLT_LIMIT",
                        "value": "16"
                    },
                    {
                        "desc": "This control changes the sustained power limit (PL1).",
                        "name": "ZES_OVERCLOCK_CONTROL_POWER_SUSTAINED_LIMIT",
                        "value": "32"
                    },
                    {
                        "desc": "This control changes the burst power limit (PL2).",
                        "name": "ZES_OVERCLOCK_CONTROL_POWER_BURST_LIMIT",
                        "value": "64"
                    },
                    {
                        "desc": "his control changes the peak power limit (PL4).",
                        "name": "ZES_OVERCLOCK_CONTROL_POWER_PEAK_LIMIT",
                        "value": "128"
                    },
                    {
                        "desc": "This control changes the value of IccMax..",
                        "name": "ZES_OVERCLOCK_CONTROL_ICCMAX_LIMIT",
                        "value": "256"
                    },
                    {
                        "desc": "This control changes the value of TjMax.",
                        "name": "ZES_OVERCLOCK_CONTROL_TEMP_LIMIT",
                        "value": "512"
                    },
                    {
                        "desc": "This control permits disabling the adaptive voltage feature ITD",
                        "name": "ZES_OVERCLOCK_CONTROL_ITD_DISABLE",
                        "value": "1024"
                    },
                    {
                        "desc": "This control permits disabling the adaptive voltage feature ACM.",
                        "name": "ZES_OVERCLOCK_CONTROL_ACM_DISABLE",
                        "value": "2048"
                    }
                ],
                "name": "zes_overclock_control_t",
                "type": "enum",
                "version": "1.5"
            },
            "zes_overclock_domain_t": {
                "class": "zesDevice",
                "desc": "Overclock domains.",
                "etors": [
                    {
                        "desc": "Overclocking card level properties such as temperature limits.",
                        "name": "ZES_OVERCLOCK_DOMAIN_CARD",
                        "value": "1"
                    },
                    {
                        "desc": "Overclocking package level properties such as power limits.",
                        "name": "ZES_OVERCLOCK_DOMAIN_PACKAGE",
                        "value": "2"
                    },
                    {
                        "desc": "Overclocking a GPU that has all accelerator assets on the same PLL/VR.",
                        "name": "ZES_OVERCLOCK_DOMAIN_GPU_ALL",
                        "value": "4"
                    },
                    {
                        "desc": "Overclocking a GPU with render and compute assets on the same PLL/VR.",
                        "name": "ZES_OVERCLOCK_DOMAIN_GPU_RENDER_COMPUTE",
                        "value": "8"
                    },
                    {
                        "desc": "Overclocking a GPU with render assets on its own PLL/VR.",
                        "name": "ZES_OVERCLOCK_DOMAIN_GPU_RENDER",
                        "value": "16"
                    },
                    {
                        "desc": "Overclocking a GPU with compute assets on its own PLL/VR.",
                        "name": "ZES_OVERCLOCK_DOMAIN_GPU_COMPUTE",
                        "value": "32"
                    },
                    {
                        "desc": "Overclocking a GPU with media assets on its own PLL/VR.",
                        "name": "ZES_OVERCLOCK_DOMAIN_GPU_MEDIA",
                        "value": "64"
                    },
                    {
                        "desc": "Overclocking device local memory.",
                        "name": "ZES_OVERCLOCK_DOMAIN_VRAM",
                        "value": "128"
                    },
                    {
                        "desc": "Overclocking LLC/L4 cache.",
                        "name": "ZES_OVERCLOCK_DOMAIN_ADM",
                        "value": "256"
                    }
                ],
                "name": "zes_overclock_domain_t",
                "type": "enum",
                "version": "1.5"
            },
            "zes_overclock_mode_t": {
                "class": "zesOverclock",
                "desc": "Overclock modes.",
                "etors": [
                    {
                        "desc": "Overclock mode is off",
                        "name": "ZES_OVERCLOCK_MODE_MODE_OFF",
                        "value": "0"
                    },
                    {
                        "desc": "Stock (manufacturing settings) are being used.",
                        "name": "ZES_OVERCLOCK_MODE_MODE_STOCK",
                        "value": "2"
                    },
                    {
                        "desc": "Overclock mode is on.",
                        "name": "ZES_OVERCLOCK_MODE_MODE_ON",
                        "value": "3"
                    },
                    {
                        "desc": "Overclocking is unavailable at this time since the system is running on battery.",
                        "name": "ZES_OVERCLOCK_MODE_MODE_UNAVAILABLE",
                        "value": "4"
                    },
                    {
                        "desc": "Overclock mode is disabled.",
                        "name": "ZES_OVERCLOCK_MODE_MODE_DISABLED",
                        "value": "5"
                    }
                ],
                "name": "zes_overclock_mode_t",
                "type": "enum",
                "version": "1.5"
            },
            "zes_pci_bar_type_t": {
                "class": "zesDevice",
                "desc": "PCI bar types",
                "etors": [
                    {
                        "desc": "MMIO registers",
                        "name": "ZES_PCI_BAR_TYPE_MMIO",
                        "value": "0"
                    },
                    {
                        "desc": "ROM aperture",
                        "name": "ZES_PCI_BAR_TYPE_ROM",
                        "value": "1"
                    },
                    {
                        "desc": "Device memory",
                        "name": "ZES_PCI_BAR_TYPE_MEM",
                        "value": "2"
                    }
                ],
                "name": "zes_pci_bar_type_t",
                "type": "enum"
            },
            "zes_pci_link_qual_issue_flags_t": {
                "class": "zesDevice",
                "desc": "PCI link quality degradation reasons",
                "etors": [
                    {
                        "desc": "A significant number of replays are occurring",
                        "name": "ZES_PCI_LINK_QUAL_ISSUE_FLAG_REPLAYS",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "There is a degradation in the maximum bandwidth of the link",
                        "name": "ZES_PCI_LINK_QUAL_ISSUE_FLAG_SPEED",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "zes_pci_link_qual_issue_flags_t",
                "type": "enum"
            },
            "zes_pci_link_stab_issue_flags_t": {
                "class": "zesDevice",
                "desc": "PCI link stability issues",
                "etors": [
                    {
                        "desc": "Link retraining has occurred to deal with quality issues",
                        "name": "ZES_PCI_LINK_STAB_ISSUE_FLAG_RETRAINING",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "zes_pci_link_stab_issue_flags_t",
                "type": "enum"
            },
            "zes_pci_link_status_t": {
                "class": "zesDevice",
                "desc": "PCI link status",
                "etors": [
                    {
                        "desc": "The link status could not be determined",
                        "name": "ZES_PCI_LINK_STATUS_UNKNOWN",
                        "value": "0"
                    },
                    {
                        "desc": "The link is up and operating as expected",
                        "name": "ZES_PCI_LINK_STATUS_GOOD",
                        "value": "1"
                    },
                    {
                        "desc": "The link is up but has quality and/or bandwidth degradation",
                        "name": "ZES_PCI_LINK_STATUS_QUALITY_ISSUES",
                        "value": "2"
                    },
                    {
                        "desc": "The link has stability issues and preventing workloads making forward progress",
                        "name": "ZES_PCI_LINK_STATUS_STABILITY_ISSUES",
                        "value": "3"
                    }
                ],
                "name": "zes_pci_link_status_t",
                "type": "enum"
            },
            "zes_pending_action_t": {
                "class": "zesOverclock",
                "desc": "Overclock pending actions.",
                "etors": [
                    {
                        "desc": "There no pending actions. .",
                        "name": "ZES_PENDING_ACTION_PENDING_NONE",
                        "value": "0"
                    },
                    {
                        "desc": "The requested change is in progress and should complete soon.",
                        "name": "ZES_PENDING_ACTION_PENDING_IMMINENT",
                        "value": "1"
                    },
                    {
                        "desc": "The requested change requires a device cold reset (hotplug, system boot).",
                        "name": "ZES_PENDING_ACTION_PENDING_COLD_RESET",
                        "value": "2"
                    },
                    {
                        "desc": "The requested change requires a device warm reset (PCIe FLR).",
                        "name": "ZES_PENDING_ACTION_PENDING_WARM_RESET",
                        "value": "3"
                    }
                ],
                "name": "zes_pending_action_t",
                "type": "enum",
                "version": "1.5"
            },
            "zes_power_domain_t": {
                "class": "zesPower",
                "desc": "Power Domain",
                "etors": [
                    {
                        "desc": "The PUnit power domain level cannot be determined.",
                        "name": "ZES_POWER_DOMAIN_UNKNOWN",
                        "value": "0"
                    },
                    {
                        "desc": "The PUnit power domain is a card-level power domain.",
                        "name": "ZES_POWER_DOMAIN_CARD",
                        "value": "1"
                    },
                    {
                        "desc": "The PUnit power domain is a package-level power domain.",
                        "name": "ZES_POWER_DOMAIN_PACKAGE",
                        "value": "2"
                    },
                    {
                        "desc": "The PUnit power domain is a stack-level power domain.",
                        "name": "ZES_POWER_DOMAIN_STACK",
                        "value": "3"
                    }
                ],
                "name": "zes_power_domain_t",
                "type": "enum",
                "version": "1.4"
            },
            "zes_power_level_t": {
                "class": "zesPower",
                "desc": "Power Level Type",
                "etors": [
                    {
                        "desc": "The PUnit power monitoring duration cannot be determined.",
                        "name": "ZES_POWER_LEVEL_UNKNOWN",
                        "value": "0"
                    },
                    {
                        "desc": "The PUnit determines effective power draw by computing a moving average of the actual power draw over a time interval (longer than BURST).",
                        "name": "ZES_POWER_LEVEL_SUSTAINED",
                        "value": "1"
                    },
                    {
                        "desc": "The PUnit determines effective power draw by computing a moving average of the actual power draw over a time interval (longer than PEAK).",
                        "name": "ZES_POWER_LEVEL_BURST",
                        "value": "2"
                    },
                    {
                        "desc": "The PUnit determines effective power draw by computing a moving average of the actual power draw over a very short time interval.",
                        "name": "ZES_POWER_LEVEL_PEAK",
                        "value": "3"
                    },
                    {
                        "desc": "The PUnit predicts effective power draw using the current device configuration (frequency, voltage, etc...) & throttles proactively to stay within the specified limit.",
                        "name": "ZES_POWER_LEVEL_INSTANTANEOUS",
                        "value": "4"
                    }
                ],
                "name": "zes_power_level_t",
                "type": "enum",
                "version": "1.4"
            },
            "zes_power_limits_ext_version_t": {
                "desc": "Power Limits Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZES_POWER_LIMITS_EXT_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZES_POWER_LIMITS_EXT_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "zes_power_limits_ext_version_t",
                "type": "enum",
                "version": "1.4"
            },
            "zes_power_source_t": {
                "class": "zesPower",
                "desc": "Power Source Type",
                "etors": [
                    {
                        "desc": "Limit active no matter whether the power source is mains powered or battery powered.",
                        "name": "ZES_POWER_SOURCE_ANY",
                        "value": "0"
                    },
                    {
                        "desc": "Limit active only when the device is mains powered.",
                        "name": "ZES_POWER_SOURCE_MAINS",
                        "value": "1"
                    },
                    {
                        "desc": "Limit active only when the device is battery powered.",
                        "name": "ZES_POWER_SOURCE_BATTERY",
                        "value": "2"
                    }
                ],
                "name": "zes_power_source_t",
                "type": "enum",
                "version": "1.4"
            },
            "zes_psu_voltage_status_t": {
                "class": "zesPsu",
                "desc": "PSU voltage status",
                "etors": [
                    {
                        "desc": "The status of the power supply voltage controllers cannot be determined",
                        "name": "ZES_PSU_VOLTAGE_STATUS_UNKNOWN",
                        "value": "0"
                    },
                    {
                        "desc": "No unusual voltages have been detected",
                        "name": "ZES_PSU_VOLTAGE_STATUS_NORMAL",
                        "value": "1"
                    },
                    {
                        "desc": "Over-voltage has occurred",
                        "name": "ZES_PSU_VOLTAGE_STATUS_OVER",
                        "value": "2"
                    },
                    {
                        "desc": "Under-voltage has occurred",
                        "name": "ZES_PSU_VOLTAGE_STATUS_UNDER",
                        "value": "3"
                    }
                ],
                "name": "zes_psu_voltage_status_t",
                "type": "enum"
            },
            "zes_ras_error_cat_t": {
                "class": "zesRas",
                "desc": "RAS error categories",
                "etors": [
                    {
                        "desc": "The number of accelerator engine resets attempted by the driver",
                        "name": "ZES_RAS_ERROR_CAT_RESET",
                        "value": "0"
                    },
                    {
                        "desc": "The number of hardware exceptions generated by the way workloads have programmed the hardware",
                        "name": "ZES_RAS_ERROR_CAT_PROGRAMMING_ERRORS",
                        "value": "1"
                    },
                    {
                        "desc": "The number of low level driver communication errors have occurred",
                        "name": "ZES_RAS_ERROR_CAT_DRIVER_ERRORS",
                        "value": "2"
                    },
                    {
                        "desc": "The number of errors that have occurred in the compute accelerator hardware",
                        "name": "ZES_RAS_ERROR_CAT_COMPUTE_ERRORS",
                        "value": "3"
                    },
                    {
                        "desc": "The number of errors that have occurred in the fixed-function accelerator hardware",
                        "name": "ZES_RAS_ERROR_CAT_NON_COMPUTE_ERRORS",
                        "value": "4"
                    },
                    {
                        "desc": "The number of errors that have occurred in caches (L1/L3/register file/shared local memory/sampler)",
                        "name": "ZES_RAS_ERROR_CAT_CACHE_ERRORS",
                        "value": "5"
                    },
                    {
                        "desc": "The number of errors that have occurred in the display",
                        "name": "ZES_RAS_ERROR_CAT_DISPLAY_ERRORS",
                        "value": "6"
                    }
                ],
                "name": "zes_ras_error_cat_t",
                "type": "enum"
            },
            "zes_ras_error_category_exp_t": {
                "class": "zesRas",
                "desc": "RAS error categories",
                "etors": [
                    {
                        "desc": "The number of accelerator engine resets attempted by the driver",
                        "name": "ZES_RAS_ERROR_CATEGORY_EXP_RESET",
                        "value": "0",
                        "version": "1.7"
                    },
                    {
                        "desc": "The number of hardware exceptions generated by the way workloads have programmed the hardware",
                        "name": "ZES_RAS_ERROR_CATEGORY_EXP_PROGRAMMING_ERRORS",
                        "value": "1",
                        "version": "1.7"
                    },
                    {
                        "desc": "The number of low level driver communication errors have occurred",
                        "name": "ZES_RAS_ERROR_CATEGORY_EXP_DRIVER_ERRORS",
                        "value": "2",
                        "version": "1.7"
                    },
                    {
                        "desc": "The number of errors that have occurred in the compute accelerator hardware",
                        "name": "ZES_RAS_ERROR_CATEGORY_EXP_COMPUTE_ERRORS",
                        "value": "3",
                        "version": "1.7"
                    },
                    {
                        "desc": "The number of errors that have occurred in the fixed-function accelerator hardware",
                        "name": "ZES_RAS_ERROR_CATEGORY_EXP_NON_COMPUTE_ERRORS",
                        "value": "4",
                        "version": "1.7"
                    },
                    {
                        "desc": "The number of errors that have occurred in caches (L1/L3/register file/shared local memory/sampler)",
                        "name": "ZES_RAS_ERROR_CATEGORY_EXP_CACHE_ERRORS",
                        "value": "5",
                        "version": "1.7"
                    },
                    {
                        "desc": "The number of errors that have occurred in the display",
                        "name": "ZES_RAS_ERROR_CATEGORY_EXP_DISPLAY_ERRORS",
                        "value": "6",
                        "version": "1.7"
                    },
                    {
                        "desc": "The number of errors that have occurred in Memory",
                        "name": "ZES_RAS_ERROR_CATEGORY_EXP_MEMORY_ERRORS",
                        "value": "7",
                        "version": "1.7"
                    },
                    {
                        "desc": "The number of errors that have occurred in Scale Fabric",
                        "name": "ZES_RAS_ERROR_CATEGORY_EXP_SCALE_ERRORS",
                        "value": "8",
                        "version": "1.7"
                    },
                    {
                        "desc": "The number of errors that have occurred in L3 Fabric",
                        "name": "ZES_RAS_ERROR_CATEGORY_EXP_L3FABRIC_ERRORS",
                        "value": "9",
                        "version": "1.7"
                    }
                ],
                "name": "zes_ras_error_category_exp_t",
                "type": "enum",
                "version": "1.7"
            },
            "zes_ras_error_type_t": {
                "class": "zesRas",
                "desc": "RAS error type",
                "etors": [
                    {
                        "desc": "Errors were corrected by hardware",
                        "name": "ZES_RAS_ERROR_TYPE_CORRECTABLE",
                        "value": "0"
                    },
                    {
                        "desc": "Error were not corrected",
                        "name": "ZES_RAS_ERROR_TYPE_UNCORRECTABLE",
                        "value": "1"
                    }
                ],
                "name": "zes_ras_error_type_t",
                "type": "enum"
            },
            "zes_ras_state_exp_version_t": {
                "desc": "RAS Get State Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZES_RAS_STATE_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZES_RAS_STATE_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "zes_ras_state_exp_version_t",
                "type": "enum",
                "version": "1.7"
            },
            "zes_repair_status_t": {
                "class": "zesDevice",
                "desc": "Device repair status",
                "etors": [
                    {
                        "desc": "The device does not support in-field repairs.",
                        "name": "ZES_REPAIR_STATUS_UNSUPPORTED",
                        "value": "0"
                    },
                    {
                        "desc": "The device has never been repaired.",
                        "name": "ZES_REPAIR_STATUS_NOT_PERFORMED",
                        "value": "1"
                    },
                    {
                        "desc": "The device has been repaired.",
                        "name": "ZES_REPAIR_STATUS_PERFORMED",
                        "value": "2"
                    }
                ],
                "name": "zes_repair_status_t",
                "type": "enum"
            },
            "zes_reset_reason_flags_t": {
                "class": "zesDevice",
                "desc": "Device reset reasons",
                "etors": [
                    {
                        "desc": "The device needs to be reset because one or more parts of the hardware is wedged",
                        "name": "ZES_RESET_REASON_FLAG_WEDGED",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "The device needs to be reset in order to complete in-field repairs",
                        "name": "ZES_RESET_REASON_FLAG_REPAIR",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "zes_reset_reason_flags_t",
                "type": "enum"
            },
            "zes_reset_type_t": {
                "class": "zesDevice",
                "desc": "Device reset type",
                "etors": [
                    {
                        "desc": "Apply warm reset",
                        "name": "ZES_RESET_TYPE_WARM",
                        "value": "0"
                    },
                    {
                        "desc": "Apply cold reset",
                        "name": "ZES_RESET_TYPE_COLD",
                        "value": "1"
                    },
                    {
                        "desc": "Apply FLR reset",
                        "name": "ZES_RESET_TYPE_FLR",
                        "value": "2"
                    }
                ],
                "name": "zes_reset_type_t",
                "type": "enum",
                "version": "1.7"
            },
            "zes_sched_mode_t": {
                "class": "zesDevice",
                "desc": "Scheduler mode",
                "etors": [
                    {
                        "desc": "Multiple applications or contexts are submitting work to the hardware. When higher priority work arrives, the scheduler attempts to pause the current executing work within some timeout interval, then submits the other work.",
                        "name": "ZES_SCHED_MODE_TIMEOUT",
                        "value": "0"
                    },
                    {
                        "desc": "The scheduler attempts to fairly timeslice hardware execution time between multiple contexts submitting work to the hardware concurrently.",
                        "name": "ZES_SCHED_MODE_TIMESLICE",
                        "value": "1"
                    },
                    {
                        "desc": "Any application or context can run indefinitely on the hardware without being preempted or terminated. All pending work for other contexts must wait until the running context completes with no further submitted work.",
                        "name": "ZES_SCHED_MODE_EXCLUSIVE",
                        "value": "2"
                    },
                    {
                        "desc": "This is a special mode that must ben enabled when debugging an application that uses this device e.g. using the Level0 Debug API. It has the effect of disabling any timeouts on workload execution time and will change workload scheduling to ensure debug accuracy.",
                        "name": "ZES_SCHED_MODE_COMPUTE_UNIT_DEBUG",
                        "value": "3"
                    }
                ],
                "name": "zes_sched_mode_t",
                "type": "enum"
            },
            "zes_standby_promo_mode_t": {
                "class": "zesStandby",
                "desc": "Standby promotion modes",
                "etors": [
                    {
                        "desc": "Best compromise between performance and energy savings.",
                        "name": "ZES_STANDBY_PROMO_MODE_DEFAULT",
                        "value": "0"
                    },
                    {
                        "desc": "The device/component will never shutdown. This can improve performance but uses more energy.",
                        "name": "ZES_STANDBY_PROMO_MODE_NEVER",
                        "value": "1"
                    }
                ],
                "name": "zes_standby_promo_mode_t",
                "type": "enum"
            },
            "zes_standby_type_t": {
                "class": "zesStandby",
                "desc": "Standby hardware components",
                "etors": [
                    {
                        "desc": "Control the overall standby policy of the device/sub-device",
                        "name": "ZES_STANDBY_TYPE_GLOBAL",
                        "value": "0"
                    }
                ],
                "name": "zes_standby_type_t",
                "type": "enum"
            },
            "zes_structure_type_t": {
                "desc": "Defines structure types",
                "etors": [
                    {
                        "desc": "zes_device_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_DEVICE_PROPERTIES",
                        "value": "0x1"
                    },
                    {
                        "desc": "zes_pci_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_PCI_PROPERTIES",
                        "value": "0x2"
                    },
                    {
                        "desc": "zes_pci_bar_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_PCI_BAR_PROPERTIES",
                        "value": "0x3"
                    },
                    {
                        "desc": "zes_diag_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_DIAG_PROPERTIES",
                        "value": "0x4"
                    },
                    {
                        "desc": "zes_engine_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_ENGINE_PROPERTIES",
                        "value": "0x5"
                    },
                    {
                        "desc": "zes_fabric_port_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_FABRIC_PORT_PROPERTIES",
                        "value": "0x6"
                    },
                    {
                        "desc": "zes_fan_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_FAN_PROPERTIES",
                        "value": "0x7"
                    },
                    {
                        "desc": "zes_firmware_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_FIRMWARE_PROPERTIES",
                        "value": "0x8"
                    },
                    {
                        "desc": "zes_freq_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_FREQ_PROPERTIES",
                        "value": "0x9"
                    },
                    {
                        "desc": "zes_led_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_LED_PROPERTIES",
                        "value": "0xa"
                    },
                    {
                        "desc": "zes_mem_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_MEM_PROPERTIES",
                        "value": "0xb"
                    },
                    {
                        "desc": "zes_perf_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_PERF_PROPERTIES",
                        "value": "0xc"
                    },
                    {
                        "desc": "zes_power_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_POWER_PROPERTIES",
                        "value": "0xd"
                    },
                    {
                        "desc": "zes_psu_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_PSU_PROPERTIES",
                        "value": "0xe"
                    },
                    {
                        "desc": "zes_ras_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_RAS_PROPERTIES",
                        "value": "0xf"
                    },
                    {
                        "desc": "zes_sched_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_SCHED_PROPERTIES",
                        "value": "0x10"
                    },
                    {
                        "desc": "zes_sched_timeout_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES",
                        "value": "0x11"
                    },
                    {
                        "desc": "zes_sched_timeslice_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES",
                        "value": "0x12"
                    },
                    {
                        "desc": "zes_standby_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_STANDBY_PROPERTIES",
                        "value": "0x13"
                    },
                    {
                        "desc": "zes_temp_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_TEMP_PROPERTIES",
                        "value": "0x14"
                    },
                    {
                        "desc": "zes_device_state_t",
                        "name": "ZES_STRUCTURE_TYPE_DEVICE_STATE",
                        "value": "0x15"
                    },
                    {
                        "desc": "zes_process_state_t",
                        "name": "ZES_STRUCTURE_TYPE_PROCESS_STATE",
                        "value": "0x16"
                    },
                    {
                        "desc": "zes_pci_state_t",
                        "name": "ZES_STRUCTURE_TYPE_PCI_STATE",
                        "value": "0x17"
                    },
                    {
                        "desc": "zes_fabric_port_config_t",
                        "name": "ZES_STRUCTURE_TYPE_FABRIC_PORT_CONFIG",
                        "value": "0x18"
                    },
                    {
                        "desc": "zes_fabric_port_state_t",
                        "name": "ZES_STRUCTURE_TYPE_FABRIC_PORT_STATE",
                        "value": "0x19"
                    },
                    {
                        "desc": "zes_fan_config_t",
                        "name": "ZES_STRUCTURE_TYPE_FAN_CONFIG",
                        "value": "0x1a"
                    },
                    {
                        "desc": "zes_freq_state_t",
                        "name": "ZES_STRUCTURE_TYPE_FREQ_STATE",
                        "value": "0x1b"
                    },
                    {
                        "desc": "zes_oc_capabilities_t",
                        "name": "ZES_STRUCTURE_TYPE_OC_CAPABILITIES",
                        "value": "0x1c"
                    },
                    {
                        "desc": "zes_led_state_t",
                        "name": "ZES_STRUCTURE_TYPE_LED_STATE",
                        "value": "0x1d"
                    },
                    {
                        "desc": "zes_mem_state_t",
                        "name": "ZES_STRUCTURE_TYPE_MEM_STATE",
                        "value": "0x1e"
                    },
                    {
                        "desc": "zes_psu_state_t",
                        "name": "ZES_STRUCTURE_TYPE_PSU_STATE",
                        "value": "0x1f"
                    },
                    {
                        "desc": "zes_base_state_t",
                        "name": "ZES_STRUCTURE_TYPE_BASE_STATE",
                        "value": "0x20"
                    },
                    {
                        "desc": "zes_ras_config_t",
                        "name": "ZES_STRUCTURE_TYPE_RAS_CONFIG",
                        "value": "0x21"
                    },
                    {
                        "desc": "zes_ras_state_t",
                        "name": "ZES_STRUCTURE_TYPE_RAS_STATE",
                        "value": "0x22"
                    },
                    {
                        "desc": "zes_temp_config_t",
                        "name": "ZES_STRUCTURE_TYPE_TEMP_CONFIG",
                        "value": "0x23"
                    },
                    {
                        "desc": "zes_pci_bar_properties_1_2_t",
                        "name": "ZES_STRUCTURE_TYPE_PCI_BAR_PROPERTIES_1_2",
                        "value": "0x24",
                        "version": "1.2"
                    },
                    {
                        "desc": "zes_device_ecc_desc_t",
                        "name": "ZES_STRUCTURE_TYPE_DEVICE_ECC_DESC",
                        "value": "0x25",
                        "version": "1.4"
                    },
                    {
                        "desc": "zes_device_ecc_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_DEVICE_ECC_PROPERTIES",
                        "value": "0x26",
                        "version": "1.4"
                    },
                    {
                        "desc": "zes_power_limit_ext_desc_t",
                        "name": "ZES_STRUCTURE_TYPE_POWER_LIMIT_EXT_DESC",
                        "value": "0x27",
                        "version": "1.4"
                    },
                    {
                        "desc": "zes_power_ext_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_POWER_EXT_PROPERTIES",
                        "value": "0x28",
                        "version": "1.4"
                    },
                    {
                        "desc": "zes_overclock_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_OVERCLOCK_PROPERTIES",
                        "value": "0x29",
                        "version": "1.5"
                    },
                    {
                        "desc": "zes_fabric_port_error_counters_t",
                        "name": "ZES_STRUCTURE_TYPE_FABRIC_PORT_ERROR_COUNTERS",
                        "value": "0x2a",
                        "version": "1.7"
                    },
                    {
                        "desc": "zes_engine_ext_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_ENGINE_EXT_PROPERTIES",
                        "value": "0x2b",
                        "version": "1.7"
                    },
                    {
                        "desc": "zes_reset_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_RESET_PROPERTIES",
                        "value": "0x2c",
                        "version": "1.7"
                    },
                    {
                        "desc": "zes_device_ext_properties_t",
                        "name": "ZES_STRUCTURE_TYPE_DEVICE_EXT_PROPERTIES",
                        "value": "0x2d",
                        "version": "1.7"
                    },
                    {
                        "desc": "zes_uuid_t",
                        "name": "ZES_STRUCTURE_TYPE_DEVICE_UUID",
                        "value": "0x2e",
                        "version": "1.7"
                    }
                ],
                "name": "zes_structure_type_t",
                "type": "enum"
            },
            "zes_temp_sensors_t": {
                "class": "zesTemperature",
                "desc": "Temperature sensors",
                "etors": [
                    {
                        "desc": "The maximum temperature across all device sensors",
                        "name": "ZES_TEMP_SENSORS_GLOBAL",
                        "value": "0"
                    },
                    {
                        "desc": "The maximum temperature across all sensors in the GPU",
                        "name": "ZES_TEMP_SENSORS_GPU",
                        "value": "1"
                    },
                    {
                        "desc": "The maximum temperature across all sensors in the local memory",
                        "name": "ZES_TEMP_SENSORS_MEMORY",
                        "value": "2"
                    },
                    {
                        "desc": "The minimum temperature across all device sensors",
                        "name": "ZES_TEMP_SENSORS_GLOBAL_MIN",
                        "value": "3"
                    },
                    {
                        "desc": "The minimum temperature across all sensors in the GPU",
                        "name": "ZES_TEMP_SENSORS_GPU_MIN",
                        "value": "4"
                    },
                    {
                        "desc": "The minimum temperature across all sensors in the local device memory",
                        "name": "ZES_TEMP_SENSORS_MEMORY_MIN",
                        "value": "5"
                    }
                ],
                "name": "zes_temp_sensors_t",
                "type": "enum"
            },
            "zes_vf_array_type_t": {
                "class": "zesOverclock",
                "desc": "VF type",
                "etors": [
                    {
                        "desc": "User V-F array",
                        "name": "ZES_VF_ARRAY_TYPE_USER_VF_ARRAY",
                        "value": "0"
                    },
                    {
                        "desc": "Default V-F array",
                        "name": "ZES_VF_ARRAY_TYPE_DEFAULT_VF_ARRAY",
                        "value": "1"
                    },
                    {
                        "desc": "Live V-F array",
                        "name": "ZES_VF_ARRAY_TYPE_LIVE_VF_ARRAY",
                        "value": "2"
                    }
                ],
                "name": "zes_vf_array_type_t",
                "type": "enum",
                "version": "1.5"
            },
            "zes_vf_program_type_t": {
                "class": "zesOverclock",
                "desc": "Overclock V-F curve programing.",
                "etors": [
                    {
                        "desc": "Can program an arbitrary number of V-F points up to the maximum number and each point can have arbitrary voltage and frequency values within the min/max/step limits",
                        "name": "ZES_VF_PROGRAM_TYPE_VF_ARBITRARY",
                        "value": "0"
                    },
                    {
                        "desc": "Can only program the voltage for the V-F points that it reads back - the frequency of those points cannot be changed",
                        "name": "ZES_VF_PROGRAM_TYPE_VF_FREQ_FIXED",
                        "value": "1"
                    },
                    {
                        "desc": "Can only program the frequency for the V-F points that is reads back - the voltage of each point cannot be changed.",
                        "name": "ZES_VF_PROGRAM_TYPE_VF_VOLT_FIXED",
                        "value": "2"
                    }
                ],
                "name": "zes_vf_program_type_t",
                "type": "enum",
                "version": "1.5"
            },
            "zes_vf_type_t": {
                "class": "zesOverclock",
                "desc": "VF type",
                "etors": [
                    {
                        "desc": "VF Voltage point",
                        "name": "ZES_VF_TYPE_VOLT",
                        "value": "0"
                    },
                    {
                        "desc": "VF Frequency point",
                        "name": "ZES_VF_TYPE_FREQ",
                        "value": "1"
                    }
                ],
                "name": "zes_vf_type_t",
                "type": "enum",
                "version": "1.5"
            },
            "zet_api_tracing_exp_version_t": {
                "desc": "API Tracing Experimental Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZET_API_TRACING_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZET_API_TRACING_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "zet_api_tracing_exp_version_t",
                "type": "enum"
            },
            "zet_debug_detach_reason_t": {
                "class": "zetDebug",
                "desc": "Supported debug detach reasons.",
                "etors": [
                    {
                        "desc": "The detach reason is not valid",
                        "name": "ZET_DEBUG_DETACH_REASON_INVALID",
                        "value": "0"
                    },
                    {
                        "desc": "The host process exited",
                        "name": "ZET_DEBUG_DETACH_REASON_HOST_EXIT",
                        "value": "1"
                    }
                ],
                "name": "zet_debug_detach_reason_t",
                "type": "enum"
            },
            "zet_debug_event_flags_t": {
                "class": "zetDebug",
                "desc": "Supported debug event flags.",
                "etors": [
                    {
                        "desc": "The event needs to be acknowledged by calling zetDebugAcknowledgeEvent.",
                        "name": "ZET_DEBUG_EVENT_FLAG_NEED_ACK",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "zet_debug_event_flags_t",
                "type": "enum"
            },
            "zet_debug_event_type_t": {
                "class": "zetDebug",
                "desc": "Supported debug event types.",
                "etors": [
                    {
                        "desc": "The event is invalid",
                        "name": "ZET_DEBUG_EVENT_TYPE_INVALID",
                        "value": "0"
                    },
                    {
                        "desc": "The tool was detached",
                        "name": "ZET_DEBUG_EVENT_TYPE_DETACHED",
                        "value": "1"
                    },
                    {
                        "desc": "The debuggee process created command queues on the device",
                        "name": "ZET_DEBUG_EVENT_TYPE_PROCESS_ENTRY",
                        "value": "2"
                    },
                    {
                        "desc": "The debuggee process destroyed all command queues on the device",
                        "name": "ZET_DEBUG_EVENT_TYPE_PROCESS_EXIT",
                        "value": "3"
                    },
                    {
                        "desc": "An in-memory module was loaded onto the device",
                        "name": "ZET_DEBUG_EVENT_TYPE_MODULE_LOAD",
                        "value": "4"
                    },
                    {
                        "desc": "An in-memory module is about to get unloaded from the device",
                        "name": "ZET_DEBUG_EVENT_TYPE_MODULE_UNLOAD",
                        "value": "5"
                    },
                    {
                        "desc": "The thread stopped due to a device exception",
                        "name": "ZET_DEBUG_EVENT_TYPE_THREAD_STOPPED",
                        "value": "6"
                    },
                    {
                        "desc": "The thread is not available to be stopped",
                        "name": "ZET_DEBUG_EVENT_TYPE_THREAD_UNAVAILABLE",
                        "value": "7"
                    },
                    {
                        "desc": "A page request could not be completed on the device",
                        "name": "ZET_DEBUG_EVENT_TYPE_PAGE_FAULT",
                        "value": "8",
                        "version": "1.1"
                    }
                ],
                "name": "zet_debug_event_type_t",
                "type": "enum"
            },
            "zet_debug_memory_space_type_t": {
                "class": "zetDebug",
                "desc": "Supported device memory space types.",
                "etors": [
                    {
                        "desc": "default memory space (attribute may be omitted)",
                        "name": "ZET_DEBUG_MEMORY_SPACE_TYPE_DEFAULT",
                        "value": "0"
                    },
                    {
                        "desc": "shared local memory space (GPU-only)",
                        "name": "ZET_DEBUG_MEMORY_SPACE_TYPE_SLM",
                        "value": "1"
                    }
                ],
                "name": "zet_debug_memory_space_type_t",
                "type": "enum"
            },
            "zet_debug_page_fault_reason_t": {
                "class": "zetDebug",
                "desc": "Page fault reasons.",
                "etors": [
                    {
                        "desc": "The page fault reason is not valid",
                        "name": "ZET_DEBUG_PAGE_FAULT_REASON_INVALID",
                        "value": "0"
                    },
                    {
                        "desc": "The address is not mapped",
                        "name": "ZET_DEBUG_PAGE_FAULT_REASON_MAPPING_ERROR",
                        "value": "1"
                    },
                    {
                        "desc": "Invalid access permissions",
                        "name": "ZET_DEBUG_PAGE_FAULT_REASON_PERMISSION_ERROR",
                        "value": "2"
                    }
                ],
                "name": "zet_debug_page_fault_reason_t",
                "type": "enum",
                "version": "1.1"
            },
            "zet_debug_regset_flags_t": {
                "class": "zetDebug",
                "desc": "Supported general register set flags.",
                "etors": [
                    {
                        "desc": "register set is readable",
                        "name": "ZET_DEBUG_REGSET_FLAG_READABLE",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "register set is writeable",
                        "name": "ZET_DEBUG_REGSET_FLAG_WRITEABLE",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "zet_debug_regset_flags_t",
                "type": "enum"
            },
            "zet_device_debug_property_flags_t": {
                "class": "zetDevice",
                "desc": "Supported device debug property flags",
                "etors": [
                    {
                        "desc": "the device supports attaching for debug",
                        "name": "ZET_DEVICE_DEBUG_PROPERTY_FLAG_ATTACH",
                        "value": "ZE_BIT(0)"
                    }
                ],
                "name": "zet_device_debug_property_flags_t",
                "type": "enum"
            },
            "zet_export_metric_data_exp_version_t": {
                "desc": "Exporting Metrics Data Experimental Extension Version(s)",
                "etors": [
                    {
                        "desc": "version 1.0",
                        "name": "ZET_EXPORT_METRIC_DATA_EXP_VERSION_1_0",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    },
                    {
                        "desc": "latest known version",
                        "name": "ZET_EXPORT_METRIC_DATA_EXP_VERSION_CURRENT",
                        "value": "ZE_MAKE_VERSION( 1, 0 )"
                    }
                ],
                "name": "zet_export_metric_data_exp_version_t",
                "type": "enum",
                "version": "1.6"
            },
            "zet_metric_group_calculation_type_t": {
                "class": "zetMetricGroup",
                "desc": "Metric group calculation type",
                "etors": [
                    {
                        "desc": "Calculated metric values from raw data.",
                        "name": "ZET_METRIC_GROUP_CALCULATION_TYPE_METRIC_VALUES",
                        "value": "0"
                    },
                    {
                        "desc": "Maximum metric values.",
                        "name": "ZET_METRIC_GROUP_CALCULATION_TYPE_MAX_METRIC_VALUES",
                        "value": "1"
                    }
                ],
                "name": "zet_metric_group_calculation_type_t",
                "type": "enum"
            },
            "zet_metric_group_sampling_type_flags_t": {
                "class": "zetMetricGroup",
                "desc": "Metric group sampling type",
                "etors": [
                    {
                        "desc": "Event based sampling",
                        "name": "ZET_METRIC_GROUP_SAMPLING_TYPE_FLAG_EVENT_BASED",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "Time based sampling",
                        "name": "ZET_METRIC_GROUP_SAMPLING_TYPE_FLAG_TIME_BASED",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "zet_metric_group_sampling_type_flags_t",
                "type": "enum"
            },
            "zet_metric_query_pool_type_t": {
                "class": "zetMetricQueryPool",
                "desc": "Metric query pool types",
                "etors": [
                    {
                        "desc": "Performance metric query pool.",
                        "name": "ZET_METRIC_QUERY_POOL_TYPE_PERFORMANCE",
                        "value": "0"
                    },
                    {
                        "desc": "Skips workload execution between begin/end calls.",
                        "name": "ZET_METRIC_QUERY_POOL_TYPE_EXECUTION",
                        "value": "1"
                    }
                ],
                "name": "zet_metric_query_pool_type_t",
                "type": "enum"
            },
            "zet_metric_type_t": {
                "class": "zetMetric",
                "desc": "Metric types",
                "etors": [
                    {
                        "desc": "Metric type: duration",
                        "name": "ZET_METRIC_TYPE_DURATION",
                        "value": "0"
                    },
                    {
                        "desc": "Metric type: event",
                        "name": "ZET_METRIC_TYPE_EVENT",
                        "value": "1"
                    },
                    {
                        "desc": "Metric type: event with range",
                        "name": "ZET_METRIC_TYPE_EVENT_WITH_RANGE",
                        "value": "2"
                    },
                    {
                        "desc": "Metric type: throughput",
                        "name": "ZET_METRIC_TYPE_THROUGHPUT",
                        "value": "3"
                    },
                    {
                        "desc": "Metric type: timestamp",
                        "name": "ZET_METRIC_TYPE_TIMESTAMP",
                        "value": "4"
                    },
                    {
                        "desc": "Metric type: flag",
                        "name": "ZET_METRIC_TYPE_FLAG",
                        "value": "5"
                    },
                    {
                        "desc": "Metric type: ratio",
                        "name": "ZET_METRIC_TYPE_RATIO",
                        "value": "6"
                    },
                    {
                        "desc": "Metric type: raw",
                        "name": "ZET_METRIC_TYPE_RAW",
                        "value": "7"
                    },
                    {
                        "desc": "Metric type: instruction pointer. Deprecated, use ZET_METRIC_TYPE_IP.",
                        "name": "ZET_METRIC_TYPE_IP_EXP",
                        "value": "0x7ffffffe"
                    },
                    {
                        "desc": "Metric type: instruction pointer",
                        "name": "ZET_METRIC_TYPE_IP",
                        "value": "0x7ffffffe",
                        "version": "1.7"
                    }
                ],
                "name": "zet_metric_type_t",
                "type": "enum"
            },
            "zet_module_debug_info_format_t": {
                "class": "zetModule",
                "desc": "Supported module debug info formats.",
                "etors": [
                    {
                        "desc": "Format is ELF/DWARF",
                        "name": "ZET_MODULE_DEBUG_INFO_FORMAT_ELF_DWARF",
                        "value": "0"
                    }
                ],
                "name": "zet_module_debug_info_format_t",
                "type": "enum"
            },
            "zet_profile_flags_t": {
                "class": "zetKernel",
                "desc": "Supportted profile features",
                "etors": [
                    {
                        "desc": "request the compiler attempt to minimize register usage as much as possible to allow for instrumentation",
                        "name": "ZET_PROFILE_FLAG_REGISTER_REALLOCATION",
                        "value": "ZE_BIT(0)"
                    },
                    {
                        "desc": "request the compiler generate free register info",
                        "name": "ZET_PROFILE_FLAG_FREE_REGISTER_INFO",
                        "value": "ZE_BIT(1)"
                    }
                ],
                "name": "zet_profile_flags_t",
                "type": "enum"
            },
            "zet_profile_token_type_t": {
                "class": "zetKernel",
                "desc": "Supported profile token types",
                "etors": [
                    {
                        "desc": "GRF info",
                        "name": "ZET_PROFILE_TOKEN_TYPE_FREE_REGISTER",
                        "value": "0"
                    }
                ],
                "name": "zet_profile_token_type_t",
                "type": "enum"
            },
            "zet_structure_type_t": {
                "desc": "Defines structure types",
                "etors": [
                    {
                        "desc": "zet_metric_group_properties_t",
                        "name": "ZET_STRUCTURE_TYPE_METRIC_GROUP_PROPERTIES",
                        "value": "0x1"
                    },
                    {
                        "desc": "zet_metric_properties_t",
                        "name": "ZET_STRUCTURE_TYPE_METRIC_PROPERTIES",
                        "value": "0x2"
                    },
                    {
                        "desc": "zet_metric_streamer_desc_t",
                        "name": "ZET_STRUCTURE_TYPE_METRIC_STREAMER_DESC",
                        "value": "0x3"
                    },
                    {
                        "desc": "zet_metric_query_pool_desc_t",
                        "name": "ZET_STRUCTURE_TYPE_METRIC_QUERY_POOL_DESC",
                        "value": "0x4"
                    },
                    {
                        "desc": "zet_profile_properties_t",
                        "name": "ZET_STRUCTURE_TYPE_PROFILE_PROPERTIES",
                        "value": "0x5"
                    },
                    {
                        "desc": "zet_device_debug_properties_t",
                        "name": "ZET_STRUCTURE_TYPE_DEVICE_DEBUG_PROPERTIES",
                        "value": "0x6"
                    },
                    {
                        "desc": "zet_debug_memory_space_desc_t",
                        "name": "ZET_STRUCTURE_TYPE_DEBUG_MEMORY_SPACE_DESC",
                        "value": "0x7"
                    },
                    {
                        "desc": "zet_debug_regset_properties_t",
                        "name": "ZET_STRUCTURE_TYPE_DEBUG_REGSET_PROPERTIES",
                        "value": "0x8"
                    },
                    {
                        "desc": "zet_metric_global_timestamps_resolution_exp_t. Deprecated, use ZET_STRUCTURE_TYPE_METRIC_GLOBAL_TIMESTAMPS_RESOLUTION_EXP.",
                        "name": "ZET_STRUCTURE_TYPE_GLOBAL_METRICS_TIMESTAMPS_EXP_PROPERTIES",
                        "value": "0x9",
                        "version": "1.5"
                    },
                    {
                        "desc": "zet_metric_global_timestamps_resolution_exp_t",
                        "name": "ZET_STRUCTURE_TYPE_METRIC_GLOBAL_TIMESTAMPS_RESOLUTION_EXP",
                        "value": "0x9",
                        "version": "1.7"
                    },
                    {
                        "desc": "zet_tracer_exp_desc_t",
                        "name": "ZET_STRUCTURE_TYPE_TRACER_EXP_DESC",
                        "value": "0x00010001"
                    },
                    {
                        "desc": "zet_metric_calculate_exp_desc_t. Deprecated, use ZET_STRUCTURE_TYPE_METRIC_CALCULATE_EXP_DESC.",
                        "name": "ZET_STRUCTURE_TYPE_METRICS_CALCULATE_EXP_DESC",
                        "value": "0x00010002",
                        "version": "1.6"
                    },
                    {
                        "desc": "zet_metric_calculate_exp_desc_t",
                        "name": "ZET_STRUCTURE_TYPE_METRIC_CALCULATE_EXP_DESC",
                        "value": "0x00010002",
                        "version": "1.7"
                    }
                ],
                "name": "zet_structure_type_t",
                "type": "enum"
            },
            "zet_value_type_t": {
                "desc": "Supported value types",
                "etors": [
                    {
                        "desc": "32-bit unsigned-integer",
                        "name": "ZET_VALUE_TYPE_UINT32",
                        "value": "0"
                    },
                    {
                        "desc": "64-bit unsigned-integer",
                        "name": "ZET_VALUE_TYPE_UINT64",
                        "value": "1"
                    },
                    {
                        "desc": "32-bit floating-point",
                        "name": "ZET_VALUE_TYPE_FLOAT32",
                        "value": "2"
                    },
                    {
                        "desc": "64-bit floating-point",
                        "name": "ZET_VALUE_TYPE_FLOAT64",
                        "value": "3"
                    },
                    {
                        "desc": "8-bit boolean",
                        "name": "ZET_VALUE_TYPE_BOOL8",
                        "value": "4"
                    },
                    {
                        "desc": "C string",
                        "name": "ZET_VALUE_TYPE_STRING",
                        "value": "5"
                    },
                    {
                        "desc": "8-bit unsigned-integer",
                        "name": "ZET_VALUE_TYPE_UINT8",
                        "value": "6"
                    },
                    {
                        "desc": "16-bit unsigned-integer",
                        "name": "ZET_VALUE_TYPE_UINT16",
                        "value": "7"
                    }
                ],
                "name": "zet_value_type_t",
                "type": "enum"
            }
        },
        "env": {
            "ZET_ENABLE_METRICS": {
                "category": "Driver",
                "desc": "Enables driver instrumentation and dependencies for device metrics",
                "name": "ZET_ENABLE_METRICS",
                "type": "env",
                "values": "0, 1"
            },
            "ZET_ENABLE_PROGRAM_DEBUGGING": {
                "category": "Driver",
                "desc": "Enables driver instrumentation and dependencies for program debugging",
                "name": "ZET_ENABLE_PROGRAM_DEBUGGING",
                "type": "env",
                "values": "0, 1"
            },
            "ZET_ENABLE_PROGRAM_INSTRUMENTATION": {
                "category": "Driver",
                "desc": "Enables driver instrumentation and dependencies for program instrumentation",
                "name": "ZET_ENABLE_PROGRAM_INSTRUMENTATION",
                "type": "env",
                "values": "0, 1"
            },
            "ZE_AFFINITY_MASK": {
                "category": "Device",
                "desc": "Forces driver to only report devices (and sub-devices) as specified by values",
                "name": "ZE_AFFINITY_MASK",
                "type": "env",
                "values": "Hex String"
            },
            "ZE_ENABLE_PCI_ID_DEVICE_ORDER": {
                "category": "Device",
                "default": "0",
                "desc": "Forces driver to report devices from lowest to highest PCI bus ID",
                "name": "ZE_ENABLE_PCI_ID_DEVICE_ORDER",
                "type": "env",
                "values": "0, 1"
            },
            "ZE_FLAT_DEVICE_HIERARCHY": {
                "category": "Device",
                "desc": "Defines the device hierarchy model exposed by Level Zero driver implementation",
                "name": "ZE_FLAT_DEVICE_HIERARCHY",
                "type": "env",
                "values": "String",
                "version": "1.7"
            },
            "ZE_SHARED_FORCE_DEVICE_ALLOC": {
                "category": "Memory",
                "default": "0",
                "desc": "Forces all shared allocations into device memory",
                "name": "ZE_SHARED_FORCE_DEVICE_ALLOC",
                "type": "env",
                "values": "0, 1"
            }
        },
        "function": {
            "AcknowledgeEvent": {
                "class": "zetDebug",
                "desc": "Acknowledge a debug event.",
                "hash": "2dbda584161c89afdaa2f2d7e25811fa56eb13db68b335e167373e2d1db654a2",
                "name": "AcknowledgeEvent",
                "params": [
                    {
                        "desc": "[in] debug session handle",
                        "name": "hDebug",
                        "type": "zet_debug_session_handle_t"
                    },
                    {
                        "desc": "[in] a pointer to a zet_debug_event_t.",
                        "name": "event",
                        "type": "const zet_debug_event_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDebug`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == event`"
                        ]
                    }
                ],
                "type": "function"
            },
            "ActivateMetricGroups": {
                "class": "zetContext",
                "desc": "Activates metric groups.",
                "details": [
                    "Immediately reconfigures the device to activate only those metric groups provided.",
                    "Any metric groups previously activated but not provided will be deactivated.",
                    "Deactivating metric groups that are still in-use will result in undefined behavior.",
                    "All metric groups must have different domains, see zet_metric_group_properties_t.",
                    "The application must **not** call this function from simultaneous threads with the same device handle."
                ],
                "hash": "34c932ade11f77be736543eb44b6cf7cebfde09ac71f5b67362519b27f763e96",
                "name": "ActivateMetricGroups",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "zet_context_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "zet_device_handle_t"
                    },
                    {
                        "desc": "[in] metric group count to activate; must be 0 if `nullptr == phMetricGroups`",
                        "name": "count",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, count)] handles of the metric groups to activate.\nnullptr deactivates all previously used metric groups.\nall metrics groups must come from a different domains.\nmetric query and metric stream must use activated metric groups.\n",
                        "name": "phMetricGroups",
                        "type": "zet_metric_group_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phMetricGroups) && (0 < count)`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ARGUMENT": [
                            "Multiple metric groups share the same domain"
                        ]
                    }
                ],
                "type": "function"
            },
            "AllocDevice": {
                "class": "zeMem",
                "decl": "static",
                "desc": "Allocates device memory on the context.",
                "details": [
                    "Device allocations are owned by a specific device.",
                    "In general, a device allocation may only be accessed by the device that owns it.",
                    "The application must only use the memory allocation for the context and device, or its sub-devices, which was provided during allocation.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "221cb83b773fc3543fec9b5986d0c3171fe46e99d294e9c26d4c8ec021b50ed4",
                "name": "AllocDevice",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] pointer to device memory allocation descriptor",
                        "name": "device_desc",
                        "type": "const ze_device_mem_alloc_desc_t*"
                    },
                    {
                        "desc": "[in] size in bytes to allocate; must be less than or equal to the `maxMemAllocSize` member of ze_device_properties_t",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] minimum alignment in bytes for the allocation; must be a power of two",
                        "name": "alignment",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[out] pointer to device allocation",
                        "name": "pptr",
                        "type": "void**"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == device_desc`",
                            "`nullptr == pptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x7 < device_desc->flags`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_SIZE": [
                            "`0 == size`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": [
                            "Must be zero or a power-of-two",
                            "`0 != (alignment & (alignment - 1))`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AllocHost": {
                "class": "zeMem",
                "decl": "static",
                "desc": "Allocates host memory on the context.",
                "details": [
                    "Host allocations are owned by the host process.",
                    "Host allocations are accessible by the host and all devices within the driver's context.",
                    "Host allocations are frequently used as staging areas to transfer data to or from devices.",
                    "The application must only use the memory allocation for the context which was provided during allocation.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "3756f52aa6a061b6c344cccfb4ad13bbf4b6f60fcdb1cfecb30fdc1140edfda6",
                "name": "AllocHost",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] pointer to host memory allocation descriptor",
                        "name": "host_desc",
                        "type": "const ze_host_mem_alloc_desc_t*"
                    },
                    {
                        "desc": "[in] size in bytes to allocate; must be less than or equal to the `maxMemAllocSize` member of ze_device_properties_t",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] minimum alignment in bytes for the allocation; must be a power of two",
                        "name": "alignment",
                        "type": "size_t"
                    },
                    {
                        "desc": "[out] pointer to host allocation",
                        "name": "pptr",
                        "type": "void**"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == host_desc`",
                            "`nullptr == pptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0xf < host_desc->flags`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_SIZE": [
                            "`0 == size`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": [
                            "Must be zero or a power-of-two",
                            "`0 != (alignment & (alignment - 1))`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AllocShared": {
                "class": "zeMem",
                "decl": "static",
                "desc": "Allocates shared memory on the context.",
                "details": [
                    "Shared allocations share ownership between the host and one or more devices.",
                    "Shared allocations may optionally be associated with a device by passing a handle to the device.",
                    "Devices supporting only single-device shared access capabilities may access shared memory associated with the device.\nFor these devices, ownership of the allocation is shared between the host and the associated device only.\n",
                    "Passing nullptr as the device handle does not associate the shared allocation with any device.\nFor allocations with no associated device, ownership of the allocation is shared between the host and all devices supporting cross-device shared access capabilities.\n",
                    "The application must only use the memory allocation for the context and device, or its sub-devices, which was provided during allocation.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "b6604184ed449716c988b49b2743e1ee23375834a00cf2a5255175ad95f829a8",
                "name": "AllocShared",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] pointer to device memory allocation descriptor",
                        "name": "device_desc",
                        "type": "const ze_device_mem_alloc_desc_t*"
                    },
                    {
                        "desc": "[in] pointer to host memory allocation descriptor",
                        "name": "host_desc",
                        "type": "const ze_host_mem_alloc_desc_t*"
                    },
                    {
                        "desc": "[in] size in bytes to allocate; must be less than or equal to the `maxMemAllocSize` member of ze_device_properties_t",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] minimum alignment in bytes for the allocation; must be a power of two",
                        "name": "alignment",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in][optional] device handle to associate with",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[out] pointer to shared allocation",
                        "name": "pptr",
                        "type": "void**"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == device_desc`",
                            "`nullptr == host_desc`",
                            "`nullptr == pptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x7 < device_desc->flags`",
                            "`0xf < host_desc->flags`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_SIZE": [
                            "`0 == size`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": [
                            "Must be zero or a power-of-two",
                            "`0 != (alignment & (alignment - 1))`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendBarrier": {
                "analogue": [
                    "**vkCmdPipelineBarrier**",
                    "clEnqueueBarrierWithWaitList"
                ],
                "class": "zeCommandList",
                "desc": "Appends an execution and global memory barrier into a command list.",
                "details": [
                    "The application must ensure the events are accessible by the device on which the command list was created.",
                    "If numWaitEvents is zero, then all previous commands, enqueued on same command queue, must complete prior to the execution of the barrier. This is not the case when numWaitEvents is non-zero.",
                    "If numWaitEvents is non-zero, then only all phWaitEvents must be signaled prior to the execution of the barrier.",
                    "This command blocks all following commands from beginning until the execution of the barrier completes.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "5a1b934c89a448d55bf286086ad31aa09ca2ccdf5e12b073074de61f54adaec1",
                "name": "AppendBarrier",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before executing barrier; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before executing barrier",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendEventReset": {
                "analogue": [
                    "vkResetEvent"
                ],
                "class": "zeCommandList",
                "desc": "Appends a reset of an event back to not signaled state into a command list.",
                "details": [
                    "The application must ensure the events are accessible by the device on which the command list was created.",
                    "The application must ensure the command list and events were created on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "fd917b07e15d242dc28ee8d79b2e3827e834a35da1af31c0f46d031b02255c25",
                "name": "AppendEventReset",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] handle of the event",
                        "name": "hEvent",
                        "type": "ze_event_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hEvent`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    }
                ],
                "type": "function"
            },
            "AppendImageCopy": {
                "analogue": [
                    "**clEnqueueCopyImage**"
                ],
                "class": "zeCommandList",
                "desc": "Copies an image.",
                "details": [
                    "The application must ensure the image and events are accessible by the device on which the command list was created.",
                    "The application must ensure the image format descriptors for both source and destination images are the same.",
                    "The application must ensure the command list, images and events were created on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "8b5c252b1ea29a9d0b4c115d15fd74725a40ada1f7ddf99f800127e5be286176",
                "name": "AppendImageCopy",
                "params": [
                    {
                        "desc": "[in] handle of command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] handle of destination image to copy to",
                        "name": "hDstImage",
                        "type": "ze_image_handle_t"
                    },
                    {
                        "desc": "[in] handle of source image to copy from",
                        "name": "hSrcImage",
                        "type": "ze_image_handle_t"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hDstImage`",
                            "`nullptr == hSrcImage`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendImageCopyFromMemory": {
                "analogue": [
                    "clEnqueueWriteImage"
                ],
                "class": "zeCommandList",
                "desc": "Copies to an image from device or shared memory.",
                "details": [
                    "The application must ensure the memory pointed to by srcptr is accessible by the device on which the command list was created.",
                    "The implementation must not access the memory pointed to by srcptr as it is free to be modified by either the Host or device up until execution.",
                    "The application must ensure the image and events are accessible by the device on which the command list was created.",
                    "The application must ensure the image format descriptor for the destination image is a single-planar format.",
                    "The application must ensure the command list, image and events were created, and the memory was allocated, on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "4e7bba1af5d32a613c3426d3b97aacb5359b92cde5fe83b7743046c68290060a",
                "name": "AppendImageCopyFromMemory",
                "params": [
                    {
                        "desc": "[in] handle of command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] handle of destination image to copy to",
                        "name": "hDstImage",
                        "type": "ze_image_handle_t"
                    },
                    {
                        "desc": "[in] pointer to source memory to copy from",
                        "name": "srcptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in][optional] destination region descriptor",
                        "name": "pDstRegion",
                        "type": "const ze_image_region_t*"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hDstImage`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == srcptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendImageCopyFromMemoryExt": {
                "analogue": [
                    "clEnqueueWriteImage"
                ],
                "class": "zeCommandList",
                "desc": "Copies to an image from device or shared memory.",
                "details": [
                    "The application must ensure the memory pointed to by srcptr is accessible by the device on which the command list was created.",
                    "The implementation must not access the memory pointed to by srcptr as it is free to be modified by either the Host or device up until execution.",
                    "The application must ensure the image and events are accessible by the device on which the command list was created.",
                    "The application must ensure the image format descriptor for the destination image is a single-planar format.",
                    "The application must ensure that the rowPitch is set to 0 if image is a 1D image. Otherwise the rowPitch must be greater than or equal to the element size in bytes x width.",
                    "If rowPitch is set to 0, the appropriate row pitch is calculated based on the size of each element in bytes multiplied by width",
                    "The application must ensure that the slicePitch is set to 0 if image is a 1D or 2D image. Otherwise this value must be greater than or equal to rowPitch x height.",
                    "If slicePitch is set to 0, the appropriate slice pitch is calculated based on the rowPitch x height.",
                    "The application must ensure the command list, image and events were created, and the memory was allocated, on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "428b2da065561bcb61dbc49bdbb0b4efc20aa473a76b1c3f2b149009c6b9678a",
                "name": "AppendImageCopyFromMemoryExt",
                "params": [
                    {
                        "desc": "[in] handle of command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] handle of destination image to copy to",
                        "name": "hDstImage",
                        "type": "ze_image_handle_t"
                    },
                    {
                        "desc": "[in] pointer to source memory to copy from",
                        "name": "srcptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in][optional] destination region descriptor",
                        "name": "pDstRegion",
                        "type": "const ze_image_region_t*"
                    },
                    {
                        "desc": "[in] size in bytes of the 1D slice of the 2D region of a 2D or 3D image or each image of a 1D or 2D image array being read",
                        "name": "srcRowPitch",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] size in bytes of the 2D slice of the 3D region of a 3D image or each image of a 1D or 2D image array being read",
                        "name": "srcSlicePitch",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hDstImage`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == srcptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.3"
            },
            "AppendImageCopyRegion": {
                "class": "zeCommandList",
                "desc": "Copies a region of an image to another image.",
                "details": [
                    "The application must ensure the image and events are accessible by the device on which the command list was created.",
                    "The region width and height for both src and dst must be same. The origins can be different.",
                    "The src and dst regions cannot be overlapping.",
                    "The application must ensure the image format descriptors for both source and destination images are the same.",
                    "The application must ensure the command list, images and events were created, and the memory was allocated, on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "cb41a9b8f263f1632d7297d926863861d60424af7e33f9e18e2f2062cde4f127",
                "name": "AppendImageCopyRegion",
                "params": [
                    {
                        "desc": "[in] handle of command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] handle of destination image to copy to",
                        "name": "hDstImage",
                        "type": "ze_image_handle_t"
                    },
                    {
                        "desc": "[in] handle of source image to copy from",
                        "name": "hSrcImage",
                        "type": "ze_image_handle_t"
                    },
                    {
                        "desc": "[in][optional] destination region descriptor",
                        "name": "pDstRegion",
                        "type": "const ze_image_region_t*"
                    },
                    {
                        "desc": "[in][optional] source region descriptor",
                        "name": "pSrcRegion",
                        "type": "const ze_image_region_t*"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hDstImage`",
                            "`nullptr == hSrcImage`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_OVERLAPPING_REGIONS": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendImageCopyToMemory": {
                "analogue": [
                    "clEnqueueReadImage"
                ],
                "class": "zeCommandList",
                "desc": "Copies from an image to device or shared memory.",
                "details": [
                    "The application must ensure the memory pointed to by dstptr is accessible by the device on which the command list was created.",
                    "The implementation must not access the memory pointed to by dstptr as it is free to be modified by either the Host or device up until execution.",
                    "The application must ensure the image and events are accessible by the device on which the command list was created.",
                    "The application must ensure the image format descriptor for the source image is a single-planar format.",
                    "The application must ensure the command list, image and events were created, and the memory was allocated, on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "8d4253ce44a753f3cf8a1bc966e8d8dd97134804940ce1c7b24767e061c98661",
                "name": "AppendImageCopyToMemory",
                "params": [
                    {
                        "desc": "[in] handle of command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] pointer to destination memory to copy to",
                        "name": "dstptr",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] handle of source image to copy from",
                        "name": "hSrcImage",
                        "type": "ze_image_handle_t"
                    },
                    {
                        "desc": "[in][optional] source region descriptor",
                        "name": "pSrcRegion",
                        "type": "const ze_image_region_t*"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hSrcImage`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == dstptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendImageCopyToMemoryExt": {
                "analogue": [
                    "clEnqueueReadImage"
                ],
                "class": "zeCommandList",
                "desc": "Copies from an image to device or shared memory.",
                "details": [
                    "The application must ensure the memory pointed to by dstptr is accessible by the device on which the command list was created.",
                    "The implementation must not access the memory pointed to by dstptr as it is free to be modified by either the Host or device up until execution.",
                    "The application must ensure the image and events are accessible by the device on which the command list was created.",
                    "The application must ensure the image format descriptor for the source image is a single-planar format.",
                    "The application must ensure that the rowPitch is set to 0 if image is a 1D image. Otherwise the rowPitch must be greater than or equal to the element size in bytes x width.",
                    "If rowPitch is set to 0, the appropriate row pitch is calculated based on the size of each element in bytes multiplied by width",
                    "The application must ensure that the slicePitch is set to 0 if image is a 1D or 2D image. Otherwise this value must be greater than or equal to rowPitch x height.",
                    "If slicePitch is set to 0, the appropriate slice pitch is calculated based on the rowPitch x height.",
                    "The application must ensure the command list, image and events were created, and the memory was allocated, on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "4617cd10fe0fef8e74a0917d936ab8ebe8cb9dd0b2b07c389fff02bf2f560cb2",
                "name": "AppendImageCopyToMemoryExt",
                "params": [
                    {
                        "desc": "[in] handle of command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] pointer to destination memory to copy to",
                        "name": "dstptr",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] handle of source image to copy from",
                        "name": "hSrcImage",
                        "type": "ze_image_handle_t"
                    },
                    {
                        "desc": "[in][optional] source region descriptor",
                        "name": "pSrcRegion",
                        "type": "const ze_image_region_t*"
                    },
                    {
                        "desc": "[in] size in bytes of the 1D slice of the 2D region of a 2D or 3D image or each image of a 1D or 2D image array being written",
                        "name": "destRowPitch",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] size in bytes of the 2D slice of the 3D region of a 3D image or each image of a 1D or 2D image array being written",
                        "name": "destSlicePitch",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hSrcImage`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == dstptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.3"
            },
            "AppendLaunchCooperativeKernel": {
                "class": "zeCommandList",
                "desc": "Launch kernel cooperatively over one or more work groups.",
                "details": [
                    "The application must ensure the kernel and events are accessible by the device on which the command list was created.",
                    "This may **only** be called for a command list created with command queue group ordinal that supports compute.",
                    "This may only be used for a command list that are submitted to command queue with cooperative flag set.",
                    "The application must ensure the command list, kernel and events were created on the same context.",
                    "This function may **not** be called from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free.",
                    "Use zeKernelSuggestMaxCooperativeGroupCount to recommend max group count for device for cooperative functions that device supports."
                ],
                "hash": "4ee4429a16ce3462d77f81121aa8fcdc54b7f6c86f719551f85d09ceef345b47",
                "name": "AppendLaunchCooperativeKernel",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[in] thread group launch arguments",
                        "name": "pLaunchFuncArgs",
                        "type": "const ze_group_count_t*"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pLaunchFuncArgs`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendLaunchKernel": {
                "class": "zeCommandList",
                "desc": "Launch kernel over one or more work groups.",
                "details": [
                    "The application must ensure the kernel and events are accessible by the device on which the command list was created.",
                    "This may **only** be called for a command list created with command queue group ordinal that supports compute.",
                    "The application must ensure the command list, kernel and events were created on the same context.",
                    "This function may **not** be called from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "f59a9452458084e6dda68853fb764998f378a3ad1d5a09acd70d1bb53ec8d2d0",
                "name": "AppendLaunchKernel",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[in] thread group launch arguments",
                        "name": "pLaunchFuncArgs",
                        "type": "const ze_group_count_t*"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pLaunchFuncArgs`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendLaunchKernelIndirect": {
                "class": "zeCommandList",
                "desc": "Launch kernel over one or more work groups using indirect arguments.",
                "details": [
                    "The application must ensure the kernel and events are accessible by the device on which the command list was created.",
                    "The application must ensure the launch arguments are visible to the device on which the command list was created.",
                    "The implementation must not access the contents of the launch arguments as they are free to be modified by either the Host or device up until execution.",
                    "This may **only** be called for a command list created with command queue group ordinal that supports compute.",
                    "The application must ensure the command list, kernel and events were created, and the memory was allocated, on the same context.",
                    "This function may **not** be called from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "2abb2eb1e4c7084a2166e1780de252181b9e2ec652c5003523f7c83d6822431e",
                "name": "AppendLaunchKernelIndirect",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[in] pointer to device buffer that will contain thread group launch arguments",
                        "name": "pLaunchArgumentsBuffer",
                        "type": "const ze_group_count_t*"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pLaunchArgumentsBuffer`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendLaunchMultipleKernelsIndirect": {
                "class": "zeCommandList",
                "desc": "Launch multiple kernels over one or more work groups using an array of indirect arguments.",
                "details": [
                    "The application must ensure the kernel and events are accessible by the device on which the command list was created.",
                    "The application must ensure the array of launch arguments and count buffer are visible to the device on which the command list was created.",
                    "The implementation must not access the contents of the array of launch arguments or count buffer as they are free to be modified by either the Host or device up until execution.",
                    "This may **only** be called for a command list created with command queue group ordinal that supports compute.",
                    "The application must enusre the command list, kernel and events were created, and the memory was allocated, on the same context.",
                    "This function may **not** be called from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "6371eb9530a0bb3b56b9423b7dfdccc85af50cfcfcd5cb5983bc1adc1a29eec7",
                "name": "AppendLaunchMultipleKernelsIndirect",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] maximum number of kernels to launch",
                        "name": "numKernels",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, numKernels)] handles of the kernel objects",
                        "name": "phKernels",
                        "type": "ze_kernel_handle_t*"
                    },
                    {
                        "desc": "[in] pointer to device memory location that will contain the actual number of kernels to launch; value must be less than or equal to numKernels",
                        "name": "pCountBuffer",
                        "type": "const uint32_t*"
                    },
                    {
                        "desc": "[in][range(0, numKernels)] pointer to device buffer that will contain a contiguous array of thread group launch arguments",
                        "name": "pLaunchArgumentsBuffer",
                        "type": "const ze_group_count_t*"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phKernels`",
                            "`nullptr == pCountBuffer`",
                            "`nullptr == pLaunchArgumentsBuffer`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendMemAdvise": {
                "class": "zeCommandList",
                "desc": "Provides advice about the use of a shared memory range",
                "details": [
                    "Memory advice is a performance hint only and is not required for functional correctness.",
                    "Memory advice can be used to override driver heuristics to explicitly control shared memory behavior.",
                    "Not all memory advice hints may be supported for all allocation types for all devices.\nIf a memory advice hint is not supported by the device it will be ignored.\n",
                    "Memory advice may only be supported at a device-specific granularity, such as at a page boundary.\nIn this case, the memory range may be expanded such that the start and end of the range satisfy granularity requirements.\n",
                    "The application must ensure the memory pointed to by ptr is accessible by the device on which the command list was created.",
                    "The application must ensure the command list was created, and memory was allocated, on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle, and the memory was allocated.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "284b6017b356f12150bfd94c56b8eaae692b7502a585c5ad79087a09f1ae1ed6",
                "name": "AppendMemAdvise",
                "params": [
                    {
                        "desc": "[in] handle of command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] device associated with the memory advice",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] Pointer to the start of the memory range",
                        "name": "ptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] Size in bytes of the memory range",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] Memory advice for the memory range",
                        "name": "advice",
                        "type": "ze_memory_advice_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZE_MEMORY_ADVICE_CLEAR_SYSTEM_MEMORY_PREFERRED_LOCATION < advice`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendMemoryCopy": {
                "analogue": [
                    "**clEnqueueCopyBuffer**",
                    "**clEnqueueReadBuffer**",
                    "**clEnqueueWriteBuffer**",
                    "**clEnqueueSVMMemcpy**"
                ],
                "class": "zeCommandList",
                "desc": "Copies host, device, or shared memory.",
                "details": [
                    "The application must ensure the memory pointed to by dstptr and srcptr is accessible by the device on which the command list was created.",
                    "The implementation must not access the memory pointed to by dstptr and srcptr as they are free to be modified by either the Host or device up until execution.",
                    "The application must ensure the events are accessible by the device on which the command list was created.",
                    "The application must ensure the command list and events were created, and the memory was allocated, on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "ad0b0d6ec34781d2d948dae898bcef13d0c53606d2e15f44083e0344c71b0c58",
                "name": "AppendMemoryCopy",
                "params": [
                    {
                        "desc": "[in] handle of command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] pointer to destination memory to copy to",
                        "name": "dstptr",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] pointer to source memory to copy from",
                        "name": "srcptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] size in bytes to copy",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == dstptr`",
                            "`nullptr == srcptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendMemoryCopyFromContext": {
                "class": "zeCommandList",
                "desc": "Copies host, device, or shared memory from another context.",
                "details": [
                    "The current active and source context must be from the same driver.",
                    "The application must ensure the memory pointed to by dstptr and srcptr is accessible by the device on which the command list was created.",
                    "The implementation must not access the memory pointed to by dstptr and srcptr as they are free to be modified by either the Host or device up until execution.",
                    "The application must ensure the events are accessible by the device on which the command list was created.",
                    "The application must ensure the command list and events were created, and the memory was allocated, on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "ee5b4182bb618a4229df230e3badddbd2d5b26d047bdc5ec1ab6d04ae1550c6c",
                "name": "AppendMemoryCopyFromContext",
                "params": [
                    {
                        "desc": "[in] handle of command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] pointer to destination memory to copy to",
                        "name": "dstptr",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] handle of source context object",
                        "name": "hContextSrc",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] pointer to source memory to copy from",
                        "name": "srcptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] size in bytes to copy",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hContextSrc`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == dstptr`",
                            "`nullptr == srcptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendMemoryCopyRegion": {
                "class": "zeCommandList",
                "desc": "Copies a region from a 2D or 3D array of host, device, or shared memory.",
                "details": [
                    "The application must ensure the memory pointed to by dstptr and srcptr is accessible by the device on which the command list was created.",
                    "The implementation must not access the memory pointed to by dstptr and srcptr as they are free to be modified by either the Host or device up until execution.",
                    "The region width, height, and depth for both src and dst must be same. The origins can be different.",
                    "The src and dst regions cannot be overlapping.",
                    "The application must ensure the events are accessible by the device on which the command list was created.",
                    "The application must ensure the command list and events were created, and the memory was allocated, on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "2d8ebe2228f5e110d96df47e805d946a86399f0753caf8daef271d41b4f1d53b",
                "name": "AppendMemoryCopyRegion",
                "params": [
                    {
                        "desc": "[in] handle of command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] pointer to destination memory to copy to",
                        "name": "dstptr",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] pointer to destination region to copy to",
                        "name": "dstRegion",
                        "type": "const ze_copy_region_t*"
                    },
                    {
                        "desc": "[in] destination pitch in bytes",
                        "name": "dstPitch",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] destination slice pitch in bytes. This is required for 3D region copies where the `depth` member of ze_copy_region_t is not 0, otherwise it's ignored.",
                        "name": "dstSlicePitch",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] pointer to source memory to copy from",
                        "name": "srcptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] pointer to source region to copy from",
                        "name": "srcRegion",
                        "type": "const ze_copy_region_t*"
                    },
                    {
                        "desc": "[in] source pitch in bytes",
                        "name": "srcPitch",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] source slice pitch in bytes. This is required for 3D region copies where the `depth` member of ze_copy_region_t is not 0, otherwise it's ignored.",
                        "name": "srcSlicePitch",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == dstptr`",
                            "`nullptr == dstRegion`",
                            "`nullptr == srcptr`",
                            "`nullptr == srcRegion`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_OVERLAPPING_REGIONS": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendMemoryFill": {
                "analogue": [
                    "**clEnqueueFillBuffer**",
                    "**clEnqueueSVMMemFill**"
                ],
                "class": "zeCommandList",
                "desc": "Initializes host, device, or shared memory.",
                "details": [
                    "The application must ensure the memory pointed to by dstptr is accessible by the device on which the command list was created.",
                    "The implementation must not access the memory pointed to by dstptr as it is free to be modified by either the Host or device up until execution.",
                    "The value to initialize memory to is described by the pattern and the pattern size.",
                    "The pattern size must be a power-of-two and less than or equal to the `maxMemoryFillPatternSize` member of ze_command_queue_group_properties_t.",
                    "The application must ensure the events are accessible by the device on which the command list was created.",
                    "The application must ensure the command list and events were created, and the memory was allocated, on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "c98cfd3f97d313db11ecb3c767d90077c416d84b29f1a71de2b5f7e92750fe2b",
                "name": "AppendMemoryFill",
                "params": [
                    {
                        "desc": "[in] handle of command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] pointer to memory to initialize",
                        "name": "ptr",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] pointer to value to initialize memory to",
                        "name": "pattern",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] size in bytes of the value to initialize memory to",
                        "name": "pattern_size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] size in bytes to initialize",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`",
                            "`nullptr == pattern`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendMemoryPrefetch": {
                "analogue": [
                    "clEnqueueSVMMigrateMem"
                ],
                "class": "zeCommandList",
                "desc": "Asynchronously prefetches shared memory to the device associated with the specified command list",
                "details": [
                    "This is a hint to improve performance only and is not required for correctness.",
                    "Only prefetching to the device associated with the specified command list is supported.\nPrefetching to the host or to a peer device is not supported.\n",
                    "Prefetching may not be supported for all allocation types for all devices.\nIf memory prefetching is not supported for the specified memory range the prefetch hint may be ignored.\n",
                    "Prefetching may only be supported at a device-specific granularity, such as at a page boundary.\nIn this case, the memory range may be expanded such that the start and end of the range satisfy granularity requirements.\n",
                    "The application must ensure the memory pointed to by ptr is accessible by the device on which the command list was created.",
                    "The application must ensure the command list was created, and the memory was allocated, on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "1fb509b4db2cea1d6ae38f5b63e959b39668825e1cb46d868ec6343758967c46",
                "name": "AppendMemoryPrefetch",
                "params": [
                    {
                        "desc": "[in] handle of command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] pointer to start of the memory range to prefetch",
                        "name": "ptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] size in bytes of the memory range to prefetch",
                        "name": "size",
                        "type": "size_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendMemoryRangesBarrier": {
                "class": "zeCommandList",
                "desc": "Appends a global memory ranges barrier into a command list.",
                "details": [
                    "The application must ensure the events are accessible by the device on which the command list was created.",
                    "If numWaitEvents is zero, then all previous commands are completed prior to the execution of the barrier.",
                    "If numWaitEvents is non-zero, then then all phWaitEvents must be signaled prior to the execution of the barrier.",
                    "This command blocks all following commands from beginning until the execution of the barrier completes.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "fae8b64e8c86fd1906d766d41853886f1dbdb52d56a653b71bda797ae302cd7c",
                "name": "AppendMemoryRangesBarrier",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] number of memory ranges",
                        "name": "numRanges",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, numRanges)] array of sizes of memory range",
                        "name": "pRangeSizes",
                        "type": "const size_t*"
                    },
                    {
                        "desc": "[in][range(0, numRanges)] array of memory ranges",
                        "name": "pRanges",
                        "type": "const void**"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before executing barrier; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before executing barrier",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pRangeSizes`",
                            "`nullptr == pRanges`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendMetricMemoryBarrier": {
                "class": "zetCommandList",
                "desc": "Appends metric query commands to flush all caches.",
                "details": [
                    "The application must **not** call this function from simultaneous threads with the same command list handle."
                ],
                "hash": "9f3cba9f6f40a91263c007a1f597465b2b96639756498cbd3a1f6a034e4b6f3a",
                "name": "AppendMetricMemoryBarrier",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "zet_command_list_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendMetricQueryBegin": {
                "class": "zetCommandList",
                "desc": "Appends metric query begin into a command list.",
                "details": [
                    "The application must ensure the metric query is accessible by the device on which the command list was created.",
                    "The application must ensure the command list and metric query were created on the same context.",
                    "This command blocks all following commands from beginning until the execution of the query completes.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle."
                ],
                "hash": "84fe1ebe23db5e8ef6eea4d147307ac6af09f6df489af8613329efb938d59e2e",
                "name": "AppendMetricQueryBegin",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "zet_command_list_handle_t"
                    },
                    {
                        "desc": "[in] handle of the metric query",
                        "name": "hMetricQuery",
                        "type": "zet_metric_query_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hMetricQuery`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendMetricQueryEnd": {
                "class": "zetCommandList",
                "desc": "Appends metric query end into a command list.",
                "details": [
                    "The application must ensure the metric query and events are accessible by the device on which the command list was created.",
                    "The application must ensure the command list, events and metric query were created on the same context.",
                    "The duration of the signal event created from an event pool that was created using ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag is undefined. However, for consistency and orthogonality the event will report correctly as signaled when used by other event API functionality.",
                    "If numWaitEvents is zero, then all previous commands are completed prior to the execution of the query.",
                    "If numWaitEvents is non-zero, then all phWaitEvents must be signaled prior to the execution of the query.",
                    "This command blocks all following commands from beginning until the execution of the query completes.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle."
                ],
                "hash": "20793bcbc2a57cd3cd64765ed31236e03d78c596d549679ccb5733f2829ff01e",
                "name": "AppendMetricQueryEnd",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "zet_command_list_handle_t"
                    },
                    {
                        "desc": "[in] handle of the metric query",
                        "name": "hMetricQuery",
                        "type": "zet_metric_query_handle_t"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in] must be zero",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][mbz] must be nullptr",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hMetricQuery`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendMetricStreamerMarker": {
                "class": "zetCommandList",
                "desc": "Append metric streamer marker into a command list.",
                "details": [
                    "The application must ensure the metric streamer is accessible by the device on which the command list was created.",
                    "The application must ensure the command list and metric streamer were created on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "Allow to associate metric stream time based metrics with executed workload."
                ],
                "hash": "442249fcbae3e728493309e244e058e9b58dbcd35d8a6e08a27fc30e787152fa",
                "name": "AppendMetricStreamerMarker",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "zet_command_list_handle_t"
                    },
                    {
                        "desc": "[in] handle of the metric streamer",
                        "name": "hMetricStreamer",
                        "type": "zet_metric_streamer_handle_t"
                    },
                    {
                        "desc": "[in] streamer marker value",
                        "name": "value",
                        "type": "uint32_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hMetricStreamer`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendQueryKernelTimestamps": {
                "class": "zeCommandList",
                "desc": "Appends a query of an events' timestamp value(s) into a command list.",
                "details": [
                    "The application must ensure the events are accessible by the device on which the command list was created.",
                    "The application must ensure the events were created from an event pool that was created using ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag.",
                    "The application must ensure the memory pointed to by both dstptr and pOffsets is accessible by the device on which the command list was created.",
                    "The value(s) written to the destination buffer are undefined if any timestamp event has not been signaled.",
                    "If pOffsets is nullptr, then multiple results will be appended sequentially into memory in the same order as phEvents.",
                    "The application must ensure the command list and events were created, and the memory was allocated, on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "4c4995873967303d865550c3b2d867bec5a54cbe91822e9d506aefb30a154a51",
                "name": "AppendQueryKernelTimestamps",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] the number of timestamp events to query",
                        "name": "numEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, numEvents)] handles of timestamp events to query",
                        "name": "phEvents",
                        "type": "ze_event_handle_t*"
                    },
                    {
                        "desc": "[in,out] pointer to memory where ze_kernel_timestamp_result_t will be written; must be size-aligned.",
                        "name": "dstptr",
                        "type": "void*"
                    },
                    {
                        "desc": "[in][optional][range(0, numEvents)] offset, in bytes, to write results; address must be 4byte-aligned and offsets must be size-aligned.",
                        "name": "pOffsets",
                        "type": "const size_t*"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before executing query; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before executing query",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phEvents`",
                            "`nullptr == dstptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "AppendSignalEvent": {
                "analogue": [
                    "**clSetUserEventStatus**",
                    "vkCmdSetEvent"
                ],
                "class": "zeCommandList",
                "desc": "Appends a signal of the event from the device into a command list.",
                "details": [
                    "The application must ensure the events are accessible by the device on which the command list was created.",
                    "The duration of an event created from an event pool that was created using ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP or ZE_EVENT_POOL_FLAG_KERNEL_MAPPED_TIMESTAMP flags is undefined. However, for consistency and orthogonality the event will report correctly as signaled when used by other event API functionality.",
                    "The application must ensure the command list and events were created on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "ef0d28011f775d958ceb555be2b1461cc174bf0b645a7086af4617a238d567d1",
                "name": "AppendSignalEvent",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] handle of the event",
                        "name": "hEvent",
                        "type": "ze_event_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`",
                            "`nullptr == hEvent`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    }
                ],
                "type": "function"
            },
            "AppendWaitOnEvents": {
                "class": "zeCommandList",
                "desc": "Appends wait on event(s) on the device into a command list.",
                "details": [
                    "The application must ensure the events are accessible by the device on which the command list was created.",
                    "The application must ensure the command list and events were created on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "ba8886530b42c816643a1fd9bc79e7b1599c5488c322575de5cb14cb4422e611",
                "name": "AppendWaitOnEvents",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in] number of events to wait on before continuing",
                        "name": "numEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, numEvents)] handles of the events to wait on before continuing",
                        "name": "phEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phEvents`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    }
                ],
                "type": "function"
            },
            "AppendWriteGlobalTimestamp": {
                "class": "zeCommandList",
                "desc": "Appends a memory write of the device's global timestamp value into a command list.",
                "details": [
                    "The application must ensure the events are accessible by the device on which the command list was created.",
                    "The timestamp frequency can be queried from the `timerResolution` member of ze_device_properties_t.",
                    "The number of valid bits in the timestamp value can be queried from the `timestampValidBits` member of ze_device_properties_t.",
                    "The application must ensure the memory pointed to by dstptr is accessible by the device on which the command list was created.",
                    "The application must ensure the command list and events were created, and the memory was allocated, on the same context.",
                    "The application must **not** call this function from simultaneous threads with the same command list handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "620d2dca06e6c6bb04322005bce81b51791428e2067de2e40dd0b139ebe9dd89",
                "name": "AppendWriteGlobalTimestamp",
                "params": [
                    {
                        "desc": "[in] handle of the command list",
                        "name": "hCommandList",
                        "type": "ze_command_list_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to memory where timestamp value will be written; must be 8byte-aligned.",
                        "name": "dstptr",
                        "type": "uint64_t*"
                    },
                    {
                        "desc": "[in][optional] handle of the event to signal on completion",
                        "name": "hSignalEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in][optional] number of events to wait on before executing query; must be 0 if `nullptr == phWaitEvents`",
                        "name": "numWaitEvents",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before executing query",
                        "name": "phWaitEvents",
                        "type": "ze_event_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandList`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == dstptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                        ]
                    }
                ],
                "type": "function"
            },
            "Attach": {
                "class": "zetDebug",
                "decl": "static",
                "desc": "Attach to a device.",
                "details": [
                    "The device must be enabled for debug; see zesSchedulerSetComputeUnitDebugMode."
                ],
                "hash": "74b0dd833de78ddc67ac82d65994001fac9a4efcc3faf3db5862b8824404bfe6",
                "name": "Attach",
                "params": [
                    {
                        "desc": "[in] device handle",
                        "name": "hDevice",
                        "type": "zet_device_handle_t"
                    },
                    {
                        "desc": "[in] the debug configuration",
                        "name": "config",
                        "type": "const zet_debug_config_t*"
                    },
                    {
                        "desc": "[out] debug session handle",
                        "name": "phDebug",
                        "type": "zet_debug_session_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == config`",
                            "`nullptr == phDebug`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "attaching to this device is not supported"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "caller does not have sufficient permissions"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "a debugger is already attached"
                        ]
                    }
                ],
                "type": "function"
            },
            "BuildExp": {
                "class": "zeRTASBuilder",
                "desc": "Build ray tracing acceleration structure",
                "details": [
                    "This function builds an acceleration structure of the scene consisting of the specified geometry information and writes the acceleration structure to the provided destination buffer. All types of geometries can get freely mixed inside a scene.\n",
                    "It is the user's responsibility to manage the acceleration structure buffer allocation, de-allocation, and potential prefetching to the device memory. The required size of the acceleration structure buffer can be queried with the zeRTASBuilderGetBuildPropertiesExp function. The acceleration structure buffer must be a shared USM allocation and should be present on the host at build time. The referenced scene data (index- and vertex- buffers) can be standard host allocations, and will not be referenced into by the build acceleration structure.\n",
                    "Before an acceleration structure can be built, the user must allocate the memory for the acceleration structure buffer and scratch buffer using sizes based on a query for the estimated size properties.\n",
                    "When using the \"worst-case\" size for the acceleration structure buffer, the acceleration structure construction will never fail with ZE_RESULT_EXP_RTAS_BUILD_RETRY.\n",
                    "When using the \"expected\" size for the acceleration structure buffer, the acceleration structure construction may fail with ZE_RESULT_EXP_RTAS_BUILD_RETRY. If this happens, the user may resize their acceleration structure buffer using the returned `*pRtasBufferSizeBytes` value, which will be updated with an improved size estimate that will likely result in a successful build.\n",
                    "The acceleration structure construction is run on the host and is synchronous, thus after the function returns with a successful result, the acceleration structure may be used.\n",
                    "All provided data buffers must be host-accessible.\n",
                    "The acceleration structure buffer must be a USM allocation.\n",
                    "A successfully constructed acceleration structure is entirely self-contained. There is no requirement for input data to persist beyond build completion.\n",
                    "A successfully constructed acceleration structure is non-copyable.\n",
                    "Acceleration structure construction may be parallelized by passing a valid handle to a parallel operation object and joining that parallel operation using zeRTASParallelOperationJoinExp with user-provided worker threads.\n",
                    "**Additional Notes**\n  - \"The geometry infos array, geometry infos, and scratch buffer must all be standard host memory allocations.\"\n  - \"A pointer to a geometry info can be a null pointer, in which case the geometry is treated as empty.\"\n  - \"If no parallel operation handle is provided, the build is run sequentially on the current thread.\"\n  - \"A parallel operation object may only be associated with a single acceleration structure build at a time.\"\n"
                ],
                "hash": "1af60f3a2043a55be18e8aa51ba5f1c4728144ab861978a1fbfd6dbe6b388b62",
                "name": "BuildExp",
                "params": [
                    {
                        "desc": "[in] handle of builder object",
                        "name": "hBuilder",
                        "type": "ze_rtas_builder_exp_handle_t"
                    },
                    {
                        "desc": "[in] pointer to build operation descriptor",
                        "name": "pBuildOpDescriptor",
                        "type": "const ze_rtas_builder_build_op_exp_desc_t*"
                    },
                    {
                        "desc": "[in][range(0, `scratchBufferSizeBytes`)] scratch buffer to be used during acceleration structure construction",
                        "name": "pScratchBuffer",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] size of scratch buffer, in bytes",
                        "name": "scratchBufferSizeBytes",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] pointer to destination buffer",
                        "name": "pRtasBuffer",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] destination buffer size, in bytes",
                        "name": "rtasBufferSizeBytes",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in][optional] handle to parallel operation object",
                        "name": "hParallelOperation",
                        "type": "ze_rtas_parallel_operation_exp_handle_t"
                    },
                    {
                        "desc": "[in][optional] pointer passed to callbacks",
                        "name": "pBuildUserPtr",
                        "type": "void*"
                    },
                    {
                        "desc": "[in,out][optional] pointer to destination address for acceleration structure bounds",
                        "name": "pBounds",
                        "type": "ze_rtas_aabb_exp_t*"
                    },
                    {
                        "desc": "[out][optional] updated acceleration structure size requirement, in bytes",
                        "name": "pRtasBufferSizeBytes",
                        "type": "size_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hBuilder`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pBuildOpDescriptor`",
                            "`nullptr == pScratchBuffer`",
                            "`nullptr == pRtasBuffer`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZE_RTAS_FORMAT_EXP_INVALID < pBuildOpDescriptor->rtasFormat`",
                            "`ZE_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_HIGH < pBuildOpDescriptor->buildQuality`",
                            "`0x3 < pBuildOpDescriptor->buildFlags`"
                        ]
                    },
                    {
                        "ZE_RESULT_EXP_RTAS_BUILD_DEFERRED": [
                            "Acceleration structure build completion is deferred to parallel operation join."
                        ]
                    },
                    {
                        "ZE_RESULT_EXP_RTAS_BUILD_RETRY": [
                            "Acceleration structure build failed due to insufficient resources, retry the build operation with a larger acceleration structure buffer allocation."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE": [
                            "Acceleration structure build failed due to parallel operation object participation in another build operation."
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "CalculateMetricExportDataExp": {
                "class": "zetMetricGroup",
                "decl": "static",
                "desc": "Calculate one or more sets of metric values from exported raw data.",
                "details": [
                    "Calculate metrics values using exported data returned by zetMetricGroupGetExportDataExp.",
                    "This function is similar to zetMetricGroupCalculateMultipleMetricValuesExp except it would calculate from exported metric data.",
                    "This function could be used to calculate metrics on a system different from where the metric raw data was collected.",
                    "The application may call this function from simultaneous threads."
                ],
                "hash": "45b7016f0a5f68adeb96524bb980cfdbf317c31a6a579e8be8dff30f93df6085",
                "name": "CalculateMetricExportDataExp",
                "params": [
                    {
                        "desc": "[in] handle of the driver instance",
                        "name": "hDriver",
                        "type": "ze_driver_handle_t"
                    },
                    {
                        "desc": "[in] calculation type to be applied on raw data",
                        "name": "type",
                        "type": "zet_metric_group_calculation_type_t"
                    },
                    {
                        "desc": "[in] size in bytes of exported data buffer",
                        "name": "exportDataSize",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in][range(0, exportDataSize)] buffer of exported data to calculate",
                        "name": "pExportData",
                        "type": "const uint8_t*"
                    },
                    {
                        "desc": "[in] descriptor specifying calculation specific parameters",
                        "name": "pCalculateDescriptor",
                        "type": "zet_metric_calculate_exp_desc_t*"
                    },
                    {
                        "desc": "[in,out] pointer to number of metric sets.\nif count is zero, then the driver shall update the value with the total number of metric sets to be calculated.\nif count is greater than the number available in the raw data buffer, then the driver shall update the value with the actual number of metric sets to be calculated.\n",
                        "name": "pSetCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out] pointer to number of the total number of metric values calculated, for all metric sets.\nif count is zero, then the driver shall update the value with the total number of metric values to be calculated.\nif count is greater than the number available in the raw data buffer, then the driver shall update the value with the actual number of metric values to be calculated.\n",
                        "name": "pTotalMetricValueCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pSetCount)] buffer of metric counts per metric set.\n",
                        "name": "pMetricCounts",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pTotalMetricValueCount)] buffer of calculated metrics.\nif count is less than the number available in the raw data buffer, then driver shall only calculate that number of metric values.\n",
                        "name": "pMetricValues",
                        "type": "zet_typed_value_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDriver`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZET_METRIC_GROUP_CALCULATION_TYPE_MAX_METRIC_VALUES < type`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pExportData`",
                            "`nullptr == pCalculateDescriptor`",
                            "`nullptr == pSetCount`",
                            "`nullptr == pTotalMetricValueCount`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.6"
            },
            "CalculateMetricValues": {
                "class": "zetMetricGroup",
                "decl": "static",
                "desc": "Calculates metric values from raw data.",
                "details": [
                    "The application may call this function from simultaneous threads."
                ],
                "hash": "cb6e20cd2535530f4def46834390547217f8eba6eeba1dc0a902555c40af9028",
                "name": "CalculateMetricValues",
                "params": [
                    {
                        "desc": "[in] handle of the metric group",
                        "name": "hMetricGroup",
                        "type": "zet_metric_group_handle_t"
                    },
                    {
                        "desc": "[in] calculation type to be applied on raw data",
                        "name": "type",
                        "type": "zet_metric_group_calculation_type_t"
                    },
                    {
                        "desc": "[in] size in bytes of raw data buffer",
                        "name": "rawDataSize",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in][range(0, rawDataSize)] buffer of raw data to calculate",
                        "name": "pRawData",
                        "type": "const uint8_t*"
                    },
                    {
                        "desc": "[in,out] pointer to number of metric values calculated.\nif count is zero, then the driver shall update the value with the total number of metric values to be calculated.\nif count is greater than the number available in the raw data buffer, then the driver shall update the value with the actual number of metric values to be calculated.\n",
                        "name": "pMetricValueCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pMetricValueCount)] buffer of calculated metrics.\nif count is less than the number available in the raw data buffer, then driver shall only calculate that number of metric values.\n",
                        "name": "pMetricValues",
                        "type": "zet_typed_value_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hMetricGroup`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZET_METRIC_GROUP_CALCULATION_TYPE_MAX_METRIC_VALUES < type`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pRawData`",
                            "`nullptr == pMetricValueCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "CalculateMultipleMetricValuesExp": {
                "class": "zetMetricGroup",
                "decl": "static",
                "desc": "Calculate one or more sets of metric values from raw data.",
                "details": [
                    "This function is similar to zetMetricGroupCalculateMetricValues except it may calculate more than one set of metric values from a single data buffer.  There may be one set of metric values for each sub-device, for example.",
                    "Each set of metric values may consist of a different number of metric values, returned as the metric value count.",
                    "All metric values are calculated into a single buffer; use the metric counts to determine which metric values belong to which set.",
                    "The application may call this function from simultaneous threads."
                ],
                "hash": "e2074d5e3c7ddbf7f7bd4a5a71cdb32afce7fdf407b420ee8e22d44c84e0bb83",
                "name": "CalculateMultipleMetricValuesExp",
                "params": [
                    {
                        "desc": "[in] handle of the metric group",
                        "name": "hMetricGroup",
                        "type": "zet_metric_group_handle_t"
                    },
                    {
                        "desc": "[in] calculation type to be applied on raw data",
                        "name": "type",
                        "type": "zet_metric_group_calculation_type_t"
                    },
                    {
                        "desc": "[in] size in bytes of raw data buffer",
                        "name": "rawDataSize",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in][range(0, rawDataSize)] buffer of raw data to calculate",
                        "name": "pRawData",
                        "type": "const uint8_t*"
                    },
                    {
                        "desc": "[in,out] pointer to number of metric sets.\nif count is zero, then the driver shall update the value with the total number of metric sets to be calculated.\nif count is greater than the number available in the raw data buffer, then the driver shall update the value with the actual number of metric sets to be calculated.\n",
                        "name": "pSetCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out] pointer to number of the total number of metric values calculated, for all metric sets.\nif count is zero, then the driver shall update the value with the total number of metric values to be calculated.\nif count is greater than the number available in the raw data buffer, then the driver shall update the value with the actual number of metric values to be calculated.\n",
                        "name": "pTotalMetricValueCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pSetCount)] buffer of metric counts per metric set.\n",
                        "name": "pMetricCounts",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pTotalMetricValueCount)] buffer of calculated metrics.\nif count is less than the number available in the raw data buffer, then driver shall only calculate that number of metric values.\n",
                        "name": "pMetricValues",
                        "type": "zet_typed_value_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hMetricGroup`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZET_METRIC_GROUP_CALCULATION_TYPE_MAX_METRIC_VALUES < type`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pRawData`",
                            "`nullptr == pSetCount`",
                            "`nullptr == pTotalMetricValueCount`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.2"
            },
            "CanAccessPeer": {
                "class": "zeDevice",
                "desc": "Queries if one device can directly access peer device allocations",
                "details": [
                    "Any device can access any other device within a node through a scale-up fabric.",
                    {
                        "The following are conditions for CanAccessPeer query.": [
                            "If both device and peer device are the same then return true.",
                            "If both sub-device and peer sub-device are the same then return true.",
                            "If both are sub-devices and share the same parent device then return true.",
                            "If both device and remote device are connected by a direct or indirect scale-up fabric or over PCIe (same root complex or shared PCIe switch) then true.",
                            "If both sub-device and remote parent device (and vice-versa) are connected by a direct or indirect scale-up fabric or over PCIe (same root complex or shared PCIe switch) then true."
                        ]
                    },
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "c0efe8786ca9d0204583c7af454d4d27a3c5bff533ae3c4a002d017c0f444943",
                "name": "CanAccessPeer",
                "ordinal": "2",
                "params": [
                    {
                        "desc": "[in] handle of the device performing the access",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] handle of the peer device with the allocation",
                        "name": "hPeerDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[out] returned access capability",
                        "name": "value",
                        "type": "ze_bool_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`",
                            "`nullptr == hPeerDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == value`"
                        ]
                    }
                ],
                "type": "function"
            },
            "ClearStateExp": {
                "class": "zesRas",
                "desc": "Ras Clear State",
                "details": [
                    "This function clears error counters for a RAS error category.",
                    "Clearing errors will affect other threads/applications - the counter values will start from zero.",
                    "Clearing errors requires write permissions.",
                    "The application should not call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "94c31ad19460e9ec5a14b5d704aa570c4b03bf09d0a0c48838190b0a3e50f362",
                "name": "ClearStateExp",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hRas",
                        "type": "zes_ras_handle_t"
                    },
                    {
                        "desc": "[in] category for which error counter is to be cleared.",
                        "name": "category",
                        "type": "zes_ras_error_category_exp_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hRas`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZES_RAS_ERROR_CATEGORY_EXP_L3FABRIC_ERRORS < category`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "Don't have permissions to clear error counters."
                        ]
                    }
                ],
                "type": "function"
            },
            "Close": {
                "class": "zetMetricStreamer",
                "desc": "Closes metric streamer.",
                "details": [
                    "The application must **not** call this function from simultaneous threads with the same metric streamer handle."
                ],
                "hash": "f4cbb10d86bc48d25d8daf58501a6a5f561fad25962e1174cdbe30f1a912e97a",
                "name": "Close",
                "params": [
                    {
                        "desc": "[in][release] handle of the metric streamer",
                        "name": "hMetricStreamer",
                        "type": "zet_metric_streamer_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hMetricStreamer`"
                        ]
                    }
                ],
                "type": "function"
            },
            "CloseIpcHandle": {
                "class": "zeMem",
                "decl": "static",
                "desc": "Closes an IPC memory handle",
                "details": [
                    "Closes an IPC memory handle by unmapping memory that was opened in this process using zeMemOpenIpcHandle.",
                    "The application must **not** call this function from simultaneous threads with the same pointer.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "1b6b175814390040738d87ef1f94dc36e59d432b77e807f87deb87214188070b",
                "name": "CloseIpcHandle",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in][release] pointer to device allocation in this process",
                        "name": "ptr",
                        "type": "const void*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`"
                        ]
                    }
                ],
                "type": "function"
            },
            "Create": {
                "class": "zetTracerExp",
                "decl": "static",
                "desc": "Creates a tracer on the context.",
                "details": [
                    "The application must only use the tracer for the context which was provided during creation.",
                    "The tracer is created in the disabled state.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "99654d158628fa6f80a407f4c6dd5fc582fec9bef666d5e4e841639ff3ddf90b",
                "name": "Create",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "zet_context_handle_t"
                    },
                    {
                        "desc": "[in] pointer to tracer descriptor",
                        "name": "desc",
                        "type": "const zet_tracer_exp_desc_t*"
                    },
                    {
                        "desc": "[out] pointer to handle of tracer object created",
                        "name": "phTracer",
                        "type": "zet_tracer_exp_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == desc`",
                            "`nullptr == desc->pUserData`",
                            "`nullptr == phTracer`"
                        ]
                    }
                ],
                "type": "function"
            },
            "CreateEx": {
                "class": "zeContext",
                "decl": "static",
                "desc": "Creates a context for the driver.",
                "details": [
                    "The application must only use the context for the driver which was provided during creation.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "d71315745f374bebe2c15c3fe1ae79886e18dd91495169b5d2c7359baae5dc9e",
                "name": "CreateEx",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the driver object",
                        "name": "hDriver",
                        "type": "ze_driver_handle_t"
                    },
                    {
                        "desc": "[in] pointer to context descriptor",
                        "name": "desc",
                        "type": "const ze_context_desc_t*"
                    },
                    {
                        "desc": "[in][optional] number of device handles; must be 0 if `nullptr == phDevices`",
                        "name": "numDevices",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][optional][range(0, numDevices)] array of device handles which context has visibility.\nif nullptr, then all devices and any sub-devices supported by the driver instance are\nvisible to the context.\notherwise, the context only has visibility to the devices and any sub-devices of the\ndevices in this array.\n",
                        "name": "phDevices",
                        "type": "ze_device_handle_t*"
                    },
                    {
                        "desc": "[out] pointer to handle of context object created",
                        "name": "phContext",
                        "type": "ze_context_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDriver`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == desc`",
                            "`nullptr == phContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x1 < desc->flags`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`(nullptr == phDevices) && (0 < numDevices)`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.1"
            },
            "CreateExp": {
                "class": "zeRTASParallelOperation",
                "desc": "Creates a ray tracing acceleration structure builder parallel operation object",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe.",
                    "The implementation must support ZE_experimental_rtas_builder extension."
                ],
                "hash": "324930a8492161bf3d335c6e360038a06bea8600cf15aec51610993fedc165e4",
                "name": "CreateExp",
                "params": [
                    {
                        "desc": "[in] handle of driver object",
                        "name": "hDriver",
                        "type": "ze_driver_handle_t"
                    },
                    {
                        "desc": "[out] handle of parallel operation object",
                        "name": "phParallelOperation",
                        "type": "ze_rtas_parallel_operation_exp_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDriver`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phParallelOperation`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "CreateImmediate": {
                "class": "zeCommandList",
                "decl": "static",
                "desc": "Creates an immediate command list on the context.",
                "details": [
                    "An immediate command list is used for low-latency submission of commands.",
                    "An immediate command list creates an implicit command queue.",
                    "Immediate command lists must not be passed to zeCommandQueueExecuteCommandLists.",
                    "Commands appended into an immediate command list may execute synchronously, by blocking until the command is complete.",
                    "The command list is created in the 'open' state and never needs to be closed.",
                    "The application must only use the command list for the device, or its sub-devices, which was provided during creation.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "1563ad20ea2a985de2198858084ef59027e1f44676ac696ddf7356143ad9a544",
                "name": "CreateImmediate",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device object",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] pointer to command queue descriptor",
                        "name": "altdesc",
                        "type": "const ze_command_queue_desc_t*"
                    },
                    {
                        "desc": "[out] pointer to handle of command list object created",
                        "name": "phCommandList",
                        "type": "ze_command_list_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == altdesc`",
                            "`nullptr == phCommandList`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x3 < altdesc->flags`",
                            "`ZE_COMMAND_QUEUE_MODE_ASYNCHRONOUS < altdesc->mode`",
                            "`ZE_COMMAND_QUEUE_PRIORITY_PRIORITY_HIGH < altdesc->priority`"
                        ]
                    }
                ],
                "type": "function"
            },
            "Destroy": {
                "class": "zetTracerExp",
                "decl": "static",
                "desc": "Destroys a tracer.",
                "details": [
                    "The application must **not** call this function from simultaneous threads with the same tracer handle.",
                    "The implementation of this function must be thread-safe.",
                    "The implementation of this function will stall and wait on any outstanding threads executing callbacks before freeing any Host allocations associated with this tracer."
                ],
                "hash": "93988865d3b59785a30efbb5b38fea9024972b775e1ec2b82b52cfcd53e0fac2",
                "name": "Destroy",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in][release] handle of tracer object to destroy",
                        "name": "hTracer",
                        "type": "zet_tracer_exp_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hTracer`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                    }
                ],
                "type": "function"
            },
            "DestroyExp": {
                "class": "zeRTASParallelOperation",
                "desc": "Destroys a ray tracing acceleration structure builder parallel operation object",
                "details": [
                    "The implementation of this function may immediately release any internal Host and Device resources associated with this parallel operation.",
                    "The application must **not** call this function from simultaneous threads with the same parallel operation handle.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "1371aca73bc98168b52b7ef394df4034d67304927b620cd3199fda16fcf3082b",
                "name": "DestroyExp",
                "params": [
                    {
                        "desc": "[in][release] handle of parallel operation object to destroy",
                        "name": "hParallelOperation",
                        "type": "ze_rtas_parallel_operation_exp_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hParallelOperation`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "Detach": {
                "class": "zetDebug",
                "desc": "Close a debug session.",
                "hash": "93beca3b9d167f52e7252bb79962171d25e1face643e2fdc0b256ce88cfd1500",
                "name": "Detach",
                "params": [
                    {
                        "desc": "[in][release] debug session handle",
                        "name": "hDebug",
                        "type": "zet_debug_session_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDebug`"
                        ]
                    }
                ],
                "type": "function"
            },
            "DynamicLink": {
                "class": "zeModule",
                "decl": "static",
                "desc": "Dynamically link modules together that share import/export linkage dependencies.",
                "details": [
                    "Modules support SPIR-V import and export linkage types for functions and global variables. See the SPIR-V specification for linkage details.",
                    "Modules can have both import and export linkage.",
                    "Modules that do not have any imports or exports do not need to be linked.",
                    "All module import requirements must be satisfied via linking before kernel objects can be created from them.",
                    "Modules cannot be partially linked. Unsatisfiable import dependencies in the set of modules passed to zeModuleDynamicLink will result in  ZE_RESULT_ERROR_MODULE_LINK_FAILURE being returned.",
                    "Modules will only be linked once. A module can be used in multiple link calls if it has exports but its imports will not be re-linked.",
                    "Ambiguous dependencies, where multiple modules satisfy the same import dependencies for a module, are not allowed.",
                    "The application must ensure the modules being linked were created on the same context.",
                    "The application may call this function from simultaneous threads as long as the import modules being linked are not the same.",
                    "ModuleGetNativeBinary can be called on any module regardless of whether it is linked or not.",
                    "A link log can optionally be returned to the caller. The caller is responsible for destroying the link log using zeModuleBuildLogDestroy.",
                    "The link log may contain a list of the unresolved import dependencies if present.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "a8c15c9dd068b5439579d4b2caf5406794937dae5b690d508861538dc48fe0dc",
                "name": "DynamicLink",
                "params": [
                    {
                        "desc": "[in] number of modules to be linked pointed to by phModules.",
                        "name": "numModules",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, numModules)] pointer to an array of modules to dynamically link together.",
                        "name": "phModules",
                        "type": "ze_module_handle_t*"
                    },
                    {
                        "desc": "[out][optional] pointer to handle of dynamic link log.",
                        "name": "phLinkLog",
                        "type": "ze_module_build_log_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phModules`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_MODULE_LINK_FAILURE": []
                    }
                ],
                "type": "function"
            },
            "EccAvailable": {
                "class": "zesDevice",
                "desc": "Is ECC functionality available - true or false?",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "264b6e89d9b7c9216eab024643025dc409bda4982818418314482dbb1724ff12",
                "name": "EccAvailable",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[out] ECC functionality is available (true)/unavailable (false).",
                        "name": "pAvailable",
                        "type": "ze_bool_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pAvailable`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.4"
            },
            "EccConfigurable": {
                "class": "zesDevice",
                "desc": "Is ECC support configurable - true or false?",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "0f8ff49a7a8abe8cde740b8234ca60bae96be561699e0a742338476b52a94218",
                "name": "EccConfigurable",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[out] ECC can be enabled/disabled (true)/enabled/disabled (false).",
                        "name": "pConfigurable",
                        "type": "ze_bool_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pConfigurable`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.4"
            },
            "EnumDiagnosticTestSuites": {
                "class": "zesDevice",
                "desc": "Get handle of diagnostics test suites",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "59ed350ef7e70b37e52550c3ab609f5379d8b887c910db4babc51892f01acaed",
                "name": "EnumDiagnosticTestSuites",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phDiagnostics",
                        "type": "zes_diag_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumEngineGroups": {
                "class": "zesDevice",
                "desc": "Get handle of engine groups",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "25e6a47559c32a64fa8b2e4c45eae905a6ec1127530dcbbeb65637befa658e26",
                "name": "EnumEngineGroups",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phEngine",
                        "type": "zes_engine_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumFabricPorts": {
                "class": "zesDevice",
                "desc": "Get handle of Fabric ports in a device",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "f8b22e29f845c563af633d8a69c44bcecceda14be9ca6c0151d348a192c5f7ff",
                "name": "EnumFabricPorts",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phPort",
                        "type": "zes_fabric_port_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumFans": {
                "class": "zesDevice",
                "desc": "Get handle of fans",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "cd402f983e5dc2e1f226dccb0609064e6bd118037410019a20723a8a58c6c4a5",
                "name": "EnumFans",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phFan",
                        "type": "zes_fan_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumFirmwares": {
                "class": "zesDevice",
                "desc": "Get handle of firmwares",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "9ba0753daddbd3a471d4b8ecb7290ed7990b77741e191e3498fd13a8961ca8bf",
                "name": "EnumFirmwares",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phFirmware",
                        "type": "zes_firmware_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumFrequencyDomains": {
                "class": "zesDevice",
                "desc": "Get handle of frequency domains",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "3a4d3adfa79bc56aef50d3cd79d36487a13688f3b3c2bf544441d95b1271691a",
                "name": "EnumFrequencyDomains",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phFrequency",
                        "type": "zes_freq_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumLeds": {
                "class": "zesDevice",
                "desc": "Get handle of LEDs",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "8c338f22d1047a3079b9f4adf6b0598674b17ba06e0605b1aaa547b901ecae6a",
                "name": "EnumLeds",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phLed",
                        "type": "zes_led_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumMemoryModules": {
                "class": "zesDevice",
                "desc": "Get handle of memory modules",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "dfed3a82c29b73a59785c50f0149f1e08aa7664d6df89896aded435611614784",
                "name": "EnumMemoryModules",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phMemory",
                        "type": "zes_mem_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumOverclockDomains": {
                "class": "zesDevice",
                "desc": "Get handle of overclock domains",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "4b879a76b3b04fde6760e7c52a1df27690607bd6f77d8eefa431bfe0bde261db",
                "name": "EnumOverclockDomains",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phDomainHandle",
                        "type": "zes_overclock_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "EnumPerformanceFactorDomains": {
                "class": "zesDevice",
                "desc": "Get handles to accelerator domains whose performance can be optimized via a Performance Factor",
                "details": [
                    "A Performance Factor should be tuned for each workload.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "5fa2bb283f8afdf882e8b81ff0c3eaf65ddf3aa1a473a6ec8e6d3a734f577a49",
                "name": "EnumPerformanceFactorDomains",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phPerf",
                        "type": "zes_perf_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumPowerDomains": {
                "class": "zesDevice",
                "desc": "Get handle of power domains",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "a162fab77909ff04da2e08eef1e2cf17487f31ae5a2f4c1a25555f6bf56bc60e",
                "name": "EnumPowerDomains",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phPower",
                        "type": "zes_pwr_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumPsus": {
                "class": "zesDevice",
                "desc": "Get handle of power supplies",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "3a4d1abb6eece0119fee707bcd6098ceb8c5cf4a72f955e268dde6b4e94a741c",
                "name": "EnumPsus",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phPsu",
                        "type": "zes_psu_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumRasErrorSets": {
                "class": "zesDevice",
                "desc": "Get handle of all RAS error sets on a device",
                "details": [
                    "A RAS error set is a collection of RAS error counters of a given type (correctable/uncorrectable) from hardware blocks contained within a sub-device or within the device.",
                    "A device without sub-devices will typically return two handles, one for correctable errors sets and one for uncorrectable error sets.",
                    "A device with sub-devices will return RAS error sets for each sub-device and possibly RAS error sets for hardware blocks outside the sub-devices.",
                    "If the function completes successfully but pCount is set to 0, RAS features are not available/enabled on this device.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "937766bf395b256301368c368e0d399cb0aee34dfdd044da3c2cdb7b29be97a3",
                "name": "EnumRasErrorSets",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phRas",
                        "type": "zes_ras_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumSchedulers": {
                "class": "zesDevice",
                "desc": "Returns handles to scheduler components.",
                "details": [
                    "Each scheduler component manages the distribution of work across one or more accelerator engines.",
                    "If an application wishes to change the scheduler behavior for all accelerator engines of a specific type (e.g. compute), it should select all the handles where the `engines` member zes_sched_properties_t contains that type.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "fd37b138e4d455f525f8b29c80b71137e78d52c62615dfa008db1a0cc7b7d716",
                "name": "EnumSchedulers",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phScheduler",
                        "type": "zes_sched_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumStandbyDomains": {
                "class": "zesDevice",
                "desc": "Get handle of standby controls",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "1321756521f332777fba5d6fd3fda68a156551a5378e0256522397b248e220f0",
                "name": "EnumStandbyDomains",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phStandby",
                        "type": "zes_standby_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EnumTemperatureSensors": {
                "class": "zesDevice",
                "desc": "Get handle of temperature sensors",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "75a0cd6be102dba55222d44af450b6940f4bb4a186a27bc64844a76cbdbc39c6",
                "name": "EnumTemperatureSensors",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                        "name": "phTemperature",
                        "type": "zes_temp_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EventListen": {
                "class": "zesDriver",
                "decl": "static",
                "desc": "Wait for events to be received from a one or more devices.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "b00de872443c97d166cd17f0042a606d264fb05f1b2ce96a3203bef5552dc652",
                "name": "EventListen",
                "params": [
                    {
                        "desc": "[in] handle of the driver instance",
                        "name": "hDriver",
                        "type": "ze_driver_handle_t"
                    },
                    {
                        "desc": "[in] if non-zero, then indicates the maximum time (in milliseconds) to yield before returning ZE_RESULT_SUCCESS or ZE_RESULT_NOT_READY;\nif zero, then will check status and return immediately;\nif `UINT32_MAX`, then function will not return until events arrive.\n",
                        "name": "timeout",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] Number of device handles in phDevices.",
                        "name": "count",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, count)] Device handles to listen to for events. Only devices from the provided driver handle can be specified in this list.",
                        "name": "phDevices",
                        "type": "zes_device_handle_t*"
                    },
                    {
                        "desc": "[in,out] Will contain the actual number of devices in phDevices that generated events. If non-zero, check pEvents to determine the devices and events that were received.",
                        "name": "pNumDeviceEvents",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out] An array that will continue the list of events for each device listened in phDevices.\nThis array must be at least as big as count.\nFor every device handle in phDevices, this will provide the events that occurred for that device at the same position in this array. If no event was received for a given device, the corresponding array entry will be zero.\n",
                        "name": "pEvents",
                        "type": "zes_event_type_flags_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDriver`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phDevices`",
                            "`nullptr == pNumDeviceEvents`",
                            "`nullptr == pEvents`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to listen to events."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ARGUMENT": [
                            "One or more of the supplied device handles belongs to a different driver."
                        ]
                    }
                ],
                "type": "function"
            },
            "EventListenEx": {
                "class": "zesDriver",
                "decl": "static",
                "desc": "Wait for events to be received from a one or more devices.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "60aaa2b499d532b22ccc6b5ce05ee5e7008c45c69550bd6c1f6e3010e6cffc01",
                "name": "EventListenEx",
                "params": [
                    {
                        "desc": "[in] handle of the driver instance",
                        "name": "hDriver",
                        "type": "ze_driver_handle_t"
                    },
                    {
                        "desc": "[in] if non-zero, then indicates the maximum time (in milliseconds) to yield before returning ZE_RESULT_SUCCESS or ZE_RESULT_NOT_READY;\nif zero, then will check status and return immediately;\nif `UINT64_MAX`, then function will not return until events arrive.\n",
                        "name": "timeout",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[in] Number of device handles in phDevices.",
                        "name": "count",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, count)] Device handles to listen to for events. Only devices from the provided driver handle can be specified in this list.",
                        "name": "phDevices",
                        "type": "zes_device_handle_t*"
                    },
                    {
                        "desc": "[in,out] Will contain the actual number of devices in phDevices that generated events. If non-zero, check pEvents to determine the devices and events that were received.",
                        "name": "pNumDeviceEvents",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out] An array that will continue the list of events for each device listened in phDevices.\nThis array must be at least as big as count.\nFor every device handle in phDevices, this will provide the events that occurred for that device at the same position in this array. If no event was received for a given device, the corresponding array entry will be zero.\n",
                        "name": "pEvents",
                        "type": "zes_event_type_flags_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDriver`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phDevices`",
                            "`nullptr == pNumDeviceEvents`",
                            "`nullptr == pEvents`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to listen to events."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ARGUMENT": [
                            "One or more of the supplied device handles belongs to a different driver."
                        ]
                    }
                ],
                "type": "function",
                "version": "1.1"
            },
            "EventRegister": {
                "class": "zesDevice",
                "desc": "Specify the list of events to listen to for a given device",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "26fc8939c3a29505329de969535a2946e59d9e03b312a2da336655b503bc9f28",
                "name": "EventRegister",
                "params": [
                    {
                        "desc": "[in] The device handle.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in] List of events to listen to.",
                        "name": "events",
                        "type": "zes_event_type_flags_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x7fff < events`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EvictImage": {
                "class": "zeContext",
                "desc": "Allows image to be evicted from the device.",
                "details": [
                    "The application must ensure the device is not currently referencing the image before it is evicted",
                    "The application may destroy the image without evicting; the image is implicitly evicted when destroyed.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "d8cabc0188f6ec7818a2001141f1a486d3e3811a48f2acd9df2e4931f119800c",
                "name": "EvictImage",
                "params": [
                    {
                        "desc": "[in] handle of context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] handle of image to make evict",
                        "name": "hImage",
                        "type": "ze_image_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`",
                            "`nullptr == hImage`"
                        ]
                    }
                ],
                "type": "function"
            },
            "EvictMemory": {
                "class": "zeContext",
                "desc": "Allows memory to be evicted from the device.",
                "details": [
                    "The application must ensure the device is not currently referencing the memory before it is evicted",
                    "The application may free the memory without evicting; the memory is implicitly evicted when freed.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "eb552c266e77cf372042990ed27a9e7e43deac5ad505858cb25a4b4db649a9eb",
                "name": "EvictMemory",
                "params": [
                    {
                        "desc": "[in] handle of context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] pointer to memory to evict",
                        "name": "ptr",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] size in bytes to evict",
                        "name": "size",
                        "type": "size_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`"
                        ]
                    }
                ],
                "type": "function"
            },
            "ExecuteCommandLists": {
                "analogue": [
                    "vkQueueSubmit"
                ],
                "class": "zeCommandQueue",
                "desc": "Executes a command list in a command queue.",
                "details": [
                    "The command lists are submitted to the device in the order they are received, whether from multiple calls (on the same or different threads) or a single call with multiple command lists.",
                    "The application must ensure the command lists are accessible by the device on which the command queue was created.",
                    "The application must ensure the device is not currently referencing the command list since the implementation is allowed to modify the contents of the command list for submission.",
                    "The application must only execute command lists created with an identical command queue group ordinal to the command queue.",
                    "The application must use a fence created using the same command queue.",
                    "The application must ensure the command queue, command list and fence were created on the same context.",
                    "The application must ensure the command lists being executed are not immediate command lists.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "38c40fa4b4a7b503a5f43b59ef659ef84d37e12cc3ea04d378c665a7de3b6c4c",
                "name": "ExecuteCommandLists",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the command queue",
                        "name": "hCommandQueue",
                        "type": "ze_command_queue_handle_t"
                    },
                    {
                        "desc": "[in] number of command lists to execute",
                        "name": "numCommandLists",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, numCommandLists)] list of handles of the command lists to execute",
                        "name": "phCommandLists",
                        "type": "ze_command_list_handle_t*"
                    },
                    {
                        "desc": "[in][optional] handle of the fence to signal on completion",
                        "name": "hFence",
                        "type": "ze_fence_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandQueue`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phCommandLists`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "`0 == numCommandLists`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_COMMAND_LIST_TYPE": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    }
                ],
                "type": "function"
            },
            "Flash": {
                "class": "zesFirmware",
                "desc": "Flash a new firmware image",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "a6cc43172f030767262ce409a236ed03fd2f41a4abb336ece7e0e1bd642004b4",
                "name": "Flash",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFirmware",
                        "type": "zes_firmware_handle_t"
                    },
                    {
                        "desc": "[in] Image of the new firmware to flash.",
                        "name": "pImage",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] Size of the flash image.",
                        "name": "size",
                        "type": "uint32_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFirmware`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pImage`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to perform this operation."
                        ]
                    }
                ],
                "type": "function"
            },
            "Free": {
                "class": "zeVirtualMem",
                "decl": "static",
                "desc": "Free pages in a reserved virtual address range.",
                "details": [
                    "Any existing virtual mappings for the range will be unmapped.",
                    "Physical allocations objects that were mapped to this range will not be destroyed. These need to be destroyed explicitly.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "a7fee129027162635fb937d37429f1359a7ac34e03bb296b4c304dc926147771",
                "name": "Free",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] pointer to start of region to free.",
                        "name": "ptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] size in bytes to free; must be page aligned.",
                        "name": "size",
                        "type": "size_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_SIZE": [
                            "`0 == size`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": []
                    }
                ],
                "type": "function"
            },
            "FreeExt": {
                "class": "zeMem",
                "desc": "Frees allocated host memory, device memory, or shared memory using the specified free policy.",
                "details": [
                    "The memory free policy is specified by the memory free descriptor.",
                    "The application must **not** call this function from simultaneous threads with the same pointer.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "2c1348cec3a26ca51bbb7430b0b2a6af88216b9711c2afcfd991b5c34880f198",
                "name": "FreeExt",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] pointer to memory free descriptor",
                        "name": "pMemFreeDesc",
                        "type": "const ze_memory_free_ext_desc_t*"
                    },
                    {
                        "desc": "[in][release] pointer to memory to free",
                        "name": "ptr",
                        "type": "void*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pMemFreeDesc`",
                            "`nullptr == ptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x3 < pMemFreeDesc->freePolicy`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.3"
            },
            "Get": {
                "class": "zesDevice",
                "decl": "static",
                "desc": "Retrieves sysman devices within a sysman driver",
                "details": [
                    "Multiple calls to this function will return identical sysman device handles, in the same order.",
                    "The number and order of handles returned from this function is NOT affected by the ZE_AFFINITY_MASK, ZE_ENABLE_PCI_ID_DEVICE_ORDER, or ZE_FLAT_DEVICE_HIERARCHY environment variables.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "39d581ecb601676e1aeb2d414243171941d470b923f87b7356eaa9b784c14cfa",
                "name": "Get",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the sysman driver instance",
                        "name": "hDriver",
                        "type": "zes_driver_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of sysman devices.\nif count is zero, then the driver shall update the value with the total number of sysman devices available.\nif count is greater than the number of sysman devices available, then the driver shall update the value with the correct number of sysman devices available.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of sysman devices.\nif count is less than the number of sysman devices available, then driver shall only retrieve that number of sysman devices.\n",
                        "name": "phDevices",
                        "type": "zes_device_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDriver`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "GetAccessAttribute": {
                "class": "zeVirtualMem",
                "decl": "static",
                "desc": "Get memory access attribute for a virtual address range.",
                "details": [
                    "If size and outSize are equal then the pages in the specified virtual address range have the same access attributes.",
                    "This function may be called from simultaneous threads with the same function handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "f0e84aa4b432103d1d37e611679e51aa6fd33d4d4dd01816b6554852dbc8264d",
                "name": "GetAccessAttribute",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] pointer to start of virtual address region for query.",
                        "name": "ptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] size in bytes; must be page aligned.",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[out] query result for page access attribute.",
                        "name": "access",
                        "type": "ze_memory_access_attribute_t*"
                    },
                    {
                        "desc": "[out] query result for size of virtual address range, starting at ptr, that shares same access attribute.",
                        "name": "outSize",
                        "type": "size_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`",
                            "`nullptr == access`",
                            "`nullptr == outSize`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": [
                            "Address must be page aligned"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_SIZE": [
                            "`0 == size`",
                            "Size must be page aligned"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetActivity": {
                "class": "zesEngine",
                "desc": "Get the activity stats for an engine group.",
                "details": [
                    "This function also returns the engine activity inside a Virtual Machine (VM), in the presence of hardware virtualization (SRIOV)",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "b4c7b2006754814930556a754b21e2fd5ee2df9dcbf6aef7521d44488a217f5e",
                "name": "GetActivity",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hEngine",
                        "type": "zes_engine_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain a snapshot of the engine group activity counters.",
                        "name": "pStats",
                        "type": "zes_engine_stats_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hEngine`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pStats`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "GetActivityExt": {
                "class": "zesEngine",
                "desc": "Get activity stats for Physical Function (PF) and each Virtual Function (VF) associated with engine group.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "7c7eb1843ce9221ba257b856861d9929463cc144d7c4bbad5350c04491413ccd",
                "name": "GetActivityExt",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hEngine",
                        "type": "zes_engine_handle_t"
                    },
                    {
                        "desc": "[in,out] Pointer to the number of VF engine stats descriptors.\n  - if count is zero, the driver shall update the value with the total number of engine stats available.\n  - if count is greater than the total number of engine stats available, the driver shall update the value with the correct number of engine stats available.\n  - The count returned is the sum of number of VF instances currently available and the PF instance.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of engine group activity counters.\n  - if count is less than the total number of engine stats available, then driver shall only retrieve that number of stats.\n  - the implementation shall populate the vector with engine stat for PF at index 0 of the vector followed by user provided pCount-1 number of VF engine stats.\n",
                        "name": "pStats",
                        "type": "zes_engine_stats_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hEngine`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE - \"Engine activity extension is not supported in the environment.\"": []
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "GetAddressRange": {
                "class": "zeMem",
                "decl": "static",
                "desc": "Retrieves the base address and/or size of an allocation",
                "details": [
                    "The application may call this function from simultaneous threads."
                ],
                "hash": "972da021a01a0357817c10cdfccea16c42a3cca55a6c36436267aa45e7a55dab",
                "name": "GetAddressRange",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] memory pointer to query",
                        "name": "ptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in,out][optional] base address of the allocation",
                        "name": "pBase",
                        "type": "void**"
                    },
                    {
                        "desc": "[in,out][optional] size of the allocation",
                        "name": "pSize",
                        "type": "size_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetAllocProperties": {
                "class": "zeMem",
                "decl": "static",
                "desc": "Retrieves attributes of a memory allocation",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The application may query attributes of a memory allocation unrelated to the context.\nWhen this occurs, the returned allocation type will be ZE_MEMORY_TYPE_UNKNOWN, and the returned identifier and associated device is unspecified.\n"
                ],
                "hash": "024e68ebb28cbd45122caa812337ed9737a93ee4cc7990e2188197ffcc2ae39f",
                "name": "GetAllocProperties",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] memory pointer to query",
                        "name": "ptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in,out] query result for memory allocation properties",
                        "name": "pMemAllocProperties",
                        "type": "ze_memory_allocation_properties_t*"
                    },
                    {
                        "desc": "[out][optional] device associated with this allocation",
                        "name": "phDevice",
                        "type": "ze_device_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`",
                            "`nullptr == pMemAllocProperties`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetAllocPropertiesExt": {
                "class": "zeImage",
                "decl": "static",
                "desc": "Retrieves attributes of an image allocation",
                "details": [
                    "The application may call this function from simultaneous threads."
                ],
                "hash": "dcc53f74863a6355f6486f556dc2c973c0e7519afd59371a5917b491e378f8ff",
                "name": "GetAllocPropertiesExt",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] handle of image object to query",
                        "name": "hImage",
                        "type": "ze_image_handle_t"
                    },
                    {
                        "desc": "[in,out] query result for image allocation properties",
                        "name": "pImageAllocProperties",
                        "type": "ze_image_allocation_ext_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hImage`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pImageAllocProperties`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.3"
            },
            "GetApiVersion": {
                "class": "zeDriver",
                "desc": "Returns the API version supported by the specified driver",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "4aeb05f8ea502a5a979a88d1e84cb6f237eed4d53f73fd96e47287706c95a15d",
                "name": "GetApiVersion",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the driver instance",
                        "name": "hDriver",
                        "type": "ze_driver_handle_t"
                    },
                    {
                        "desc": "[out] api version",
                        "name": "version",
                        "type": "ze_api_version_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDriver`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == version`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetAtomicAccessAttributeExp": {
                "class": "zeMem",
                "desc": "Retrieves the atomic access attributes previously set for a shared allocation",
                "details": [
                    "The application may call this function from simultaneous threads\nwith the same pointer.\n",
                    "The implementation of this function should be lock-free.\n"
                ],
                "hash": "219d80b819a20dcbd0a22583d0d62eeedd17df0717c2c5a09bd67d859ef386cc",
                "name": "GetAtomicAccessAttributeExp",
                "params": [
                    {
                        "desc": "[in] handle of context",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] device associated with the memory advice",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] Pointer to the start of the memory range",
                        "name": "ptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] Size in bytes of the memory range",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[out] Atomic access attributes for the specified range",
                        "name": "pAttr",
                        "type": "ze_memory_atomic_attr_exp_flags_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`",
                            "`nullptr == pAttr`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "GetAvailableClocks": {
                "class": "zesFrequency",
                "desc": "Get available non-overclocked hardware clock frequencies for the frequency domain",
                "details": [
                    "The list of available frequencies is returned in order of slowest to fastest.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "1e3eebd0166a83daf2ae65a559bf765664cd393e3e131aa4e983f538ba8baf64",
                "name": "GetAvailableClocks",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of frequencies.\nif count is zero, then the driver shall update the value with the total number of frequencies that are available.\nif count is greater than the number of frequencies that are available, then the driver shall update the value with the correct number of frequencies.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of frequencies in units of MHz and sorted from slowest to fastest.\nif count is less than the number of frequencies that are available, then the driver shall only retrieve that number of frequencies.\n",
                        "name": "phFrequency",
                        "type": "double*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetBandwidth": {
                "class": "zesMemory",
                "desc": "Get memory bandwidth",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "659bc6516bf56722790d5d4dd35f93c8e4194e20157b93f6428bb63a2a1c71f5",
                "name": "GetBandwidth",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hMemory",
                        "type": "zes_mem_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain the total number of bytes read from and written to memory, as well as the current maximum bandwidth.",
                        "name": "pBandwidth",
                        "type": "zes_mem_bandwidth_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hMemory`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pBandwidth`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to query this telemetry."
                        ]
                    }
                ],
                "type": "function"
            },
            "GetBuildPropertiesExp": {
                "class": "zeRTASBuilder",
                "desc": "Retrieves ray tracing acceleration structure builder properties",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "b29cb765e7e65f033b6c19af26626a6a8e39e8bb4f86361a8315f9c7c42c413a",
                "name": "GetBuildPropertiesExp",
                "params": [
                    {
                        "desc": "[in] handle of builder object",
                        "name": "hBuilder",
                        "type": "ze_rtas_builder_exp_handle_t"
                    },
                    {
                        "desc": "[in] pointer to build operation descriptor",
                        "name": "pBuildOpDescriptor",
                        "type": "const ze_rtas_builder_build_op_exp_desc_t*"
                    },
                    {
                        "desc": "[in,out] query result for builder properties",
                        "name": "pProperties",
                        "type": "ze_rtas_builder_exp_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hBuilder`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pBuildOpDescriptor`",
                            "`nullptr == pProperties`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZE_RTAS_FORMAT_EXP_INVALID < pBuildOpDescriptor->rtasFormat`",
                            "`ZE_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_HIGH < pBuildOpDescriptor->buildQuality`",
                            "`0x3 < pBuildOpDescriptor->buildFlags`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "GetCacheProperties": {
                "analogue": [
                    "clGetDeviceInfo"
                ],
                "class": "zeDevice",
                "desc": "Retrieves cache properties of the device",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "493480cf46dd0872dca7d72ddd49bbe4b0cdac57b58f634fee06939ba2d4822c",
                "name": "GetCacheProperties",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of cache properties.\nif count is zero, then the driver shall update the value with the total number of cache properties available.\nif count is greater than the number of cache properties available, then the driver shall update the value with the correct number of cache properties available.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of query results for cache properties.\nif count is less than the number of cache properties available, then driver shall only retrieve that number of cache properties.\n",
                        "name": "pCacheProperties",
                        "type": "ze_device_cache_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetCardPowerDomain": {
                "class": "zesDevice",
                "desc": "Get handle of the PCIe card-level power",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "047ca99995666fe5cefd48dde4b5e5262fd4ac1916c75723f18649b25c4e6942",
                "name": "GetCardPowerDomain",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] power domain handle for the entire PCIe card.",
                        "name": "phPower",
                        "type": "zes_pwr_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phPower`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "The device does not provide access to card level power controls or telemetry. An invalid power domain handle will be returned in phPower."
                        ]
                    }
                ],
                "type": "function"
            },
            "GetCommandQueueGroupProperties": {
                "analogue": [
                    "**vkGetPhysicalDeviceQueueFamilyProperties**"
                ],
                "class": "zeDevice",
                "desc": "Retrieves command queue group properties of the device.",
                "details": [
                    "Properties are reported for each physical command queue type supported by the device.",
                    "Multiple calls to this function will return properties in the same order.",
                    "The order in which the properties are returned defines the command queue group's ordinal.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "4d89248f9e54ca673c3e133ddd0a3b5a7ab46bc27866a7f6978f5b43860cd6b0",
                "name": "GetCommandQueueGroupProperties",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of command queue group properties.\nif count is zero, then the driver shall update the value with the total number of command queue group properties available.\nif count is greater than the number of command queue group properties available, then the driver shall update the value with the correct number of command queue group properties available.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of query results for command queue group properties.\nif count is less than the number of command queue group properties available, then driver shall only retrieve that number of command queue group properties.\n",
                        "name": "pCommandQueueGroupProperties",
                        "type": "ze_command_queue_group_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetComputeProperties": {
                "analogue": [
                    "clGetDeviceInfo"
                ],
                "class": "zeDevice",
                "desc": "Retrieves compute properties of the device.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "7f1420ab7455a639874a23c83d2643e649a65a1340bad17572fed4071c94142b",
                "name": "GetComputeProperties",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] query result for compute properties",
                        "name": "pComputeProperties",
                        "type": "ze_device_compute_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pComputeProperties`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetConfig": {
                "class": "zesTemperature",
                "desc": "Get temperature configuration for this sensor - which events are triggered and the trigger conditions",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "59b77f7353eacc0c25fea8df764d6ae44f6e0504dd349e8a92cb0db7c1003e9a",
                "name": "GetConfig",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hTemperature",
                        "type": "zes_temp_handle_t"
                    },
                    {
                        "desc": "[in,out] Returns current configuration.",
                        "name": "pConfig",
                        "type": "zes_temp_config_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hTemperature`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pConfig`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Temperature thresholds are not supported on this temperature sensor. Generally this is only supported for temperature sensor ZES_TEMP_SENSORS_GLOBAL.",
                            "One or both of the thresholds is not supported. Check the `isThreshold1Supported` and `isThreshold2Supported` members of zes_temp_properties_t."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to request this feature."
                        ]
                    }
                ],
                "type": "function"
            },
            "GetControlCurrentValue": {
                "class": "zesOverclock",
                "desc": "Read the current value for a given overclock control",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "d9b4cc3a89e0a244a5748ef773a56340b963b51a15ff79e6e84a53598a2a8e06",
                "name": "GetControlCurrentValue",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hDomainHandle",
                        "type": "zes_overclock_handle_t"
                    },
                    {
                        "desc": "[in] Overclock Control.",
                        "name": "DomainControl",
                        "type": "zes_overclock_control_t"
                    },
                    {
                        "desc": "[in,out] Getting overclock control value for the specified control.",
                        "name": "pValue",
                        "type": "double*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDomainHandle`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZES_OVERCLOCK_CONTROL_ACM_DISABLE < DomainControl`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pValue`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this control domain"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "GetControlPendingValue": {
                "class": "zesOverclock",
                "desc": "Read the the reset pending value for a given overclock control",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "9ba2bc75c2454afb04fa795e698945acb130400573382ae99ebf3105a50b4f27",
                "name": "GetControlPendingValue",
                "params": [
                    {
                        "desc": "[in] Handle for the component domain.",
                        "name": "hDomainHandle",
                        "type": "zes_overclock_handle_t"
                    },
                    {
                        "desc": "[in] Overclock Control.",
                        "name": "DomainControl",
                        "type": "zes_overclock_control_t"
                    },
                    {
                        "desc": "[out] Returns the pending value for a given control. The units and format of the value depend on the control type.",
                        "name": "pValue",
                        "type": "double*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDomainHandle`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZES_OVERCLOCK_CONTROL_ACM_DISABLE < DomainControl`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pValue`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this control domain"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "GetControlState": {
                "class": "zesOverclock",
                "desc": "Determine the state of an overclock control",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "f6955ca25e09f286e83af378e9b44a83ee85177ef351898262df6df3bf834e58",
                "name": "GetControlState",
                "params": [
                    {
                        "desc": "[in] Handle for the component domain.",
                        "name": "hDomainHandle",
                        "type": "zes_overclock_handle_t"
                    },
                    {
                        "desc": "[in] Domain Control.",
                        "name": "DomainControl",
                        "type": "zes_overclock_control_t"
                    },
                    {
                        "desc": "[out] Current overclock control state.",
                        "name": "pControlState",
                        "type": "zes_control_state_t*"
                    },
                    {
                        "desc": "[out] Pending overclock setting.",
                        "name": "pPendingAction",
                        "type": "zes_pending_action_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDomainHandle`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZES_OVERCLOCK_CONTROL_ACM_DISABLE < DomainControl`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pControlState`",
                            "`nullptr == pPendingAction`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this control domain"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "GetCurrentMode": {
                "class": "zesScheduler",
                "desc": "Get current scheduling mode in effect on a scheduler component.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "ff8efe1877bfdddb8ab4c8a3c626ef2f4e6dfca3e49a05ff48fe2c08dc0aa05b",
                "name": "GetCurrentMode",
                "params": [
                    {
                        "desc": "[in] Sysman handle for the component.",
                        "name": "hScheduler",
                        "type": "zes_sched_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain the current scheduler mode.",
                        "name": "pMode",
                        "type": "zes_sched_mode_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hScheduler`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pMode`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "This scheduler component does not support scheduler modes."
                        ]
                    }
                ],
                "type": "function"
            },
            "GetData": {
                "class": "zetMetricQuery",
                "desc": "Retrieves raw data for a given metric query.",
                "details": [
                    "The application may call this function from simultaneous threads."
                ],
                "hash": "80cdaba4fc2a26a2427d93307cd9bf45b900a795ffb6f1f21eb0c74ccfd23ba6",
                "name": "GetData",
                "params": [
                    {
                        "desc": "[in] handle of the metric query",
                        "name": "hMetricQuery",
                        "type": "zet_metric_query_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to size in bytes of raw data requested to read.\nif size is zero, then the driver will update the value with the total size in bytes needed for all reports available.\nif size is non-zero, then driver will only retrieve the number of reports that fit into the buffer.\nif size is larger than size needed for all reports, then driver will update the value with the actual size needed.\n",
                        "name": "pRawDataSize",
                        "type": "size_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pRawDataSize)] buffer containing query reports in raw format",
                        "name": "pRawData",
                        "type": "uint8_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hMetricQuery`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pRawDataSize`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetDebugInfo": {
                "class": "zetModule",
                "desc": "Retrieve debug info from module.",
                "details": [
                    "The caller can pass nullptr for pDebugInfo when querying only for size.",
                    "The implementation will copy the native binary into a buffer supplied by the caller.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "8cd9f86cd846e4d9733e3bc32027b2def4b4376df1cb35f5521f692a1ee88ecc",
                "name": "GetDebugInfo",
                "params": [
                    {
                        "desc": "[in] handle of the module",
                        "name": "hModule",
                        "type": "zet_module_handle_t"
                    },
                    {
                        "desc": "[in] debug info format requested",
                        "name": "format",
                        "type": "zet_module_debug_info_format_t"
                    },
                    {
                        "desc": "[in,out] size of debug info in bytes",
                        "name": "pSize",
                        "type": "size_t*"
                    },
                    {
                        "desc": "[in,out][optional] byte pointer to debug info",
                        "name": "pDebugInfo",
                        "type": "uint8_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hModule`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZET_MODULE_DEBUG_INFO_FORMAT_ELF_DWARF < format`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pSize`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetDebugProperties": {
                "class": "zetDevice",
                "desc": "Retrieves debug properties of the device.",
                "hash": "c3d026b82778fe2460ab811b9c2e883dd0be74d7bdcb48098e3fe0d9be5ea054",
                "name": "GetDebugProperties",
                "params": [
                    {
                        "desc": "[in] device handle",
                        "name": "hDevice",
                        "type": "zet_device_handle_t"
                    },
                    {
                        "desc": "[in,out] query result for debug properties",
                        "name": "pDebugProperties",
                        "type": "zet_device_debug_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pDebugProperties`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetDeviceExp": {
                "class": "zeFabricVertex",
                "desc": "Returns device handle from fabric vertex handle.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "48861d8bf149f5ca741df5e1bd9aae1b92287efaf56573366d6788ab60ef7043",
                "name": "GetDeviceExp",
                "params": [
                    {
                        "desc": "[in] handle of the fabric vertex",
                        "name": "hVertex",
                        "type": "ze_fabric_vertex_handle_t"
                    },
                    {
                        "desc": "[out] device handle corresponding to fabric vertex",
                        "name": "phDevice",
                        "type": "ze_device_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hVertex`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_EXP_ERROR_VERTEX_IS_NOT_DEVICE": [
                            "Provided fabric vertex handle does not correspond to a device or subdevice."
                        ]
                    },
                    {
                        "ZE_RESULT_EXP_ERROR_REMOTE_DEVICE": [
                            "Provided fabric vertex handle corresponds to remote device or subdevice."
                        ]
                    }
                ],
                "type": "function",
                "version": "1.4"
            },
            "GetDomainControlProperties": {
                "class": "zesOverclock",
                "desc": "Read overclock control values - min/max/step/default/ref",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "cade6249e729096d63ce08310fd878151a968afa8abc580980d5c258a9ec48fb",
                "name": "GetDomainControlProperties",
                "params": [
                    {
                        "desc": "[in] Handle for the component domain.",
                        "name": "hDomainHandle",
                        "type": "zes_overclock_handle_t"
                    },
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "DomainControl",
                        "type": "zes_overclock_control_t"
                    },
                    {
                        "desc": "[in,out] overclock control values.",
                        "name": "pControlProperties",
                        "type": "zes_control_property_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDomainHandle`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZES_OVERCLOCK_CONTROL_ACM_DISABLE < DomainControl`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pControlProperties`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this control domain"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "GetDomainProperties": {
                "class": "zesOverclock",
                "desc": "Get overclock domain control properties",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "416c9b4d0a45ce8cef79a8367a0d9e5a23de228774dbf59a5c06a7af0ce6e325",
                "name": "GetDomainProperties",
                "params": [
                    {
                        "desc": "[in] Handle for the component domain.",
                        "name": "hDomainHandle",
                        "type": "zes_overclock_handle_t"
                    },
                    {
                        "desc": "[in,out] The overclock properties for the specified domain.",
                        "name": "pDomainProperties",
                        "type": "zes_overclock_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDomainHandle`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pDomainProperties`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this control domain"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "GetDomainVFProperties": {
                "class": "zesOverclock",
                "desc": "Read overclock VF min,max and step values",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "899c590948448590df0ce9f6d0767f769d4f1480b939a30cc769cc07f80315c4",
                "name": "GetDomainVFProperties",
                "params": [
                    {
                        "desc": "[in] Handle for the component domain.",
                        "name": "hDomainHandle",
                        "type": "zes_overclock_handle_t"
                    },
                    {
                        "desc": "[in,out] The VF min,max,step for a specified domain.",
                        "name": "pVFProperties",
                        "type": "zes_vf_property_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDomainHandle`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pVFProperties`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this control domain"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "GetEccState": {
                "class": "zesDevice",
                "desc": "Get current ECC state, pending state, and pending action",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "6c8f13b7f3cc21e39963799875b4651b8a7bc0d3790f8cfec04d2a216d242634",
                "name": "GetEccState",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[out] ECC state, pending state, and pending action for state change.",
                        "name": "pState",
                        "type": "zes_device_ecc_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pState`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.4"
            },
            "GetEnergyCounter": {
                "class": "zesPower",
                "desc": "Get energy counter",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "55238b643e181150dd35ae06a62b397c7488fdda9c500a0b999b95d00fa07311",
                "name": "GetEnergyCounter",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hPower",
                        "type": "zes_pwr_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain the latest snapshot of the energy counter and timestamp when the last counter value was measured.",
                        "name": "pEnergy",
                        "type": "zes_power_energy_counter_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hPower`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pEnergy`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetEnergyThreshold": {
                "class": "zesPower",
                "desc": "Get energy threshold",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "11e5666d7a95676691c797e7d12570dba7a301c7b51b07fc5e6550764a071806",
                "name": "GetEnergyThreshold",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hPower",
                        "type": "zes_pwr_handle_t"
                    },
                    {
                        "desc": "[in,out] Returns information about the energy threshold setting - enabled/energy threshold/process ID.",
                        "name": "pThreshold",
                        "type": "zes_energy_threshold_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hPower`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pThreshold`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Energy threshold not supported on this power domain (check the `isEnergyThresholdSupported` member of zes_power_properties_t)."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to request this feature."
                        ]
                    }
                ],
                "type": "function"
            },
            "GetExp": {
                "class": "zeFabricEdge",
                "decl": "static",
                "desc": "Retrieves all fabric edges between provided pair of fabric vertices",
                "details": [
                    "A fabric edge represents one or more physical links between two fabric vertices.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "49c8b5bf1db998a1e71e1f5cbd3960b2389a55e949acf172171586c40d5bdc14",
                "name": "GetExp",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of first fabric vertex instance",
                        "name": "hVertexA",
                        "type": "ze_fabric_vertex_handle_t"
                    },
                    {
                        "desc": "[in] handle of second fabric vertex instance",
                        "name": "hVertexB",
                        "type": "ze_fabric_vertex_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of fabric edges.\nif count is zero, then the driver shall update the value with the total number of fabric edges available.\nif count is greater than the number of fabric edges available, then the driver shall update the value with the correct number of fabric edges available.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of fabric edges.\nif count is less than the number of fabric edges available, then driver shall only retrieve that number of fabric edges.\n",
                        "name": "phEdges",
                        "type": "ze_fabric_edge_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hVertexA`",
                            "`nullptr == hVertexB`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.4"
            },
            "GetExportDataExp": {
                "class": "zetMetricGroup",
                "decl": "static",
                "desc": "Export Metrics Data for system independent calculation.",
                "details": [
                    "This function exports raw data and necessary information to perform metrics calculation of collected data in a different system than where data was collected, which may or may not have accelerators.",
                    "Implementations can choose to describe the data arrangement of the exported data, using any mechanism which allows users to read and process them.",
                    "The application may call this function from simultaneous threads."
                ],
                "hash": "499db6354496cf5b11624cc913efa9de29684492f7c073d1b6a55a7015e2e9c5",
                "name": "GetExportDataExp",
                "params": [
                    {
                        "desc": "[in] handle of the metric group",
                        "name": "hMetricGroup",
                        "type": "zet_metric_group_handle_t"
                    },
                    {
                        "desc": "[in] buffer of raw data",
                        "name": "pRawData",
                        "type": "const uint8_t*"
                    },
                    {
                        "desc": "[in] size in bytes of raw data buffer",
                        "name": "rawDataSize",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in,out] size in bytes of export data buffer\nif size is zero, then the driver shall update the value with the number of bytes necessary to store the exported data.\nif size is greater than required, then the driver shall update the value with the actual number of bytes necessary to store the exported data.\n",
                        "name": "pExportDataSize",
                        "type": "size_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pExportDataSize)] buffer of exported data.\n",
                        "name": "pExportData",
                        "type": "uint8_t *"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hMetricGroup`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pRawData`",
                            "`nullptr == pExportDataSize`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.6"
            },
            "GetExtensionFunctionAddress": {
                "class": "zeDriver",
                "desc": "Retrieves function pointer for vendor-specific or experimental extensions",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "06b81bd7c84e1d4a4ce904b9123444ca519be82720267c97f602201ac5009dc8",
                "name": "GetExtensionFunctionAddress",
                "params": [
                    {
                        "desc": "[in] handle of the driver instance",
                        "name": "hDriver",
                        "type": "ze_driver_handle_t"
                    },
                    {
                        "desc": "[in] extension function name",
                        "name": "name",
                        "type": "const char*"
                    },
                    {
                        "desc": "[out] pointer to function pointer",
                        "name": "ppFunctionAddress",
                        "type": "void**"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDriver`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == name`",
                            "`nullptr == ppFunctionAddress`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.1"
            },
            "GetExtensionProperties": {
                "analogue": [
                    "**vkEnumerateInstanceExtensionProperties**"
                ],
                "class": "zeDriver",
                "desc": "Retrieves extension properties",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "8e44ae247d11d858ca4bad79512a3bf69323a900b1ac782903bb513479bba13a",
                "name": "GetExtensionProperties",
                "params": [
                    {
                        "desc": "[in] handle of the driver instance",
                        "name": "hDriver",
                        "type": "ze_driver_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of extension properties.\nif count is zero, then the driver shall update the value with the total number of extension properties available.\nif count is greater than the number of extension properties available, then the driver shall update the value with the correct number of extension properties available.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of query results for extension properties.\nif count is less than the number of extension properties available, then driver shall only retrieve that number of extension properties.\n",
                        "name": "pExtensionProperties",
                        "type": "ze_driver_extension_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDriver`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetExternalMemoryProperties": {
                "class": "zeDevice",
                "desc": "Retrieves external memory import and export of the device",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "d81f59bbdb025bf574b919caac089a8ce331897bda578e170f4ade841f7100d4",
                "name": "GetExternalMemoryProperties",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] query result for external memory properties",
                        "name": "pExternalMemoryProperties",
                        "type": "ze_device_external_memory_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pExternalMemoryProperties`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetFabricErrorCounters": {
                "class": "zesFabricPort",
                "desc": "Get Fabric Port Error Counters",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free.",
                    "The memory backing the arrays for phPorts and ppThroughputs must be allocated in system memory by the user who is also responsible for releasing them when they are no longer needed."
                ],
                "hash": "67d5b753e3b6f42b1997d5d3db8f20671924a2eee917e7a8147cef40cc6dfeb0",
                "name": "GetFabricErrorCounters",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hPort",
                        "type": "zes_fabric_port_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain the Fabric port Error counters.",
                        "name": "pErrors",
                        "type": "zes_fabric_port_error_counters_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hPort`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pErrors`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to query this telemetry."
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "GetFabricVertexExp": {
                "class": "zeDevice",
                "desc": "Returns fabric vertex handle from device handle.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "6a63ee8ccb8f52e0b4fe869619bd1dbf6b8817f2b0d61e8b6acff07a81334135",
                "name": "GetFabricVertexExp",
                "params": [
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[out] fabric vertex handle corresponding to device",
                        "name": "phVertex",
                        "type": "ze_fabric_vertex_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phVertex`"
                        ]
                    },
                    {
                        "ZE_RESULT_EXP_ERROR_DEVICE_IS_NOT_VERTEX": [
                            "Provided device handle does not correspond to a fabric vertex."
                        ]
                    }
                ],
                "type": "function",
                "version": "1.4"
            },
            "GetFileDescriptorFromIpcHandleExp": {
                "class": "zeMem",
                "decl": "static",
                "desc": "Gets the file descriptor contained in an IPC memory handle",
                "details": [
                    "IPC memory handle must be a valid handle obtained with zeMemGetIpcHandle.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "4f0cd196b792fa6c5010f1779f899fc5252608ccded499cc460199f47343f4b6",
                "name": "GetFileDescriptorFromIpcHandleExp",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] IPC memory handle",
                        "name": "ipcHandle",
                        "type": "ze_ipc_mem_handle_t"
                    },
                    {
                        "desc": "[out] Returned file descriptor",
                        "name": "pHandle",
                        "type": "uint64_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pHandle`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.6"
            },
            "GetFunctionPointer": {
                "class": "zeModule",
                "desc": "Retrieve a function pointer from a module by name",
                "details": [
                    "The function pointer is unique for the device on which the module was created.",
                    "The function pointer is no longer valid if module is destroyed.",
                    "The function name should only refer to callable functions within the module.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "d316b47d5880386648c2751e90d316a28a7ae230f11cb4fa1375a9e332cc7c82",
                "name": "GetFunctionPointer",
                "params": [
                    {
                        "desc": "[in] handle of the module",
                        "name": "hModule",
                        "type": "ze_module_handle_t"
                    },
                    {
                        "desc": "[in] Name of function to retrieve function pointer for.",
                        "name": "pFunctionName",
                        "type": "const char*"
                    },
                    {
                        "desc": "[out] pointer to function.",
                        "name": "pfnFunction",
                        "type": "void**"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hModule`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pFunctionName`",
                            "`nullptr == pfnFunction`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_FUNCTION_NAME": []
                    }
                ],
                "type": "function"
            },
            "GetGlobalPointer": {
                "class": "zeModule",
                "desc": "Retrieve global variable pointer from Module.",
                "details": [
                    "The application may query global pointer from any module that either exports or imports it.",
                    "The application must dynamically link a module that imports a global before the global pointer can be queried from it.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "5b39f769e7f1b56183210d7ad1290017dbf8c68582d982875b94d07e8e0a549c",
                "name": "GetGlobalPointer",
                "params": [
                    {
                        "desc": "[in] handle of the module",
                        "name": "hModule",
                        "type": "ze_module_handle_t"
                    },
                    {
                        "desc": "[in] name of global variable in module",
                        "name": "pGlobalName",
                        "type": "const char*"
                    },
                    {
                        "desc": "[in,out][optional] size of global variable",
                        "name": "pSize",
                        "type": "size_t*"
                    },
                    {
                        "desc": "[in,out][optional] device visible pointer",
                        "name": "pptr",
                        "type": "void**"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hModule`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pGlobalName`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_GLOBAL_NAME": []
                    }
                ],
                "type": "function"
            },
            "GetGlobalTimestamps": {
                "class": "zeDevice",
                "desc": "Returns synchronized Host and device global timestamps.",
                "details": [
                    "The application may call this function from simultaneous threads with the same device handle.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "2ad37bd9529ed6bc957d68b53699066d3294f886224528d4eb06cb86782c44f2",
                "name": "GetGlobalTimestamps",
                "params": [
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[out] value of the Host's global timestamp that correlates with the Device's global timestamp value",
                        "name": "hostTimestamp",
                        "type": "uint64_t*"
                    },
                    {
                        "desc": "[out] value of the Device's global timestamp that correlates with the Host's global timestamp value",
                        "name": "deviceTimestamp",
                        "type": "uint64_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == hostTimestamp`",
                            "`nullptr == deviceTimestamp`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.1"
            },
            "GetGlobalTimestampsExp": {
                "class": "zetMetricGroup",
                "decl": "static",
                "desc": "Returns metric timestamps synchronized with global device timestamps, optionally synchronized with host",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "By default, the global and metrics timestamps are synchronized to the device."
                ],
                "hash": "223592fae768685fbaf678e7be2615d9d155a4f4c8d4e984da32b75707c71394",
                "name": "GetGlobalTimestampsExp",
                "params": [
                    {
                        "desc": "[in] handle of the metric group",
                        "name": "hMetricGroup",
                        "type": "zet_metric_group_handle_t"
                    },
                    {
                        "desc": "[in] Returns the timestamps synchronized to the host or the device.",
                        "init": "false",
                        "name": "synchronizedWithHost",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Device timestamp.\n",
                        "name": "globalTimestamp",
                        "type": "uint64_t*"
                    },
                    {
                        "desc": "[out] Metric timestamp.\n",
                        "name": "metricTimestamp",
                        "type": "uint64_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hMetricGroup`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == globalTimestamp`",
                            "`nullptr == metricTimestamp`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "GetImageProperties": {
                "class": "zeDevice",
                "desc": "Retrieves image properties of the device",
                "details": [
                    "See zeImageGetProperties for format-specific capabilities.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "bde7a513c160408c6c590644da9f96a3e8c341222d50c1f4cb015595727aafa7",
                "name": "GetImageProperties",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] query result for image properties",
                        "name": "pImageProperties",
                        "type": "ze_device_image_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pImageProperties`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetIndirectAccess": {
                "class": "zeKernel",
                "desc": "Retrieve kernel indirect access flags.",
                "details": [
                    "This function may be called from simultaneous threads with the same Kernel handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "e95327d9eb9e3e93fa04fcb25411b5f5aa78220c63165ca3f7b0e1d3a8d51771",
                "name": "GetIndirectAccess",
                "params": [
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[out] query result for kernel indirect access flags.",
                        "name": "pFlags",
                        "type": "ze_kernel_indirect_access_flags_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pFlags`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetIpcHandle": {
                "class": "zeMem",
                "decl": "static",
                "desc": "Creates an IPC memory handle for the specified allocation",
                "details": [
                    "Takes a pointer to a device memory allocation and creates an IPC memory handle for exporting it for use in another process.",
                    "The pointer must be base pointer of a device or host memory allocation; i.e. the value returned from zeMemAllocDevice or from zeMemAllocHost, respectively.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "0c93fecc4e19c55c79ca9d1b7001f7c9fcdc783c6cb181c18cae4924ae0e7b4a",
                "name": "GetIpcHandle",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] pointer to the device memory allocation",
                        "name": "ptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] Returned IPC memory handle",
                        "name": "pIpcHandle",
                        "type": "ze_ipc_mem_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`",
                            "`nullptr == pIpcHandle`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetIpcHandleFromFileDescriptorExp": {
                "class": "zeMem",
                "decl": "static",
                "desc": "Creates an IPC memory handle out of a file descriptor",
                "details": [
                    "Handle passed must be a valid file descriptor obtained with ze_external_memory_export_fd_t via zeMemGetAllocProperties.",
                    "Returned IPC handle may contain metadata in addition to the file descriptor.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "85dd8fd011ef561b945d46995f774fa76385cef8b350475fb4fa35684277399e",
                "name": "GetIpcHandleFromFileDescriptorExp",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] file descriptor",
                        "name": "handle",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Returned IPC memory handle",
                        "name": "pIpcHandle",
                        "type": "ze_ipc_mem_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pIpcHandle`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.6"
            },
            "GetIpcProperties": {
                "class": "zeDriver",
                "desc": "Retrieves IPC attributes of the driver",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "3f55d5186d2c4daedc8426a8adfb98ad27492c060c20748bebad12ec50bd5293",
                "name": "GetIpcProperties",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the driver instance",
                        "name": "hDriver",
                        "type": "ze_driver_handle_t"
                    },
                    {
                        "desc": "[in,out] query result for IPC properties",
                        "name": "pIpcProperties",
                        "type": "ze_driver_ipc_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDriver`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pIpcProperties`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetKernelNames": {
                "class": "zeModule",
                "desc": "Retrieve all kernel names in the module.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "0e05374b34a6bf84f993c6c127a9c2e7affdbc11fe96cbedcfa8e306bd18cc21",
                "name": "GetKernelNames",
                "params": [
                    {
                        "desc": "[in] handle of the module",
                        "name": "hModule",
                        "type": "ze_module_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of names.\nif count is zero, then the driver shall update the value with the total number of names available.\nif count is greater than the number of names available, then the driver shall update the value with the correct number of names available.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of names of functions.\nif count is less than the number of names available, then driver shall only retrieve that number of names.\n",
                        "name": "pNames",
                        "type": "const char**"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hModule`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetLastErrorDescription": {
                "class": "zeDriver",
                "desc": "Retrieves a string describing the last error code returned by the driver in the current thread.",
                "details": [
                    "String returned is thread local.",
                    "String is only updated on calls returning an error, i.e., not on calls returning ZE_RESULT_SUCCESS.",
                    "String may be empty if driver considers error code is already explicit enough to describe cause.",
                    "Memory pointed to by ppString is owned by the driver.",
                    "String returned is null-terminated."
                ],
                "hash": "a3ac6b1e67b0b263ef01af2319655f3a1efe1b2d8483fa6eb1ce4f0e80af0612",
                "name": "GetLastErrorDescription",
                "params": [
                    {
                        "desc": "[in] handle of the driver instance",
                        "name": "hDriver",
                        "type": "ze_driver_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to a null-terminated array of characters describing cause of error.",
                        "name": "ppString",
                        "type": "const char**"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDriver`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ppString`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.6"
            },
            "GetLimits": {
                "class": "zesPower",
                "desc": "Get power limits",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free.",
                    "Note: This function is deprecated and replaced by zesPowerGetLimitsExt."
                ],
                "hash": "ed0462ffcd8d44a95439a0ea86fbb1bc0e13e357c0d73fabd1d3322abd658e18",
                "name": "GetLimits",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hPower",
                        "type": "zes_pwr_handle_t"
                    },
                    {
                        "desc": "[in,out][optional] The sustained power limit. If this is null, the current sustained power limits will not be returned.",
                        "name": "pSustained",
                        "type": "zes_power_sustained_limit_t*"
                    },
                    {
                        "desc": "[in,out][optional] The burst power limit. If this is null, the current peak power limits will not be returned.",
                        "name": "pBurst",
                        "type": "zes_power_burst_limit_t*"
                    },
                    {
                        "desc": "[in,out][optional] The peak power limit. If this is null, the peak power limits will not be returned.",
                        "name": "pPeak",
                        "type": "zes_power_peak_limit_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hPower`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetLimitsExt": {
                "class": "zesPower",
                "desc": "Get power limits",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free.",
                    "This function returns all the power limits associated with the supplied power domain."
                ],
                "hash": "68f318093a420db4811cba53835f34da4a4fa9ffb3b98d7793765842d0424b8c",
                "name": "GetLimitsExt",
                "params": [
                    {
                        "desc": "[in] Power domain handle instance.",
                        "name": "hPower",
                        "type": "zes_pwr_handle_t"
                    },
                    {
                        "desc": "[in,out] Pointer to the number of power limit descriptors. If count is zero, then the driver shall update the value with the total number of components of this type that are available. If count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] Array of query results for power limit descriptors. If count is less than the number of components of this type that are available, then the driver shall only retrieve that number of components.",
                        "name": "pSustained",
                        "type": "zes_power_limit_ext_desc_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hPower`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetLinkType": {
                "class": "zesFabricPort",
                "desc": "Get Fabric port link type",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "ded4dbd69e173ddcbb1a8dfa0aa5d9c019a40c71a09ab024e055ef4dbbad1ca0",
                "name": "GetLinkType",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hPort",
                        "type": "zes_fabric_port_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain details about the link attached to the Fabric port.",
                        "name": "pLinkType",
                        "type": "zes_fabric_link_type_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hPort`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pLinkType`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetMemoryAccessProperties": {
                "analogue": [
                    "clGetDeviceInfo"
                ],
                "class": "zeDevice",
                "desc": "Retrieves memory access properties of the device.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "e874d3ac0d34ac6938b4be6d38888e2f568d939aef6960e1d5803d6258142613",
                "name": "GetMemoryAccessProperties",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] query result for memory access properties",
                        "name": "pMemAccessProperties",
                        "type": "ze_device_memory_access_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pMemAccessProperties`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetMemoryProperties": {
                "analogue": [
                    "clGetDeviceInfo"
                ],
                "class": "zeDevice",
                "desc": "Retrieves local memory properties of the device.",
                "details": [
                    "Properties are reported for each physical memory type supported by the device.",
                    "Multiple calls to this function will return properties in the same order.",
                    "The order in which the properties are returned defines the device's local memory ordinal.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "f28eb5727554e11a61cdab0d97af8c41880e56e379c2594800a0226c6e72340b",
                "name": "GetMemoryProperties",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of memory properties.\nif count is zero, then the driver shall update the value with the total number of memory properties available.\nif count is greater than the number of memory properties available, then the driver shall update the value with the correct number of memory properties available.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of query results for memory properties.\nif count is less than the number of memory properties available, then driver shall only retrieve that number of memory properties.\n",
                        "name": "pMemProperties",
                        "type": "ze_device_memory_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetMemoryPropertiesExp": {
                "analogue": [
                    "None"
                ],
                "class": "zeImage",
                "decl": "static",
                "desc": "Query image memory properties.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe.",
                    "The implementation must support ZE_experimental_image_memory_properties extension."
                ],
                "hash": "573043a1d9ef253c5802bfac3cdf26568142e4e0748351fc4cd7a6a4cfc4856a",
                "name": "GetMemoryPropertiesExp",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of image object",
                        "name": "hImage",
                        "type": "ze_image_handle_t"
                    },
                    {
                        "desc": "[in,out] query result for image memory properties.",
                        "name": "pMemoryProperties",
                        "type": "ze_image_memory_properties_exp_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hImage`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pMemoryProperties`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.2"
            },
            "GetMode": {
                "class": "zesStandby",
                "desc": "Get the current standby promotion mode",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "5b35e78c5cabe67779534fa696ed6b8e877734f8e052462b4e2f0f25c9625092",
                "name": "GetMode",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hStandby",
                        "type": "zes_standby_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain the current standby mode.",
                        "name": "pMode",
                        "type": "zes_standby_promo_mode_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hStandby`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pMode`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetModuleProperties": {
                "class": "zeDevice",
                "desc": "Retrieves module properties of the device",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "9e5d1ce3fb67ea2e00c710fc6eef0fe7caf842ce5ddb43fc56f009765f1ffcc1",
                "name": "GetModuleProperties",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] query result for module properties",
                        "name": "pModuleProperties",
                        "type": "ze_device_module_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pModuleProperties`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetMultiPortThroughput": {
                "class": "zesFabricPort",
                "desc": "Get Fabric port throughput from multiple ports in a single call",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "b19183e0e5208c1c5bac396db4c5d36d7334fbfdc1a7eedd01031666a174a232",
                "name": "GetMultiPortThroughput",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in] Number of ports enumerated in function zesDeviceEnumFabricPorts",
                        "name": "numPorts",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, numPorts)] array of fabric port handles provided by user to gather throughput values. \n",
                        "name": "phPort",
                        "type": "zes_fabric_port_handle_t*"
                    },
                    {
                        "desc": "[out][range(0, numPorts)] array of fabric port throughput counters from multiple ports of type zes_fabric_port_throughput_t.\n",
                        "name": "pThroughput",
                        "type": "zes_fabric_port_throughput_t**"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phPort`",
                            "`nullptr == pThroughput`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "GetName": {
                "class": "zeKernel",
                "desc": "Retrieve kernel name from Kernel.",
                "details": [
                    "The caller can pass nullptr for pName when querying only for size.",
                    "The implementation will copy the kernel name into a buffer supplied by the caller.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "688cd9a40f353689c2635349ed4eb5ad3a874d0c2fa19479596e7da9354e851f",
                "name": "GetName",
                "params": [
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[in,out] size of kernel name string, including null terminator, in bytes.",
                        "name": "pSize",
                        "type": "size_t*"
                    },
                    {
                        "desc": "[in,out][optional] char pointer to kernel name.",
                        "name": "pName",
                        "type": "char*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pSize`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetNativeBinary": {
                "class": "zeModule",
                "desc": "Retrieve native binary from Module.",
                "details": [
                    "The native binary output can be cached to disk and new modules can be later constructed from the cached copy.",
                    "The native binary will retain debugging information that is associated with a module.",
                    "The caller can pass nullptr for pModuleNativeBinary when querying only for size.",
                    "The implementation will copy the native binary into a buffer supplied by the caller.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "043affb5d74a5738f6f15766b94cb19bb925ed422b5fde9a86bd8be47b341aca",
                "name": "GetNativeBinary",
                "params": [
                    {
                        "desc": "[in] handle of the module",
                        "name": "hModule",
                        "type": "ze_module_handle_t"
                    },
                    {
                        "desc": "[in,out] size of native binary in bytes.",
                        "name": "pSize",
                        "type": "size_t*"
                    },
                    {
                        "desc": "[in,out][optional] byte pointer to native binary",
                        "name": "pModuleNativeBinary",
                        "type": "uint8_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hModule`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pSize`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetOverclockControls": {
                "class": "zesDevice",
                "desc": "Get the list of supported overclock controls available for one of the supported overclock domains on the device",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "4377753972c5b509120ab9c0d528b6c7428abbbaa4b0eb1c0704a51a7d8c351c",
                "name": "GetOverclockControls",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in] Domain type.",
                        "name": "domainType",
                        "type": "zes_overclock_domain_t"
                    },
                    {
                        "desc": "[in,out] Returns the overclock controls that are supported for the specified overclock domain (a bit for each of enum zes_overclock_control_t).",
                        "name": "pAvailableControls",
                        "type": "uint32_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZES_OVERCLOCK_DOMAIN_ADM < domainType`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pAvailableControls`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this control domain"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "GetOverclockDomains": {
                "class": "zesDevice",
                "desc": "Get the list of supported overclock domains for this device",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "0d9d47c012a59f1376b1664e436a9a25f3aece1c27faa5827e7e521c9066e5f7",
                "name": "GetOverclockDomains",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] Returns the overclock domains that are supported (a bit for each of enum zes_overclock_domain_t). If no bits are set, the device doesn't support overclocking.",
                        "name": "pOverclockDomains",
                        "type": "uint32_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pOverclockDomains`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this control domain"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "GetP2PProperties": {
                "class": "zeDevice",
                "desc": "Retrieves peer-to-peer properties between one device and a peer devices",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "3c9fd37471b51c83bbd77b22c8ded7aa056bcf0badc076f48796a83f2cd0635e",
                "name": "GetP2PProperties",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the device performing the access",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] handle of the peer device with the allocation",
                        "name": "hPeerDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] Peer-to-Peer properties between source and peer device",
                        "name": "pP2PProperties",
                        "type": "ze_device_p2p_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`",
                            "`nullptr == hPeerDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pP2PProperties`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetProfileInfo": {
                "class": "zetKernel",
                "desc": "Retrieve profiling information generated for the kernel.",
                "details": [
                    {
                        "Module must be created using the following build option:": [
                            "\"-zet-profile-flags <n>\" - enable generation of profile information",
                            "\"<n>\" must be a combination of zet_profile_flag_t, in hex"
                        ]
                    },
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "daba304e8f1cfd945f7fcfe506ff1f93db38b2e14d5ec6326ce09a0180dbff9d",
                "name": "GetProfileInfo",
                "params": [
                    {
                        "desc": "[in] handle to kernel",
                        "name": "hKernel",
                        "type": "zet_kernel_handle_t"
                    },
                    {
                        "desc": "[out] pointer to profile properties",
                        "name": "pProfileProperties",
                        "type": "zet_profile_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pProfileProperties`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetProperties": {
                "class": "zesTemperature",
                "desc": "Get temperature sensor properties",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "aed86f68f316999523ed898037cdc44bb6e1a9447b9aed0c17792c9af3b44fef",
                "name": "GetProperties",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hTemperature",
                        "type": "zes_temp_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain the temperature sensor properties.",
                        "name": "pProperties",
                        "type": "zes_temp_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hTemperature`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pProperties`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetPropertiesExp": {
                "class": "zeRTASParallelOperation",
                "desc": "Retrieves ray tracing acceleration structure builder parallel operation properties",
                "details": [
                    "The application must first bind the parallel operation object to a build operation before it may query the parallel operation properties. In other words, the application must first call zeRTASBuilderBuildExp with **hParallelOperation** before calling this function.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "7f52d48c631cdad4d5d9f6e9bfa9ba6bf2567c0d9f00637d921a927df1e0b279",
                "name": "GetPropertiesExp",
                "params": [
                    {
                        "desc": "[in] handle of parallel operation object",
                        "name": "hParallelOperation",
                        "type": "ze_rtas_parallel_operation_exp_handle_t"
                    },
                    {
                        "desc": "[in,out] query result for parallel operation properties",
                        "name": "pProperties",
                        "type": "ze_rtas_parallel_operation_exp_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hParallelOperation`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pProperties`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "GetRange": {
                "class": "zesFrequency",
                "desc": "Get current frequency limits",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "a9d1984f6ba89157405380e202cbd1031171726de90f2ed76f1c3ae3c1c5ec15",
                "name": "GetRange",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[in,out] The range between which the hardware can operate for the specified domain.",
                        "name": "pLimits",
                        "type": "zes_freq_range_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pLimits`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetRegisterSetProperties": {
                "class": "zetDebug",
                "decl": "static",
                "desc": "Retrieves debug register set properties.",
                "hash": "66c8f10d019ad513b3749bc9486eacb1dbc5934eb24fdd59ce915c1de01f6fa9",
                "name": "GetRegisterSetProperties",
                "params": [
                    {
                        "desc": "[in] device handle",
                        "name": "hDevice",
                        "type": "zet_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of register set properties.\nif count is zero, then the driver shall update the value with the total number of register set properties available.\nif count is greater than the number of register set properties available, then the driver shall update the value with the correct number of registry set properties available.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of query results for register set properties.\nif count is less than the number of register set properties available, then driver shall only retrieve that number of register set properties.\n",
                        "name": "pRegisterSetProperties",
                        "type": "zet_debug_regset_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetRootDevice": {
                "class": "zeDevice",
                "desc": "Retrieves the root-device of a device handle",
                "details": [
                    "When the device handle passed does not belong to any root-device, nullptr is returned.",
                    "Multiple calls to this function will return the same device handle.",
                    "The root-device handle returned by this function does not have access automatically to the resources\ncreated with the associated sub-device, unless those resources have been created with a context\nexplicitly containing both handles.\n",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "0bbac157544da3d3020c75b2f762fe8dd1478b32e281d59fae2769988693f2a3",
                "name": "GetRootDevice",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the device object",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] parent root device.",
                        "name": "phRootDevice",
                        "type": "ze_device_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phRootDevice`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "GetSourceAttributes": {
                "class": "zeKernel",
                "desc": "Retrieve all declared kernel attributes (i.e. can be specified with __attribute__ in runtime language).",
                "details": [
                    "This function may be called from simultaneous threads with the same Kernel handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "0505f799e0856339ac55ee4d2dde294e63feea2656afcf18943cb69bb6dfdc03",
                "name": "GetSourceAttributes",
                "params": [
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to size of string in bytes, including null-terminating character.",
                        "name": "pSize",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional] pointer to application-managed character array (string data).\nIf NULL, the string length of the kernel source attributes, including a null-terminating character, is returned in pSize.\nOtherwise, pString must point to valid application memory that is greater than or equal to *pSize bytes in length, and on return the pointed-to string will contain a space-separated list of kernel source attributes.\n",
                        "name": "pString",
                        "type": "char**"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pSize`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetState": {
                "class": "zesTemperature",
                "desc": "Get the temperature from a specified sensor",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "6e03eadebfa90ec535691d9f5ee770f0838a4014177254ed824c0f9878e0c4d7",
                "name": "GetState",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hTemperature",
                        "type": "zes_temp_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain the temperature read from the specified sensor in degrees Celsius.",
                        "name": "pTemperature",
                        "type": "double*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hTemperature`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pTemperature`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetStateExp": {
                "class": "zesRas",
                "desc": "Ras Get State",
                "details": [
                    "This function retrieves error counters for different RAS error categories.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "9e9e646c541c50da30308738da88832993b6df10556583499dff169f46e4b908",
                "name": "GetStateExp",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hRas",
                        "type": "zes_ras_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of RAS state structures that can be retrieved.\nif count is zero, then the driver shall update the value with the total number of error categories for which state can be retrieved.\nif count is greater than the number of RAS states available, then the driver shall update the value with the correct number of RAS states available.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of query results for RAS error states for different categories.\nif count is less than the number of RAS states available, then driver shall only retrieve that number of RAS states.\n",
                        "name": "pState",
                        "type": "zes_ras_state_exp_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hRas`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetStatus": {
                "class": "zeContext",
                "desc": "Returns current status of the context.",
                "details": [
                    "The application may call this function from simultaneous threads with the same context handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "916b95db8d91275de73f2f168f5c3e402ea64d5fa6c33be1074d0955da333d48",
                "name": "GetStatus",
                "params": [
                    {
                        "desc": "[in] handle of context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_SUCCESS": [
                            "Context is available for use."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": [
                            "Context is invalid; due to device lost or reset."
                        ]
                    }
                ],
                "type": "function"
            },
            "GetString": {
                "class": "zeModuleBuildLog",
                "desc": "Retrieves text string for build log.",
                "details": [
                    "The caller can pass nullptr for pBuildLog when querying only for size.",
                    "The caller must provide memory for build log.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "2e8534b4dfea4cf845efe49987825ea8f684cf88eb1011b027e2081c50bf786b",
                "name": "GetString",
                "params": [
                    {
                        "desc": "[in] handle of the module build log object.",
                        "name": "hModuleBuildLog",
                        "type": "ze_module_build_log_handle_t"
                    },
                    {
                        "desc": "[in,out] size of build log string.",
                        "name": "pSize",
                        "type": "size_t*"
                    },
                    {
                        "desc": "[in,out][optional] pointer to null-terminated string of the log.",
                        "name": "pBuildLog",
                        "type": "char*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hModuleBuildLog`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pSize`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetSubDevices": {
                "analogue": [
                    "clCreateSubDevices"
                ],
                "class": "zeDevice",
                "desc": "Retrieves a sub-device from a device",
                "details": [
                    "When the device handle passed does not contain any sub-device, a pCount of 0 is returned.",
                    "Multiple calls to this function will return identical device handles, in the same order.",
                    "The number of handles returned from this function is affected by the ZE_AFFINITY_MASK environment variable.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "c5cfde4e916b948e35c7cd02c26f6a6bd17741a8b1f3e8227fb3c5285222dee0",
                "name": "GetSubDevices",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the device object",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of sub-devices.\nif count is zero, then the driver shall update the value with the total number of sub-devices available.\nif count is greater than the number of sub-devices available, then the driver shall update the value with the correct number of sub-devices available.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of sub-devices.\nif count is less than the number of sub-devices available, then driver shall only retrieve that number of sub-devices.\n",
                        "name": "phSubdevices",
                        "type": "ze_device_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetSubVerticesExp": {
                "class": "zeFabricVertex",
                "desc": "Retrieves a fabric sub-vertex from a fabric vertex",
                "details": [
                    "Multiple calls to this function will return identical fabric vertex handles, in the same order.",
                    "The number of handles returned from this function is affected by the ZE_AFFINITY_MASK environment variable.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "f12d9729896b900bb80da1ed058c5f42c956bd8995514decb6cc13de518fd077",
                "name": "GetSubVerticesExp",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the fabric vertex object",
                        "name": "hVertex",
                        "type": "ze_fabric_vertex_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of sub-vertices.\nif count is zero, then the driver shall update the value with the total number of sub-vertices available.\nif count is greater than the number of sub-vertices available, then the driver shall update the value with the correct number of sub-vertices available.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of handle of sub-vertices.\nif count is less than the number of sub-vertices available, then driver shall only retrieve that number of sub-vertices.\n",
                        "name": "phSubvertices",
                        "type": "ze_fabric_vertex_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hVertex`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.4"
            },
            "GetTests": {
                "class": "zesDiagnostics",
                "desc": "Get individual tests that can be run separately. Not all test suites permit running individual tests, check the `haveTests` member of zes_diag_properties_t.",
                "details": [
                    "The list of available tests is returned in order of increasing test index (see the `index` member of zes_diag_test_t).",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "4219d4ef7697f5b2b7b20571adf1350eeb3e20d96f93c37d10e86d05b8faed06",
                "name": "GetTests",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hDiagnostics",
                        "type": "zes_diag_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of tests.\nif count is zero, then the driver shall update the value with the total number of tests that are available.\nif count is greater than the number of tests that are available, then the driver shall update the value with the correct number of tests.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of information about individual tests sorted by increasing value of the `index` member of zes_diag_test_t.\nif count is less than the number of tests that are available, then the driver shall only retrieve that number of tests.\n",
                        "name": "pTests",
                        "type": "zes_diag_test_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDiagnostics`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetThreadRegisterSetProperties": {
                "class": "zetDebug",
                "decl": "static",
                "desc": "Retrieves debug register set properties for a given thread.",
                "hash": "96f5ab4fe190013dfe748f26ae4db3b9d95a62f88dcb7a7e9468b00d94945169",
                "name": "GetThreadRegisterSetProperties",
                "params": [
                    {
                        "desc": "[in] debug session handle",
                        "name": "hDebug",
                        "type": "zet_debug_session_handle_t"
                    },
                    {
                        "desc": "[in] the thread identifier specifying a single stopped thread",
                        "name": "thread",
                        "type": "ze_device_thread_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of register set properties.\nif count is zero, then the driver shall update the value with the total number of register set properties available.\nif count is greater than the number of register set properties available, then the driver shall update the value with the correct number of registry set properties available.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of query results for register set properties.\nif count is less than the number of register set properties available, then driver shall only retrieve that number of register set properties.\n",
                        "name": "pRegisterSetProperties",
                        "type": "zet_debug_regset_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDebug`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "the thread is running or unavailable"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ARGUMENT": [
                            "the thread argument specifies more than one or a non-existant thread"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "GetThrottleTime": {
                "class": "zesFrequency",
                "desc": "Get frequency throttle time",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "cd622002168430e88f48dce3e9b1fb51c92f6ef41c9d4fa64b18bb4274f8236d",
                "name": "GetThrottleTime",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain a snapshot of the throttle time counters for the specified domain.",
                        "name": "pThrottleTime",
                        "type": "zes_freq_throttle_time_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pThrottleTime`"
                        ]
                    }
                ],
                "type": "function"
            },
            "GetThroughput": {
                "class": "zesFabricPort",
                "desc": "Get Fabric port throughput",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "b624dbb1f8e689bd83898f312af1283e0d67d3606e5440a6dbff6351ab6556b4",
                "name": "GetThroughput",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hPort",
                        "type": "zes_fabric_port_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain the Fabric port throughput counters.",
                        "name": "pThroughput",
                        "type": "zes_fabric_port_throughput_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hPort`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pThroughput`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to query this telemetry."
                        ]
                    }
                ],
                "type": "function"
            },
            "GetTimeoutModeProperties": {
                "class": "zesScheduler",
                "desc": "Get scheduler config for mode ZES_SCHED_MODE_TIMEOUT",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "15bf9620651387ae69552ff0dfacf3fd96d7cd553599e0f549414c62aa97938f",
                "name": "GetTimeoutModeProperties",
                "params": [
                    {
                        "desc": "[in] Sysman handle for the component.",
                        "name": "hScheduler",
                        "type": "zes_sched_handle_t"
                    },
                    {
                        "desc": "[in] If TRUE, the driver will return the system default properties for this mode, otherwise it will return the current properties.",
                        "name": "getDefaults",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] Will contain the current parameters for this mode.",
                        "name": "pConfig",
                        "type": "zes_sched_timeout_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hScheduler`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pConfig`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "This scheduler component does not support scheduler modes."
                        ]
                    }
                ],
                "type": "function"
            },
            "GetTimesliceModeProperties": {
                "class": "zesScheduler",
                "desc": "Get scheduler config for mode ZES_SCHED_MODE_TIMESLICE",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "4cdaf9f11a323f15db5d9dfa4e9cc43cfc054832618dd32e37ca908c5ea1e348",
                "name": "GetTimesliceModeProperties",
                "params": [
                    {
                        "desc": "[in] Sysman handle for the component.",
                        "name": "hScheduler",
                        "type": "zes_sched_handle_t"
                    },
                    {
                        "desc": "[in] If TRUE, the driver will return the system default properties for this mode, otherwise it will return the current properties.",
                        "name": "getDefaults",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] Will contain the current parameters for this mode.",
                        "name": "pConfig",
                        "type": "zes_sched_timeslice_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hScheduler`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pConfig`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "This scheduler component does not support scheduler modes."
                        ]
                    }
                ],
                "type": "function"
            },
            "GetVFPointValues": {
                "class": "zesOverclock",
                "desc": "Read the frequency or voltage of a V-F point from the default or custom V-F curve.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "8b56f4fb8f854cf65406481cf251f0a09fd6ab09ae35df9a0d8a7362529153a8",
                "name": "GetVFPointValues",
                "params": [
                    {
                        "desc": "[in] Handle for the component domain.",
                        "name": "hDomainHandle",
                        "type": "zes_overclock_handle_t"
                    },
                    {
                        "desc": "[in] Voltage or Freqency point to read.",
                        "name": "VFType",
                        "type": "zes_vf_type_t"
                    },
                    {
                        "desc": "[in] User,Default or Live VF array to read from",
                        "name": "VFArrayType",
                        "type": "zes_vf_array_type_t"
                    },
                    {
                        "desc": "[in] Point index - number between (0, max_num_points - 1).",
                        "name": "PointIndex",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Returns the frequency in 1kHz units or voltage in millivolt units from the custom V-F curve at the specified zero-based index ",
                        "name": "PointValue",
                        "type": "uint32_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDomainHandle`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZES_VF_TYPE_FREQ < VFType`",
                            "`ZES_VF_ARRAY_TYPE_LIVE_VF_ARRAY < VFArrayType`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == PointValue`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this control domain"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "GetVerticesExp": {
                "class": "zeFabricEdge",
                "decl": "static",
                "desc": "Retrieves fabric vertices connected by a fabric edge",
                "details": [
                    "A fabric vertex represents either a device or a switch connected to other fabric vertices via a fabric edge.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "d124cc6c609daf4e248dde72e0ef67facc7ddc419f4feb4ea6f29e5f347ec2f6",
                "name": "GetVerticesExp",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the fabric edge instance",
                        "name": "hEdge",
                        "type": "ze_fabric_edge_handle_t"
                    },
                    {
                        "desc": "[out] fabric vertex connected to one end of the given fabric edge.",
                        "name": "phVertexA",
                        "type": "ze_fabric_vertex_handle_t*"
                    },
                    {
                        "desc": "[out] fabric vertex connected to other end of the given fabric edge.",
                        "name": "phVertexB",
                        "type": "ze_fabric_vertex_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hEdge`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == phVertexA`",
                            "`nullptr == phVertexB`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.4"
            },
            "HostReset": {
                "analogue": [
                    "vkResetEvent"
                ],
                "class": "zeEvent",
                "desc": "The current host thread resets an event back to not signaled state.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "cb686654e319bb98f202bace7ac3af520e7df43764c02d371a2fea219c0693ae",
                "name": "HostReset",
                "params": [
                    {
                        "desc": "[in] handle of the event",
                        "name": "hEvent",
                        "type": "ze_event_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hEvent`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    }
                ],
                "type": "function"
            },
            "HostSignal": {
                "analogue": [
                    "clSetUserEventStatus"
                ],
                "class": "zeEvent",
                "desc": "Signals a event from host.",
                "details": [
                    "The duration of an event created from an event pool that was created using ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP or ZE_EVENT_POOL_FLAG_KERNEL_MAPPED_TIMESTAMP flags is undefined. However, for consistency and orthogonality the event will report correctly as signaled when used by other event API functionality.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "069d419381dc35e214bcc3c367f3db0a6fd811f4843e17fb2da82d90f0a1b2d3",
                "name": "HostSignal",
                "params": [
                    {
                        "desc": "[in] handle of the event",
                        "name": "hEvent",
                        "type": "ze_event_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hEvent`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    }
                ],
                "type": "function"
            },
            "HostSynchronize": {
                "analogue": [
                    "**vkWaitForFences**"
                ],
                "class": "zeFence",
                "desc": "The current host thread waits on a fence to be signaled.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "ee76f2ad28be311148d0c6979eb3176567fdef2271f753006ada6aba2240efdd",
                "name": "HostSynchronize",
                "params": [
                    {
                        "desc": "[in] handle of the fence",
                        "name": "hFence",
                        "type": "ze_fence_handle_t"
                    },
                    {
                        "desc": "[in] if non-zero, then indicates the maximum time (in nanoseconds) to yield before returning ZE_RESULT_SUCCESS or ZE_RESULT_NOT_READY;\nif zero, then operates exactly like zeFenceQueryStatus;\nif `UINT64_MAX`, then function will not return until complete or device is lost.\nDue to external dependencies, timeout may be rounded to the closest value allowed by the accuracy of those dependencies.\n",
                        "name": "timeout",
                        "type": "uint64_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFence`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_NOT_READY": [
                            "timeout expired"
                        ]
                    }
                ],
                "type": "function"
            },
            "Init": {
                "class": "zes",
                "decl": "static",
                "desc": "Initialize 'oneAPI' System Resource Management (sysman)",
                "details": [
                    "The application must call this function or zeInit with the ZES_ENABLE_SYSMAN environment variable set before calling any other sysman function.",
                    "If this function is not called then all other sysman functions will return ZE_RESULT_ERROR_UNINITIALIZED.",
                    "This function will only initialize sysman. To initialize other functions, call zeInit.",
                    "There is no requirement to call this function before or after zeInit.",
                    "Only one instance of sysman will be initialized per process.",
                    "The application must call this function after forking new processes. Each forked process must call this function.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe for scenarios where multiple libraries may initialize sysman simultaneously."
                ],
                "hash": "1bbd5be40cc583c65df6085755af48c663f466a9fc324f6a5c43a9f9c4cb3b97",
                "name": "Init",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] initialization flags.\ncurrently unused, must be 0 (default).\n",
                        "init": "0",
                        "name": "flags",
                        "type": "zes_init_flags_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x1 < flags`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "InspectLinkageExt": {
                "analogue": [
                    "None"
                ],
                "class": "zeModule",
                "decl": "static",
                "desc": "List Imports & Exports",
                "details": [
                    "List all the import & unresolveable import dependencies & exports of a set of modules"
                ],
                "hash": "4a77c63603dfa3295f8a24068e27b55c8f35aec421582f4ec1d313e101578aee",
                "name": "InspectLinkageExt",
                "params": [
                    {
                        "desc": "[in] pointer to linkage inspection descriptor structure.",
                        "name": "pInspectDesc",
                        "type": "ze_linkage_inspection_ext_desc_t*"
                    },
                    {
                        "desc": "[in] number of modules to be inspected pointed to by phModules.",
                        "name": "numModules",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, numModules)] pointer to an array of modules to be inspected for import dependencies.",
                        "name": "phModules",
                        "type": "ze_module_handle_t*"
                    },
                    {
                        "desc": "[out] pointer to handle of linkage inspection log. Log object will contain separate lists of imports, un-resolvable imports, and exports.",
                        "name": "phLog",
                        "type": "ze_module_build_log_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pInspectDesc`",
                            "`nullptr == phModules`",
                            "`nullptr == phLog`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x7 < pInspectDesc->flags`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.3"
            },
            "Interrupt": {
                "class": "zetDebug",
                "desc": "Interrupt device threads.",
                "hash": "97d57d2337376beea4fcf5647996d6a695c408b43c4402bc50cb7f1f849100c8",
                "name": "Interrupt",
                "params": [
                    {
                        "desc": "[in] debug session handle",
                        "name": "hDebug",
                        "type": "zet_debug_session_handle_t"
                    },
                    {
                        "desc": "[in] the thread to interrupt",
                        "name": "thread",
                        "type": "ze_device_thread_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDebug`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "the thread is already stopped or unavailable"
                        ]
                    }
                ],
                "type": "function"
            },
            "JoinExp": {
                "class": "zeRTASParallelOperation",
                "desc": "Joins a parallel build operation",
                "details": [
                    "All worker threads return the same error code for the parallel build operation upon build completion"
                ],
                "hash": "9af290b29e7178a88fb88802c8ba03e7259de678f3b672f657f522c70bad9cc1",
                "name": "JoinExp",
                "params": [
                    {
                        "desc": "[in] handle of parallel operation object",
                        "name": "hParallelOperation",
                        "type": "ze_rtas_parallel_operation_exp_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hParallelOperation`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "MakeImageResident": {
                "class": "zeContext",
                "desc": "Makes image resident for the device.",
                "details": [
                    "The application must ensure the image is resident before being referenced by the device",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "57b4676a6a5206cc9915a2ad3c7a130d70c9ea65c6484b0508523ea12eee4ae9",
                "name": "MakeImageResident",
                "params": [
                    {
                        "desc": "[in] handle of context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] handle of image to make resident",
                        "name": "hImage",
                        "type": "ze_image_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`",
                            "`nullptr == hImage`"
                        ]
                    }
                ],
                "type": "function"
            },
            "MakeMemoryResident": {
                "class": "zeContext",
                "desc": "Makes memory resident for the device.",
                "details": [
                    "The application must ensure the memory is resident before being referenced by the device",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "0ede25c0fa4f257fa909c006790cbb66b632bedf075bfb9e5fb177b24b03519c",
                "name": "MakeMemoryResident",
                "params": [
                    {
                        "desc": "[in] handle of context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] pointer to memory to make resident",
                        "name": "ptr",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] size in bytes to make resident",
                        "name": "size",
                        "type": "size_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`"
                        ]
                    }
                ],
                "type": "function"
            },
            "Map": {
                "class": "zeVirtualMem",
                "decl": "static",
                "desc": "Maps pages in virtual address space to pages from physical memory object.",
                "details": [
                    "The virtual address range must have been reserved using zeVirtualMemReserve.",
                    "The application must only use the mapped memory allocation on the context for which it was created.",
                    "The virtual start address and size must be page aligned. See zeVirtualMemQueryPageSize.",
                    "The application should use, for the starting address and size, the same size alignment used for the physical allocation.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "6c2094655bab4890d0ef07d9e5b7e92dc48dc3f2ba18b68517c369adad3c58e9",
                "name": "Map",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] pointer to start of virtual address range to map.",
                        "name": "ptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] size in bytes of virtual address range to map; must be page aligned.",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] handle to physical memory object.",
                        "name": "hPhysicalMemory",
                        "type": "ze_physical_mem_handle_t"
                    },
                    {
                        "desc": "[in] offset into physical memory allocation object; must be page aligned.",
                        "name": "offset",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] specifies page access attributes to apply to the virtual address range.",
                        "name": "access",
                        "type": "ze_memory_access_attribute_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hPhysicalMemory`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZE_MEMORY_ACCESS_ATTRIBUTE_READONLY < access`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_SIZE": [
                            "`0 == size`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": []
                    }
                ],
                "type": "function"
            },
            "OcGetCapabilities": {
                "class": "zesFrequency",
                "desc": "Get the overclocking capabilities.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "27bf6388e5923bdaa0967f8e74b1675ffd0e7c82980c7974dda6e82d24efc5c2",
                "name": "OcGetCapabilities",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[in,out] Pointer to the capabilities structure.",
                        "name": "pOcCapabilities",
                        "type": "zes_oc_capabilities_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pOcCapabilities`"
                        ]
                    }
                ],
                "type": "function"
            },
            "OcGetFrequencyTarget": {
                "class": "zesFrequency",
                "desc": "Get the current overclocking frequency target, if extended moded is supported, will returned in 1 Mhz granularity.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "a1fee7e08b70a9ff9017be269ccba56a321c80f2a1bd0f08f4bf25b80edb8e87",
                "name": "OcGetFrequencyTarget",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[out] Overclocking Frequency in MHz, if extended moded is supported, will returned in 1 Mhz granularity, else, in multiples of 50 Mhz. This cannot be greater than the `maxOcFrequency` member of zes_oc_capabilities_t.",
                        "name": "pCurrentOcFrequency",
                        "type": "double*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCurrentOcFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of zes_oc_capabilities_t).",
                            "The specified voltage and/or frequency overclock settings exceed the hardware values (see the `maxOcFrequency`, `maxOcVoltage`, `minOcVoltageOffset` and `maxOcVoltageOffset` members of zes_oc_capabilities_t).",
                            "Requested voltage overclock is very high but the `isHighVoltModeEnabled` member of zes_oc_capabilities_t is not enabled for the device."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "Overclocking feature is locked on this frequency domain."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    }
                ],
                "type": "function"
            },
            "OcGetIccMax": {
                "class": "zesFrequency",
                "desc": "Get the maximum current limit setting.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "dd3afa560c90667b89253d02e45759933e6ee6a5f4a4657c783e821f9b8d8660",
                "name": "OcGetIccMax",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain the maximum current limit in Amperes on successful return.",
                        "name": "pOcIccMax",
                        "type": "double*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pOcIccMax`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of zes_oc_capabilities_t).",
                            "Capability the `isIccMaxSupported` member of zes_oc_capabilities_t is false for this frequency domain."
                        ]
                    }
                ],
                "type": "function"
            },
            "OcGetMode": {
                "class": "zesFrequency",
                "desc": "Get the current overclocking mode.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "62c4575e249097bdec5d726201f5f1259da813d0d7c0045814a5b917ff6a1308",
                "name": "OcGetMode",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[out] Current Overclocking Mode zes_oc_mode_t.",
                        "name": "pCurrentOcMode",
                        "type": "zes_oc_mode_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCurrentOcMode`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of zes_oc_capabilities_t).",
                            "The specified voltage and/or frequency overclock settings exceed the hardware values (see the `maxOcFrequency`, `maxOcVoltage`, `minOcVoltageOffset` and `maxOcVoltageOffset` members of zes_oc_capabilities_t).",
                            "Requested voltage overclock is very high but the `isHighVoltModeEnabled` member of zes_oc_capabilities_t is not enabled for the device."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "Overclocking feature is locked on this frequency domain."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    }
                ],
                "type": "function"
            },
            "OcGetTjMax": {
                "class": "zesFrequency",
                "desc": "Get the maximum temperature limit setting.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "c1758ddfd68bb1988d3753bb71636b3b666c3f011d35cd830c8d0434c777d5e3",
                "name": "OcGetTjMax",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain the maximum temperature limit in degrees Celsius on successful return.",
                        "name": "pOcTjMax",
                        "type": "double*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pOcTjMax`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of zes_oc_capabilities_t)."
                        ]
                    }
                ],
                "type": "function"
            },
            "OcGetVoltageTarget": {
                "class": "zesFrequency",
                "desc": "Get the current overclocking voltage settings.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "f6a3671ccc34ac2d3e6af12869ff5edfc85e3cc20db0d48b61cfe96781198c94",
                "name": "OcGetVoltageTarget",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[out] Overclock voltage in Volts. This cannot be greater than the `maxOcVoltage` member of zes_oc_capabilities_t.",
                        "name": "pCurrentVoltageTarget",
                        "type": "double*"
                    },
                    {
                        "desc": "[out] This voltage offset is applied to all points on the voltage/frequency curve, including the new overclock voltageTarget. Valid range is between the `minOcVoltageOffset` and `maxOcVoltageOffset` members of zes_oc_capabilities_t.",
                        "name": "pCurrentVoltageOffset",
                        "type": "double*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCurrentVoltageTarget`",
                            "`nullptr == pCurrentVoltageOffset`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of zes_oc_capabilities_t).",
                            "The specified voltage and/or frequency overclock settings exceed the hardware values (see the `maxOcFrequency`, `maxOcVoltage`, `minOcVoltageOffset` and `maxOcVoltageOffset` members of zes_oc_capabilities_t).",
                            "Requested voltage overclock is very high but the `isHighVoltModeEnabled` member of zes_oc_capabilities_t is not enabled for the device."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "Overclocking feature is locked on this frequency domain."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    }
                ],
                "type": "function"
            },
            "OcSetFrequencyTarget": {
                "class": "zesFrequency",
                "desc": "Set the current overclocking frequency target, if extended moded is supported, can be set in 1 Mhz granularity.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "3a6b01a51f459abd4b5094093ec355d270545a80ddac2792d06d29aee7463e1b",
                "name": "OcSetFrequencyTarget",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[in] Overclocking Frequency in MHz, if extended moded is supported, it could be set in 1 Mhz granularity, else, in multiples of 50 Mhz. This cannot be greater than the `maxOcFrequency` member of zes_oc_capabilities_t.",
                        "name": "CurrentOcFrequency",
                        "type": "double"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of zes_oc_capabilities_t).",
                            "The specified voltage and/or frequency overclock settings exceed the hardware values (see the `maxOcFrequency`, `maxOcVoltage`, `minOcVoltageOffset` and `maxOcVoltageOffset` members of zes_oc_capabilities_t).",
                            "Requested voltage overclock is very high but the `isHighVoltModeEnabled` member of zes_oc_capabilities_t is not enabled for the device."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "Overclocking feature is locked on this frequency domain."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    }
                ],
                "type": "function"
            },
            "OcSetIccMax": {
                "class": "zesFrequency",
                "desc": "Change the maximum current limit setting.",
                "details": [
                    "Setting ocIccMax to 0.0 will return the value to the factory default.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "e75fd6668d4a7b5f10fc95f5830293547df215abe25c798afb1b88def4360fe6",
                "name": "OcSetIccMax",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[in] The new maximum current limit in Amperes.",
                        "name": "ocIccMax",
                        "type": "double"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of zes_oc_capabilities_t).",
                            "The `isIccMaxSupported` member of zes_oc_capabilities_t is false for this frequency domain."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "Overclocking feature is locked on this frequency domain."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ARGUMENT": [
                            "The specified current limit is too low or too high."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    }
                ],
                "type": "function"
            },
            "OcSetMode": {
                "class": "zesFrequency",
                "desc": "Set the current overclocking mode.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "309c17c47d975efe332fedbe4501950c7216615dbfaeec37f3de3576ee3d5407",
                "name": "OcSetMode",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[in] Current Overclocking Mode zes_oc_mode_t.",
                        "name": "CurrentOcMode",
                        "type": "zes_oc_mode_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZES_OC_MODE_FIXED < CurrentOcMode`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of zes_oc_capabilities_t).",
                            "The specified voltage and/or frequency overclock settings exceed the hardware values (see the `maxOcFrequency`, `maxOcVoltage`, `minOcVoltageOffset` and `maxOcVoltageOffset` members of zes_oc_capabilities_t).",
                            "Requested voltage overclock is very high but the `isHighVoltModeEnabled` member of zes_oc_capabilities_t is not enabled for the device."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "Overclocking feature is locked on this frequency domain."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    }
                ],
                "type": "function"
            },
            "OcSetTjMax": {
                "class": "zesFrequency",
                "desc": "Change the maximum temperature limit setting.",
                "details": [
                    "Setting ocTjMax to 0.0 will return the value to the factory default.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "742e421c8ae9294b2993a07eab549a060b678d7a5c74c5c71ce6e012f22d50aa",
                "name": "OcSetTjMax",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[in] The new maximum temperature limit in degrees Celsius.",
                        "name": "ocTjMax",
                        "type": "double"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of zes_oc_capabilities_t).",
                            "The `isTjMaxSupported` member of zes_oc_capabilities_t is false for this frequency domain."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "Overclocking feature is locked on this frequency domain."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ARGUMENT": [
                            "The specified temperature limit is too high."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    }
                ],
                "type": "function"
            },
            "OcSetVoltageTarget": {
                "class": "zesFrequency",
                "desc": "Set the current overclocking voltage settings.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "5f4c50d38e299212417f47798a74b4da436371eaee20c92098f13d3192b8b590",
                "name": "OcSetVoltageTarget",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[in] Overclock voltage in Volts. This cannot be greater than the `maxOcVoltage` member of zes_oc_capabilities_t.",
                        "name": "CurrentVoltageTarget",
                        "type": "double"
                    },
                    {
                        "desc": "[in] This voltage offset is applied to all points on the voltage/frequency curve, include the new overclock voltageTarget. Valid range is between the `minOcVoltageOffset` and `maxOcVoltageOffset` members of zes_oc_capabilities_t.",
                        "name": "CurrentVoltageOffset",
                        "type": "double"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of zes_oc_capabilities_t).",
                            "The specified voltage and/or frequency overclock settings exceed the hardware values (see the `maxOcFrequency`, `maxOcVoltage`, `minOcVoltageOffset` and `maxOcVoltageOffset` members of zes_oc_capabilities_t).",
                            "Requested voltage overclock is very high but the `isHighVoltModeEnabled` member of zes_oc_capabilities_t is not enabled for the device."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "Overclocking feature is locked on this frequency domain."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    }
                ],
                "type": "function"
            },
            "Open": {
                "class": "zetMetricStreamer",
                "decl": "static",
                "desc": "Opens metric streamer for a device.",
                "details": [
                    "The notification event must have been created from an event pool that was created using ZE_EVENT_POOL_FLAG_HOST_VISIBLE flag.",
                    "The duration of the signal event created from an event pool that was created using ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag is undefined. However, for consistency and orthogonality the event will report correctly as signaled when used by other event API functionality.",
                    "The application must **not** call this function from simultaneous threads with the same device handle."
                ],
                "hash": "fd476dcac868ee20bbfeaa63a804477465714e4b754e0d863151f3f5f39ffc23",
                "name": "Open",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "zet_context_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "zet_device_handle_t"
                    },
                    {
                        "desc": "[in] handle of the metric group",
                        "name": "hMetricGroup",
                        "type": "zet_metric_group_handle_t"
                    },
                    {
                        "desc": "[in,out] metric streamer descriptor",
                        "name": "desc",
                        "type": "zet_metric_streamer_desc_t*"
                    },
                    {
                        "desc": "[in][optional] event used for report availability notification",
                        "name": "hNotificationEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[out] handle of metric streamer",
                        "name": "phMetricStreamer",
                        "type": "zet_metric_streamer_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`",
                            "`nullptr == hMetricGroup`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == desc`",
                            "`nullptr == phMetricStreamer`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    }
                ],
                "type": "function"
            },
            "OpenIpcHandle": {
                "class": "zeMem",
                "decl": "static",
                "desc": "Opens an IPC memory handle to retrieve a device pointer on the context.",
                "details": [
                    "Takes an IPC memory handle from a remote process and associates it with a device pointer usable in this process.",
                    "The device pointer in this process should not be freed with zeMemFree, but rather with zeMemCloseIpcHandle.",
                    "Multiple calls to this function with the same IPC handle will return unique pointers.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "4c72e60d813bc0a5b107447c8fa631b5bbab875a991dbc25647bc34a281fd554",
                "name": "OpenIpcHandle",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device to associate with the IPC memory handle",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] IPC memory handle",
                        "name": "handle",
                        "type": "ze_ipc_mem_handle_t"
                    },
                    {
                        "desc": "[in] flags controlling the operation.\nmust be 0 (default) or a valid combination of ze_ipc_memory_flag_t.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_ipc_memory_flags_t"
                    },
                    {
                        "desc": "[out] pointer to device allocation in this process",
                        "name": "pptr",
                        "type": "void**"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x3 < flags`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pptr`"
                        ]
                    }
                ],
                "type": "function"
            },
            "PciGetBars": {
                "class": "zesDevice",
                "desc": "Get information about each configured bar",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "88ba4b62a295f7ab057dac57aabd8ab6e46cd95e29f99e9c4c094d837c6d141d",
                "name": "PciGetBars",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of PCI bars.\nif count is zero, then the driver shall update the value with the total number of PCI bars that are setup.\nif count is greater than the number of PCI bars that are setup, then the driver shall update the value with the correct number of PCI bars.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of information about setup PCI bars.\nif count is less than the number of PCI bars that are setup, then the driver shall only retrieve information about that number of PCI bars.\n",
                        "name": "pProperties",
                        "type": "zes_pci_bar_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "PciGetProperties": {
                "class": "zesDevice",
                "desc": "Get PCI properties - address, max speed",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "e87d7976293d00d44adf69bd42f1430f154f7bf820abeda534a7330211550eec",
                "name": "PciGetProperties",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain the PCI properties.",
                        "name": "pProperties",
                        "type": "zes_pci_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pProperties`"
                        ]
                    }
                ],
                "type": "function"
            },
            "PciGetPropertiesExt": {
                "analogue": [
                    "None"
                ],
                "class": "zeDevice",
                "decl": "static",
                "desc": "Get PCI properties - address, max speed",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "44e9f8dd96a5b149313aec8d704fc3335e63766d2449fa074376ecd43a46def8",
                "name": "PciGetPropertiesExt",
                "params": [
                    {
                        "desc": "[in] handle of the device object.",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] returns the PCI properties of the device.",
                        "name": "pPciProperties",
                        "type": "ze_pci_ext_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pPciProperties`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.3"
            },
            "PciGetState": {
                "class": "zesDevice",
                "desc": "Get current PCI state - current speed",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "84dc8436ca5d1cfcdace8795f05b6fff03f037f9e33c0871a68a7df0c4919ac9",
                "name": "PciGetState",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain the PCI properties.",
                        "name": "pState",
                        "type": "zes_pci_state_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pState`"
                        ]
                    }
                ],
                "type": "function"
            },
            "PciGetStats": {
                "class": "zesDevice",
                "desc": "Get PCI stats - bandwidth, number of packets, number of replays",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "a4510a9789e8a79b17f288aee861954692b2662324b154bcb479f977c08e0e08",
                "name": "PciGetStats",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] Will contain a snapshot of the latest stats.",
                        "name": "pStats",
                        "type": "zes_pci_stats_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pStats`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to query this telemetry."
                        ]
                    }
                ],
                "type": "function"
            },
            "ProcessesGetState": {
                "class": "zesDevice",
                "desc": "Get information about host processes using the device",
                "details": [
                    "The number of processes connected to the device is dynamic. This means that between a call to determine the value of pCount and the subsequent call, the number of processes may have increased or decreased. It is recommended that a large array be passed in so as to avoid receiving the error ZE_RESULT_ERROR_INVALID_SIZE. Also, always check the returned value in pCount since it may be less than the earlier call to get the required array size.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "e0532e5c68d72d06053786f30f98e8586a9f97e4123742ec00b31bd1190d67b0",
                "name": "ProcessesGetState",
                "params": [
                    {
                        "desc": "[in] Sysman handle for the device",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of processes.\nif count is zero, then the driver shall update the value with the total number of processes currently attached to the device.\nif count is greater than the number of processes currently attached to the device, then the driver shall update the value with the correct number of processes.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of process information.\nif count is less than the number of processes currently attached to the device, then the driver shall only retrieve information about that number of processes. In this case, the return code will ZE_RESULT_ERROR_INVALID_SIZE.\n",
                        "name": "pProcesses",
                        "type": "zes_process_state_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SIZE": [
                            "The provided value of pCount is not big enough to store information about all the processes currently attached to the device."
                        ]
                    }
                ],
                "type": "function"
            },
            "PutIpcHandle": {
                "class": "zeMem",
                "decl": "static",
                "desc": "Returns an IPC memory handle to the driver",
                "details": [
                    "This call may be used for IPC handles previously obtained with either zeMemGetIpcHandle or with ze_external_memory_export_fd_t via zeMemGetAllocProperties.\n",
                    "Upon call, driver may release any underlying resources associated with the IPC handle.\nFor instance, it may close the file descriptor contained in the IPC handle, if such type of handle is being used by the driver.\n",
                    "This call does not free the original allocation for which the IPC handle was created.",
                    "This function may **not** be called from simultaneous threads with the same IPC handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "34244e7493a2b2f9d15f3f02f77e55814209a257d38057e839b02653d59f6608",
                "name": "PutIpcHandle",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] IPC memory handle",
                        "name": "handle",
                        "type": "ze_ipc_mem_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.6"
            },
            "QueryKernelTimestamp": {
                "class": "zeEvent",
                "desc": "Queries an event's timestamp value on the host.",
                "details": [
                    "The application must ensure the event was created from an event pool that was created using ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP or ZE_EVENT_POOL_FLAG_KERNEL_MAPPED_TIMESTAMP flag.",
                    "The destination memory will be unmodified if the event has not been signaled.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "d4389b8347228d4d121f41bcb0f912329fe59812baa02f9af059d27e6c922aa7",
                "name": "QueryKernelTimestamp",
                "params": [
                    {
                        "desc": "[in] handle of the event",
                        "name": "hEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to memory for where timestamp result will be written.",
                        "name": "dstptr",
                        "type": "ze_kernel_timestamp_result_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hEvent`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == dstptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_NOT_READY": [
                            "not signaled"
                        ]
                    }
                ],
                "type": "function"
            },
            "QueryKernelTimestampsExt": {
                "class": "zeEvent",
                "desc": "Query an event's timestamp value on the host, with domain preference.",
                "details": [
                    "For collecting *only* kernel timestamps, the application must ensure the event was created from an event pool that was created using ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag.",
                    "For collecting synchronized timestamps, the application must ensure the event was created from an event pool that was created using ZE_EVENT_POOL_FLAG_KERNEL_MAPPED_TIMESTAMP flag. Kernel timestamps are also available from this type of event pool, but there is a performance cost.",
                    "The destination memory will be unmodified if the event has not been signaled.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe.",
                    "The implementation must support ZE_extension_event_query_kernel_timestamps.",
                    "The implementation must return all timestamps for the specified event and device pair.",
                    "The implementation must return all timestamps for all sub-devices when device handle is parent device.",
                    "The implementation may return all timestamps for sub-devices when device handle is sub-device or may return 0 for count."
                ],
                "hash": "1fd7be75405b56820b9d681d430d712ad8c789c74a5cd4e3332d20245e9694c0",
                "name": "QueryKernelTimestampsExt",
                "params": [
                    {
                        "desc": "[in] handle of the event",
                        "name": "hEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device to query",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of event packets available.\n    - This value is implementation specific.\n    - if `*pCount` is zero, then the driver shall update the value with the total number of event packets available.\n    - if `*pCount` is greater than the number of event packets available, the driver shall update the value with the correct value.\n    - Buffer(s) for query results must be sized by the application to accommodate a minimum of `*pCount` elements.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] pointer to event query properties structure(s).\n    - This parameter may be null when `*pCount` is zero.\n    - if `*pCount` is less than the number of event packets available, the driver may only update `*pCount` elements, starting at element zero.\n    - if `*pCount` is greater than the number of event packets available, the driver may only update the valid elements.\n",
                        "name": "pResults",
                        "type": "ze_event_query_kernel_timestamps_results_ext_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hEvent`",
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.6"
            },
            "QueryPageSize": {
                "class": "zeVirtualMem",
                "decl": "static",
                "desc": "Queries page size to use for aligning virtual memory reservations and physical memory allocations.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "797592efbb6fa316e5659e501c55e0f8c7459e921366c683633e74afc0ba2129",
                "name": "QueryPageSize",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device object",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] unaligned allocation size in bytes",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[out] pointer to page size to use for start address and size alignments.",
                        "name": "pagesize",
                        "type": "size_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pagesize`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_SIZE": [
                            "`0 == size`"
                        ]
                    }
                ],
                "type": "function"
            },
            "QueryStatus": {
                "analogue": [
                    "**vkGetFenceStatus**"
                ],
                "class": "zeFence",
                "desc": "Queries a fence object's status.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "54d115edc2a41acd09d4b8170e56d9826a2b5706f11c6104736eb5860d23c5bc",
                "name": "QueryStatus",
                "params": [
                    {
                        "desc": "[in] handle of the fence",
                        "name": "hFence",
                        "type": "ze_fence_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFence`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                    },
                    {
                        "ZE_RESULT_NOT_READY": [
                            "not signaled"
                        ]
                    }
                ],
                "type": "function"
            },
            "QueryTimestampsExp": {
                "analogue": [
                    "None"
                ],
                "class": "zeEvent",
                "decl": "static",
                "desc": "Query event timestamps for a device or sub-device.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe.",
                    "The implementation must support ZE_experimental_event_query_timestamps.",
                    "The implementation must return all timestamps for the specified event and device pair.",
                    "The implementation must return all timestamps for all sub-devices when device handle is parent device.",
                    "The implementation may return all timestamps for sub-devices when device handle is sub-device or may return 0 for count."
                ],
                "hash": "d82c2f32f452c9fff17b3a5272be146346fc845655fd7e4567a55514b33343bc",
                "name": "QueryTimestampsExp",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the event",
                        "name": "hEvent",
                        "type": "ze_event_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device to query",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in,out] pointer to the number of timestamp results.\nif count is zero, then the driver shall update the value with the total number of timestamps available.\nif count is greater than the number of timestamps available, then the driver shall update the value with the correct number of timestamps available.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of timestamp results.\nif count is less than the number of timestamps available, then driver shall only retrieve that number of timestamps.",
                        "name": "pTimestamps",
                        "type": "ze_kernel_timestamp_result_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hEvent`",
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.2"
            },
            "RTASFormatCompatibilityCheckExp": {
                "class": "zeDriver",
                "desc": "Checks ray tracing acceleration structure format compatibility",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "1bedf76c353eb5fb199eb3f1a0366cc5c376199b7f36771c72a08c54181d1a53",
                "name": "RTASFormatCompatibilityCheckExp",
                "params": [
                    {
                        "desc": "[in] handle of driver object",
                        "name": "hDriver",
                        "type": "ze_driver_handle_t"
                    },
                    {
                        "desc": "[in] operand A",
                        "name": "rtasFormatA",
                        "type": "ze_rtas_format_exp_t"
                    },
                    {
                        "desc": "[in] operand B",
                        "name": "rtasFormatB",
                        "type": "ze_rtas_format_exp_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDriver`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZE_RTAS_FORMAT_EXP_INVALID < rtasFormatA`",
                            "`ZE_RTAS_FORMAT_EXP_INVALID < rtasFormatB`"
                        ]
                    },
                    {
                        "ZE_RESULT_SUCCESS": [
                            "An acceleration structure built with `rtasFormatA` is compatible with devices that report `rtasFormatB`."
                        ]
                    },
                    {
                        "ZE_RESULT_EXP_ERROR_OPERANDS_INCOMPATIBLE": [
                            "An acceleration structure built with `rtasFormatA` is **not** compatible with devices that report `rtasFormatB`."
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "ReadData": {
                "class": "zetMetricStreamer",
                "desc": "Reads data from metric streamer.",
                "details": [
                    "The application may call this function from simultaneous threads."
                ],
                "hash": "46f3a51dca41a6993577fdad58dc258e362bc98c7ffac1bdc6f6000b327acd2b",
                "name": "ReadData",
                "params": [
                    {
                        "desc": "[in] handle of the metric streamer",
                        "name": "hMetricStreamer",
                        "type": "zet_metric_streamer_handle_t"
                    },
                    {
                        "desc": "[in] the maximum number of reports the application wants to receive.\nif `UINT32_MAX`, then function will retrieve all reports available\n",
                        "name": "maxReportCount",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out] pointer to size in bytes of raw data requested to read.\nif size is zero, then the driver will update the value with the total size in bytes needed for all reports available.\nif size is non-zero, then driver will only retrieve the number of reports that fit into the buffer.\nif size is larger than size needed for all reports, then driver will update the value with the actual size needed.\n",
                        "name": "pRawDataSize",
                        "type": "size_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pRawDataSize)] buffer containing streamer reports in raw format",
                        "name": "pRawData",
                        "type": "uint8_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hMetricStreamer`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pRawDataSize`"
                        ]
                    },
                    {
                        "ZE_RESULT_WARNING_DROPPED_DATA": [
                            "Metric streamer data may have been dropped. Reduce sampling period."
                        ]
                    }
                ],
                "type": "function"
            },
            "ReadEvent": {
                "class": "zetDebug",
                "desc": "Read the topmost debug event.",
                "hash": "fd2eafa037418a5cbc68fa5bf7a0fe66ada619637cd7ce2a926e5a71032fc51b",
                "name": "ReadEvent",
                "params": [
                    {
                        "desc": "[in] debug session handle",
                        "name": "hDebug",
                        "type": "zet_debug_session_handle_t"
                    },
                    {
                        "desc": "[in] if non-zero, then indicates the maximum time (in milliseconds) to yield before returning ZE_RESULT_SUCCESS or ZE_RESULT_NOT_READY;\nif zero, then immediately returns the status of the event;\nif `UINT64_MAX`, then function will not return until complete or device is lost.\nDue to external dependencies, timeout may be rounded to the closest value allowed by the accuracy of those dependencies.\n",
                        "name": "timeout",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[in,out] a pointer to a zet_debug_event_t.",
                        "name": "event",
                        "type": "zet_debug_event_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDebug`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == event`"
                        ]
                    },
                    {
                        "ZE_RESULT_NOT_READY": [
                            "the timeout expired"
                        ]
                    }
                ],
                "type": "function"
            },
            "ReadMemory": {
                "class": "zetDebug",
                "desc": "Read memory.",
                "details": [
                    "The thread identifier 'all' can be used for accessing the default memory space, e.g. for setting breakpoints."
                ],
                "hash": "32d1103937128d0fdc73b46974a88ff0502d29fdd3bdbe361a6819eea9e2af36",
                "name": "ReadMemory",
                "params": [
                    {
                        "desc": "[in] debug session handle",
                        "name": "hDebug",
                        "type": "zet_debug_session_handle_t"
                    },
                    {
                        "desc": "[in] the thread identifier.",
                        "name": "thread",
                        "type": "ze_device_thread_t"
                    },
                    {
                        "desc": "[in] memory space descriptor",
                        "name": "desc",
                        "type": "const zet_debug_memory_space_desc_t*"
                    },
                    {
                        "desc": "[in] the number of bytes to read",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in,out] a buffer to hold a copy of the memory",
                        "name": "buffer",
                        "type": "void*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDebug`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == desc`",
                            "`nullptr == buffer`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZET_DEBUG_MEMORY_SPACE_TYPE_SLM < desc->type`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "the thread is running or unavailable",
                            "the memory cannot be accessed from the supplied thread"
                        ]
                    }
                ],
                "type": "function"
            },
            "ReadOverclockState": {
                "class": "zesDevice",
                "desc": "Determine the state of overclocking",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "bf83d33d94f9f7a4212f5acf692aa525675b4ae890259e8e179069c1a95c83e2",
                "name": "ReadOverclockState",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[out] One of overclock mode.",
                        "name": "pOverclockMode",
                        "type": "zes_overclock_mode_t*"
                    },
                    {
                        "desc": "[out] Waiver setting: 0 = Waiver not set, 1 = waiver has been set.",
                        "name": "pWaiverSetting",
                        "type": "ze_bool_t*"
                    },
                    {
                        "desc": "[out] Current settings 0 =manufacturing state, 1= shipped state)..",
                        "name": "pOverclockState",
                        "type": "ze_bool_t*"
                    },
                    {
                        "desc": "[out] This enum is returned when the driver attempts to set an overclock control or reset overclock settings.",
                        "name": "pPendingAction",
                        "type": "zes_pending_action_t*"
                    },
                    {
                        "desc": "[out] Pending reset 0 =manufacturing state, 1= shipped state)..",
                        "name": "pPendingReset",
                        "type": "ze_bool_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pOverclockMode`",
                            "`nullptr == pWaiverSetting`",
                            "`nullptr == pOverclockState`",
                            "`nullptr == pPendingAction`",
                            "`nullptr == pPendingReset`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this control domain"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "ReadRegisters": {
                "class": "zetDebug",
                "desc": "Read register state.",
                "hash": "4971ff5ff86f5c20fda571c8540832b90f68b99ff6b2c72527ae590fb92ecd13",
                "name": "ReadRegisters",
                "params": [
                    {
                        "desc": "[in] debug session handle",
                        "name": "hDebug",
                        "type": "zet_debug_session_handle_t"
                    },
                    {
                        "desc": "[in] the thread identifier",
                        "name": "thread",
                        "type": "ze_device_thread_t"
                    },
                    {
                        "desc": "[in] register set type",
                        "name": "type",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] the starting offset into the register state area; must be less than the `count` member of zet_debug_regset_properties_t for the type",
                        "name": "start",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] the number of registers to read; start+count must be less than or equal to the `count` member of zet_debug_register_group_properties_t for the type",
                        "name": "count",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out][optional][range(0, count)] buffer of register values",
                        "name": "pRegisterValues",
                        "type": "void*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDebug`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "the thread is running or unavailable"
                        ]
                    }
                ],
                "type": "function"
            },
            "Reserve": {
                "class": "zeVirtualMem",
                "decl": "static",
                "desc": "Reserves pages in virtual address space.",
                "details": [
                    "The application must only use the memory allocation on the context for which it was created.",
                    "The starting address and size must be page aligned. See zeVirtualMemQueryPageSize.",
                    "If pStart is not null then implementation will attempt to reserve starting from that address. If not available then will find another suitable starting address.",
                    "The application may call this function from simultaneous threads.",
                    "The access attributes will default to none to indicate reservation is inaccessible.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "a9216049788e72f4182b91847f59a63dd476ba819dbb07d9dfa072504c8c9111",
                "name": "Reserve",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in][optional] pointer to start of region to reserve. If nullptr then implementation will choose a start address.",
                        "name": "pStart",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] size in bytes to reserve; must be page aligned.",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[out] pointer to virtual reservation.",
                        "name": "pptr",
                        "type": "void**"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_SIZE": [
                            "`0 == size`"
                        ]
                    }
                ],
                "type": "function"
            },
            "ReserveCacheExt": {
                "analogue": [
                    "None"
                ],
                "class": "zeDevice",
                "decl": "static",
                "desc": "Reserve Cache on Device",
                "details": [
                    "The application may call this function but may not be successful as some other application may have reserve prior"
                ],
                "hash": "c490e6bf5354109695b33536ac7b380214713bbf13b772512d880dd17781417b",
                "name": "ReserveCacheExt",
                "params": [
                    {
                        "desc": "[in] handle of the device object",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] cache level where application want to reserve. If zero, then the driver shall default to last level of cache and attempt to reserve in that cache.",
                        "name": "cacheLevel",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] value for reserving size, in bytes. If zero, then the driver shall remove prior reservation",
                        "name": "cacheReservationSize",
                        "type": "size_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.2"
            },
            "Reset": {
                "class": "zesDevice",
                "desc": "Reset device",
                "details": [
                    "Performs a PCI bus reset of the device. This will result in all current device state being lost.",
                    "All applications using the device should be stopped before calling this function.",
                    "If the force argument is specified, all applications using the device will be forcibly killed.",
                    "The function will block until the device has restarted or an implementation defined timeout occurred waiting for the reset to complete."
                ],
                "hash": "67b1841611f9320f42b40fbca89a7d36fe40df9eb3f266d1eaa2b10d345bf9dd",
                "name": "Reset",
                "params": [
                    {
                        "desc": "[in] Sysman handle for the device",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in] If set to true, all applications that are currently using the device will be forcibly killed.",
                        "name": "force",
                        "type": "ze_bool_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to perform this operation."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE": [
                            "Reset cannot be performed because applications are using this device."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNKNOWN": [
                            "There were problems unloading the device driver, performing a bus reset or reloading the device driver."
                        ]
                    }
                ],
                "type": "function"
            },
            "ResetExt": {
                "class": "zesDevice",
                "desc": "Reset device extension",
                "details": [
                    "Performs a PCI bus reset of the device. This will result in all current device state being lost.",
                    "Prior to calling this function, user is responsible for closing applications using the device unless force argument is specified.",
                    "If the force argument is specified, all applications using the device will be forcibly killed.",
                    "The function will block until the device has restarted or a implementation specific timeout occurred waiting for the reset to complete."
                ],
                "hash": "483a18c10d33993940d82a433a1d1315e607f86845f02ea1cb32d9f41b225fb3",
                "name": "ResetExt",
                "params": [
                    {
                        "desc": "[in] Sysman handle for the device",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in] Device reset properties to apply",
                        "name": "pProperties",
                        "type": "zes_reset_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pProperties`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to perform this operation."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE": [
                            "Reset cannot be performed because applications are using this device."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNKNOWN": [
                            "There were problems unloading the device driver, performing a bus reset or reloading the device driver."
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "ResetOverclockSettings": {
                "class": "zesDevice",
                "desc": "Reset all overclock settings to default values (shipped = 1 or manufacturing =0)",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "7318489a5a2134bc3f0789ac6ae8a5f1712f4d71314cbb846d6d0260eae1b474",
                "name": "ResetOverclockSettings",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in] True will reset to shipped state; false will reset to manufacturing state",
                        "name": "onShippedState",
                        "type": "ze_bool_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this control domain"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "Resume": {
                "class": "zetDebug",
                "desc": "Resume device threads.",
                "hash": "55072197ef54909f2ff6ecbf176fccb95dbad2a2266b806d585e46715fb65173",
                "name": "Resume",
                "params": [
                    {
                        "desc": "[in] debug session handle",
                        "name": "hDebug",
                        "type": "zet_debug_session_handle_t"
                    },
                    {
                        "desc": "[in] the thread to resume",
                        "name": "thread",
                        "type": "ze_device_thread_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDebug`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "the thread is already running or unavailable"
                        ]
                    }
                ],
                "type": "function"
            },
            "RunTests": {
                "class": "zesDiagnostics",
                "desc": "Run a diagnostics test suite, either all tests or a subset of tests.",
                "details": [
                    "WARNING: Running diagnostics may destroy current device state information. Gracefully close any running workloads before initiating.",
                    "To run all tests in a test suite, set start = ZES_DIAG_FIRST_TEST_INDEX and end = ZES_DIAG_LAST_TEST_INDEX.",
                    "If the test suite permits running individual tests, the `haveTests` member of zes_diag_properties_t will be true. In this case, the function zesDiagnosticsGetTests() can be called to get the list of tests and corresponding indices that can be supplied to the arguments start and end in this function.",
                    "This function will block until the diagnostics have completed and force reset based on result"
                ],
                "hash": "349d2006c7ca8ec132f2c6eb5efdabdcbb4c439f9905517fd0fb216f63671c28",
                "name": "RunTests",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hDiagnostics",
                        "type": "zes_diag_handle_t"
                    },
                    {
                        "desc": "[in] The index of the first test to run. Set to ZES_DIAG_FIRST_TEST_INDEX to start from the beginning.",
                        "name": "startIndex",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The index of the last test to run. Set to ZES_DIAG_LAST_TEST_INDEX to complete all tests after the start test.",
                        "name": "endIndex",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out] The result of the diagnostics",
                        "name": "pResult",
                        "type": "zes_diag_result_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDiagnostics`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pResult`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to perform diagnostics."
                        ]
                    }
                ],
                "type": "function"
            },
            "SchedulingHintExp": {
                "class": "zeKernel",
                "desc": "Provide kernel scheduling hints that may improve performance",
                "details": [
                    "The scheduling hints may improve performance only and are not required for correctness.",
                    "If a specified scheduling hint is unsupported it will be silently ignored.",
                    "If two conflicting scheduling hints are specified there is no defined behavior;\nthe hints may be ignored or one hint may be chosen arbitrarily.\n",
                    "The application must not call this function from simultaneous threads with the same kernel handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "110b8a3075cc45ff59fe652e291c497f8b213359b3a8ede04e6b64701f778c93",
                "name": "SchedulingHintExp",
                "params": [
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[in] pointer to kernel scheduling hint descriptor",
                        "name": "pHint",
                        "type": "ze_scheduling_hint_exp_desc_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pHint`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x7 < pHint->flags`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.2"
            },
            "SetAccessAttribute": {
                "class": "zeVirtualMem",
                "decl": "static",
                "desc": "Set memory access attributes for a virtual address range.",
                "details": [
                    "This function may be called from simultaneous threads with the same function handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "db21a82c9040758010176726f744e6cbe096eadc04091fd2d5a56da599954fca",
                "name": "SetAccessAttribute",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] pointer to start of reserved virtual address region.",
                        "name": "ptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] size in bytes; must be page aligned.",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] specifies page access attributes to apply to the virtual address range.",
                        "name": "access",
                        "type": "ze_memory_access_attribute_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZE_MEMORY_ACCESS_ATTRIBUTE_READONLY < access`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": [
                            "Address must be page aligned"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_SIZE": [
                            "`0 == size`",
                            "Size must be page aligned"
                        ]
                    }
                ],
                "type": "function"
            },
            "SetArgumentValue": {
                "class": "zeKernel",
                "desc": "Set kernel argument for a kernel.",
                "details": [
                    "The argument values will be used when a zeCommandListAppendLaunchKernel variant is called.",
                    "The application must **not** call this function from simultaneous threads with the same kernel handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "0b8a841d505ec3d9908a00d179af05f65deb76b9d366b1aeb087f885106e55dc",
                "name": "SetArgumentValue",
                "params": [
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[in] argument index in range [0, num args - 1]",
                        "name": "argIndex",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] size of argument type",
                        "name": "argSize",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in][optional] argument value represented as matching arg type. If null then argument value is considered null.",
                        "name": "pArgValue",
                        "type": "const void*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE": []
                    }
                ],
                "type": "function"
            },
            "SetAtomicAccessAttributeExp": {
                "class": "zeMem",
                "desc": "Sets atomic access attributes for a shared allocation",
                "details": [
                    "If the shared-allocation is owned by multiple devices (i.e. nullptr\nwas passed to zeMemAllocShared when creating it), then hDevice may be\npassed to set the attributes in that specific device. If nullptr is\npassed in hDevice, then the atomic attributes are set in all devices\nassociated with the allocation.\n",
                    "If the atomic access attribute select is not supported by the driver,\nZE_RESULT_INVALID_ARGUMENT is returned.\n",
                    "The atomic access attribute may be only supported at a device-specific\ngranularity, such as at a page boundary. In this case, the memory range\nmay be expanded such that the start and end of the range satisfy granularity\nrequirements.\n",
                    "When calling this function multiple times with different flags, only the\nattributes from last call are honored.\n",
                    "The application must not call this function for shared-allocations currently\nbeing used by the device.\n",
                    "The application must **not** call this function from simultaneous threads\nwith the same pointer.\n",
                    "The implementation of this function should be lock-free.\n"
                ],
                "hash": "741bf3ff2078c00b3af694e94f4efb8488e24ba16934c94b28d614daef51a2c7",
                "name": "SetAtomicAccessAttributeExp",
                "params": [
                    {
                        "desc": "[in] handle of context",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] device associated with the memory advice",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] Pointer to the start of the memory range",
                        "name": "ptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] Size in bytes of the memory range",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] Atomic access attributes to set for the specified range.\nMust be 0 (default) or a valid combination of ze_memory_atomic_attr_exp_flag_t.\n",
                        "name": "attr",
                        "type": "ze_memory_atomic_attr_exp_flags_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x7f < attr`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.7"
            },
            "SetCacheAdviceExt": {
                "class": "zeDevice",
                "decl": "static",
                "desc": "Assign VA section to use reserved section",
                "details": [
                    "The application may call this function to assign VA to particular reservartion region"
                ],
                "hash": "c076c37bb4879633219acc29a0bda1fe2d289b5da21655ae9da5d8a21b0e00e0",
                "name": "SetCacheAdviceExt",
                "params": [
                    {
                        "desc": "[in] handle of the device object",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] memory pointer to query",
                        "name": "ptr",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] region size, in pages",
                        "name": "regionSize",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] reservation region",
                        "name": "cacheRegion",
                        "type": "ze_cache_ext_region_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZE_CACHE_EXT_REGION_NON_RESERVED < cacheRegion`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.2"
            },
            "SetCacheConfig": {
                "class": "zeKernel",
                "desc": "Sets the preferred cache configuration.",
                "details": [
                    "The cache configuration will be used when a zeCommandListAppendLaunchKernel variant is called.",
                    "The application must **not** call this function from simultaneous threads with the same kernel handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "a298b03ab502760766b10871da1128b64b08c721c71553ec0b42aba86b5b1859",
                "name": "SetCacheConfig",
                "ordinal": "2",
                "params": [
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[in] cache configuration.\nmust be 0 (default configuration) or a valid combination of ze_cache_config_flag_t.\n",
                        "name": "flags",
                        "type": "ze_cache_config_flags_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x3 < flags`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": []
                    }
                ],
                "type": "function"
            },
            "SetColor": {
                "class": "zesLed",
                "desc": "Set the color of the LED",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "311a39222a3cb1343b3a126fb769defe80f38e4f6c2b3fe6bd438a3bad613a8e",
                "name": "SetColor",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hLed",
                        "type": "zes_led_handle_t"
                    },
                    {
                        "desc": "[in] New color of the LED.",
                        "name": "pColor",
                        "type": "const zes_led_color_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hLed`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pColor`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "This LED doesn't not support color changes. See the `haveRGB` member of zes_led_properties_t."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetComputeUnitDebugMode": {
                "class": "zesScheduler",
                "desc": "Change scheduler mode to ZES_SCHED_MODE_COMPUTE_UNIT_DEBUG",
                "details": [
                    "This is a special mode that must ben enabled when debugging an application that uses this device e.g. using the Level0 Debug API.",
                    "It ensures that only one command queue can execute work on the hardware at a given time. Work is permitted to run as long as needed without enforcing any scheduler fairness policies.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "20f2f46d786180d013bcdd048e18fa11689f100439628591f3d4d26a33d3d071",
                "name": "SetComputeUnitDebugMode",
                "params": [
                    {
                        "desc": "[in] Sysman handle for the component.",
                        "name": "hScheduler",
                        "type": "zes_sched_handle_t"
                    },
                    {
                        "desc": "[in,out] Will be set to TRUE if a device driver reload is needed to apply the new scheduler mode.",
                        "name": "pNeedReload",
                        "type": "ze_bool_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hScheduler`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pNeedReload`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "This scheduler component does not support scheduler modes."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make this modification."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetConfig": {
                "class": "zesTemperature",
                "desc": "Set temperature configuration for this sensor - indicates which events are triggered and the trigger conditions",
                "details": [
                    "Events ZES_EVENT_TYPE_FLAG_TEMP_CRITICAL will be triggered when temperature reaches the critical range. Use the function zesDeviceEventRegister() to start receiving this event.",
                    "Events ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD1 and ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD2 will be generated when temperature cross the thresholds set using this function. Use the function zesDeviceEventRegister() to start receiving these events.",
                    "Only one running process can set the temperature configuration at a time. If another process attempts to change the configuration, the error ZE_RESULT_ERROR_NOT_AVAILABLE will be returned. The function zesTemperatureGetConfig() will return the process ID currently controlling these settings.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "e7c1c15a3b996c73398851cf8822ce99c876e9b834540276ccf63243785b7e69",
                "name": "SetConfig",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hTemperature",
                        "type": "zes_temp_handle_t"
                    },
                    {
                        "desc": "[in] New configuration.",
                        "name": "pConfig",
                        "type": "const zes_temp_config_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hTemperature`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pConfig`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Temperature thresholds are not supported on this temperature sensor. Generally they are only supported for temperature sensor ZES_TEMP_SENSORS_GLOBAL.",
                            "Enabling the critical temperature event is not supported. Check the `isCriticalTempSupported` member of zes_temp_properties_t.",
                            "One or both of the thresholds is not supported. Check the `isThreshold1Supported` and `isThreshold2Supported` members of zes_temp_properties_t."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to request this feature."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "Another running process is controlling these settings."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ARGUMENT": [
                            "One or both the thresholds is above TjMax (see zesFrequencyOcGetTjMax()). Temperature thresholds must be below this value."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetControlUserValue": {
                "class": "zesOverclock",
                "desc": "Set the value for a given overclock control",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "dfbb3911b91acb313aa7d4bb72ebd08d0183a56b5663f5f44ea114b83270ac10",
                "name": "SetControlUserValue",
                "params": [
                    {
                        "desc": "[in] Handle for the component domain.",
                        "name": "hDomainHandle",
                        "type": "zes_overclock_handle_t"
                    },
                    {
                        "desc": "[in] Domain Control.",
                        "name": "DomainControl",
                        "type": "zes_overclock_control_t"
                    },
                    {
                        "desc": "[in] The new value of the control. The units and format of the value depend on the control type.",
                        "name": "pValue",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Pending overclock setting.",
                        "name": "pPendingAction",
                        "type": "zes_pending_action_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDomainHandle`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZES_OVERCLOCK_CONTROL_ACM_DISABLE < DomainControl`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pPendingAction`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this control domain"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "SetDefaultMode": {
                "class": "zesFan",
                "desc": "Configure the fan to run with hardware factory settings (set mode to ZES_FAN_SPEED_MODE_DEFAULT)",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "3f32c8b4c13c29cd9a801fb9abdb42c1b1e96c76465506d70a3c9b0a234997c5",
                "name": "SetDefaultMode",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFan",
                        "type": "zes_fan_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFan`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetEccState": {
                "class": "zesDevice",
                "desc": "Set new ECC state",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free.",
                    "zesDeviceGetState should be called to determine pending action required to implement state change."
                ],
                "hash": "5170246117a72b8ffc924046f9ebe857e8e0da6f5e41829c7029a7d8eb4b280e",
                "name": "SetEccState",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    },
                    {
                        "desc": "[in] Pointer to desired ECC state.",
                        "name": "newState",
                        "type": "const zes_device_ecc_desc_t*"
                    },
                    {
                        "desc": "[out] ECC state, pending state, and pending action for state change.",
                        "name": "pState",
                        "type": "zes_device_ecc_properties_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == newState`",
                            "`nullptr == pState`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZES_DEVICE_ECC_STATE_DISABLED < newState->state`"
                        ]
                    },
                    {
                        "ZE_RESULT_WARNING_ACTION_REQUIRED": [
                            "User must look at the pendingAction attribute of pState & perform the action required to complete the ECC state change."
                        ]
                    }
                ],
                "type": "function",
                "version": "1.4"
            },
            "SetEnabled": {
                "class": "zetTracerExp",
                "desc": "Enables (or disables) the tracer",
                "details": [
                    "The application must **not** call this function from simultaneous threads with the same tracer handle."
                ],
                "hash": "60691e67f575e8b84d93b29f94642fafd9b9a302bc05b5f0d45340e335804de9",
                "name": "SetEnabled",
                "params": [
                    {
                        "desc": "[in] handle of the tracer",
                        "name": "hTracer",
                        "type": "zet_tracer_exp_handle_t"
                    },
                    {
                        "desc": "[in] enable the tracer if true; disable if false",
                        "name": "enable",
                        "type": "ze_bool_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hTracer`"
                        ]
                    }
                ],
                "type": "function"
            },
            "SetEnergyThreshold": {
                "class": "zesPower",
                "desc": "Set energy threshold",
                "details": [
                    "An event ZES_EVENT_TYPE_FLAG_ENERGY_THRESHOLD_CROSSED will be generated when the delta energy consumed starting from this call exceeds the specified threshold. Use the function zesDeviceEventRegister() to start receiving the event.",
                    "Only one running process can control the energy threshold at a given time. If another process attempts to change the energy threshold, the error ZE_RESULT_ERROR_NOT_AVAILABLE will be returned. The function zesPowerGetEnergyThreshold() to determine the process ID currently controlling this setting.",
                    "Calling this function will remove any pending energy thresholds and start counting from the time of this call.",
                    "Once the energy threshold has been reached and the event generated, the threshold is automatically removed. It is up to the application to request a new threshold.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "ef52d53f78f5e95a24faf530e9ee0bb353cff7d607cec5a27376f4dd4ebf2255",
                "name": "SetEnergyThreshold",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hPower",
                        "type": "zes_pwr_handle_t"
                    },
                    {
                        "desc": "[in] The energy threshold to be set in joules.",
                        "name": "threshold",
                        "type": "double"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hPower`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Energy threshold not supported on this power domain (check the `isEnergyThresholdSupported` member of zes_power_properties_t)."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to request this feature."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "Another running process has set the energy threshold."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetEpilogues": {
                "class": "zetTracerExp",
                "desc": "Sets the collection of callbacks to be executed **after** driver execution.",
                "details": [
                    "The application only needs to set the function pointers it is interested in receiving; all others should be 'nullptr'",
                    "The application must ensure that no other threads are executing functions for which the tracing functions are changing.",
                    "The application must **not** call this function from simultaneous threads with the same tracer handle."
                ],
                "hash": "fe64ecc4c3782cee737bb511673becc83b0a86f22604887853b751fe9ce897df",
                "name": "SetEpilogues",
                "params": [
                    {
                        "desc": "[in] handle of the tracer",
                        "name": "hTracer",
                        "type": "zet_tracer_exp_handle_t"
                    },
                    {
                        "desc": "[in] pointer to table of 'core' callback function pointers",
                        "name": "pCoreCbs",
                        "type": "zet_core_callbacks_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hTracer`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCoreCbs`"
                        ]
                    }
                ],
                "type": "function"
            },
            "SetExclusiveMode": {
                "class": "zesScheduler",
                "desc": "Change scheduler mode to ZES_SCHED_MODE_EXCLUSIVE",
                "details": [
                    "This mode is optimized for single application/context use-cases. It permits a context to run indefinitely on the hardware without being preempted or terminated. All pending work for other contexts must wait until the running context completes with no further submitted work.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "b3ddcb66d6d358c372478f16c47c422e9b18e2acbd01923f385fd58f394c8a76",
                "name": "SetExclusiveMode",
                "params": [
                    {
                        "desc": "[in] Sysman handle for the component.",
                        "name": "hScheduler",
                        "type": "zes_sched_handle_t"
                    },
                    {
                        "desc": "[in,out] Will be set to TRUE if a device driver reload is needed to apply the new scheduler mode.",
                        "name": "pNeedReload",
                        "type": "ze_bool_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hScheduler`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pNeedReload`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "This scheduler component does not support scheduler modes."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make this modification."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetFixedSpeedMode": {
                "class": "zesFan",
                "desc": "Configure the fan to rotate at a fixed speed (set mode to ZES_FAN_SPEED_MODE_FIXED)",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "398f43a1f432602ccfac89afb43dfcb063e4d3b17e473a0e486fcfed9bae3945",
                "name": "SetFixedSpeedMode",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFan",
                        "type": "zes_fan_handle_t"
                    },
                    {
                        "desc": "[in] The fixed fan speed setting",
                        "name": "speed",
                        "type": "const zes_fan_speed_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFan`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == speed`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Fixing the fan speed not supported by the hardware or the fan speed units are not supported. See the `supportedModes` and `supportedUnits` members of zes_fan_properties_t."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetGlobalOffsetExp": {
                "class": "zeKernel",
                "desc": "Set global work offset for a kernel.",
                "details": [
                    "The global work offset will be used when a zeCommandListAppendLaunchKernel() variant is called.",
                    "The application must **not** call this function from simultaneous threads with the same kernel handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "fa00f796d961e703ea19fdcf427500db930f497ba9902bd6df6371187c8cf785",
                "name": "SetGlobalOffsetExp",
                "params": [
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[in] global offset for X dimension to use for this kernel",
                        "name": "offsetX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] global offset for Y dimension to use for this kernel",
                        "name": "offsetY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] global offset for Z dimension to use for this kernel",
                        "name": "offsetZ",
                        "type": "uint32_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hKernel`"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.1"
            },
            "SetGroupSize": {
                "class": "zeKernel",
                "desc": "Set group size for a kernel.",
                "details": [
                    "The group size will be used when a zeCommandListAppendLaunchKernel variant is called.",
                    "The application must **not** call this function from simultaneous threads with the same kernel handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "794a9f8c8ae2f9f273a023823511de300ddc95d22eca649281b91efe28fccf74",
                "name": "SetGroupSize",
                "params": [
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[in] group size for X dimension to use for this kernel",
                        "name": "groupSizeX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] group size for Y dimension to use for this kernel",
                        "name": "groupSizeY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] group size for Z dimension to use for this kernel",
                        "name": "groupSizeZ",
                        "type": "uint32_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION": []
                    }
                ],
                "type": "function"
            },
            "SetIndirectAccess": {
                "class": "zeKernel",
                "desc": "Sets kernel indirect access flags.",
                "details": [
                    "The application should specify which allocations will be indirectly accessed by the kernel to allow driver to optimize which allocations are made resident",
                    "This function may **not** be called from simultaneous threads with the same Kernel handle.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "3fa02e042af4c1e07f7d75e582ef89ee505f9c6c5d60aecd76a42ad941087eae",
                "name": "SetIndirectAccess",
                "params": [
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[in] kernel indirect access flags",
                        "name": "flags",
                        "type": "ze_kernel_indirect_access_flags_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x7 < flags`"
                        ]
                    }
                ],
                "type": "function"
            },
            "SetLimits": {
                "class": "zesPower",
                "desc": "Set power limits",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free.",
                    "Note: This function is deprecated and replaced by zesPowerSetLimitsExt."
                ],
                "hash": "adfce6f8e5ca88571ca8d3c876751c1de2ba0acca3d52639c128be64a18c4550",
                "name": "SetLimits",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hPower",
                        "type": "zes_pwr_handle_t"
                    },
                    {
                        "desc": "[in][optional] The sustained power limit. If this is null, no changes will be made to the sustained power limits.",
                        "name": "pSustained",
                        "type": "const zes_power_sustained_limit_t*"
                    },
                    {
                        "desc": "[in][optional] The burst power limit. If this is null, no changes will be made to the burst power limits.",
                        "name": "pBurst",
                        "type": "const zes_power_burst_limit_t*"
                    },
                    {
                        "desc": "[in][optional] The peak power limit. If this is null, no changes will be made to the peak power limits.",
                        "name": "pPeak",
                        "type": "const zes_power_peak_limit_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hPower`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "The device is in use, meaning that the GPU is under Over clocking, applying power limits under overclocking is not supported."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetLimitsExt": {
                "class": "zesPower",
                "desc": "Set power limits",
                "details": [
                    "The application can only modify unlocked members of the limit descriptors returned by zesPowerGetLimitsExt.",
                    "Not all the limits returned by zesPowerGetLimitsExt need to be supplied to this function.",
                    "Limits do not have to be supplied in the same order as returned by zesPowerGetLimitsExt.",
                    "The same limit can be supplied multiple times. Limits are applied in the order in which they are supplied.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "c3fd274f580f2e3476b92eaf271f4bb46b76ab91842dd1c8af90981870e5098c",
                "name": "SetLimitsExt",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hPower",
                        "type": "zes_pwr_handle_t"
                    },
                    {
                        "desc": "[in] Pointer to the number of power limit descriptors.",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in][optional][range(0, *pCount)] Array of power limit descriptors.",
                        "name": "pSustained",
                        "type": "zes_power_limit_ext_desc_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hPower`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCount`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "The device is in use, meaning that the GPU is under Over clocking, applying power limits under overclocking is not supported."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetMode": {
                "class": "zesStandby",
                "desc": "Set standby promotion mode",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "c7ed048761bf7be69e42f0cd80d79177b513cc831bce3fbffb9774c9da950e43",
                "name": "SetMode",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hStandby",
                        "type": "zes_standby_handle_t"
                    },
                    {
                        "desc": "[in] New standby mode.",
                        "name": "mode",
                        "type": "zes_standby_promo_mode_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hStandby`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZES_STANDBY_PROMO_MODE_NEVER < mode`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetOverclockWaiver": {
                "class": "zesDevice",
                "desc": "Set the overclock waiver.The overclock waiver setting is persistent until the next pcode boot",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "55c493e98932c5d36afcb11a3c43d6ac222932f5e4d8f125bcc5106787e4a320",
                "name": "SetOverclockWaiver",
                "params": [
                    {
                        "desc": "[in] Sysman handle of the device.",
                        "name": "hDevice",
                        "type": "zes_device_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDevice`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "This product does not support overclocking"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "SetPrologues": {
                "class": "zetTracerExp",
                "desc": "Sets the collection of callbacks to be executed **before** driver execution.",
                "details": [
                    "The application only needs to set the function pointers it is interested in receiving; all others should be 'nullptr'",
                    "The application must ensure that no other threads are executing functions for which the tracing functions are changing.",
                    "The application must **not** call this function from simultaneous threads with the same tracer handle."
                ],
                "hash": "3757c0ce726200f3b8edc93579a5460a058c240b7c52a06ff74e4756ebfc3eb0",
                "name": "SetPrologues",
                "params": [
                    {
                        "desc": "[in] handle of the tracer",
                        "name": "hTracer",
                        "type": "zet_tracer_exp_handle_t"
                    },
                    {
                        "desc": "[in] pointer to table of 'core' callback function pointers",
                        "name": "pCoreCbs",
                        "type": "zet_core_callbacks_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hTracer`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pCoreCbs`"
                        ]
                    }
                ],
                "type": "function"
            },
            "SetRange": {
                "class": "zesFrequency",
                "desc": "Set frequency range between which the hardware can operate.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "e510f70acdcb9a652fda8f2d444a9c7d0c4fcd724de88d78b34d1ef7c4248a2d",
                "name": "SetRange",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFrequency",
                        "type": "zes_freq_handle_t"
                    },
                    {
                        "desc": "[in] The limits between which the hardware can operate for the specified domain.",
                        "name": "pLimits",
                        "type": "const zes_freq_range_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFrequency`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pLimits`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetSpeedTableMode": {
                "class": "zesFan",
                "desc": "Configure the fan to adjust speed based on a temperature/speed table (set mode to ZES_FAN_SPEED_MODE_TABLE)",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "4a3133b6a3f27db154819ab2a6b881355cad632a0ef1c30235d89948bf2273c8",
                "name": "SetSpeedTableMode",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hFan",
                        "type": "zes_fan_handle_t"
                    },
                    {
                        "desc": "[in] A table containing temperature/speed pairs.",
                        "name": "speedTable",
                        "type": "const zes_fan_speed_table_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hFan`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == speedTable`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ARGUMENT": [
                            "The temperature/speed pairs in the array are not sorted on temperature from lowest to highest."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Fan speed table not supported by the hardware or the fan speed units are not supported. See the `supportedModes` and `supportedUnits` members of zes_fan_properties_t."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetState": {
                "class": "zesLed",
                "desc": "Turn the LED on/off",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "a227391f6b01ac4e31857dbfd585f48e43d9382186521f55039c197a6b6eb54e",
                "name": "SetState",
                "params": [
                    {
                        "desc": "[in] Handle for the component.",
                        "name": "hLed",
                        "type": "zes_led_handle_t"
                    },
                    {
                        "desc": "[in] Set to TRUE to turn the LED on, FALSE to turn off.",
                        "name": "enable",
                        "type": "ze_bool_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hLed`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make these modifications."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetTimeoutMode": {
                "class": "zesScheduler",
                "desc": "Change scheduler mode to ZES_SCHED_MODE_TIMEOUT or update scheduler mode parameters if already running in this mode.",
                "details": [
                    "This mode is optimized for multiple applications or contexts submitting work to the hardware. When higher priority work arrives, the scheduler attempts to pause the current executing work within some timeout interval, then submits the other work.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "3f9453cd11aa3272d37a2631c25d45a0f71a9ae27f29994148f76170753de50c",
                "name": "SetTimeoutMode",
                "params": [
                    {
                        "desc": "[in] Sysman handle for the component.",
                        "name": "hScheduler",
                        "type": "zes_sched_handle_t"
                    },
                    {
                        "desc": "[in] The properties to use when configurating this mode.",
                        "name": "pProperties",
                        "type": "zes_sched_timeout_properties_t*"
                    },
                    {
                        "desc": "[in,out] Will be set to TRUE if a device driver reload is needed to apply the new scheduler mode.",
                        "name": "pNeedReload",
                        "type": "ze_bool_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hScheduler`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pProperties`",
                            "`nullptr == pNeedReload`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "This scheduler component does not support scheduler modes."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make this modification."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetTimesliceMode": {
                "class": "zesScheduler",
                "desc": "Change scheduler mode to ZES_SCHED_MODE_TIMESLICE or update scheduler mode parameters if already running in this mode.",
                "details": [
                    "This mode is optimized to provide fair sharing of hardware execution time between multiple contexts submitting work to the hardware concurrently.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "11dedcf5e86b6e8f766178a724293a56c52026ebe98f4de0a7501aaf3d6246c0",
                "name": "SetTimesliceMode",
                "params": [
                    {
                        "desc": "[in] Sysman handle for the component.",
                        "name": "hScheduler",
                        "type": "zes_sched_handle_t"
                    },
                    {
                        "desc": "[in] The properties to use when configurating this mode.",
                        "name": "pProperties",
                        "type": "zes_sched_timeslice_properties_t*"
                    },
                    {
                        "desc": "[in,out] Will be set to TRUE if a device driver reload is needed to apply the new scheduler mode.",
                        "name": "pNeedReload",
                        "type": "ze_bool_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hScheduler`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == pProperties`",
                            "`nullptr == pNeedReload`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "This scheduler component does not support scheduler modes."
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                            "User does not have permissions to make this modification."
                        ]
                    }
                ],
                "type": "function"
            },
            "SetVFPointValues": {
                "class": "zesOverclock",
                "desc": "Write the frequency or voltage of a V-F point to custom V-F curve.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "8bb361cef11696f36f541cac2d919f200cf453261bc940ec647786681f425e9c",
                "name": "SetVFPointValues",
                "params": [
                    {
                        "desc": "[in] Handle for the component domain.",
                        "name": "hDomainHandle",
                        "type": "zes_overclock_handle_t"
                    },
                    {
                        "desc": "[in] Voltage or Freqency point to read.",
                        "name": "VFType",
                        "type": "zes_vf_type_t"
                    },
                    {
                        "desc": "[in] Point index - number between (0, max_num_points - 1).",
                        "name": "PointIndex",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] Writes frequency in 1kHz units or voltage in millivolt units to custom V-F curve at the specified zero-based index ",
                        "name": "PointValue",
                        "type": "uint32_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDomainHandle`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZES_VF_TYPE_FREQ < VFType`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                            "Overclocking is not supported on this control domain"
                        ]
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "SuggestGroupSize": {
                "class": "zeKernel",
                "desc": "Query a suggested group size for a kernel given a global size for each dimension.",
                "details": [
                    "This function ignores the group size that is set using zeKernelSetGroupSize.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "3ddaa55cddcdc68068314af08f3053ce0c6ce9bbb37edf06da21812e5a669b77",
                "name": "SuggestGroupSize",
                "params": [
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[in] global width for X dimension",
                        "name": "globalSizeX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] global width for Y dimension",
                        "name": "globalSizeY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] global width for Z dimension",
                        "name": "globalSizeZ",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] recommended size of group for X dimension",
                        "name": "groupSizeX",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[out] recommended size of group for Y dimension",
                        "name": "groupSizeY",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[out] recommended size of group for Z dimension",
                        "name": "groupSizeZ",
                        "type": "uint32_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == groupSizeX`",
                            "`nullptr == groupSizeY`",
                            "`nullptr == groupSizeZ`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION": []
                    }
                ],
                "type": "function"
            },
            "SuggestMaxCooperativeGroupCount": {
                "class": "zeKernel",
                "desc": "Query a suggested max group count for a cooperative kernel.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "35146bbbfe48d099b66c9436975ff150cb0aeeb0f86e25226681b3e3676fb233",
                "name": "SuggestMaxCooperativeGroupCount",
                "params": [
                    {
                        "desc": "[in] handle of the kernel object",
                        "name": "hKernel",
                        "type": "ze_kernel_handle_t"
                    },
                    {
                        "desc": "[out] recommended total group count.",
                        "name": "totalGroupCount",
                        "type": "uint32_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hKernel`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == totalGroupCount`"
                        ]
                    }
                ],
                "type": "function"
            },
            "Synchronize": {
                "class": "zeCommandQueue",
                "desc": "Synchronizes a command queue by waiting on the host.",
                "details": [
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "7f909e35eca980d6b02b05a87d35661018470382d0016a1ca2a41a47e879116c",
                "name": "Synchronize",
                "ordinal": "1",
                "params": [
                    {
                        "desc": "[in] handle of the command queue",
                        "name": "hCommandQueue",
                        "type": "ze_command_queue_handle_t"
                    },
                    {
                        "desc": "[in] if non-zero, then indicates the maximum time (in nanoseconds) to yield before returning ZE_RESULT_SUCCESS or ZE_RESULT_NOT_READY;\nif zero, then immediately returns the status of the command queue;\nif `UINT64_MAX`, then function will not return until complete or device is lost.\nDue to external dependencies, timeout may be rounded to the closest value allowed by the accuracy of those dependencies.\n",
                        "name": "timeout",
                        "type": "uint64_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hCommandQueue`"
                        ]
                    },
                    {
                        "ZE_RESULT_NOT_READY": [
                            "timeout expired"
                        ]
                    }
                ],
                "type": "function"
            },
            "SystemBarrier": {
                "class": "zeContext",
                "desc": "Ensures in-bound writes to the device are globally observable.",
                "details": [
                    "This is a special-case system level barrier that can be used to ensure global observability of writes; \ntypically needed after a producer (e.g., NIC) performs direct writes to the device's memory (e.g., Direct RDMA writes).\nThis is typically required when the memory corresponding to the writes is subsequently accessed from a remote device.\n",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function should be lock-free."
                ],
                "hash": "704009b09d19e5a30335258a0ad70ee6527d0d08e5c7dee4a0b17e6849931bc6",
                "name": "SystemBarrier",
                "params": [
                    {
                        "desc": "[in] handle of context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`"
                        ]
                    }
                ],
                "type": "function"
            },
            "Unmap": {
                "class": "zeVirtualMem",
                "decl": "static",
                "desc": "Unmaps pages in virtual address space from pages from a physical memory object.",
                "details": [
                    "The page access attributes for virtual address range will revert back to none.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe."
                ],
                "hash": "742bd0bf1e65a4ea16e347ffad8506f2d55b406c4892fe841499d04124a7b60e",
                "name": "Unmap",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] pointer to start of region to unmap.",
                        "name": "ptr",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] size in bytes to unmap; must be page aligned.",
                        "name": "size",
                        "type": "size_t"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == ptr`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": [
                            "Address must be page aligned"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_SIZE": [
                            "`0 == size`",
                            "Size must be page aligned"
                        ]
                    }
                ],
                "type": "function"
            },
            "ViewCreateExp": {
                "analogue": [
                    "None"
                ],
                "class": "zeImage",
                "decl": "static",
                "desc": "Create image view on the context.",
                "details": [
                    "The application must only use the image view for the device, or its sub-devices, which was provided during creation.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe.",
                    "The implementation must support ZE_experimental_image_view extension.",
                    "Image views are treated as images from the API.",
                    "Image views provide a mechanism to redescribe how an image is interpreted (e.g. different format).",
                    "Image views become disabled when their corresponding image resource is destroyed.",
                    "Use zeImageDestroy to destroy image view objects.",
                    "Note: This function is deprecated and replaced by zeImageViewCreateExt."
                ],
                "hash": "5fa8627a9e4828cd94d2b51124c3c538f44a677552dd0358bf7d53a84b0c25ac",
                "name": "ViewCreateExp",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] pointer to image descriptor",
                        "name": "desc",
                        "type": "const ze_image_desc_t*"
                    },
                    {
                        "desc": "[in] handle of image object to create view from",
                        "name": "hImage",
                        "type": "ze_image_handle_t"
                    },
                    {
                        "desc": "[out] pointer to handle of image object created for view",
                        "name": "phImageView",
                        "type": "ze_image_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`",
                            "`nullptr == hImage`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == desc`",
                            "`nullptr == phImageView`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x3 < desc->flags`",
                            "`ZE_IMAGE_TYPE_BUFFER < desc->type`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT": []
                    }
                ],
                "type": "function",
                "version": "1.2"
            },
            "ViewCreateExt": {
                "analogue": [
                    "None"
                ],
                "class": "zeImage",
                "decl": "static",
                "desc": "Create image view on the context.",
                "details": [
                    "The application must only use the image view for the device, or its sub-devices, which was provided during creation.",
                    "The application may call this function from simultaneous threads.",
                    "The implementation of this function must be thread-safe.",
                    "The implementation must support ZE_extension_image_view extension.",
                    "Image views are treated as images from the API.",
                    "Image views provide a mechanism to redescribe how an image is interpreted (e.g. different format).",
                    "Image views become disabled when their corresponding image resource is destroyed.",
                    "Use zeImageDestroy to destroy image view objects."
                ],
                "hash": "32d72203dc99f10d2d5a31ec2905a7b10ca523c1c0cd07a2cd5ea03ef489ec35",
                "name": "ViewCreateExt",
                "ordinal": "0",
                "params": [
                    {
                        "desc": "[in] handle of the context object",
                        "name": "hContext",
                        "type": "ze_context_handle_t"
                    },
                    {
                        "desc": "[in] handle of the device",
                        "name": "hDevice",
                        "type": "ze_device_handle_t"
                    },
                    {
                        "desc": "[in] pointer to image descriptor",
                        "name": "desc",
                        "type": "const ze_image_desc_t*"
                    },
                    {
                        "desc": "[in] handle of image object to create view from",
                        "name": "hImage",
                        "type": "ze_image_handle_t"
                    },
                    {
                        "desc": "[out] pointer to handle of image object created for view",
                        "name": "phImageView",
                        "type": "ze_image_handle_t*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hContext`",
                            "`nullptr == hDevice`",
                            "`nullptr == hImage`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == desc`",
                            "`nullptr == phImageView`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`0x3 < desc->flags`",
                            "`ZE_IMAGE_TYPE_BUFFER < desc->type`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT": []
                    }
                ],
                "type": "function",
                "version": "1.5"
            },
            "WriteMemory": {
                "class": "zetDebug",
                "desc": "Write memory.",
                "details": [
                    "The thread identifier 'all' can be used for accessing the default memory space, e.g. for setting breakpoints."
                ],
                "hash": "9f56cdf99c4ac640421569f841d86c1e915a0929508bb7afe8a44b4a221a93a1",
                "name": "WriteMemory",
                "params": [
                    {
                        "desc": "[in] debug session handle",
                        "name": "hDebug",
                        "type": "zet_debug_session_handle_t"
                    },
                    {
                        "desc": "[in] the thread identifier.",
                        "name": "thread",
                        "type": "ze_device_thread_t"
                    },
                    {
                        "desc": "[in] memory space descriptor",
                        "name": "desc",
                        "type": "const zet_debug_memory_space_desc_t*"
                    },
                    {
                        "desc": "[in] the number of bytes to write",
                        "name": "size",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] a buffer holding the pattern to write",
                        "name": "buffer",
                        "type": "const void*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDebug`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_POINTER": [
                            "`nullptr == desc`",
                            "`nullptr == buffer`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_ENUMERATION": [
                            "`ZET_DEBUG_MEMORY_SPACE_TYPE_SLM < desc->type`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "the thread is running or unavailable",
                            "the memory cannot be accessed from the supplied thread"
                        ]
                    }
                ],
                "type": "function"
            },
            "WriteRegisters": {
                "class": "zetDebug",
                "desc": "Write register state.",
                "hash": "a7e5e8a068e13a51cbe0643ad035cb7b9c043f5a050593e66978ede75b49023c",
                "name": "WriteRegisters",
                "params": [
                    {
                        "desc": "[in] debug session handle",
                        "name": "hDebug",
                        "type": "zet_debug_session_handle_t"
                    },
                    {
                        "desc": "[in] the thread identifier",
                        "name": "thread",
                        "type": "ze_device_thread_t"
                    },
                    {
                        "desc": "[in] register set type",
                        "name": "type",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] the starting offset into the register state area; must be less than the `count` member of zet_debug_regset_properties_t for the type",
                        "name": "start",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] the number of registers to write; start+count must be less than or equal to the `count` member of zet_debug_register_group_properties_t for the type",
                        "name": "count",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out][optional][range(0, count)] buffer of register values",
                        "name": "pRegisterValues",
                        "type": "void*"
                    }
                ],
                "returns": [
                    {
                        "ZE_RESULT_SUCCESS": []
                    },
                    {
                        "ZE_RESULT_ERROR_UNINITIALIZED": []
                    },
                    {
                        "ZE_RESULT_ERROR_DEVICE_LOST": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                    },
                    {
                        "ZE_RESULT_ERROR_INVALID_NULL_HANDLE": [
                            "`nullptr == hDebug`"
                        ]
                    },
                    {
                        "ZE_RESULT_ERROR_NOT_AVAILABLE": [
                            "the thread is running or unavailable"
                        ]
                    }
                ],
                "type": "function"
            }
        },
        "handle": {
            "ze_command_list_handle_t": {
                "class": "zeCommandList",
                "desc": "Handle of driver's command list object",
                "name": "ze_command_list_handle_t",
                "type": "handle"
            },
            "ze_command_queue_handle_t": {
                "class": "zeCommandQueue",
                "desc": "Handle of driver's command queue object",
                "name": "ze_command_queue_handle_t",
                "type": "handle"
            },
            "ze_context_handle_t": {
                "class": "zeContext",
                "desc": "Handle of driver's context object",
                "name": "ze_context_handle_t",
                "type": "handle"
            },
            "ze_device_handle_t": {
                "class": "zeDevice",
                "desc": "Handle of driver's device object",
                "name": "ze_device_handle_t",
                "type": "handle"
            },
            "ze_driver_handle_t": {
                "class": "zeDriver",
                "desc": "Handle of a driver instance",
                "name": "ze_driver_handle_t",
                "type": "handle"
            },
            "ze_event_handle_t": {
                "class": "zeEvent",
                "desc": "Handle of driver's event object",
                "name": "ze_event_handle_t",
                "type": "handle"
            },
            "ze_event_pool_handle_t": {
                "class": "zeEventPool",
                "desc": "Handle of driver's event pool object",
                "name": "ze_event_pool_handle_t",
                "type": "handle"
            },
            "ze_fabric_edge_handle_t": {
                "class": "zeFabricEdge",
                "desc": "Handle of driver's fabric edge object",
                "name": "ze_fabric_edge_handle_t",
                "type": "handle",
                "version": "1.4"
            },
            "ze_fabric_vertex_handle_t": {
                "class": "zeFabricVertex",
                "desc": "Handle of driver's fabric vertex object",
                "name": "ze_fabric_vertex_handle_t",
                "type": "handle",
                "version": "1.4"
            },
            "ze_fence_handle_t": {
                "class": "zeFence",
                "desc": "Handle of driver's fence object",
                "name": "ze_fence_handle_t",
                "type": "handle"
            },
            "ze_image_handle_t": {
                "class": "zeImage",
                "desc": "Handle of driver's image object",
                "name": "ze_image_handle_t",
                "type": "handle"
            },
            "ze_kernel_handle_t": {
                "class": "zeKernel",
                "desc": "Handle of driver's kernel object",
                "name": "ze_kernel_handle_t",
                "type": "handle"
            },
            "ze_module_build_log_handle_t": {
                "class": "zeModuleBuildLog",
                "desc": "Handle of module's build log object",
                "name": "ze_module_build_log_handle_t",
                "type": "handle"
            },
            "ze_module_handle_t": {
                "class": "zeModule",
                "desc": "Handle of driver's module object",
                "name": "ze_module_handle_t",
                "type": "handle"
            },
            "ze_physical_mem_handle_t": {
                "class": "zePhysicalMem",
                "desc": "Handle of physical memory object",
                "name": "ze_physical_mem_handle_t",
                "type": "handle"
            },
            "ze_rtas_builder_exp_handle_t": {
                "class": "zeRTASBuilder",
                "desc": "Handle of ray tracing acceleration structure builder object",
                "name": "ze_rtas_builder_exp_handle_t",
                "type": "handle",
                "version": "1.7"
            },
            "ze_rtas_parallel_operation_exp_handle_t": {
                "class": "zeRTASParallelOperation",
                "desc": "Handle of ray tracing acceleration structure builder parallel operation object",
                "name": "ze_rtas_parallel_operation_exp_handle_t",
                "type": "handle",
                "version": "1.7"
            },
            "ze_sampler_handle_t": {
                "class": "zeSampler",
                "desc": "Handle of driver's sampler object",
                "name": "ze_sampler_handle_t",
                "type": "handle"
            },
            "zes_device_handle_t": {
                "alias": "ze_device_handle_t",
                "class": "zesDevice",
                "desc": "Handle of device object",
                "name": "zes_device_handle_t",
                "type": "handle"
            },
            "zes_diag_handle_t": {
                "class": "zesDiagnostics",
                "desc": "Handle for a Sysman device diagnostics test suite",
                "name": "zes_diag_handle_t",
                "type": "handle"
            },
            "zes_driver_handle_t": {
                "alias": "ze_driver_handle_t",
                "class": "zesDriver",
                "desc": "Handle to a driver instance",
                "name": "zes_driver_handle_t",
                "type": "handle"
            },
            "zes_engine_handle_t": {
                "class": "zesEngine",
                "desc": "Handle for a Sysman device engine group",
                "name": "zes_engine_handle_t",
                "type": "handle"
            },
            "zes_fabric_port_handle_t": {
                "class": "zesFabricPort",
                "desc": "Handle for a Sysman fabric port",
                "name": "zes_fabric_port_handle_t",
                "type": "handle"
            },
            "zes_fan_handle_t": {
                "class": "zesFan",
                "desc": "Handle for a Sysman device fan",
                "name": "zes_fan_handle_t",
                "type": "handle"
            },
            "zes_firmware_handle_t": {
                "class": "zesFirmware",
                "desc": "Handle for a Sysman device firmware",
                "name": "zes_firmware_handle_t",
                "type": "handle"
            },
            "zes_freq_handle_t": {
                "class": "zesFrequency",
                "desc": "Handle for a Sysman device frequency domain",
                "name": "zes_freq_handle_t",
                "type": "handle"
            },
            "zes_led_handle_t": {
                "class": "zesLed",
                "desc": "Handle for a Sysman device LED",
                "name": "zes_led_handle_t",
                "type": "handle"
            },
            "zes_mem_handle_t": {
                "class": "zesMemory",
                "desc": "Handle for a Sysman device memory module",
                "name": "zes_mem_handle_t",
                "type": "handle"
            },
            "zes_overclock_handle_t": {
                "class": "zesOverclock",
                "desc": "Handle for a Sysman device overclock domain",
                "name": "zes_overclock_handle_t",
                "type": "handle",
                "version": "1.5"
            },
            "zes_perf_handle_t": {
                "class": "zesPerformanceFactor",
                "desc": "Handle for a Sysman device performance factors",
                "name": "zes_perf_handle_t",
                "type": "handle"
            },
            "zes_psu_handle_t": {
                "class": "zesPsu",
                "desc": "Handle for a Sysman device power supply",
                "name": "zes_psu_handle_t",
                "type": "handle"
            },
            "zes_pwr_handle_t": {
                "class": "zesPower",
                "desc": "Handle for a Sysman device power domain",
                "name": "zes_pwr_handle_t",
                "type": "handle"
            },
            "zes_ras_handle_t": {
                "class": "zesRas",
                "desc": "Handle for a Sysman device RAS error set",
                "name": "zes_ras_handle_t",
                "type": "handle"
            },
            "zes_sched_handle_t": {
                "class": "zesScheduler",
                "desc": "Handle for a Sysman device scheduler queue",
                "name": "zes_sched_handle_t",
                "type": "handle"
            },
            "zes_standby_handle_t": {
                "class": "zesStandby",
                "desc": "Handle for a Sysman device standby control",
                "name": "zes_standby_handle_t",
                "type": "handle"
            },
            "zes_temp_handle_t": {
                "class": "zesTemperature",
                "desc": "Handle for a Sysman device temperature sensor",
                "name": "zes_temp_handle_t",
                "type": "handle"
            },
            "zet_command_list_handle_t": {
                "alias": "ze_command_list_handle_t",
                "class": "zetCommandList",
                "desc": "Handle of command list object",
                "name": "zet_command_list_handle_t",
                "type": "handle"
            },
            "zet_context_handle_t": {
                "alias": "ze_context_handle_t",
                "class": "zetContext",
                "desc": "Handle of context object",
                "name": "zet_context_handle_t",
                "type": "handle"
            },
            "zet_debug_session_handle_t": {
                "class": "zetDebug",
                "desc": "Debug session handle",
                "name": "zet_debug_session_handle_t",
                "type": "handle"
            },
            "zet_device_handle_t": {
                "alias": "ze_device_handle_t",
                "class": "zetDevice",
                "desc": "Handle of device object",
                "name": "zet_device_handle_t",
                "type": "handle"
            },
            "zet_driver_handle_t": {
                "alias": "ze_driver_handle_t",
                "class": "zetDriver",
                "desc": "Handle to a driver instance",
                "name": "zet_driver_handle_t",
                "type": "handle"
            },
            "zet_kernel_handle_t": {
                "alias": "ze_kernel_handle_t",
                "class": "zetKernel",
                "desc": "Handle of function object",
                "name": "zet_kernel_handle_t",
                "type": "handle"
            },
            "zet_metric_group_handle_t": {
                "class": "zetMetricGroup",
                "desc": "Handle of metric group's object",
                "name": "zet_metric_group_handle_t",
                "type": "handle"
            },
            "zet_metric_handle_t": {
                "class": "zetMetric",
                "desc": "Handle of metric's object",
                "name": "zet_metric_handle_t",
                "type": "handle"
            },
            "zet_metric_query_handle_t": {
                "class": "zetMetricQuery",
                "desc": "Handle of metric query's object",
                "name": "zet_metric_query_handle_t",
                "type": "handle"
            },
            "zet_metric_query_pool_handle_t": {
                "class": "zetMetricQueryPool",
                "desc": "Handle of metric query pool's object",
                "name": "zet_metric_query_pool_handle_t",
                "type": "handle"
            },
            "zet_metric_streamer_handle_t": {
                "class": "zetMetricStreamer",
                "desc": "Handle of metric streamer's object",
                "name": "zet_metric_streamer_handle_t",
                "type": "handle"
            },
            "zet_module_handle_t": {
                "alias": "ze_module_handle_t",
                "class": "zetModule",
                "desc": "Handle of module object",
                "name": "zet_module_handle_t",
                "type": "handle"
            },
            "zet_tracer_exp_handle_t": {
                "class": "zetTracerExp",
                "desc": "Handle of tracer object",
                "name": "zet_tracer_exp_handle_t",
                "type": "handle"
            }
        },
        "macro": {
            "ZES_DIAG_FIRST_TEST_INDEX": {
                "desc": "Diagnostic test index to use for the very first test.",
                "name": "ZES_DIAG_FIRST_TEST_INDEX",
                "type": "macro",
                "value": "0x0"
            },
            "ZES_DIAG_LAST_TEST_INDEX": {
                "desc": "Diagnostic test index to use for the very last test.",
                "name": "ZES_DIAG_LAST_TEST_INDEX",
                "type": "macro",
                "value": "0xFFFFFFFF"
            },
            "ZES_ENGINE_ACTIVITY_EXT_NAME": {
                "desc": "Engine Activity Extension Name",
                "name": "ZES_ENGINE_ACTIVITY_EXT_NAME",
                "type": "macro",
                "value": "\"ZES_extension_engine_activity\"",
                "version": "1.7"
            },
            "ZES_FAN_TEMP_SPEED_PAIR_COUNT": {
                "desc": "Maximum number of fan temperature/speed pairs in the fan speed table.",
                "name": "ZES_FAN_TEMP_SPEED_PAIR_COUNT",
                "type": "macro",
                "value": "32"
            },
            "ZES_MAX_FABRIC_LINK_TYPE_SIZE": {
                "desc": "Maximum size of the buffer that will return information about link types",
                "name": "ZES_MAX_FABRIC_LINK_TYPE_SIZE",
                "type": "macro",
                "value": "256"
            },
            "ZES_MAX_FABRIC_PORT_MODEL_SIZE": {
                "desc": "Maximum Fabric port model string size",
                "name": "ZES_MAX_FABRIC_PORT_MODEL_SIZE",
                "type": "macro",
                "value": "256"
            },
            "ZES_MAX_RAS_ERROR_CATEGORY_COUNT": {
                "desc": "The maximum number of categories",
                "name": "ZES_MAX_RAS_ERROR_CATEGORY_COUNT",
                "type": "macro",
                "value": "7"
            },
            "ZES_MAX_UUID_SIZE": {
                "desc": "Maximum device universal unique id (UUID) size in bytes.",
                "name": "ZES_MAX_UUID_SIZE",
                "type": "macro",
                "value": "16"
            },
            "ZES_POWER_LIMITS_EXT_NAME": {
                "desc": "Power Limits Extension Name",
                "name": "ZES_POWER_LIMITS_EXT_NAME",
                "type": "macro",
                "value": "\"ZES_extension_power_limits\"",
                "version": "1.4"
            },
            "ZES_RAS_GET_STATE_EXP_NAME": {
                "desc": "RAS Get State Extension Name",
                "name": "ZES_RAS_GET_STATE_EXP_NAME",
                "type": "macro",
                "value": "\"ZES_extension_ras_state\"",
                "version": "1.7"
            },
            "ZES_SCHED_WATCHDOG_DISABLE": {
                "desc": "Disable forward progress guard timeout.",
                "name": "ZES_SCHED_WATCHDOG_DISABLE",
                "type": "macro",
                "value": "(~(0ULL))"
            },
            "ZES_STRING_PROPERTY_SIZE": {
                "desc": "Maximum number of characters in string properties.",
                "name": "ZES_STRING_PROPERTY_SIZE",
                "type": "macro",
                "value": "64"
            },
            "ZET_API_TRACING_EXP_NAME": {
                "desc": "API Tracing Experimental Extension Name",
                "name": "ZET_API_TRACING_EXP_NAME",
                "type": "macro",
                "value": "\"ZET_experimental_api_tracing\""
            },
            "ZET_EXPORT_METRICS_DATA_EXP_NAME": {
                "desc": "Exporting Metrics Data Experimental Extension Name",
                "name": "ZET_EXPORT_METRICS_DATA_EXP_NAME",
                "type": "macro",
                "value": "\"ZET_experimental_metric_export_data\"",
                "version": "1.6"
            },
            "ZET_GLOBAL_METRICS_TIMESTAMPS_EXP_NAME": {
                "desc": "Global Metric Timestamps Experimental Extension Name",
                "name": "ZET_GLOBAL_METRICS_TIMESTAMPS_EXP_NAME",
                "type": "macro",
                "value": "\"ZET_experimental_global_metric_timestamps\"",
                "version": "1.5"
            },
            "ZET_MAX_METRIC_COMPONENT": {
                "desc": "Maximum metric component string size",
                "name": "ZET_MAX_METRIC_COMPONENT",
                "type": "macro",
                "value": "256"
            },
            "ZET_MAX_METRIC_DESCRIPTION": {
                "desc": "Maximum metric description string size",
                "name": "ZET_MAX_METRIC_DESCRIPTION",
                "type": "macro",
                "value": "256"
            },
            "ZET_MAX_METRIC_EXPORT_DATA_ELEMENT_DESCRIPTION_EXP": {
                "desc": "Maximum export data element description string size",
                "name": "ZET_MAX_METRIC_EXPORT_DATA_ELEMENT_DESCRIPTION_EXP",
                "type": "macro",
                "value": "256",
                "version": "1.6"
            },
            "ZET_MAX_METRIC_EXPORT_DATA_ELEMENT_NAME_EXP": {
                "desc": "Maximum count of characters in export data element name",
                "name": "ZET_MAX_METRIC_EXPORT_DATA_ELEMENT_NAME_EXP",
                "type": "macro",
                "value": "256",
                "version": "1.6"
            },
            "ZET_MAX_METRIC_GROUP_DESCRIPTION": {
                "desc": "Maximum metric group description string size",
                "name": "ZET_MAX_METRIC_GROUP_DESCRIPTION",
                "type": "macro",
                "value": "256"
            },
            "ZET_MAX_METRIC_GROUP_NAME": {
                "desc": "Maximum metric group name string size",
                "name": "ZET_MAX_METRIC_GROUP_NAME",
                "type": "macro",
                "value": "256"
            },
            "ZET_MAX_METRIC_NAME": {
                "desc": "Maximum metric name string size",
                "name": "ZET_MAX_METRIC_NAME",
                "type": "macro",
                "value": "256"
            },
            "ZET_MAX_METRIC_RESULT_UNITS": {
                "desc": "Maximum metric result units string size",
                "name": "ZET_MAX_METRIC_RESULT_UNITS",
                "type": "macro",
                "value": "256"
            },
            "ZET_MULTI_METRICS_EXP_NAME": {
                "desc": "Calculating Multiple Metrics Experimental Extension Name",
                "name": "ZET_MULTI_METRICS_EXP_NAME",
                "type": "macro",
                "value": "\"ZET_experimental_calculate_multiple_metrics\"",
                "version": "1.2"
            },
            "ZE_APICALL": {
                "altvalue": "",
                "condition": "defined(_WIN32)",
                "desc": "Calling convention for all API functions",
                "name": "ZE_APICALL",
                "type": "macro",
                "value": "__cdecl"
            },
            "ZE_APIEXPORT": {
                "altvalue": "",
                "condition": "__GNUC__ >= 4",
                "desc": "GCC-specific dllexport storage-class attribute",
                "name": "ZE_APIEXPORT",
                "type": "macro",
                "value": "__attribute__ ((visibility (\"default\")))"
            },
            "ZE_BANDWIDTH_PROPERTIES_EXP_NAME": {
                "desc": "Bandwidth Extension Name",
                "name": "ZE_BANDWIDTH_PROPERTIES_EXP_NAME",
                "type": "macro",
                "value": "\"ZE_experimental_bandwidth_properties\"",
                "version": "1.4"
            },
            "ZE_BFLOAT16_CONVERSIONS_EXT_NAME": {
                "desc": "Bfloat16 Conversions Extension Name",
                "name": "ZE_BFLOAT16_CONVERSIONS_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_bfloat16_conversions\"",
                "version": "1.5"
            },
            "ZE_BIT": {
                "desc": "Generic macro for enumerator bit masks",
                "name": "ZE_BIT( _i )",
                "type": "macro",
                "value": "( 1 << _i )"
            },
            "ZE_CACHE_RESERVATION_EXT_NAME": {
                "desc": "Cache_Reservation Extension Name",
                "name": "ZE_CACHE_RESERVATION_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_cache_reservation\"",
                "version": "1.2"
            },
            "ZE_CONTEXT_POWER_SAVING_HINT_EXP_NAME": {
                "desc": "Power Saving Hint Extension Name",
                "name": "ZE_CONTEXT_POWER_SAVING_HINT_EXP_NAME",
                "type": "macro",
                "value": "\"ZE_experimental_power_saving_hint\"",
                "version": "1.2"
            },
            "ZE_DEVICE_IP_VERSION_EXT_NAME": {
                "desc": "Device IP Version Extension Name",
                "name": "ZE_DEVICE_IP_VERSION_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_device_ip_version\"",
                "version": "1.5"
            },
            "ZE_DEVICE_LUID_EXT_NAME": {
                "desc": "Device Local Identifier (LUID) Extension Name",
                "name": "ZE_DEVICE_LUID_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_device_luid\"",
                "version": "1.4"
            },
            "ZE_DEVICE_MEMORY_PROPERTIES_EXT_NAME": {
                "desc": "Device Memory Properties Extension Name",
                "name": "ZE_DEVICE_MEMORY_PROPERTIES_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_device_memory_properties\"",
                "version": "1.4"
            },
            "ZE_DLLEXPORT": {
                "altvalue": "",
                "condition": "__GNUC__ >= 4",
                "desc": "GCC-specific dllexport storage-class attribute",
                "name": "ZE_DLLEXPORT",
                "type": "macro",
                "value": "__attribute__ ((visibility (\"default\")))"
            },
            "ZE_EU_COUNT_EXT_NAME": {
                "desc": "EU Count Extension Name",
                "name": "ZE_EU_COUNT_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_eu_count\"",
                "version": "1.3"
            },
            "ZE_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_NAME": {
                "desc": "Event Query Kernel Timestamps Extension Name",
                "name": "ZE_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_event_query_kernel_timestamps\"",
                "version": "1.6"
            },
            "ZE_EVENT_QUERY_TIMESTAMPS_EXP_NAME": {
                "desc": "Event Query Timestamps Extension Name",
                "name": "ZE_EVENT_QUERY_TIMESTAMPS_EXP_NAME",
                "type": "macro",
                "value": "\"ZE_experimental_event_query_timestamps\"",
                "version": "1.2"
            },
            "ZE_FABRIC_EXP_NAME": {
                "desc": "Fabric Topology Discovery Extension Name",
                "name": "ZE_FABRIC_EXP_NAME",
                "type": "macro",
                "value": "\"ZE_experimental_fabric\"",
                "version": "1.4"
            },
            "ZE_FLOAT_ATOMICS_EXT_NAME": {
                "desc": "Floating-Point Atomics Extension Name",
                "name": "ZE_FLOAT_ATOMICS_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_float_atomics\"",
                "version": "1.1"
            },
            "ZE_GLOBAL_OFFSET_EXP_NAME": {
                "desc": "Global Offset Extension Name",
                "name": "ZE_GLOBAL_OFFSET_EXP_NAME",
                "type": "macro",
                "value": "\"ZE_experimental_global_offset\"",
                "version": "1.1"
            },
            "ZE_IMAGE_COPY_EXT_NAME": {
                "desc": "Image Copy Extension Name",
                "name": "ZE_IMAGE_COPY_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_image_copy\"",
                "version": "1.3"
            },
            "ZE_IMAGE_MEMORY_PROPERTIES_EXP_NAME": {
                "desc": "Image Memory Properties Extension Name",
                "name": "ZE_IMAGE_MEMORY_PROPERTIES_EXP_NAME",
                "type": "macro",
                "value": "\"ZE_experimental_image_memory_properties\"",
                "version": "1.2"
            },
            "ZE_IMAGE_QUERY_ALLOC_PROPERTIES_EXT_NAME": {
                "desc": "Image Query Allocation Properties Extension Name",
                "name": "ZE_IMAGE_QUERY_ALLOC_PROPERTIES_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_image_query_alloc_properties\"",
                "version": "1.3"
            },
            "ZE_IMAGE_VIEW_EXP_NAME": {
                "desc": "Image View Extension Name",
                "name": "ZE_IMAGE_VIEW_EXP_NAME",
                "type": "macro",
                "value": "\"ZE_experimental_image_view\"",
                "version": "1.2"
            },
            "ZE_IMAGE_VIEW_EXT_NAME": {
                "desc": "Image View Extension Name",
                "name": "ZE_IMAGE_VIEW_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_image_view\"",
                "version": "1.5"
            },
            "ZE_IMAGE_VIEW_PLANAR_EXP_NAME": {
                "desc": "Image View Planar Extension Name",
                "name": "ZE_IMAGE_VIEW_PLANAR_EXP_NAME",
                "type": "macro",
                "value": "\"ZE_experimental_image_view_planar\"",
                "version": "1.2"
            },
            "ZE_IMAGE_VIEW_PLANAR_EXT_NAME": {
                "desc": "Image View Planar Extension Name",
                "name": "ZE_IMAGE_VIEW_PLANAR_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_image_view_planar\"",
                "version": "1.5"
            },
            "ZE_KERNEL_MAX_GROUP_SIZE_PROPERTIES_EXT_NAME": {
                "desc": "Kernel Max Group Size Properties Extension Name",
                "name": "ZE_KERNEL_MAX_GROUP_SIZE_PROPERTIES_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_kernel_max_group_size_properties\"",
                "version": "1.5"
            },
            "ZE_KERNEL_SCHEDULING_HINTS_EXP_NAME": {
                "desc": "Kernel Scheduling Hints Extension Name",
                "name": "ZE_KERNEL_SCHEDULING_HINTS_EXP_NAME",
                "type": "macro",
                "value": "\"ZE_experimental_scheduling_hints\"",
                "version": "1.2"
            },
            "ZE_LINKAGE_INSPECTION_EXT_NAME": {
                "desc": "Linkage Inspection Extension Name",
                "name": "ZE_LINKAGE_INSPECTION_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_linkage_inspection\"",
                "version": "1.3"
            },
            "ZE_LINKONCE_ODR_EXT_NAME": {
                "desc": "Linkonce ODR Extension Name",
                "name": "ZE_LINKONCE_ODR_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_linkonce_odr\"",
                "version": "1.2"
            },
            "ZE_MAJOR_VERSION": {
                "desc": "Extracts 'oneAPI' API major version",
                "name": "ZE_MAJOR_VERSION( _ver )",
                "type": "macro",
                "value": "( _ver >> 16 )"
            },
            "ZE_MAKE_VERSION": {
                "desc": "Generates generic 'oneAPI' API versions",
                "name": "ZE_MAKE_VERSION( _major, _minor )",
                "type": "macro",
                "value": "(( _major << 16 )|( _minor & 0x0000ffff))"
            },
            "ZE_MAX_DEVICE_LUID_SIZE_EXT": {
                "desc": "Maximum device local identifier (LUID) size in bytes",
                "name": "ZE_MAX_DEVICE_LUID_SIZE_EXT",
                "type": "macro",
                "value": "8",
                "version": "1.4"
            },
            "ZE_MAX_DEVICE_NAME": {
                "desc": "Maximum device name string size",
                "name": "ZE_MAX_DEVICE_NAME",
                "type": "macro",
                "value": "256"
            },
            "ZE_MAX_DEVICE_UUID_SIZE": {
                "desc": "Maximum device universal unique id (UUID) size in bytes",
                "name": "ZE_MAX_DEVICE_UUID_SIZE",
                "type": "macro",
                "value": "16"
            },
            "ZE_MAX_DRIVER_UUID_SIZE": {
                "desc": "Maximum driver universal unique id (UUID) size in bytes",
                "name": "ZE_MAX_DRIVER_UUID_SIZE",
                "type": "macro",
                "value": "16"
            },
            "ZE_MAX_EXTENSION_NAME": {
                "desc": "Maximum extension name string size",
                "name": "ZE_MAX_EXTENSION_NAME",
                "type": "macro",
                "value": "256"
            },
            "ZE_MAX_FABRIC_EDGE_MODEL_EXP_SIZE": {
                "desc": "Maximum fabric edge model string size",
                "name": "ZE_MAX_FABRIC_EDGE_MODEL_EXP_SIZE",
                "type": "macro",
                "value": "256"
            },
            "ZE_MAX_IPC_HANDLE_SIZE": {
                "desc": "Maximum IPC handle size",
                "name": "ZE_MAX_IPC_HANDLE_SIZE",
                "type": "macro",
                "value": "64"
            },
            "ZE_MAX_KERNEL_UUID_SIZE": {
                "desc": "Maximum kernel universal unique id (UUID) size in bytes",
                "name": "ZE_MAX_KERNEL_UUID_SIZE",
                "type": "macro",
                "value": "16"
            },
            "ZE_MAX_MODULE_UUID_SIZE": {
                "desc": "Maximum module universal unique id (UUID) size in bytes",
                "name": "ZE_MAX_MODULE_UUID_SIZE",
                "type": "macro",
                "value": "16"
            },
            "ZE_MAX_NATIVE_KERNEL_UUID_SIZE": {
                "desc": "Maximum native kernel universal unique id (UUID) size in bytes",
                "name": "ZE_MAX_NATIVE_KERNEL_UUID_SIZE",
                "type": "macro",
                "value": "16"
            },
            "ZE_MAX_UUID_SIZE": {
                "desc": "Maximum universal unique id (UUID) size in bytes",
                "name": "ZE_MAX_UUID_SIZE",
                "type": "macro",
                "value": "16",
                "version": "1.4"
            },
            "ZE_MEMORY_COMPRESSION_HINTS_EXT_NAME": {
                "desc": "Memory Compression Hints Extension Name",
                "name": "ZE_MEMORY_COMPRESSION_HINTS_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_memory_compression_hints\"",
                "version": "1.3"
            },
            "ZE_MEMORY_FREE_POLICIES_EXT_NAME": {
                "desc": "Memory Free Policies Extension Name",
                "name": "ZE_MEMORY_FREE_POLICIES_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_memory_free_policies\"",
                "version": "1.3"
            },
            "ZE_MINOR_VERSION": {
                "desc": "Extracts 'oneAPI' API minor version",
                "name": "ZE_MINOR_VERSION( _ver )",
                "type": "macro",
                "value": "( _ver & 0x0000ffff )"
            },
            "ZE_MODULE_PROGRAM_EXP_NAME": {
                "desc": "Module Program Extension Name",
                "name": "ZE_MODULE_PROGRAM_EXP_NAME",
                "type": "macro",
                "value": "\"ZE_experimental_module_program\"",
                "version": "1.0"
            },
            "ZE_PCI_PROPERTIES_EXT_NAME": {
                "desc": "PCI Properties Extension Name",
                "name": "ZE_PCI_PROPERTIES_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_pci_properties\"",
                "version": "1.3"
            },
            "ZE_RAYTRACING_EXT_NAME": {
                "desc": "Raytracing Extension Name",
                "name": "ZE_RAYTRACING_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_raytracing\"",
                "version": "1.0"
            },
            "ZE_RELAXED_ALLOCATION_LIMITS_EXP_NAME": {
                "desc": "Relaxed Allocation Limits Extension Name",
                "name": "ZE_RELAXED_ALLOCATION_LIMITS_EXP_NAME",
                "type": "macro",
                "value": "\"ZE_experimental_relaxed_allocation_limits\"",
                "version": "1.1"
            },
            "ZE_RTAS_BUILDER_EXP_NAME": {
                "desc": "Ray Tracing Acceleration Structure Builder Extension Name",
                "name": "ZE_RTAS_BUILDER_EXP_NAME",
                "type": "macro",
                "value": "\"ZE_experimental_rtas_builder\"",
                "version": "1.7"
            },
            "ZE_SRGB_EXT_NAME": {
                "desc": "sRGB Extension Name",
                "name": "ZE_SRGB_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_srgb\"",
                "version": "1.3"
            },
            "ZE_SUBGROUPSIZE_COUNT": {
                "desc": "Maximum number of subgroup sizes supported.",
                "name": "ZE_SUBGROUPSIZE_COUNT",
                "type": "macro",
                "value": "8"
            },
            "ZE_SUBGROUPS_EXT_NAME": {
                "desc": "Subgroups Extension Name",
                "name": "ZE_SUBGROUPS_EXT_NAME",
                "type": "macro",
                "value": "\"ZE_extension_subgroups\"",
                "version": "1.2"
            },
            "ZE_SUB_ALLOCATIONS_EXP_NAME": {
                "desc": "Sub-Allocations Properties Extension Name",
                "name": "ZE_SUB_ALLOCATIONS_EXP_NAME",
                "type": "macro",
                "value": "\"ZE_experimental_sub_allocations\"",
                "version": "1.5"
            }
        },
        "struct": {
            "ze_base_cb_params_t": {
                "desc": "Base for all callback function parameter types",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    }
                ],
                "name": "ze_base_cb_params_t",
                "type": "struct"
            },
            "ze_base_desc_t": {
                "desc": "Base for all descriptor types",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    }
                ],
                "name": "ze_base_desc_t",
                "type": "struct"
            },
            "ze_base_properties_t": {
                "desc": "Base for all properties types",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    }
                ],
                "name": "ze_base_properties_t",
                "type": "struct"
            },
            "ze_cache_reservation_ext_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeDevice",
                "desc": "CacheReservation structure",
                "details": [
                    "This structure must be passed to zeDeviceGetCacheProperties via the `pNext` member of ze_device_cache_properties_t",
                    "Used for determining the max cache reservation allowed on device. Size of zero means no reservation available."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_CACHE_RESERVATION_EXT_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] max cache reservation size",
                        "name": "maxCacheReservationSize",
                        "type": "size_t"
                    }
                ],
                "name": "ze_cache_reservation_ext_desc_t",
                "type": "struct",
                "version": "1.2"
            },
            "ze_command_list_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeCommandList",
                "desc": "Command List descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_COMMAND_LIST_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] command queue group ordinal to which this command list will be submitted",
                        "name": "commandQueueGroupOrdinal",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] usage flags.\nmust be 0 (default) or a valid combination of ze_command_list_flag_t;\ndefault behavior may use implicit driver-based heuristics to balance latency and throughput.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_command_list_flags_t"
                    }
                ],
                "name": "ze_command_list_desc_t",
                "type": "struct"
            },
            "ze_command_queue_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeCommandQueue",
                "desc": "Command Queue descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_COMMAND_QUEUE_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] command queue group ordinal",
                        "name": "ordinal",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] command queue index within the group;\nmust be zero if ZE_COMMAND_QUEUE_FLAG_EXPLICIT_ONLY is not set\n",
                        "name": "index",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] usage flags.\nmust be 0 (default) or a valid combination of ze_command_queue_flag_t;\ndefault behavior may use implicit driver-based heuristics to balance latency and throughput.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_command_queue_flags_t"
                    },
                    {
                        "desc": "[in] operation mode",
                        "init": "ZE_COMMAND_QUEUE_MODE_DEFAULT",
                        "name": "mode",
                        "type": "ze_command_queue_mode_t"
                    },
                    {
                        "desc": "[in] priority",
                        "init": "ZE_COMMAND_QUEUE_PRIORITY_NORMAL",
                        "name": "priority",
                        "type": "ze_command_queue_priority_t"
                    }
                ],
                "name": "ze_command_queue_desc_t",
                "type": "struct"
            },
            "ze_command_queue_group_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Command queue group properties queried using zeDeviceGetCommandQueueGroupProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_COMMAND_QUEUE_GROUP_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] 0 (none) or a valid combination of ze_command_queue_group_property_flag_t",
                        "name": "flags",
                        "type": "ze_command_queue_group_property_flags_t"
                    },
                    {
                        "desc": "[out] maximum `pattern_size` supported by command queue group.\nSee zeCommandListAppendMemoryFill for more details.\n",
                        "name": "maxMemoryFillPatternSize",
                        "type": "size_t"
                    },
                    {
                        "desc": "[out] the number of physical engines within the group.",
                        "name": "numQueues",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_command_queue_group_properties_t",
                "type": "struct"
            },
            "ze_context_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeContext",
                "desc": "Context descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_CONTEXT_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of ze_context_flag_t;\ndefault behavior may use implicit driver-based heuristics.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_context_flags_t"
                    }
                ],
                "name": "ze_context_desc_t",
                "type": "struct"
            },
            "ze_context_power_saving_hint_exp_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeContext",
                "desc": "Extended context descriptor containing power saving hint.",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_CONTEXT_POWER_SAVING_HINT_EXP_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] power saving hint (default value = 0). This is value from [0,100] and can use pre-defined settings from ze_power_saving_hint_type_t.\n",
                        "init": "0",
                        "name": "hint",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_context_power_saving_hint_exp_desc_t",
                "type": "struct",
                "version": "1.2"
            },
            "ze_copy_bandwidth_exp_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeCommandQueue",
                "desc": "Copy Bandwidth Properties",
                "details": [
                    "This structure may be passed to zeDeviceGetCommandQueueGroupProperties by having the pNext member of ze_command_queue_group_properties_t point at this struct."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_COPY_BANDWIDTH_EXP_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] design bandwidth supported by this engine type for copy operations",
                        "name": "copyBandwidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] copy bandwidth unit",
                        "name": "copyBandwidthUnit",
                        "type": "ze_bandwidth_unit_t"
                    }
                ],
                "name": "ze_copy_bandwidth_exp_properties_t",
                "type": "struct",
                "version": "1.4"
            },
            "ze_copy_region_t": {
                "class": "zeCommandList",
                "desc": "Copy region descriptor",
                "members": [
                    {
                        "desc": "[in] The origin x offset for region in bytes",
                        "name": "originX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The origin y offset for region in rows",
                        "name": "originY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The origin z offset for region in slices",
                        "name": "originZ",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The region width relative to origin in bytes",
                        "name": "width",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The region height relative to origin in rows",
                        "name": "height",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The region depth relative to origin in slices. Set this to 0 for 2D copy.",
                        "name": "depth",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_copy_region_t",
                "type": "struct"
            },
            "ze_device_cache_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Device cache properties queried using zeDeviceGetCacheProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_CACHE_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] 0 (none) or a valid combination of ze_device_cache_property_flag_t",
                        "name": "flags",
                        "type": "ze_device_cache_property_flags_t"
                    },
                    {
                        "desc": "[out] Per-cache size, in bytes",
                        "name": "cacheSize",
                        "type": "size_t"
                    }
                ],
                "name": "ze_device_cache_properties_t",
                "type": "struct"
            },
            "ze_device_compute_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Device compute properties queried using zeDeviceGetComputeProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_COMPUTE_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] Maximum items per compute group. (groupSizeX * groupSizeY * groupSizeZ) <= maxTotalGroupSize",
                        "name": "maxTotalGroupSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum items for X dimension in group",
                        "name": "maxGroupSizeX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum items for Y dimension in group",
                        "name": "maxGroupSizeY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum items for Z dimension in group",
                        "name": "maxGroupSizeZ",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum groups that can be launched for x dimension",
                        "name": "maxGroupCountX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum groups that can be launched for y dimension",
                        "name": "maxGroupCountY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum groups that can be launched for z dimension",
                        "name": "maxGroupCountZ",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum shared local memory per group.",
                        "name": "maxSharedLocalMemory",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Number of subgroup sizes supported. This indicates number of entries in subGroupSizes.",
                        "name": "numSubGroupSizes",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Size group sizes supported.",
                        "name": "subGroupSizes[ZE_SUBGROUPSIZE_COUNT]",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_device_compute_properties_t",
                "type": "struct"
            },
            "ze_device_external_memory_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Device external memory import and export properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_EXTERNAL_MEMORY_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] Supported external memory import types for memory allocations.",
                        "name": "memoryAllocationImportTypes",
                        "type": "ze_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[out] Supported external memory export types for memory allocations.",
                        "name": "memoryAllocationExportTypes",
                        "type": "ze_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[out] Supported external memory import types for images.",
                        "name": "imageImportTypes",
                        "type": "ze_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[out] Supported external memory export types for images.",
                        "name": "imageExportTypes",
                        "type": "ze_external_memory_type_flags_t"
                    }
                ],
                "name": "ze_device_external_memory_properties_t",
                "type": "struct"
            },
            "ze_device_image_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Device image properties queried using zeDeviceGetImageProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_IMAGE_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] Maximum image dimensions for 1D resources. if 0, then 1D images are unsupported.",
                        "name": "maxImageDims1D",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum image dimensions for 2D resources. if 0, then 2D images are unsupported.",
                        "name": "maxImageDims2D",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum image dimensions for 3D resources. if 0, then 3D images are unsupported.",
                        "name": "maxImageDims3D",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum image buffer size in bytes. if 0, then buffer images are unsupported.",
                        "name": "maxImageBufferSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Maximum image array slices. if 0, then image arrays are unsupported.",
                        "name": "maxImageArraySlices",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Max samplers that can be used in kernel. if 0, then sampling is unsupported.",
                        "name": "maxSamplers",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Returns the maximum number of simultaneous image objects that can be read from by a kernel. if 0, then reading images is unsupported.",
                        "name": "maxReadImageArgs",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Returns the maximum number of simultaneous image objects that can be written to by a kernel. if 0, then writing images is unsupported.",
                        "name": "maxWriteImageArgs",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_device_image_properties_t",
                "type": "struct"
            },
            "ze_device_ip_version_ext_t": {
                "base": "ze_base_desc_t",
                "class": "zeDevice",
                "desc": "Device IP version queried using zeDeviceGetProperties",
                "details": [
                    "This structure may be returned from zeDeviceGetProperties via the `pNext` member of ze_device_properties_t"
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_IP_VERSION_EXT",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] Device IP version. The meaning of the device IP version is\nimplementation-defined, but newer devices should have a higher\nversion than older devices.\n",
                        "name": "ipVersion",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_device_ip_version_ext_t",
                "type": "struct",
                "version": "1.5"
            },
            "ze_device_luid_ext_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Device LUID properties queried using zeDeviceGetProperties",
                "details": [
                    "This structure may be returned from zeDeviceGetProperties, via the `pNext` member of ze_device_properties_t."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_LUID_EXT_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] locally unique identifier (LUID).\nThe returned LUID can be cast to a LUID object and must be equal to the locally\nunique identifier of an IDXGIAdapter1 object that corresponds to the device.\n",
                        "name": "luid",
                        "type": "ze_device_luid_ext_t"
                    },
                    {
                        "desc": "[out] node mask.\nThe returned node mask must contain exactly one bit.\nIf the device is running on an operating system that supports the Direct3D 12 API\nand the device corresponds to an individual device in a linked device adapter, the\nreturned node mask identifies the Direct3D 12 node corresponding to the device.\nOtherwise, the returned node mask must be 1.\n",
                        "name": "nodeMask",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_device_luid_ext_properties_t",
                "type": "struct",
                "version": "1.4"
            },
            "ze_device_luid_ext_t": {
                "desc": "Device local identifier (LUID)",
                "members": [
                    {
                        "desc": "[out] opaque data representing a device LUID",
                        "name": "id[ZE_MAX_DEVICE_LUID_SIZE_EXT]",
                        "type": "uint8_t"
                    }
                ],
                "name": "ze_device_luid_ext_t",
                "type": "struct"
            },
            "ze_device_mem_alloc_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeMem",
                "desc": "Device memory allocation descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_MEM_ALLOC_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] flags specifying additional allocation controls.\nmust be 0 (default) or a valid combination of ze_device_mem_alloc_flag_t;\ndefault behavior may use implicit driver-based heuristics.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_device_mem_alloc_flags_t"
                    },
                    {
                        "desc": "[in] ordinal of the device's local memory to allocate from.\nmust be less than the count returned from zeDeviceGetMemoryProperties.\n",
                        "init": "0",
                        "name": "ordinal",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_device_mem_alloc_desc_t",
                "type": "struct"
            },
            "ze_device_memory_access_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Device memory access properties queried using zeDeviceGetMemoryAccessProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_MEMORY_ACCESS_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] host memory capabilities.\nreturns 0 (unsupported) or a combination of ze_memory_access_cap_flag_t.\n",
                        "name": "hostAllocCapabilities",
                        "type": "ze_memory_access_cap_flags_t"
                    },
                    {
                        "desc": "[out] device memory capabilities.\nreturns 0 (unsupported) or a combination of ze_memory_access_cap_flag_t.\n",
                        "name": "deviceAllocCapabilities",
                        "type": "ze_memory_access_cap_flags_t"
                    },
                    {
                        "desc": "[out] shared, single-device memory capabilities.\nreturns 0 (unsupported) or a combination of ze_memory_access_cap_flag_t.\n",
                        "name": "sharedSingleDeviceAllocCapabilities",
                        "type": "ze_memory_access_cap_flags_t"
                    },
                    {
                        "desc": "[out] shared, cross-device memory capabilities.\nreturns 0 (unsupported) or a combination of ze_memory_access_cap_flag_t.\n",
                        "name": "sharedCrossDeviceAllocCapabilities",
                        "type": "ze_memory_access_cap_flags_t"
                    },
                    {
                        "desc": "[out] shared, system memory capabilities.\nreturns 0 (unsupported) or a combination of ze_memory_access_cap_flag_t.\n",
                        "name": "sharedSystemAllocCapabilities",
                        "type": "ze_memory_access_cap_flags_t"
                    }
                ],
                "name": "ze_device_memory_access_properties_t",
                "type": "struct"
            },
            "ze_device_memory_ext_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Memory properties",
                "details": [
                    "This structure may be returned from zeDeviceGetMemoryProperties via the `pNext` member of ze_device_memory_properties_t"
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_MEMORY_EXT_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] The memory type",
                        "name": "type",
                        "type": "ze_device_memory_ext_type_t"
                    },
                    {
                        "desc": "[out] Physical memory size in bytes. A value of 0 indicates that this property is not known. However, a call to $sMemoryGetState() will correctly return the total size of usable memory.",
                        "name": "physicalSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Design bandwidth for reads",
                        "name": "readBandwidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Design bandwidth for writes",
                        "name": "writeBandwidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] bandwidth unit",
                        "name": "bandwidthUnit",
                        "type": "ze_bandwidth_unit_t"
                    }
                ],
                "name": "ze_device_memory_ext_properties_t",
                "type": "struct",
                "version": "1.4"
            },
            "ze_device_memory_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Device local memory properties queried using zeDeviceGetMemoryProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_MEMORY_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] 0 (none) or a valid combination of ze_device_memory_property_flag_t",
                        "name": "flags",
                        "type": "ze_device_memory_property_flags_t"
                    },
                    {
                        "desc": "[out] Maximum clock rate for device memory.",
                        "name": "maxClockRate",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum bus width between device and memory.",
                        "name": "maxBusWidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Total memory size in bytes that is available to the device.",
                        "name": "totalSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Memory name",
                        "name": "name[ZE_MAX_DEVICE_NAME]",
                        "type": "char"
                    }
                ],
                "name": "ze_device_memory_properties_t",
                "type": "struct"
            },
            "ze_device_module_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Device module properties queried using zeDeviceGetModuleProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_MODULE_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] Maximum supported SPIR-V version.\nReturns zero if SPIR-V is not supported.\nContains major and minor attributes, use ZE_MAJOR_VERSION and ZE_MINOR_VERSION.\n",
                        "name": "spirvVersionSupported",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] 0 or a valid combination of ze_device_module_flag_t",
                        "name": "flags",
                        "type": "ze_device_module_flags_t"
                    },
                    {
                        "desc": "[out] Capabilities for half-precision floating-point operations.\nreturns 0 (if ZE_DEVICE_MODULE_FLAG_FP16 is not set) or a combination of ze_device_fp_flag_t.\n",
                        "name": "fp16flags",
                        "type": "ze_device_fp_flags_t"
                    },
                    {
                        "desc": "[out] Capabilities for single-precision floating-point operations.\nreturns a combination of ze_device_fp_flag_t.\n",
                        "name": "fp32flags",
                        "type": "ze_device_fp_flags_t"
                    },
                    {
                        "desc": "[out] Capabilities for double-precision floating-point operations.\nreturns 0 (if ZE_DEVICE_MODULE_FLAG_FP64 is not set) or a combination of ze_device_fp_flag_t.\n",
                        "name": "fp64flags",
                        "type": "ze_device_fp_flags_t"
                    },
                    {
                        "desc": "[out] Maximum kernel argument size that is supported.",
                        "name": "maxArgumentsSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum size of internal buffer that holds output of printf calls from kernel.",
                        "name": "printfBufferSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Compatibility UUID of supported native kernel.\nUUID may or may not be the same across driver release, devices, or operating systems.\nApplication is responsible for ensuring UUID matches before creating module using\npreviously created native kernel.\n",
                        "name": "nativeKernelSupported",
                        "type": "ze_native_kernel_uuid_t"
                    }
                ],
                "name": "ze_device_module_properties_t",
                "type": "struct"
            },
            "ze_device_p2p_bandwidth_exp_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "P2P Bandwidth Properties",
                "details": [
                    "This structure may be passed to zeDeviceGetP2PProperties by having the pNext member of ze_device_p2p_properties_t point at this struct."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_P2P_BANDWIDTH_EXP_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] total logical design bandwidth for all links connecting the two devices",
                        "name": "logicalBandwidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] total physical design bandwidth for all links connecting the two devices",
                        "name": "physicalBandwidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] bandwidth unit",
                        "name": "bandwidthUnit",
                        "type": "ze_bandwidth_unit_t"
                    },
                    {
                        "desc": "[out] average logical design latency for all links connecting the two devices",
                        "name": "logicalLatency",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] average physical design latency for all links connecting the two devices",
                        "name": "physicalLatency",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] latency unit",
                        "name": "latencyUnit",
                        "type": "ze_latency_unit_t"
                    }
                ],
                "name": "ze_device_p2p_bandwidth_exp_properties_t",
                "type": "struct",
                "version": "1.4"
            },
            "ze_device_p2p_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Device peer-to-peer properties queried using zeDeviceGetP2PProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_P2P_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] 0 (none) or a valid combination of ze_device_p2p_property_flag_t",
                        "name": "flags",
                        "type": "ze_device_p2p_property_flags_t"
                    }
                ],
                "name": "ze_device_p2p_properties_t",
                "type": "struct"
            },
            "ze_device_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Device properties queried using zeDeviceGetProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] generic device type",
                        "name": "type",
                        "type": "ze_device_type_t"
                    },
                    {
                        "desc": "[out] vendor id from PCI configuration",
                        "name": "vendorId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] device id from PCI configuration\nNote, the device id uses little-endian format.\n",
                        "name": "deviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] 0 (none) or a valid combination of ze_device_property_flag_t",
                        "name": "flags",
                        "type": "ze_device_property_flags_t"
                    },
                    {
                        "desc": "[out] sub-device id. Only valid if ZE_DEVICE_PROPERTY_FLAG_SUBDEVICE is set.",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Clock rate for device core.",
                        "name": "coreClockRate",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum memory allocation size.",
                        "name": "maxMemAllocSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Maximum number of logical hardware contexts.",
                        "name": "maxHardwareContexts",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum priority for command queues. Higher value is higher priority.",
                        "name": "maxCommandQueuePriority",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum number of threads per EU.",
                        "name": "numThreadsPerEU",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] The physical EU simd width.",
                        "name": "physicalEUSimdWidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum number of EUs per sub-slice.",
                        "name": "numEUsPerSubslice",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum number of sub-slices per slice.",
                        "name": "numSubslicesPerSlice",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Maximum number of slices.",
                        "name": "numSlices",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Returns the resolution of device timer used for profiling, timestamps, etc. When stype==ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES the units are in nanoseconds. When stype==ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES_1_2 units are in cycles/sec",
                        "name": "timerResolution",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Returns the number of valid bits in the timestamp value.",
                        "name": "timestampValidBits",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Returns the number of valid bits in the kernel timestamp values",
                        "name": "kernelTimestampValidBits",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] universal unique identifier. Note: Subdevices will have their own uuid.",
                        "name": "uuid",
                        "type": "ze_device_uuid_t"
                    },
                    {
                        "desc": "[out] Device name",
                        "name": "name[ZE_MAX_DEVICE_NAME]",
                        "type": "char"
                    }
                ],
                "name": "ze_device_properties_t",
                "type": "struct"
            },
            "ze_device_raytracing_ext_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeContext",
                "desc": "Raytracing properties queried using zeDeviceGetModuleProperties",
                "details": [
                    "This structure may be returned from zeDeviceGetModuleProperties, via the `pNext` member of ze_device_module_properties_t."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DEVICE_RAYTRACING_EXT_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] 0 or a valid combination of ze_device_raytracing_ext_flags_t",
                        "name": "flags",
                        "type": "ze_device_raytracing_ext_flags_t"
                    },
                    {
                        "desc": "[out] Maximum number of BVH levels supported",
                        "name": "maxBVHLevels",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_device_raytracing_ext_properties_t",
                "type": "struct",
                "version": "1.0"
            },
            "ze_device_thread_t": {
                "class": "zeDevice",
                "desc": "Device thread identifier.",
                "members": [
                    {
                        "desc": "[in,out] the slice number.\nMust be `UINT32_MAX` (all) or less than the `numSlices` member of ze_device_properties_t.\n",
                        "name": "slice",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out] the sub-slice number within its slice.\nMust be `UINT32_MAX` (all) or less than the `numSubslicesPerSlice` member of ze_device_properties_t.\n",
                        "name": "subslice",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out] the EU number within its sub-slice.\nMust be `UINT32_MAX` (all) or less than the `numEUsPerSubslice` member of ze_device_properties_t.\n",
                        "name": "eu",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out] the thread number within its EU.\nMust be `UINT32_MAX` (all) or less than the `numThreadsPerEU` member of ze_device_properties_t.\n",
                        "name": "thread",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_device_thread_t",
                "type": "struct"
            },
            "ze_device_uuid_t": {
                "desc": "Device universal unique id (UUID)",
                "members": [
                    {
                        "desc": "[out] opaque data representing a device UUID",
                        "name": "id[ZE_MAX_DEVICE_UUID_SIZE]",
                        "type": "uint8_t"
                    }
                ],
                "name": "ze_device_uuid_t",
                "type": "struct"
            },
            "ze_driver_extension_properties_t": {
                "class": "zeDriver",
                "desc": "Extension properties queried using zeDriverGetExtensionProperties",
                "members": [
                    {
                        "desc": "[out] extension name",
                        "name": "name[ZE_MAX_EXTENSION_NAME]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] extension version using ZE_MAKE_VERSION",
                        "name": "version",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_driver_extension_properties_t",
                "type": "struct"
            },
            "ze_driver_ipc_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDriver",
                "desc": "IPC properties queried using zeDriverGetIpcProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DRIVER_IPC_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] 0 (none) or a valid combination of ze_ipc_property_flag_t",
                        "name": "flags",
                        "type": "ze_ipc_property_flags_t"
                    }
                ],
                "name": "ze_driver_ipc_properties_t",
                "type": "struct"
            },
            "ze_driver_memory_free_ext_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDriver",
                "desc": "Driver memory free properties queried using zeDriverGetProperties",
                "details": [
                    "All drivers must support an immediate free policy, which is the default free policy.",
                    "This structure may be returned from zeDriverGetProperties, via the `pNext` member of ze_driver_properties_t."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DRIVER_MEMORY_FREE_EXT_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] Supported memory free policies.\nmust be 0 or a combination of ze_driver_memory_free_policy_ext_flag_t.\n",
                        "name": "freePolicies",
                        "type": "ze_driver_memory_free_policy_ext_flags_t"
                    }
                ],
                "name": "ze_driver_memory_free_ext_properties_t",
                "type": "struct",
                "version": "1.3"
            },
            "ze_driver_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDriver",
                "desc": "Driver properties queried using zeDriverGetProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_DRIVER_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] universal unique identifier.",
                        "name": "uuid",
                        "type": "ze_driver_uuid_t"
                    },
                    {
                        "desc": "[out] driver version\nThe driver version is a non-zero, monotonically increasing value where higher values always indicate a more recent version.\n",
                        "name": "driverVersion",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_driver_properties_t",
                "type": "struct"
            },
            "ze_driver_uuid_t": {
                "desc": "Driver universal unique id (UUID)",
                "members": [
                    {
                        "desc": "[out] opaque data representing a driver UUID",
                        "name": "id[ZE_MAX_DRIVER_UUID_SIZE]",
                        "type": "uint8_t"
                    }
                ],
                "name": "ze_driver_uuid_t",
                "type": "struct"
            },
            "ze_eu_count_ext_t": {
                "base": "ze_base_desc_t",
                "class": "zeDevice",
                "desc": "EU count queried using zeDeviceGetProperties",
                "details": [
                    "This structure may be returned from zeDeviceGetProperties via the `pNext` member of ze_device_properties_t.",
                    "Used for determining the total number of EUs available on device."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_EU_COUNT_EXT",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] Total number of EUs available",
                        "name": "numTotalEUs",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_eu_count_ext_t",
                "type": "struct",
                "version": "1.3"
            },
            "ze_event_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeEvent",
                "desc": "Event descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_EVENT_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] index of the event within the pool; must be less than the count specified during pool creation",
                        "name": "index",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] defines the scope of relevant cache hierarchies to flush on a signal action before the event is triggered.\nmust be 0 (default) or a valid combination of ze_event_scope_flag_t;\ndefault behavior is synchronization within the command list only, no additional cache hierarchies are flushed.\n",
                        "init": "0",
                        "name": "signal",
                        "type": "ze_event_scope_flags_t"
                    },
                    {
                        "desc": "[in] defines the scope of relevant cache hierarchies to invalidate on a wait action after the event is complete.\nmust be 0 (default) or a valid combination of ze_event_scope_flag_t;\ndefault behavior is synchronization within the command list only, no additional cache hierarchies are invalidated.\n",
                        "init": "0",
                        "name": "wait",
                        "type": "ze_event_scope_flags_t"
                    }
                ],
                "name": "ze_event_desc_t",
                "type": "struct"
            },
            "ze_event_pool_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeEventPool",
                "desc": "Event pool descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_EVENT_POOL_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of ze_event_pool_flag_t;\ndefault behavior is signals and waits are visible to the entire device and peer devices.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_event_pool_flags_t"
                    },
                    {
                        "desc": "[in] number of events within the pool; must be greater than 0",
                        "name": "count",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_event_pool_desc_t",
                "type": "struct"
            },
            "ze_event_query_kernel_timestamps_ext_properties_t": {
                "base": "ze_base_properties_t",
                "desc": "Event query kernel timestamps properties",
                "details": [
                    "This structure may be returned from zeDeviceGetProperties, via the `pNext` member of ze_device_properties_t."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] 0 or some combination of ze_event_query_kernel_timestamps_ext_flag_t flags",
                        "name": "flags",
                        "type": "ze_event_query_kernel_timestamps_ext_flags_t"
                    }
                ],
                "name": "ze_event_query_kernel_timestamps_ext_properties_t",
                "type": "struct",
                "version": "1.6"
            },
            "ze_event_query_kernel_timestamps_results_ext_properties_t": {
                "base": "ze_base_properties_t",
                "desc": "Event query kernel timestamps results properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_EVENT_QUERY_KERNEL_TIMESTAMPS_RESULTS_EXT_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] pointer to destination buffer of kernel timestamp results",
                        "init": "nullptr",
                        "name": "pKernelTimestampsBuffer",
                        "type": "ze_kernel_timestamp_result_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] pointer to destination buffer of synchronized timestamp results",
                        "init": "nullptr",
                        "name": "pSynchronizedTimestampsBuffer",
                        "type": "ze_synchronized_timestamp_result_ext_t*"
                    }
                ],
                "name": "ze_event_query_kernel_timestamps_results_ext_properties_t",
                "type": "struct",
                "version": "1.6"
            },
            "ze_external_memory_export_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeMem",
                "desc": "Additional allocation descriptor for exporting external memory",
                "details": [
                    "This structure may be passed to zeMemAllocDevice and zeMemAllocHost, via the `pNext` member of ze_device_mem_alloc_desc_t or ze_host_mem_alloc_desc_t, respectively, to indicate an exportable memory allocation.",
                    "This structure may be passed to zeImageCreate, via the `pNext` member of ze_image_desc_t, to indicate an exportable image."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] flags specifying memory export types for this allocation.\nmust be 0 (default) or a valid combination of ze_external_memory_type_flags_t\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_external_memory_type_flags_t"
                    }
                ],
                "name": "ze_external_memory_export_desc_t",
                "type": "struct"
            },
            "ze_external_memory_export_fd_t": {
                "base": "ze_base_desc_t",
                "class": "zeMem",
                "desc": "Exports an allocation as a file descriptor",
                "details": [
                    "This structure may be passed to zeMemGetAllocProperties, via the `pNext` member of ze_memory_allocation_properties_t, to export a memory allocation as a file descriptor.",
                    "This structure may be passed to zeImageGetAllocPropertiesExt, via the `pNext` member of ze_image_allocation_ext_properties_t, to export an image as a file descriptor.",
                    "The requested memory export type must have been specified when the allocation was made."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_FD",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] flags specifying the memory export type for the file descriptor.\nmust be 0 (default) or a valid combination of ze_external_memory_type_flags_t\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[out] the exported file descriptor handle representing the allocation.",
                        "name": "fd",
                        "type": "int"
                    }
                ],
                "name": "ze_external_memory_export_fd_t",
                "type": "struct"
            },
            "ze_external_memory_export_win32_handle_t": {
                "base": "ze_base_desc_t",
                "class": "zeMem",
                "desc": "Exports an allocation as a Win32 handle",
                "details": [
                    "This structure may be passed to zeMemGetAllocProperties, via the `pNext` member of ze_memory_allocation_properties_t, to export a memory allocation as a Win32 handle.",
                    "This structure may be passed to zeImageGetAllocPropertiesExt, via the `pNext` member of ze_image_allocation_ext_properties_t, to export an image as a Win32 handle.",
                    "The requested memory export type must have been specified when the allocation was made."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_WIN32_HANDLE",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] flags specifying the memory export type for the Win32 handle.\nmust be 0 (default) or a valid combination of ze_external_memory_type_flags_t\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[out] the exported Win32 handle representing the allocation.",
                        "name": "handle",
                        "type": "void*"
                    }
                ],
                "name": "ze_external_memory_export_win32_handle_t",
                "type": "struct",
                "version": "1.2"
            },
            "ze_external_memory_import_fd_t": {
                "base": "ze_base_desc_t",
                "class": "zeMem",
                "desc": "Additional allocation descriptor for importing external memory as a file descriptor",
                "details": [
                    "This structure may be passed to zeMemAllocDevice or zeMemAllocHost, via the `pNext` member of ze_device_mem_alloc_desc_t or of ze_host_mem_alloc_desc_t, respectively, to import memory from a file descriptor.",
                    "This structure may be passed to zeImageCreate, via the `pNext` member of ze_image_desc_t, to import memory from a file descriptor."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_FD",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] flags specifying the memory import type for the file descriptor.\nmust be 0 (default) or a valid combination of ze_external_memory_type_flags_t\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[in] the file descriptor handle to import",
                        "name": "fd",
                        "type": "int"
                    }
                ],
                "name": "ze_external_memory_import_fd_t",
                "type": "struct"
            },
            "ze_external_memory_import_win32_handle_t": {
                "base": "ze_base_desc_t",
                "class": "zeMem",
                "desc": "Additional allocation descriptor for importing external memory as a Win32 handle",
                "details": [
                    "When `handle` is `nullptr`, `name` must not be `nullptr`.",
                    "When `name` is `nullptr`, `handle` must not be `nullptr`.",
                    "When `flags` is ZE_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_WIN32_KMT, `name` must be `nullptr`.",
                    "This structure may be passed to zeMemAllocDevice or zeMemAllocHost, via the `pNext` member of ze_device_mem_alloc_desc_t or of ze_host_mem_alloc_desc_t, respectively, to import memory from a Win32 handle.",
                    "This structure may be passed to zeImageCreate, via the `pNext` member of ze_image_desc_t, to import memory from a Win32 handle."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_WIN32_HANDLE",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] flags specifying the memory import type for the Win32 handle.\nmust be 0 (default) or a valid combination of ze_external_memory_type_flags_t\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_external_memory_type_flags_t"
                    },
                    {
                        "desc": "[in][optional] the Win32 handle to import",
                        "name": "handle",
                        "type": "void*"
                    },
                    {
                        "desc": "[in][optional] name of a memory object to import",
                        "name": "name",
                        "type": "const void*"
                    }
                ],
                "name": "ze_external_memory_import_win32_handle_t",
                "type": "struct",
                "version": "1.2"
            },
            "ze_fabric_edge_exp_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeFabricEdge",
                "desc": "Fabric Edge properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_FABRIC_EDGE_EXP_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] universal unique identifier.",
                        "name": "uuid",
                        "type": "ze_uuid_t"
                    },
                    {
                        "desc": "[out] Description of fabric edge technology. Will be set to the string \"unkown\" if this cannot be determined for this edge",
                        "name": "model[ZE_MAX_FABRIC_EDGE_MODEL_EXP_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] design bandwidth",
                        "name": "bandwidth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] bandwidth unit",
                        "name": "bandwidthUnit",
                        "type": "ze_bandwidth_unit_t"
                    },
                    {
                        "desc": "[out] design latency",
                        "name": "latency",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] latency unit",
                        "name": "latencyUnit",
                        "type": "ze_latency_unit_t"
                    },
                    {
                        "desc": "[out] Duplexity of the fabric edge",
                        "name": "duplexity",
                        "type": "ze_fabric_edge_exp_duplexity_t"
                    }
                ],
                "name": "ze_fabric_edge_exp_properties_t",
                "type": "struct"
            },
            "ze_fabric_vertex_exp_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeFabricVertex",
                "desc": "Fabric Vertex properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_FABRIC_VERTEX_EXP_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] universal unique identifier. If the vertex is co-located with a device/subdevice, then this uuid will match that of the corresponding device/subdevice",
                        "name": "uuid",
                        "type": "ze_uuid_t"
                    },
                    {
                        "desc": "[out] does the fabric vertex represent a device, subdevice, or switch?",
                        "name": "type",
                        "type": "ze_fabric_vertex_exp_type_t"
                    },
                    {
                        "desc": "[out] does the fabric vertex live on the local node or on a remote node?",
                        "name": "remote",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] B/D/F address of fabric vertex & associated device/subdevice if available",
                        "name": "address",
                        "type": "ze_fabric_vertex_pci_exp_address_t"
                    }
                ],
                "name": "ze_fabric_vertex_exp_properties_t",
                "type": "struct",
                "version": "1.4"
            },
            "ze_fabric_vertex_pci_exp_address_t": {
                "class": "zeFabricVertex",
                "desc": "PCI address",
                "details": [
                    "A PCI BDF address is the bus:device:function address of the device and is useful for locating the device in the PCI switch fabric."
                ],
                "members": [
                    {
                        "desc": "[out] PCI domain number",
                        "name": "domain",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] PCI BDF bus number",
                        "name": "bus",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] PCI BDF device number",
                        "name": "device",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] PCI BDF function number",
                        "name": "function",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_fabric_vertex_pci_exp_address_t",
                "type": "struct",
                "version": "1.4"
            },
            "ze_fence_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeFence",
                "desc": "Fence descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_FENCE_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of ze_fence_flag_t.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_fence_flags_t"
                    }
                ],
                "name": "ze_fence_desc_t",
                "type": "struct"
            },
            "ze_float_atomic_ext_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Device floating-point atomic properties queried using zeDeviceGetModuleProperties",
                "details": [
                    "This structure may be returned from zeDeviceGetModuleProperties, via the `pNext` member of ze_device_module_properties_t."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_FLOAT_ATOMIC_EXT_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] Capabilities for half-precision floating-point atomic operations",
                        "name": "fp16Flags",
                        "type": "ze_device_fp_atomic_ext_flags_t"
                    },
                    {
                        "desc": "[out] Capabilities for single-precision floating-point atomic operations",
                        "name": "fp32Flags",
                        "type": "ze_device_fp_atomic_ext_flags_t"
                    },
                    {
                        "desc": "[out] Capabilities for double-precision floating-point atomic operations",
                        "name": "fp64Flags",
                        "type": "ze_device_fp_atomic_ext_flags_t"
                    }
                ],
                "name": "ze_float_atomic_ext_properties_t",
                "type": "struct",
                "version": "1.1"
            },
            "ze_group_count_t": {
                "class": "zeCommandList",
                "desc": "Kernel dispatch group count.",
                "members": [
                    {
                        "desc": "[in] number of thread groups in X dimension",
                        "init": "0",
                        "name": "groupCountX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] number of thread groups in Y dimension",
                        "init": "0",
                        "name": "groupCountY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] number of thread groups in Z dimension",
                        "init": "0",
                        "name": "groupCountZ",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_group_count_t",
                "type": "struct"
            },
            "ze_host_mem_alloc_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeMem",
                "desc": "Host memory allocation descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_HOST_MEM_ALLOC_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] flags specifying additional allocation controls.\nmust be 0 (default) or a valid combination of ze_host_mem_alloc_flag_t;\ndefault behavior may use implicit driver-based heuristics.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_host_mem_alloc_flags_t"
                    }
                ],
                "name": "ze_host_mem_alloc_desc_t",
                "type": "struct"
            },
            "ze_image_allocation_ext_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeImage",
                "desc": "Image allocation properties queried using zeImageGetAllocPropertiesExt",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_IMAGE_ALLOCATION_EXT_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] identifier for this allocation",
                        "name": "id",
                        "type": "uint64_t"
                    }
                ],
                "name": "ze_image_allocation_ext_properties_t",
                "type": "struct",
                "version": "1.3"
            },
            "ze_image_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeImage",
                "desc": "Image descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_IMAGE_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of ze_image_flag_t;\ndefault is read-only, cached access.\n",
                        "name": "flags",
                        "type": "ze_image_flags_t"
                    },
                    {
                        "desc": "[in] image type. Media format layouts are unsupported for ZE_IMAGE_TYPE_BUFFER",
                        "name": "type",
                        "type": "ze_image_type_t"
                    },
                    {
                        "desc": "[in] image format",
                        "name": "format",
                        "type": "ze_image_format_t"
                    },
                    {
                        "desc": "[in] width dimension.\nZE_IMAGE_TYPE_BUFFER: size in bytes; see the `maxImageBufferSize` member of ze_device_image_properties_t for limits.\nZE_IMAGE_TYPE_1D, ZE_IMAGE_TYPE_1DARRAY: width in pixels; see the `maxImageDims1D` member of ze_device_image_properties_t for limits.\nZE_IMAGE_TYPE_2D, ZE_IMAGE_TYPE_2DARRAY: width in pixels; see the `maxImageDims2D` member of ze_device_image_properties_t for limits.\nZE_IMAGE_TYPE_3D: width in pixels; see the `maxImageDims3D` member of ze_device_image_properties_t for limits.\n",
                        "init": "0",
                        "name": "width",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[in] height dimension.\nZE_IMAGE_TYPE_2D, ZE_IMAGE_TYPE_2DARRAY: height in pixels; see the `maxImageDims2D` member of ze_device_image_properties_t for limits.\nZE_IMAGE_TYPE_3D: height in pixels; see the `maxImageDims3D` member of ze_device_image_properties_t for limits.\nother: ignored.\n",
                        "init": "0",
                        "name": "height",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] depth dimension.\nZE_IMAGE_TYPE_3D: depth in pixels; see the `maxImageDims3D` member of ze_device_image_properties_t for limits.\nother: ignored.\n",
                        "init": "0",
                        "name": "depth",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] array levels.\nZE_IMAGE_TYPE_1DARRAY, ZE_IMAGE_TYPE_2DARRAY: see the `maxImageArraySlices` member of ze_device_image_properties_t for limits.\nother: ignored.\n",
                        "init": "1",
                        "name": "arraylevels",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] mipmap levels (must be 0)",
                        "init": "0",
                        "name": "miplevels",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_image_desc_t",
                "type": "struct"
            },
            "ze_image_format_t": {
                "class": "zeImage",
                "desc": "Image format ",
                "members": [
                    {
                        "desc": "[in] image format component layout (e.g. N-component layouts and media formats)",
                        "name": "layout",
                        "type": "ze_image_format_layout_t"
                    },
                    {
                        "desc": "[in] image format type",
                        "name": "type",
                        "type": "ze_image_format_type_t"
                    },
                    {
                        "desc": "[in] image component swizzle into channel x",
                        "name": "x",
                        "type": "ze_image_format_swizzle_t"
                    },
                    {
                        "desc": "[in] image component swizzle into channel y",
                        "name": "y",
                        "type": "ze_image_format_swizzle_t"
                    },
                    {
                        "desc": "[in] image component swizzle into channel z",
                        "name": "z",
                        "type": "ze_image_format_swizzle_t"
                    },
                    {
                        "desc": "[in] image component swizzle into channel w",
                        "name": "w",
                        "type": "ze_image_format_swizzle_t"
                    }
                ],
                "name": "ze_image_format_t",
                "type": "struct"
            },
            "ze_image_memory_properties_exp_t": {
                "base": "ze_base_desc_t",
                "class": "zeImage",
                "desc": "Image memory properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_IMAGE_MEMORY_PROPERTIES_EXP",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] size of image allocation in bytes.",
                        "name": "size",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] size of image row in bytes.",
                        "name": "rowPitch",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] size of image slice in bytes.",
                        "name": "slicePitch",
                        "type": "uint64_t"
                    }
                ],
                "name": "ze_image_memory_properties_exp_t",
                "type": "struct",
                "version": "1.2"
            },
            "ze_image_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeImage",
                "desc": "Image properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_IMAGE_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] supported sampler filtering.\nreturns 0 (unsupported) or a combination of ze_image_sampler_filter_flag_t.\n",
                        "name": "samplerFilterFlags",
                        "type": "ze_image_sampler_filter_flags_t"
                    }
                ],
                "name": "ze_image_properties_t",
                "type": "struct"
            },
            "ze_image_region_t": {
                "class": "zeCommandList",
                "desc": "Region descriptor",
                "members": [
                    {
                        "desc": "[in] The origin x offset for region in pixels",
                        "name": "originX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The origin y offset for region in pixels",
                        "name": "originY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The origin z offset for region in pixels",
                        "name": "originZ",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The region width relative to origin in pixels",
                        "name": "width",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The region height relative to origin in pixels",
                        "name": "height",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] The region depth relative to origin. For 1D or 2D images, set this to 1.",
                        "name": "depth",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_image_region_t",
                "type": "struct"
            },
            "ze_image_view_planar_exp_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeImage",
                "desc": "Image view planar descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_IMAGE_VIEW_PLANAR_EXP_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] the 0-based plane index (e.g. NV12 is 0 = Y plane, 1 UV plane)",
                        "name": "planeIndex",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_image_view_planar_exp_desc_t",
                "type": "struct",
                "version": "1.2"
            },
            "ze_image_view_planar_ext_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeImage",
                "desc": "Image view planar descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_IMAGE_VIEW_PLANAR_EXT_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] the 0-based plane index (e.g. NV12 is 0 = Y plane, 1 UV plane)",
                        "name": "planeIndex",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_image_view_planar_ext_desc_t",
                "type": "struct",
                "version": "1.5"
            },
            "ze_ipc_event_pool_handle_t": {
                "desc": "IPC handle to a event pool allocation",
                "members": [
                    {
                        "desc": "[out] Opaque data representing an IPC handle",
                        "name": "data[ZE_MAX_IPC_HANDLE_SIZE]",
                        "type": "char"
                    }
                ],
                "name": "ze_ipc_event_pool_handle_t",
                "type": "struct"
            },
            "ze_ipc_mem_handle_t": {
                "desc": "IPC handle to a memory allocation",
                "members": [
                    {
                        "desc": "[out] Opaque data representing an IPC handle",
                        "name": "data[ZE_MAX_IPC_HANDLE_SIZE]",
                        "type": "char"
                    }
                ],
                "name": "ze_ipc_mem_handle_t",
                "type": "struct"
            },
            "ze_kernel_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeKernel",
                "desc": "Kernel descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_KERNEL_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of ze_kernel_flag_t;\ndefault behavior may use driver-based residency.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_kernel_flags_t"
                    },
                    {
                        "desc": "[in] null-terminated name of kernel in module",
                        "init": "nullptr",
                        "name": "pKernelName",
                        "type": "const char*"
                    }
                ],
                "name": "ze_kernel_desc_t",
                "type": "struct"
            },
            "ze_kernel_max_group_size_properties_ext_t": {
                "base": "ze_base_properties_t",
                "class": "zeKernel",
                "desc": "Additional kernel max group size properties",
                "details": [
                    "This structure may be passed to zeKernelGetProperties, via the `pNext` member of ze_kernel_properties_t, to query additional kernel max group size properties."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_KERNEL_MAX_GROUP_SIZE_PROPERTIES_EXT",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] maximum group size that can be used to execute the kernel. This value may be less than or equal to the `maxTotalGroupSize` member of ze_device_compute_properties_t.",
                        "name": "maxGroupSize",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_kernel_max_group_size_properties_ext_t",
                "type": "struct",
                "version": "1.5"
            },
            "ze_kernel_preferred_group_size_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeKernel",
                "desc": "Additional kernel preferred group size properties",
                "details": [
                    "This structure may be passed to zeKernelGetProperties, via the `pNext` member of ze_kernel_properties_t, to query additional kernel preferred group size properties."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_KERNEL_PREFERRED_GROUP_SIZE_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] preferred group size multiple",
                        "name": "preferredMultiple",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_kernel_preferred_group_size_properties_t",
                "type": "struct",
                "version": "1.2"
            },
            "ze_kernel_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeKernel",
                "desc": "Kernel properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_KERNEL_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] number of kernel arguments.",
                        "name": "numKernelArgs",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] required group size in the X dimension,\nor zero if there is no required group size\n",
                        "name": "requiredGroupSizeX",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] required group size in the Y dimension,\nor zero if there is no required group size\n",
                        "name": "requiredGroupSizeY",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] required group size in the Z dimension,\nor zero if there is no required group size\n",
                        "name": "requiredGroupSizeZ",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] required number of subgroups per thread group,\nor zero if there is no required number of subgroups\n",
                        "name": "requiredNumSubGroups",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] required subgroup size,\nor zero if there is no required subgroup size\n",
                        "name": "requiredSubgroupSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] maximum subgroup size",
                        "name": "maxSubgroupSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] maximum number of subgroups per thread group",
                        "name": "maxNumSubgroups",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] local memory size used by each thread group",
                        "name": "localMemSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] private memory size allocated by compiler used by each thread",
                        "name": "privateMemSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] spill memory size allocated by compiler",
                        "name": "spillMemSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] universal unique identifier.",
                        "name": "uuid",
                        "type": "ze_kernel_uuid_t"
                    }
                ],
                "name": "ze_kernel_properties_t",
                "type": "struct"
            },
            "ze_kernel_timestamp_data_t": {
                "class": "zeEvent",
                "desc": "Kernel timestamp clock data",
                "details": [
                    "The timestamp frequency can be queried from the `timerResolution` member of ze_device_properties_t.",
                    "The number of valid bits in the timestamp value can be queried from the `kernelTimestampValidBits` member of ze_device_properties_t."
                ],
                "members": [
                    {
                        "desc": "[out] device clock at start of kernel execution",
                        "name": "kernelStart",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] device clock at end of kernel execution",
                        "name": "kernelEnd",
                        "type": "uint64_t"
                    }
                ],
                "name": "ze_kernel_timestamp_data_t",
                "type": "struct"
            },
            "ze_kernel_timestamp_result_t": {
                "class": "zeEvent",
                "desc": "Kernel timestamp result",
                "members": [
                    {
                        "desc": "[out] wall-clock data",
                        "name": "global",
                        "type": "ze_kernel_timestamp_data_t"
                    },
                    {
                        "desc": "[out] context-active data; only includes clocks while device context was actively executing.",
                        "name": "context",
                        "type": "ze_kernel_timestamp_data_t"
                    }
                ],
                "name": "ze_kernel_timestamp_result_t",
                "type": "struct"
            },
            "ze_kernel_uuid_t": {
                "desc": "Kernel universal unique id (UUID)",
                "members": [
                    {
                        "desc": "[out] opaque data representing a kernel UUID",
                        "name": "kid[ZE_MAX_KERNEL_UUID_SIZE]",
                        "type": "uint8_t"
                    },
                    {
                        "desc": "[out] opaque data representing the kernel's module UUID",
                        "name": "mid[ZE_MAX_MODULE_UUID_SIZE]",
                        "type": "uint8_t"
                    }
                ],
                "name": "ze_kernel_uuid_t",
                "type": "struct"
            },
            "ze_linkage_inspection_ext_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeModule",
                "desc": "Module linkage inspection descriptor",
                "details": [
                    "This structure may be passed to zeModuleInspectLinkageExt."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_LINKAGE_INSPECTION_EXT_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] flags specifying module linkage inspection.\nmust be 0 (default) or a valid combination of ze_linkage_inspection_ext_flag_t.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_linkage_inspection_ext_flags_t"
                    }
                ],
                "name": "ze_linkage_inspection_ext_desc_t",
                "type": "struct",
                "version": "1.3"
            },
            "ze_memory_allocation_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeMem",
                "desc": "Memory allocation properties queried using zeMemGetAllocProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_MEMORY_ALLOCATION_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] type of allocated memory",
                        "name": "type",
                        "type": "ze_memory_type_t"
                    },
                    {
                        "desc": "[out] identifier for this allocation",
                        "name": "id",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] page size used for allocation",
                        "name": "pageSize",
                        "type": "uint64_t"
                    }
                ],
                "name": "ze_memory_allocation_properties_t",
                "type": "struct"
            },
            "ze_memory_compression_hints_ext_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeMem",
                "desc": "Compression hints memory allocation descriptor",
                "details": [
                    "This structure may be passed to zeMemAllocShared or zeMemAllocDevice, via the `pNext` member of ze_device_mem_alloc_desc_t.",
                    "This structure may be passed to zeMemAllocHost, via the `pNext` member of ze_host_mem_alloc_desc_t.",
                    "This structure may be passed to zeImageCreate, via the `pNext` member of ze_image_desc_t."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_MEMORY_COMPRESSION_HINTS_EXT_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] flags specifying if allocation should be compressible or not.\nMust be set to one of the ze_memory_compression_hints_ext_flag_t;\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_memory_compression_hints_ext_flags_t"
                    }
                ],
                "name": "ze_memory_compression_hints_ext_desc_t",
                "type": "struct",
                "version": "1.3"
            },
            "ze_memory_free_ext_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeMem",
                "desc": "Memory free descriptor with free policy",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_MEMORY_FREE_EXT_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] flags specifying the memory free policy.\nmust be 0 (default) or a supported ze_driver_memory_free_policy_ext_flag_t;\ndefault behavior is to free immediately.\n",
                        "name": "freePolicy",
                        "type": "ze_driver_memory_free_policy_ext_flags_t"
                    }
                ],
                "name": "ze_memory_free_ext_desc_t",
                "type": "struct",
                "version": "1.3"
            },
            "ze_memory_sub_allocations_exp_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeMem",
                "desc": "Sub-Allocations Properties",
                "details": [
                    "This structure may be passed to zeMemGetAllocProperties, via the `pNext` member of ze_memory_allocation_properties_t."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_MEMORY_SUB_ALLOCATIONS_EXP_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[in,out] pointer to the number of sub-allocations.\nif count is zero, then the driver shall update the value with the total number of sub-allocations on which the allocation has been divided.\nif count is greater than the number of sub-allocations, then the driver shall update the value with the correct number of sub-allocations.\n",
                        "name": "pCount",
                        "type": "uint32_t*"
                    },
                    {
                        "desc": "[in,out][optional][range(0, *pCount)] array of properties for sub-allocations.\nif count is less than the number of sub-allocations available, then driver shall only retrieve properties for that number of sub-allocations.\n",
                        "name": "pSubAllocations",
                        "type": "ze_sub_allocation_t*"
                    }
                ],
                "name": "ze_memory_sub_allocations_exp_properties_t",
                "type": "struct",
                "version": "1.5"
            },
            "ze_module_constants_t": {
                "class": "zeModule",
                "desc": "Specialization constants - User defined constants",
                "members": [
                    {
                        "desc": "[in] Number of specialization constants.",
                        "name": "numConstants",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, numConstants)] Array of IDs that is sized to numConstants.",
                        "name": "pConstantIds",
                        "type": "const uint32_t*"
                    },
                    {
                        "desc": "[in][range(0, numConstants)] Array of pointers to values that is sized to numConstants.",
                        "name": "pConstantValues",
                        "type": "const void**"
                    }
                ],
                "name": "ze_module_constants_t",
                "type": "struct"
            },
            "ze_module_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeModule",
                "desc": "Module descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_MODULE_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] Module format passed in with pInputModule",
                        "name": "format",
                        "type": "ze_module_format_t"
                    },
                    {
                        "desc": "[in] size of input IL or ISA from pInputModule.",
                        "init": "0",
                        "name": "inputSize",
                        "type": "size_t"
                    },
                    {
                        "desc": "[in] pointer to IL or ISA",
                        "init": "nullptr",
                        "name": "pInputModule",
                        "type": "const uint8_t*"
                    },
                    {
                        "desc": "[in][optional] string containing one or more (comma-separated) compiler flags. If unsupported, flag is ignored with a warning.\n  - \"-ze-opt-disable\"\n       - Disable optimizations\n  - \"-ze-opt-level\"\n       - Specifies optimization level for compiler. Levels are implementation specific.\n           - 0 is no optimizations (equivalent to -ze-opt-disable)\n           - 1 is optimize minimally (may be the same as 2)\n           - 2 is optimize more (default)\n  - \"-ze-opt-greater-than-4GB-buffer-required\"\n       - Use 64-bit offset calculations for buffers.\n  - \"-ze-opt-large-register-file\"\n       - Increase number of registers available to threads.\n  - \"-ze-opt-has-buffer-offset-arg\"\n       - Extend stateless to stateful optimization to more\n         cases with the use of additional offset (e.g. 64-bit\n         pointer to binding table with 32-bit offset).\n  - \"-g\"\n       - Include debugging information.\n",
                        "init": "nullptr",
                        "name": "pBuildFlags",
                        "type": "const char*"
                    },
                    {
                        "desc": "[in][optional] pointer to specialization constants. Valid only for SPIR-V input. This must be set to nullptr if no specialization constants are provided.",
                        "init": "nullptr",
                        "name": "pConstants",
                        "type": "const ze_module_constants_t*"
                    }
                ],
                "name": "ze_module_desc_t",
                "type": "struct"
            },
            "ze_module_program_exp_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeModule",
                "desc": "Module extended descriptor to support multiple input modules.",
                "details": [
                    "Implementation must support ZE_experimental_module_program extension",
                    "Modules support import and export linkage for functions and global variables.",
                    "SPIR-V import and export linkage types are used. See SPIR-V specification for linkage details.",
                    "pInputModules, pBuildFlags, and pConstants from ze_module_desc_t is ignored.",
                    "Format in ze_module_desc_t needs to be set to ZE_MODULE_FORMAT_IL_SPIRV."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_MODULE_PROGRAM_EXP_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] Count of input modules",
                        "name": "count",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in][range(0, count)] sizes of each input IL module in pInputModules.",
                        "name": "inputSizes",
                        "type": "const size_t*"
                    },
                    {
                        "desc": "[in][range(0, count)] pointer to an array of IL (e.g. SPIR-V modules). Valid only for SPIR-V input.",
                        "init": "nullptr",
                        "name": "pInputModules",
                        "type": "const uint8_t**"
                    },
                    {
                        "desc": "[in][optional][range(0, count)] array of strings containing build flags. See pBuildFlags in ze_module_desc_t.",
                        "init": "nullptr",
                        "name": "pBuildFlags",
                        "type": "const char**"
                    },
                    {
                        "desc": "[in][optional][range(0, count)] pointer to array of specialization constant strings. Valid only for SPIR-V input. This must be set to nullptr if no specialization constants are provided.",
                        "init": "nullptr",
                        "name": "pConstants",
                        "type": "const ze_module_constants_t**"
                    }
                ],
                "name": "ze_module_program_exp_desc_t",
                "type": "struct"
            },
            "ze_module_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeModule",
                "desc": "Module properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_MODULE_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] 0 (none) or a valid combination of ze_module_property_flag_t",
                        "name": "flags",
                        "type": "ze_module_property_flags_t"
                    }
                ],
                "name": "ze_module_properties_t",
                "type": "struct"
            },
            "ze_native_kernel_uuid_t": {
                "class": "zeDevice",
                "desc": "Native kernel universal unique id (UUID)",
                "members": [
                    {
                        "desc": "[out] opaque data representing a native kernel UUID",
                        "name": "id[ZE_MAX_NATIVE_KERNEL_UUID_SIZE]",
                        "type": "uint8_t"
                    }
                ],
                "name": "ze_native_kernel_uuid_t",
                "type": "struct"
            },
            "ze_pci_address_ext_t": {
                "class": "zeDevice",
                "desc": "Device PCI address",
                "details": [
                    "This structure may be passed to zeDevicePciGetPropertiesExt as an attribute of ze_pci_ext_properties_t.",
                    "A PCI BDF address is the bus:device:function address of the device and is useful for locating the device in the PCI switch fabric."
                ],
                "members": [
                    {
                        "desc": "[out] PCI domain number",
                        "name": "domain",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] PCI BDF bus number",
                        "name": "bus",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] PCI BDF device number",
                        "name": "device",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] PCI BDF function number",
                        "name": "function",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_pci_address_ext_t",
                "type": "struct",
                "version": "1.3"
            },
            "ze_pci_ext_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Static PCI properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_PCI_EXT_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] The BDF address",
                        "name": "address",
                        "type": "ze_pci_address_ext_t"
                    },
                    {
                        "desc": "[out] Fastest port configuration supported by the device (sum of all lanes)",
                        "name": "maxSpeed",
                        "type": "ze_pci_speed_ext_t"
                    }
                ],
                "name": "ze_pci_ext_properties_t",
                "type": "struct"
            },
            "ze_pci_speed_ext_t": {
                "class": "zeDevice",
                "desc": "Device PCI speed",
                "members": [
                    {
                        "desc": "[out] The link generation. A value of -1 means that this property is unknown.",
                        "name": "genVersion",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The number of lanes. A value of -1 means that this property is unknown.",
                        "name": "width",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The theoretical maximum bandwidth in bytes/sec (sum of all lanes). A value of -1 means that this property is unknown.",
                        "name": "maxBandwidth",
                        "type": "int64_t"
                    }
                ],
                "name": "ze_pci_speed_ext_t",
                "type": "struct",
                "version": "1.3"
            },
            "ze_physical_mem_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zePhysicalMem",
                "desc": "Physical memory descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_PHYSICAL_MEM_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of ze_physical_mem_flag_t.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_physical_mem_flags_t"
                    },
                    {
                        "desc": "[in] size in bytes to reserve; must be page aligned.",
                        "name": "size",
                        "type": "size_t"
                    }
                ],
                "name": "ze_physical_mem_desc_t",
                "type": "struct"
            },
            "ze_raytracing_mem_alloc_ext_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeContext",
                "desc": "Raytracing memory allocation descriptor",
                "details": [
                    "This structure must be passed to zeMemAllocShared or zeMemAllocDevice, via the `pNext` member of ze_device_mem_alloc_desc_t, for any memory allocation that is to be accessed by raytracing fixed-function of the device."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_RAYTRACING_MEM_ALLOC_EXT_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] flags specifying additional allocation controls.\nmust be 0 (default) or a valid combination of ze_raytracing_mem_alloc_ext_flag_t;\ndefault behavior may use implicit driver-based heuristics.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_raytracing_mem_alloc_ext_flags_t"
                    }
                ],
                "name": "ze_raytracing_mem_alloc_ext_desc_t",
                "type": "struct",
                "version": "1.0"
            },
            "ze_relaxed_allocation_limits_exp_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeMem",
                "desc": "Relaxed limits memory allocation descriptor",
                "details": [
                    "This structure may be passed to zeMemAllocShared or zeMemAllocDevice, via the `pNext` member of ze_device_mem_alloc_desc_t.",
                    "This structure may also be passed to zeMemAllocHost, via the `pNext` member of ze_host_mem_alloc_desc_t."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_RELAXED_ALLOCATION_LIMITS_EXP_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] flags specifying allocation limits to relax.\nmust be 0 (default) or a valid combination of ze_relaxed_allocation_limits_exp_flag_t;\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_relaxed_allocation_limits_exp_flags_t"
                    }
                ],
                "name": "ze_relaxed_allocation_limits_exp_desc_t",
                "type": "struct",
                "version": "1.1"
            },
            "ze_rtas_aabb_exp_t": {
                "desc": "A 3-dimensional axis-aligned bounding-box with lower and upper bounds in each dimension",
                "members": [
                    {
                        "desc": "[in] lower bounds of AABB",
                        "name": "lower",
                        "type": "ze_rtas_float3_exp_t"
                    },
                    {
                        "desc": "[in] upper bounds of AABB",
                        "name": "upper",
                        "type": "ze_rtas_float3_exp_t"
                    }
                ],
                "name": "ze_rtas_aabb_exp_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_builder_build_op_exp_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeRTASBuilder",
                "desc": "",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_RTAS_BUILDER_BUILD_OP_EXP_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] ray tracing acceleration structure format",
                        "name": "rtasFormat",
                        "type": "ze_rtas_format_exp_t"
                    },
                    {
                        "desc": "[in] acceleration structure build quality hint",
                        "name": "buildQuality",
                        "type": "ze_rtas_builder_build_quality_hint_exp_t"
                    },
                    {
                        "desc": "[in] 0 or some combination of ze_rtas_builder_build_op_exp_flag_t flags",
                        "name": "buildFlags",
                        "type": "ze_rtas_builder_build_op_exp_flags_t"
                    },
                    {
                        "desc": "[in][optional][range(0, `numGeometries`)] NULL or a valid array of pointers to geometry infos",
                        "name": "ppGeometries",
                        "type": "const ze_rtas_builder_geometry_info_exp_t**"
                    },
                    {
                        "desc": "[in] number of geometries in geometry infos array, can be zero when `ppGeometries` is NULL",
                        "name": "numGeometries",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_rtas_builder_build_op_exp_desc_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_builder_exp_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure builder descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_RTAS_BUILDER_EXP_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] ray tracing acceleration structure builder version",
                        "name": "builderVersion",
                        "type": "ze_rtas_builder_exp_version_t"
                    }
                ],
                "name": "ze_rtas_builder_exp_desc_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_builder_exp_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure builder properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_RTAS_BUILDER_EXP_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] ray tracing acceleration structure builder flags",
                        "name": "flags",
                        "type": "ze_rtas_builder_exp_flags_t"
                    },
                    {
                        "desc": "[out] expected size (in bytes) required for acceleration structure buffer\n    - When using an acceleration structure buffer of this size, the build is expected to succeed; however, it is possible that the build may fail with ZE_RESULT_EXP_RTAS_BUILD_RETRY\n",
                        "name": "rtasBufferSizeBytesExpected",
                        "type": "size_t"
                    },
                    {
                        "desc": "[out] worst-case size (in bytes) required for acceleration structure buffer\n    - When using an acceleration structure buffer of this size, the build is guaranteed to not run out of memory.\n",
                        "name": "rtasBufferSizeBytesMaxRequired",
                        "type": "size_t"
                    },
                    {
                        "desc": "[out] scratch buffer size (in bytes) required for acceleration structure build.",
                        "name": "scratchBufferSizeBytes",
                        "type": "size_t"
                    }
                ],
                "name": "ze_rtas_builder_exp_properties_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_builder_geometry_info_exp_t": {
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure builder geometry info",
                "members": [
                    {
                        "desc": "[in] geometry type",
                        "name": "geometryType",
                        "type": "ze_rtas_builder_packed_geometry_type_exp_t"
                    }
                ],
                "name": "ze_rtas_builder_geometry_info_exp_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_builder_instance_geometry_info_exp_t": {
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure builder instance geometry info",
                "members": [
                    {
                        "desc": "[in] geometry type, must be ZE_RTAS_BUILDER_GEOMETRY_TYPE_EXP_INSTANCE",
                        "name": "geometryType",
                        "type": "ze_rtas_builder_packed_geometry_type_exp_t"
                    },
                    {
                        "desc": "[in] 0 or some combination of ze_rtas_builder_geometry_exp_flag_t bits representing the geometry flags for all primitives of this geometry",
                        "name": "instanceFlags",
                        "type": "ze_rtas_builder_packed_instance_exp_flags_t"
                    },
                    {
                        "desc": "[in] 8-bit geometry mask for ray masking",
                        "name": "geometryMask",
                        "type": "uint8_t"
                    },
                    {
                        "desc": "[in] format of the specified transformation",
                        "name": "transformFormat",
                        "type": "ze_rtas_builder_packed_input_data_format_exp_t"
                    },
                    {
                        "desc": "[in] user-specified identifier for the instance",
                        "name": "instanceUserID",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] object-to-world instance transformation in specified format",
                        "name": "pTransform",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] object-space axis-aligned bounding-box of the instanced acceleration structure",
                        "name": "pBounds",
                        "type": "ze_rtas_aabb_exp_t*"
                    },
                    {
                        "desc": "[in] pointer to acceleration structure to instantiate",
                        "name": "pAccelerationStructure",
                        "type": "void*"
                    }
                ],
                "name": "ze_rtas_builder_instance_geometry_info_exp_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_builder_procedural_geometry_info_exp_t": {
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure builder procedural primitives geometry info",
                "details": [
                    "A host-side bounds callback function is invoked by the acceleration structure builder to query the bounds of procedural primitives on demand. The callback is passed some `pGeomUserPtr` that can point to an application-side representation of the procedural primitives. Further, a second `pBuildUserPtr`, which is set by a parameter to zeRTASBuilderBuildExp, is passed to the callback. This allows the build to change the bounds of the procedural geometry, for example, to build a BVH only over a short time range to implement multi-segment motion blur.\n"
                ],
                "members": [
                    {
                        "desc": "[in] geometry type, must be ZE_RTAS_BUILDER_GEOMETRY_TYPE_EXP_PROCEDURAL",
                        "name": "geometryType",
                        "type": "ze_rtas_builder_packed_geometry_type_exp_t"
                    },
                    {
                        "desc": "[in] 0 or some combination of ze_rtas_builder_geometry_exp_flag_t bits representing the geometry flags for all primitives of this geometry",
                        "name": "geometryFlags",
                        "type": "ze_rtas_builder_packed_geometry_exp_flags_t"
                    },
                    {
                        "desc": "[in] 8-bit geometry mask for ray masking",
                        "name": "geometryMask",
                        "type": "uint8_t"
                    },
                    {
                        "desc": "[in] reserved for future use",
                        "name": "reserved",
                        "type": "uint8_t"
                    },
                    {
                        "desc": "[in] number of primitives in geometry",
                        "name": "primCount",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] pointer to callback function to get the axis-aligned bounding-box for a range of primitives",
                        "name": "pfnGetBoundsCb",
                        "type": "ze_rtas_geometry_aabbs_cb_exp_t"
                    },
                    {
                        "desc": "[in] user data pointer passed to callback",
                        "name": "pGeomUserPtr",
                        "type": "void*"
                    }
                ],
                "name": "ze_rtas_builder_procedural_geometry_info_exp_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_builder_quads_geometry_info_exp_t": {
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure builder quad mesh geometry info",
                "details": [
                    "A quad is a triangle pair represented using 4 vertex indices v0, v1, v2, v3.\nThe first triangle is made out of indices v0, v1, v3 and the second triangle\nfrom indices v2, v3, v1. The piecewise linear barycentric u/v parametrization\nof the quad is defined as:\n    - (u=0, v=0) at v0,\n    - (u=1, v=0) at v1,\n    - (u=0, v=1) at v3, and\n    - (u=1, v=1) at v2\nThis is achieved by correcting the u'/v' coordinates of the second triangle by\n*u = 1-u'* and *v = 1-v'*, yielding a piecewise linear parametrization.\n"
                ],
                "members": [
                    {
                        "desc": "[in] geometry type, must be ZE_RTAS_BUILDER_GEOMETRY_TYPE_EXP_QUADS",
                        "name": "geometryType",
                        "type": "ze_rtas_builder_packed_geometry_type_exp_t"
                    },
                    {
                        "desc": "[in] 0 or some combination of ze_rtas_builder_geometry_exp_flag_t bits representing the geometry flags for all primitives of this geometry",
                        "name": "geometryFlags",
                        "type": "ze_rtas_builder_packed_geometry_exp_flags_t"
                    },
                    {
                        "desc": "[in] 8-bit geometry mask for ray masking",
                        "name": "geometryMask",
                        "type": "uint8_t"
                    },
                    {
                        "desc": "[in] format of quad buffer data, must be ZE_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_QUAD_INDICES_UINT32",
                        "name": "quadFormat",
                        "type": "ze_rtas_builder_packed_input_data_format_exp_t"
                    },
                    {
                        "desc": "[in] format of vertex buffer data, must be ZE_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3",
                        "name": "vertexFormat",
                        "type": "ze_rtas_builder_packed_input_data_format_exp_t"
                    },
                    {
                        "desc": "[in] number of quads in quad buffer",
                        "name": "quadCount",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] number of vertices in vertex buffer",
                        "name": "vertexCount",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] stride (in bytes) of quads in quad buffer",
                        "name": "quadStride",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] stride (in bytes) of vertices in vertex buffer",
                        "name": "vertexStride",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] pointer to array of quad indices in specified format",
                        "name": "pQuadBuffer",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] pointer to array of quad vertices in specified format",
                        "name": "pVertexBuffer",
                        "type": "void*"
                    }
                ],
                "name": "ze_rtas_builder_quads_geometry_info_exp_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_builder_triangles_geometry_info_exp_t": {
                "class": "zeRTASBuilder",
                "desc": "Ray tracing acceleration structure builder triangle mesh geometry info",
                "details": [
                    "The linear barycentric u/v parametrization of the triangle is defined as:\n    - (u=0, v=0) at v0,\n    - (u=1, v=0) at v1, and\n    - (u=0, v=1) at v2\n"
                ],
                "members": [
                    {
                        "desc": "[in] geometry type, must be ZE_RTAS_BUILDER_GEOMETRY_TYPE_EXP_TRIANGLES",
                        "name": "geometryType",
                        "type": "ze_rtas_builder_packed_geometry_type_exp_t"
                    },
                    {
                        "desc": "[in] 0 or some combination of ze_rtas_builder_geometry_exp_flag_t bits representing the geometry flags for all primitives of this geometry",
                        "name": "geometryFlags",
                        "type": "ze_rtas_builder_packed_geometry_exp_flags_t"
                    },
                    {
                        "desc": "[in] 8-bit geometry mask for ray masking",
                        "name": "geometryMask",
                        "type": "uint8_t"
                    },
                    {
                        "desc": "[in] format of triangle buffer data, must be ZE_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_TRIANGLE_INDICES_UINT32",
                        "name": "triangleFormat",
                        "type": "ze_rtas_builder_packed_input_data_format_exp_t"
                    },
                    {
                        "desc": "[in] format of vertex buffer data, must be ZE_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3",
                        "name": "vertexFormat",
                        "type": "ze_rtas_builder_packed_input_data_format_exp_t"
                    },
                    {
                        "desc": "[in] number of triangles in triangle buffer",
                        "name": "triangleCount",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] number of vertices in vertex buffer",
                        "name": "vertexCount",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] stride (in bytes) of triangles in triangle buffer",
                        "name": "triangleStride",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] stride (in bytes) of vertices in vertex buffer",
                        "name": "vertexStride",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] pointer to array of triangle indices in specified format",
                        "name": "pTriangleBuffer",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] pointer to array of triangle vertices in specified format",
                        "name": "pVertexBuffer",
                        "type": "void*"
                    }
                ],
                "name": "ze_rtas_builder_triangles_geometry_info_exp_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_device_exp_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Ray tracing acceleration structure device properties",
                "details": [
                    "This structure may be passed to zeDeviceGetProperties, via `pNext` member of ze_device_properties_t.",
                    "The implementation shall populate `format` with a value other than ZE_RTAS_FORMAT_EXP_INVALID when the device supports ray tracing."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_RTAS_DEVICE_EXP_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] ray tracing acceleration structure device flags",
                        "name": "flags",
                        "type": "ze_rtas_device_exp_flags_t"
                    },
                    {
                        "desc": "[out] ray tracing acceleration structure format",
                        "name": "rtasFormat",
                        "type": "ze_rtas_format_exp_t"
                    },
                    {
                        "desc": "[out] required alignment of acceleration structure buffer",
                        "name": "rtasBufferAlignment",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_rtas_device_exp_properties_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_float3_exp_t": {
                "desc": "A 3-component vector type",
                "members": [
                    {
                        "desc": "[in] x-coordinate of float3 vector",
                        "name": "x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] y-coordinate of float3 vector",
                        "name": "y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] z-coordinate of float3 vector",
                        "name": "z",
                        "type": "float"
                    }
                ],
                "name": "ze_rtas_float3_exp_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_geometry_aabbs_exp_cb_params_t": {
                "base": "ze_base_cb_params_t",
                "desc": "AABB callback function parameters",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_RTAS_GEOMETRY_AABBS_EXP_CB_PARAMS",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] first primitive to return bounds for",
                        "name": "primID",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] number of primitives to return bounds for",
                        "name": "primIDCount",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] pointer provided through geometry descriptor",
                        "name": "pGeomUserPtr",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] pointer provided through zeRTASBuilderBuildExp function",
                        "name": "pBuildUserPtr",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] destination buffer to write AABB bounds to",
                        "name": "pBoundsOut",
                        "type": "ze_rtas_aabb_exp_t*"
                    }
                ],
                "name": "ze_rtas_geometry_aabbs_exp_cb_params_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_parallel_operation_exp_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeRTASParallelOperation",
                "desc": "Ray tracing acceleration structure builder parallel operation properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_RTAS_PARALLEL_OPERATION_EXP_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] ray tracing acceleration structure builder parallel operation flags",
                        "name": "flags",
                        "type": "ze_rtas_parallel_operation_exp_flags_t"
                    },
                    {
                        "desc": "[out] maximum number of threads that may join the parallel operation",
                        "name": "maxConcurrency",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_rtas_parallel_operation_exp_properties_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_quad_indices_uint32_exp_t": {
                "desc": "Quad represented using 4 vertex indices",
                "details": [
                    "Represents a quad composed of 4 indices that index into a vertex array that needs to be provided together with the index array.",
                    "A quad is a triangle pair represented using 4 vertex indices v0, v1, v2, v3.\nThe first triangle is made out of indices v0, v1, v3 and the second triangle\nfrom indices v2, v3, v1. The piecewise linear barycentric u/v parametrization\nof the quad is defined as:\n    - (u=0, v=0) at v0,\n    - (u=1, v=0) at v1,\n    - (u=0, v=1) at v3, and\n    - (u=1, v=1) at v2\nThis is achieved by correcting the u'/v' coordinates of the second triangle by\n*u = 1-u'* and *v = 1-v'*, yielding a piecewise linear parametrization.\n"
                ],
                "members": [
                    {
                        "desc": "[in] first index pointing to the first quad vertex in vertex array",
                        "name": "v0",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] second index pointing to the second quad vertex in vertex array",
                        "name": "v1",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] third index pointing to the third quad vertex in vertex array",
                        "name": "v2",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] fourth index pointing to the fourth quad vertex in vertex array",
                        "name": "v3",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_rtas_quad_indices_uint32_exp_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_transform_float3x4_aligned_column_major_exp_t": {
                "desc": "3x4 affine transformation in column-major layout with aligned column vectors",
                "details": [
                    "A 3x4 affine transformation in column major layout, consisting of vectors\n  - vx=(vx_x, vx_y, vx_z),\n  - vy=(vy_x, vy_y, vy_z),\n  - vz=(vz_x, vz_y, vz_z), and\n  - p=(p_x, p_y, p_z)\n",
                    "The transformation transforms a point (x, y, z) to: `x*vx + y*vy + z*vz + p`.",
                    "The column vectors are aligned to 16-bytes and pad members are ignored."
                ],
                "members": [
                    {
                        "desc": "[in] element 0 of column 0 of 3x4 matrix",
                        "name": "vx_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 0 of 3x4 matrix",
                        "name": "vx_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 0 of 3x4 matrix",
                        "name": "vx_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] ignored padding",
                        "name": "pad0",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of column 1 of 3x4 matrix",
                        "name": "vy_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 1 of 3x4 matrix",
                        "name": "vy_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 1 of 3x4 matrix",
                        "name": "vy_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] ignored padding",
                        "name": "pad1",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of column 2 of 3x4 matrix",
                        "name": "vz_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 2 of 3x4 matrix",
                        "name": "vz_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 2 of 3x4 matrix",
                        "name": "vz_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] ignored padding",
                        "name": "pad2",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of column 3 of 3x4 matrix",
                        "name": "p_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 3 of 3x4 matrix",
                        "name": "p_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 3 of 3x4 matrix",
                        "name": "p_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] ignored padding",
                        "name": "pad3",
                        "type": "float"
                    }
                ],
                "name": "ze_rtas_transform_float3x4_aligned_column_major_exp_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_transform_float3x4_column_major_exp_t": {
                "desc": "3x4 affine transformation in column-major layout",
                "details": [
                    "A 3x4 affine transformation in column major layout, consisting of vectors\n    - vx=(vx_x, vx_y, vx_z),\n    - vy=(vy_x, vy_y, vy_z),\n    - vz=(vz_x, vz_y, vz_z), and\n    - p=(p_x, p_y, p_z)\n",
                    "The transformation transforms a point (x, y, z) to: `x*vx + y*vy + z*vz + p`."
                ],
                "members": [
                    {
                        "desc": "[in] element 0 of column 0 of 3x4 matrix",
                        "name": "vx_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 0 of 3x4 matrix",
                        "name": "vx_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 0 of 3x4 matrix",
                        "name": "vx_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of column 1 of 3x4 matrix",
                        "name": "vy_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 1 of 3x4 matrix",
                        "name": "vy_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 1 of 3x4 matrix",
                        "name": "vy_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of column 2 of 3x4 matrix",
                        "name": "vz_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 2 of 3x4 matrix",
                        "name": "vz_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 2 of 3x4 matrix",
                        "name": "vz_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of column 3 of 3x4 matrix",
                        "name": "p_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of column 3 of 3x4 matrix",
                        "name": "p_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of column 3 of 3x4 matrix",
                        "name": "p_z",
                        "type": "float"
                    }
                ],
                "name": "ze_rtas_transform_float3x4_column_major_exp_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_transform_float3x4_row_major_exp_t": {
                "desc": "3x4 affine transformation in row-major layout",
                "details": [
                    "A 3x4 affine transformation in row-major layout, consisting of vectors\n    - vx=(vx_x, vx_y, vx_z),\n    - vy=(vy_x, vy_y, vy_z),\n    - vz=(vz_x, vz_y, vz_z), and\n    - p=(p_x, p_y, p_z)\n",
                    "The transformation transforms a point (x, y, z) to: `x*vx + y*vy + z*vz + p`."
                ],
                "members": [
                    {
                        "desc": "[in] element 0 of row 0 of 3x4 matrix",
                        "name": "vx_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of row 0 of 3x4 matrix",
                        "name": "vy_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of row 0 of 3x4 matrix",
                        "name": "vz_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 3 of row 0 of 3x4 matrix",
                        "name": "p_x",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of row 1 of 3x4 matrix",
                        "name": "vx_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of row 1 of 3x4 matrix",
                        "name": "vy_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of row 1 of 3x4 matrix",
                        "name": "vz_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 3 of row 1 of 3x4 matrix",
                        "name": "p_y",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 0 of row 2 of 3x4 matrix",
                        "name": "vx_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 1 of row 2 of 3x4 matrix",
                        "name": "vy_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 2 of row 2 of 3x4 matrix",
                        "name": "vz_z",
                        "type": "float"
                    },
                    {
                        "desc": "[in] element 3 of row 2 of 3x4 matrix",
                        "name": "p_z",
                        "type": "float"
                    }
                ],
                "name": "ze_rtas_transform_float3x4_row_major_exp_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_rtas_triangle_indices_uint32_exp_t": {
                "desc": "Triangle represented using 3 vertex indices",
                "details": [
                    "Represents a triangle using 3 vertex indices that index into a vertex array that needs to be provided together with the index array.",
                    "The linear barycentric u/v parametrization of the triangle is defined as:\n    - (u=0, v=0) at v0,\n    - (u=1, v=0) at v1, and\n    - (u=0, v=1) at v2\n"
                ],
                "members": [
                    {
                        "desc": "[in] first index pointing to the first triangle vertex in vertex array",
                        "name": "v0",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] second index pointing to the second triangle vertex in vertex array",
                        "name": "v1",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in] third index pointing to the third triangle vertex in vertex array",
                        "name": "v2",
                        "type": "uint32_t"
                    }
                ],
                "name": "ze_rtas_triangle_indices_uint32_exp_t",
                "type": "struct",
                "version": "1.7"
            },
            "ze_sampler_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeSampler",
                "desc": "Sampler descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_SAMPLER_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] Sampler addressing mode to determine how out-of-bounds coordinates are handled.",
                        "init": "ZE_SAMPLER_ADDRESS_MODE_NONE",
                        "name": "addressMode",
                        "type": "ze_sampler_address_mode_t"
                    },
                    {
                        "desc": "[in] Sampler filter mode to determine how samples are filtered.",
                        "init": "ZE_SAMPLER_FILTER_MODE_NEAREST",
                        "name": "filterMode",
                        "type": "ze_sampler_filter_mode_t"
                    },
                    {
                        "desc": "[in] Are coordinates normalized [0, 1] or not.",
                        "init": "true",
                        "name": "isNormalized",
                        "type": "ze_bool_t"
                    }
                ],
                "name": "ze_sampler_desc_t",
                "type": "struct"
            },
            "ze_scheduling_hint_exp_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeKernel",
                "desc": "Kernel scheduling hint descriptor",
                "details": [
                    "This structure may be passed to zeKernelSchedulingHintExp."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_SCHEDULING_HINT_EXP_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] flags specifying kernel scheduling hints.\nmust be 0 (default) or a valid combination of ze_scheduling_hint_exp_flag_t.\n",
                        "init": "0",
                        "name": "flags",
                        "type": "ze_scheduling_hint_exp_flags_t"
                    }
                ],
                "name": "ze_scheduling_hint_exp_desc_t",
                "type": "struct",
                "version": "1.2"
            },
            "ze_scheduling_hint_exp_properties_t": {
                "base": "ze_base_properties_t",
                "class": "zeDevice",
                "desc": "Device kernel scheduling hint properties queried using zeDeviceGetModuleProperties",
                "details": [
                    "This structure may be returned from zeDeviceGetModuleProperties, via the `pNext` member of ze_device_module_properties_t."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_SCHEDULING_HINT_EXP_PROPERTIES",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] Supported kernel scheduling hints.\nMay be 0 (none) or a valid combination of ze_scheduling_hint_exp_flag_t.\n",
                        "name": "schedulingHintFlags",
                        "type": "ze_scheduling_hint_exp_flags_t"
                    }
                ],
                "name": "ze_scheduling_hint_exp_properties_t",
                "type": "struct",
                "version": "1.2"
            },
            "ze_srgb_ext_desc_t": {
                "base": "ze_base_desc_t",
                "class": "zeImage",
                "desc": "sRGB image descriptor",
                "details": [
                    "This structure may be passed to zeImageCreate via the `pNext` member of ze_image_desc_t",
                    "Used for specifying that the image is in sRGB format."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZE_STRUCTURE_TYPE_SRGB_EXT_DESC",
                        "name": "stype",
                        "type": "ze_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] Is sRGB.",
                        "name": "sRGB",
                        "type": "ze_bool_t"
                    }
                ],
                "name": "ze_srgb_ext_desc_t",
                "type": "struct",
                "version": "1.3"
            },
            "ze_sub_allocation_t": {
                "class": "zeMem",
                "desc": "Properties returned for a sub-allocation",
                "members": [
                    {
                        "desc": "[in,out][optional] base address of the sub-allocation",
                        "name": "base",
                        "type": "void*"
                    },
                    {
                        "desc": "[in,out][optional] size of the allocation",
                        "name": "size",
                        "type": "size_t"
                    }
                ],
                "name": "ze_sub_allocation_t",
                "type": "struct",
                "version": "1.5"
            },
            "ze_synchronized_timestamp_data_ext_t": {
                "class": "zeEvent",
                "desc": "Kernel timestamp clock data synchronized to the host time domain",
                "members": [
                    {
                        "desc": "[out] synchronized clock at start of kernel execution",
                        "name": "kernelStart",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] synchronized clock at end of kernel execution",
                        "name": "kernelEnd",
                        "type": "uint64_t"
                    }
                ],
                "name": "ze_synchronized_timestamp_data_ext_t",
                "type": "struct",
                "version": "1.6"
            },
            "ze_synchronized_timestamp_result_ext_t": {
                "class": "zeEvent",
                "desc": "Synchronized kernel timestamp result",
                "members": [
                    {
                        "desc": "[out] wall-clock data",
                        "name": "global",
                        "type": "ze_synchronized_timestamp_data_ext_t"
                    },
                    {
                        "desc": "[out] context-active data; only includes clocks while device context was actively executing.",
                        "name": "context",
                        "type": "ze_synchronized_timestamp_data_ext_t"
                    }
                ],
                "name": "ze_synchronized_timestamp_result_ext_t",
                "type": "struct",
                "version": "1.6"
            },
            "ze_uuid_t": {
                "desc": "Universal unique id (UUID)",
                "members": [
                    {
                        "desc": "[out] opaque data representing a UUID",
                        "name": "id[ZE_MAX_UUID_SIZE]",
                        "type": "uint8_t"
                    }
                ],
                "name": "ze_uuid_t",
                "type": "struct",
                "version": "1.4"
            },
            "zes_base_capability_t": {
                "desc": "Base for all capability types",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    }
                ],
                "name": "zes_base_capability_t",
                "type": "struct"
            },
            "zes_base_config_t": {
                "desc": "Base for all config types",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    }
                ],
                "name": "zes_base_config_t",
                "type": "struct"
            },
            "zes_base_desc_t": {
                "desc": "Base for all descriptor types",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    }
                ],
                "name": "zes_base_desc_t",
                "type": "struct"
            },
            "zes_base_properties_t": {
                "desc": "Base for all properties types",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    }
                ],
                "name": "zes_base_properties_t",
                "type": "struct"
            },
            "zes_base_state_t": {
                "desc": "Base for all state types",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    }
                ],
                "name": "zes_base_state_t",
                "type": "struct"
            },
            "zes_control_property_t": {
                "class": "zesOverclock",
                "desc": "Overclock Control properties",
                "details": [
                    "Provides all the control capabilities supported by the device for the overclock domain."
                ],
                "members": [
                    {
                        "desc": "[out]  This provides information about the limits of the control value so that the driver can calculate the set of valid values.",
                        "name": "MinValue",
                        "type": "double"
                    },
                    {
                        "desc": "[out]  This provides information about the limits of the control value so that the driver can calculate the set of valid values.",
                        "name": "MaxValue",
                        "type": "double"
                    },
                    {
                        "desc": "[out]  This provides information about the limits of the control value so that the driver can calculate the set of valid values.",
                        "name": "StepValue",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The reference value provides the anchor point, UIs can combine this with the user offset request to show the anticipated improvement.",
                        "name": "RefValue",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The shipped out-of-box position of this control. Driver can request this value at any time to return to the out-of-box behavior.",
                        "name": "DefaultValue",
                        "type": "double"
                    }
                ],
                "name": "zes_control_property_t",
                "type": "struct",
                "version": "1.5"
            },
            "zes_device_ecc_desc_t": {
                "base": "zes_base_desc_t",
                "class": "zesDevice",
                "desc": "ECC State Descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_DEVICE_ECC_DESC",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] ECC state",
                        "name": "state",
                        "type": "zes_device_ecc_state_t"
                    }
                ],
                "name": "zes_device_ecc_desc_t",
                "type": "struct",
                "version": "1.4"
            },
            "zes_device_ecc_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesDevice",
                "desc": "ECC State",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_DEVICE_ECC_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] Current ECC state",
                        "name": "currentState",
                        "type": "zes_device_ecc_state_t"
                    },
                    {
                        "desc": "[out] Pending ECC state",
                        "name": "pendingState",
                        "type": "zes_device_ecc_state_t"
                    },
                    {
                        "desc": "[out] Pending action",
                        "name": "pendingAction",
                        "type": "zes_device_action_t"
                    }
                ],
                "name": "zes_device_ecc_properties_t",
                "type": "struct",
                "version": "1.4"
            },
            "zes_device_ext_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesDevice",
                "desc": "Device properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_DEVICE_EXT_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] universal unique identifier. Note: uuid obtained from Sysman API is the same as from core API. Subdevices will have their own uuid.",
                        "name": "uuid",
                        "type": "zes_uuid_t"
                    },
                    {
                        "desc": "[out] generic device type",
                        "name": "type",
                        "type": "zes_device_type_t"
                    },
                    {
                        "desc": "[out] 0 (none) or a valid combination of zes_device_property_flag_t",
                        "name": "flags",
                        "type": "zes_device_property_flags_t"
                    }
                ],
                "name": "zes_device_ext_properties_t",
                "type": "struct",
                "version": "1.7"
            },
            "zes_device_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesDevice",
                "desc": "Device properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_DEVICE_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] (Deprecated, use zes_uuid_t in the extended structure) Core device properties",
                        "name": "core",
                        "type": "ze_device_properties_t"
                    },
                    {
                        "desc": "[out] Number of sub-devices. A value of 0 indicates that this device doesn't have sub-devices.",
                        "name": "numSubdevices",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Manufacturing serial number (NULL terminated string value). This value is intended to reflect the Part ID/SoC ID assigned by manufacturer that is unique for a SoC. Will be set to the string \"unknown\" if this cannot be determined for the device.",
                        "name": "serialNumber[ZES_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] Manufacturing board number (NULL terminated string value). Alternatively \"boardSerialNumber\", this value is intended to reflect the string printed on board label by manufacturer. Will be set to the string \"unknown\" if this cannot be determined for the device.",
                        "name": "boardNumber[ZES_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] Brand name of the device (NULL terminated string value). Will be set to the string \"unknown\" if this cannot be determined for the device.",
                        "name": "brandName[ZES_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] Model name of the device (NULL terminated string value). Will be set to the string \"unknown\" if this cannot be determined for the device.",
                        "name": "modelName[ZES_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] Vendor name of the device (NULL terminated string value). Will be set to the string \"unknown\" if this cannot be determined for the device.",
                        "name": "vendorName[ZES_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] Installed driver version (NULL terminated string value). Will be set to the string \"unknown\" if this cannot be determined for the device.",
                        "name": "driverVersion[ZES_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    }
                ],
                "name": "zes_device_properties_t",
                "type": "struct"
            },
            "zes_device_state_t": {
                "base": "zes_base_state_t",
                "class": "zesDevice",
                "desc": "Device state",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_DEVICE_STATE",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] Indicates if the device needs to be reset and for what reasons.\nreturns 0 (none) or combination of zes_reset_reason_flag_t\n",
                        "name": "reset",
                        "type": "zes_reset_reason_flags_t"
                    },
                    {
                        "desc": "[out] Indicates if the device has been repaired",
                        "name": "repaired",
                        "type": "zes_repair_status_t"
                    }
                ],
                "name": "zes_device_state_t",
                "type": "struct"
            },
            "zes_diag_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesDiagnostics",
                "desc": "Diagnostics test suite properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_DIAG_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Name of the diagnostics test suite",
                        "name": "name[ZES_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] Indicates if this test suite has individual tests which can be run separately (use the function zesDiagnosticsGetTests() to get the list of these tests)",
                        "name": "haveTests",
                        "type": "ze_bool_t"
                    }
                ],
                "name": "zes_diag_properties_t",
                "type": "struct"
            },
            "zes_diag_test_t": {
                "class": "zesDiagnostics",
                "desc": "Diagnostic test",
                "members": [
                    {
                        "desc": "[out] Index of the test",
                        "name": "index",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Name of the test",
                        "name": "name[ZES_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    }
                ],
                "name": "zes_diag_test_t",
                "type": "struct"
            },
            "zes_energy_threshold_t": {
                "class": "zesPower",
                "desc": "Energy threshold",
                "details": [
                    "."
                ],
                "members": [
                    {
                        "desc": "[in,out] Indicates if the energy threshold is enabled.",
                        "name": "enable",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] The energy threshold in Joules. Will be 0.0 if no threshold has been set.",
                        "name": "threshold",
                        "type": "double"
                    },
                    {
                        "desc": "[in,out] The host process ID that set the energy threshold. Will be 0xFFFFFFFF if no threshold has been set.",
                        "name": "processId",
                        "type": "uint32_t"
                    }
                ],
                "name": "zes_energy_threshold_t",
                "type": "struct"
            },
            "zes_engine_ext_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesEngine",
                "desc": "Extension properties related to Engine Groups",
                "details": [
                    "This structure may be passed to zesEngineGetProperties by having the pNext member of zes_engine_properties_t point at this struct.",
                    "Used for SRIOV per Virtual Function device utilization by zes_engine_group_t"
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_ENGINE_EXT_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] Number of Virtual Function(VF) instances associated with engine to monitor the utilization of hardware across all Virtual Function from a Physical Function (PF) instance.\nThese VF-by-VF views should provide engine group and individual engine level granularity.\nThis count represents the number of VF instances that are actively using the resource represented by the engine handle.\n",
                        "name": "countOfVirtualFunctionInstance",
                        "type": "uint32_t"
                    }
                ],
                "name": "zes_engine_ext_properties_t",
                "type": "struct",
                "version": "1.7"
            },
            "zes_engine_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesEngine",
                "desc": "Engine group properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_ENGINE_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] The engine group",
                        "name": "type",
                        "type": "zes_engine_group_t"
                    },
                    {
                        "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    }
                ],
                "name": "zes_engine_properties_t",
                "type": "struct"
            },
            "zes_engine_stats_t": {
                "class": "zesEngine",
                "desc": "Engine activity counters",
                "details": [
                    "Percent utilization is calculated by taking two snapshots (s1, s2) and using the equation: %util = (s2.activeTime - s1.activeTime) / (s2.timestamp - s1.timestamp)"
                ],
                "members": [
                    {
                        "desc": "[out] Monotonic counter for time in microseconds that this resource is actively running workloads.",
                        "name": "activeTime",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic timestamp counter in microseconds when activeTime counter was sampled.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                        "name": "timestamp",
                        "type": "uint64_t"
                    }
                ],
                "name": "zes_engine_stats_t",
                "type": "struct"
            },
            "zes_fabric_link_type_t": {
                "class": "zesFabricPort",
                "desc": "Provides information about the fabric link attached to a port",
                "members": [
                    {
                        "desc": "[out] Description of link technology. Will be set to the string \"unkown\" if this cannot be determined for this link.",
                        "name": "desc[ZES_MAX_FABRIC_LINK_TYPE_SIZE]",
                        "type": "char"
                    }
                ],
                "name": "zes_fabric_link_type_t",
                "type": "struct"
            },
            "zes_fabric_port_config_t": {
                "base": "zes_base_config_t",
                "class": "zesFabricPort",
                "desc": "Fabric port configuration",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_FABRIC_PORT_CONFIG",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in,out] Port is configured up/down",
                        "name": "enabled",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] Beaconing is configured on/off",
                        "name": "beaconing",
                        "type": "ze_bool_t"
                    }
                ],
                "name": "zes_fabric_port_config_t",
                "type": "struct"
            },
            "zes_fabric_port_error_counters_t": {
                "base": "zes_base_properties_t",
                "class": "zesFabricPort",
                "desc": "Fabric Port Error Counters",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_FABRIC_PORT_ERROR_COUNTERS",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] Link Failure Error Count reported per port",
                        "name": "linkFailureCount",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Firmware Communication Error Count reported per device",
                        "name": "fwCommErrorCount",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Firmware reported Error Count reported per device",
                        "name": "fwErrorCount",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Link Degrade Error Count reported per port",
                        "name": "linkDegradeCount",
                        "type": "uint64_t"
                    }
                ],
                "name": "zes_fabric_port_error_counters_t",
                "type": "struct",
                "version": "1.7"
            },
            "zes_fabric_port_id_t": {
                "class": "zesFabricPort",
                "desc": "Unique identifier for a fabric port",
                "details": [
                    "This not a universal identifier. The identified is garanteed to be unique for the current hardware configuration of the system. Changes in the hardware may result in a different identifier for a given port.",
                    "The main purpose of this identifier to build up an instantaneous topology map of system connectivity. An application should enumerate all fabric ports and match the `remotePortId` member of zes_fabric_port_state_t to the `portId` member of zes_fabric_port_properties_t."
                ],
                "members": [
                    {
                        "desc": "[out] Unique identifier for the fabric end-point",
                        "name": "fabricId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Unique identifier for the device attachment point",
                        "name": "attachId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] The logical port number (this is typically marked somewhere on the physical device)",
                        "name": "portNumber",
                        "type": "uint8_t"
                    }
                ],
                "name": "zes_fabric_port_id_t",
                "type": "struct"
            },
            "zes_fabric_port_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesFabricPort",
                "desc": "Fabric port properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_FABRIC_PORT_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] Description of port technology. Will be set to the string \"unkown\" if this cannot be determined for this port.",
                        "name": "model[ZES_MAX_FABRIC_PORT_MODEL_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] True if the port is located on a sub-device; false means that the port is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] The unique port identifier",
                        "name": "portId",
                        "type": "zes_fabric_port_id_t"
                    },
                    {
                        "desc": "[out] Maximum speed supported by the receive side of the port (sum of all lanes)",
                        "name": "maxRxSpeed",
                        "type": "zes_fabric_port_speed_t"
                    },
                    {
                        "desc": "[out] Maximum speed supported by the transmit side of the port (sum of all lanes)",
                        "name": "maxTxSpeed",
                        "type": "zes_fabric_port_speed_t"
                    }
                ],
                "name": "zes_fabric_port_properties_t",
                "type": "struct"
            },
            "zes_fabric_port_speed_t": {
                "class": "zesFabricPort",
                "desc": "Fabric port speed in one direction",
                "members": [
                    {
                        "desc": "[out] Bits/sec that the link is operating at. A value of -1 means that this property is unknown.",
                        "name": "bitRate",
                        "type": "int64_t"
                    },
                    {
                        "desc": "[out] The number of lanes. A value of -1 means that this property is unknown.",
                        "name": "width",
                        "type": "int32_t"
                    }
                ],
                "name": "zes_fabric_port_speed_t",
                "type": "struct"
            },
            "zes_fabric_port_state_t": {
                "base": "zes_base_state_t",
                "class": "zesFabricPort",
                "desc": "Fabric port state",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_FABRIC_PORT_STATE",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] The current status of the port",
                        "name": "status",
                        "type": "zes_fabric_port_status_t"
                    },
                    {
                        "desc": "[out] If status is ZES_FABRIC_PORT_STATUS_DEGRADED,\nthen this gives a combination of zes_fabric_port_qual_issue_flag_t for quality issues that have been detected;\notherwise, 0 indicates there are no quality issues with the link at this time.\n",
                        "name": "qualityIssues",
                        "type": "zes_fabric_port_qual_issue_flags_t"
                    },
                    {
                        "desc": "[out] If status is ZES_FABRIC_PORT_STATUS_FAILED,\nthen this gives a combination of zes_fabric_port_failure_flag_t for reasons for the connection instability;\notherwise, 0 indicates there are no connection stability issues at this time.\n",
                        "name": "failureReasons",
                        "type": "zes_fabric_port_failure_flags_t"
                    },
                    {
                        "desc": "[out] The unique port identifier for the remote connection point if status is ZES_FABRIC_PORT_STATUS_HEALTHY, ZES_FABRIC_PORT_STATUS_DEGRADED or ZES_FABRIC_PORT_STATUS_FAILED",
                        "name": "remotePortId",
                        "type": "zes_fabric_port_id_t"
                    },
                    {
                        "desc": "[out] Current maximum receive speed (sum of all lanes)",
                        "name": "rxSpeed",
                        "type": "zes_fabric_port_speed_t"
                    },
                    {
                        "desc": "[out] Current maximum transmit speed (sum of all lanes)",
                        "name": "txSpeed",
                        "type": "zes_fabric_port_speed_t"
                    }
                ],
                "name": "zes_fabric_port_state_t",
                "type": "struct"
            },
            "zes_fabric_port_throughput_t": {
                "class": "zesFabricPort",
                "desc": "Fabric port throughput.",
                "members": [
                    {
                        "desc": "[out] Monotonic timestamp counter in microseconds when the measurement was made.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                        "name": "timestamp",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic counter for the number of bytes received (sum of all lanes). This includes all protocol overhead, not only the GPU traffic.",
                        "name": "rxCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic counter for the number of bytes transmitted (sum of all lanes). This includes all protocol overhead, not only the GPU traffic.",
                        "name": "txCounter",
                        "type": "uint64_t"
                    }
                ],
                "name": "zes_fabric_port_throughput_t",
                "type": "struct"
            },
            "zes_fan_config_t": {
                "base": "zes_base_config_t",
                "class": "zesFan",
                "desc": "Fan configuration",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_FAN_CONFIG",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in,out] The fan speed mode (fixed, temp-speed table)",
                        "name": "mode",
                        "type": "zes_fan_speed_mode_t"
                    },
                    {
                        "desc": "[in,out] The current fixed fan speed setting",
                        "name": "speedFixed",
                        "type": "zes_fan_speed_t"
                    },
                    {
                        "desc": "[out] A table containing temperature/speed pairs",
                        "name": "speedTable",
                        "type": "zes_fan_speed_table_t"
                    }
                ],
                "name": "zes_fan_config_t",
                "type": "struct"
            },
            "zes_fan_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesFan",
                "desc": "Fan properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_FAN_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Indicates if software can control the fan speed assuming the user has permissions",
                        "name": "canControl",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Bitfield of supported fan configuration modes (1<<zes_fan_speed_mode_t)",
                        "name": "supportedModes",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Bitfield of supported fan speed units (1<<zes_fan_speed_units_t)",
                        "name": "supportedUnits",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] The maximum RPM of the fan. A value of -1 means that this property is unknown. ",
                        "name": "maxRPM",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The maximum number of points in the fan temp/speed table. A value of -1 means that this fan doesn't support providing a temp/speed table.",
                        "name": "maxPoints",
                        "type": "int32_t"
                    }
                ],
                "name": "zes_fan_properties_t",
                "type": "struct"
            },
            "zes_fan_speed_t": {
                "class": "zesFan",
                "desc": "Fan speed",
                "members": [
                    {
                        "desc": "[in,out] The speed of the fan. On output, a value of -1 indicates that there is no fixed fan speed setting.",
                        "name": "speed",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[in,out] The units that the fan speed is expressed in. On output, if fan speed is -1 then units should be ignored.",
                        "name": "units",
                        "type": "zes_fan_speed_units_t"
                    }
                ],
                "name": "zes_fan_speed_t",
                "type": "struct"
            },
            "zes_fan_speed_table_t": {
                "class": "zesFan",
                "desc": "Fan speed table",
                "members": [
                    {
                        "desc": "[in,out] The number of valid points in the fan speed table. 0 means that there is no fan speed table configured. -1 means that a fan speed table is not supported by the hardware.",
                        "name": "numPoints",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[in,out] Array of temperature/fan speed pairs. The table is ordered based on temperature from lowest to highest.",
                        "name": "table[ZES_FAN_TEMP_SPEED_PAIR_COUNT]",
                        "type": "zes_fan_temp_speed_t"
                    }
                ],
                "name": "zes_fan_speed_table_t",
                "type": "struct"
            },
            "zes_fan_temp_speed_t": {
                "class": "zesFan",
                "desc": "Fan temperature/speed pair",
                "members": [
                    {
                        "desc": "[in,out] Temperature in degrees Celsius.",
                        "name": "temperature",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out] The speed of the fan",
                        "name": "speed",
                        "type": "zes_fan_speed_t"
                    }
                ],
                "name": "zes_fan_temp_speed_t",
                "type": "struct"
            },
            "zes_firmware_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesFirmware",
                "desc": "Firmware properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_FIRMWARE_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Indicates if software can flash the firmware assuming the user has permissions",
                        "name": "canControl",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] NULL terminated string value. The string \"unknown\" will be returned if this property cannot be determined.",
                        "name": "name[ZES_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] NULL terminated string value. The string \"unknown\" will be returned if this property cannot be determined.",
                        "name": "version[ZES_STRING_PROPERTY_SIZE]",
                        "type": "char"
                    }
                ],
                "name": "zes_firmware_properties_t",
                "type": "struct"
            },
            "zes_freq_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesFrequency",
                "desc": "Frequency properties",
                "details": [
                    "Indicates if this frequency domain can be overclocked (if true, functions such as zesFrequencyOcSetFrequencyTarget() are supported).",
                    "The min/max hardware frequencies are specified for non-overclock configurations. For overclock configurations, use zesFrequencyOcGetFrequencyTarget() to determine the maximum frequency that can be requested."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_FREQ_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] The hardware block that this frequency domain controls (GPU, memory, ...)",
                        "name": "type",
                        "type": "zes_freq_domain_t"
                    },
                    {
                        "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Indicates if software can control the frequency of this domain assuming the user has permissions",
                        "name": "canControl",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if software can register to receive event ZES_EVENT_TYPE_FLAG_FREQ_THROTTLED",
                        "name": "isThrottleEventSupported",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] The minimum hardware clock frequency in units of MHz.",
                        "name": "min",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The maximum non-overclock hardware clock frequency in units of MHz.",
                        "name": "max",
                        "type": "double"
                    }
                ],
                "name": "zes_freq_properties_t",
                "type": "struct"
            },
            "zes_freq_range_t": {
                "class": "zesFrequency",
                "desc": "Frequency range between which the hardware can operate.",
                "details": [
                    "When setting limits, they will be clamped to the hardware limits.",
                    "When setting limits, ensure that the max frequency is greater than or equal to the min frequency specified.",
                    "When setting limits to return to factory settings, specify -1 for both the min and max limit."
                ],
                "members": [
                    {
                        "desc": "[in,out] The min frequency in MHz below which hardware frequency management will not request frequencies. On input, setting to 0 will permit the frequency to go down to the hardware minimum while setting to -1 will return the min frequency limit to the factory value (can be larger than the hardware min). On output, a negative value indicates that no external minimum frequency limit is in effect.",
                        "name": "min",
                        "type": "double"
                    },
                    {
                        "desc": "[in,out] The max frequency in MHz above which hardware frequency management will not request frequencies. On input, setting to 0 or a very big number will permit the frequency to go all the way up to the hardware maximum while setting to -1 will return the max frequency to the factory value (which can be less than the hardware max). On output, a negative number indicates that no external maximum frequency limit is in effect.",
                        "name": "max",
                        "type": "double"
                    }
                ],
                "name": "zes_freq_range_t",
                "type": "struct"
            },
            "zes_freq_state_t": {
                "base": "zes_base_state_t",
                "class": "zesFrequency",
                "desc": "Frequency state",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_FREQ_STATE",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] Current voltage in Volts. A negative value indicates that this property is not known.",
                        "name": "currentVoltage",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The current frequency request in MHz. A negative value indicates that this property is not known.",
                        "name": "request",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The maximum frequency in MHz supported under the current TDP conditions. This fluctuates dynamically based on the power and thermal limits of the part. A negative value indicates that this property is not known.",
                        "name": "tdp",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The efficient minimum frequency in MHz. A negative value indicates that this property is not known.",
                        "name": "efficient",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The resolved frequency in MHz. A negative value indicates that this property is not known.",
                        "name": "actual",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The reasons that the frequency is being limited by the hardware.\nReturns 0 (frequency not throttled) or a combination of zes_freq_throttle_reason_flag_t.\n",
                        "name": "throttleReasons",
                        "type": "zes_freq_throttle_reason_flags_t"
                    }
                ],
                "name": "zes_freq_state_t",
                "type": "struct"
            },
            "zes_freq_throttle_time_t": {
                "class": "zesFrequency",
                "desc": "Frequency throttle time snapshot",
                "details": [
                    "Percent time throttled is calculated by taking two snapshots (s1, s2) and using the equation: %throttled = (s2.throttleTime - s1.throttleTime) / (s2.timestamp - s1.timestamp)"
                ],
                "members": [
                    {
                        "desc": "[out] The monotonic counter of time in microseconds that the frequency has been limited by the hardware.",
                        "name": "throttleTime",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Microsecond timestamp when throttleTime was captured.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                        "name": "timestamp",
                        "type": "uint64_t"
                    }
                ],
                "name": "zes_freq_throttle_time_t",
                "type": "struct"
            },
            "zes_led_color_t": {
                "class": "zesLed",
                "desc": "LED color",
                "members": [
                    {
                        "desc": "[in,out][range(0.0, 1.0)] The LED red value. On output, a value less than 0.0 indicates that the color is not known.",
                        "name": "red",
                        "type": "double"
                    },
                    {
                        "desc": "[in,out][range(0.0, 1.0)] The LED green value. On output, a value less than 0.0 indicates that the color is not known.",
                        "name": "green",
                        "type": "double"
                    },
                    {
                        "desc": "[in,out][range(0.0, 1.0)] The LED blue value. On output, a value less than 0.0 indicates that the color is not known.",
                        "name": "blue",
                        "type": "double"
                    }
                ],
                "name": "zes_led_color_t",
                "type": "struct"
            },
            "zes_led_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesLed",
                "desc": "LED properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_LED_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Indicates if software can control the LED assuming the user has permissions",
                        "name": "canControl",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if the LED is RGB capable",
                        "name": "haveRGB",
                        "type": "ze_bool_t"
                    }
                ],
                "name": "zes_led_properties_t",
                "type": "struct"
            },
            "zes_led_state_t": {
                "base": "zes_base_state_t",
                "class": "zesLed",
                "desc": "LED state",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_LED_STATE",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] Indicates if the LED is on or off",
                        "name": "isOn",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Color of the LED",
                        "name": "color",
                        "type": "zes_led_color_t"
                    }
                ],
                "name": "zes_led_state_t",
                "type": "struct"
            },
            "zes_mem_bandwidth_t": {
                "class": "zesMemory",
                "desc": "Memory bandwidth",
                "details": [
                    "Percent bandwidth is calculated by taking two snapshots (s1, s2) and using the equation: %bw = 10^6 * ((s2.readCounter - s1.readCounter) + (s2.writeCounter - s1.writeCounter)) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))",
                    "Counter can roll over and rollover needs to be handled by comparing the current read against the previous read",
                    "Counter is a 32 byte transaction count, which means the calculated delta (delta = current_value - previous_value or delta = 2^32 - previous_value + current_value in case of rollover) needs to be multiplied by 32 to get delta between samples in actual byte count"
                ],
                "members": [
                    {
                        "desc": "[out] Total bytes read from memory",
                        "name": "readCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Total bytes written to memory",
                        "name": "writeCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Current maximum bandwidth in units of bytes/sec",
                        "name": "maxBandwidth",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] The timestamp in microseconds when these measurements were sampled.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                        "name": "timestamp",
                        "type": "uint64_t"
                    }
                ],
                "name": "zes_mem_bandwidth_t",
                "type": "struct"
            },
            "zes_mem_ext_bandwidth_t": {
                "class": "zesMemory",
                "desc": "Extension properties for Memory bandwidth",
                "details": [
                    "Number of counter bits"
                ],
                "members": [
                    {
                        "desc": "[out] Returns the number of valid bits in the timestamp values",
                        "name": "memoryTimestampValidBits",
                        "type": "uint32_t"
                    }
                ],
                "name": "zes_mem_ext_bandwidth_t",
                "type": "struct",
                "version": "1.7"
            },
            "zes_mem_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesMemory",
                "desc": "Memory properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_MEM_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] The memory type",
                        "name": "type",
                        "type": "zes_mem_type_t"
                    },
                    {
                        "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Location of this memory (system, device)",
                        "name": "location",
                        "type": "zes_mem_loc_t"
                    },
                    {
                        "desc": "[out] Physical memory size in bytes. A value of 0 indicates that this property is not known. However, a call to zesMemoryGetState() will correctly return the total size of usable memory.",
                        "name": "physicalSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Width of the memory bus. A value of -1 means that this property is unknown.",
                        "name": "busWidth",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The number of memory channels. A value of -1 means that this property is unknown.",
                        "name": "numChannels",
                        "type": "int32_t"
                    }
                ],
                "name": "zes_mem_properties_t",
                "type": "struct"
            },
            "zes_mem_state_t": {
                "base": "zes_base_state_t",
                "class": "zesMemory",
                "desc": "Memory state - health, allocated",
                "details": [
                    "Percent allocation is given by 100 * (size - free / size.",
                    "Percent free is given by 100 * free / size."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_MEM_STATE",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] Indicates the health of the memory",
                        "name": "health",
                        "type": "zes_mem_health_t"
                    },
                    {
                        "desc": "[out] The free memory in bytes",
                        "name": "free",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] The total allocatable memory in bytes (can be less than the `physicalSize` member of zes_mem_properties_t)",
                        "name": "size",
                        "type": "uint64_t"
                    }
                ],
                "name": "zes_mem_state_t",
                "type": "struct"
            },
            "zes_oc_capabilities_t": {
                "base": "zes_base_capability_t",
                "class": "zesFrequency",
                "desc": "Overclocking properties",
                "details": [
                    "Provides all the overclocking capabilities and properties supported by the device for the frequency domain."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_OC_CAPABILITIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] Indicates if any overclocking features are supported on this frequency domain.",
                        "name": "isOcSupported",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Factory default non-overclock maximum frequency in Mhz.",
                        "name": "maxFactoryDefaultFrequency",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Factory default voltage used for the non-overclock maximum frequency in MHz.",
                        "name": "maxFactoryDefaultVoltage",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Maximum hardware overclocking frequency limit in Mhz.",
                        "name": "maxOcFrequency",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The minimum voltage offset that can be applied to the voltage/frequency curve. Note that this number can be negative.",
                        "name": "minOcVoltageOffset",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The maximum voltage offset that can be applied to the voltage/frequency curve.",
                        "name": "maxOcVoltageOffset",
                        "type": "double"
                    },
                    {
                        "desc": "[out] The maximum overclock voltage that hardware supports.",
                        "name": "maxOcVoltage",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Indicates if the maximum temperature limit (TjMax) can be changed for this frequency domain.",
                        "name": "isTjMaxSupported",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if the maximum current (IccMax) can be changed for this frequency domain.",
                        "name": "isIccMaxSupported",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if this frequency domains supports a feature to set very high voltages.",
                        "name": "isHighVoltModeCapable",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if very high voltages are permitted on this frequency domain.",
                        "name": "isHighVoltModeEnabled",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if the extended overclocking features are supported. If this is supported, increments are on 1 Mhz basis.",
                        "name": "isExtendedModeSupported",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if the fixed mode is supported. In this mode, hardware will disable most frequency throttling and lock the frequency and voltage at the specified overclock values.",
                        "name": "isFixedModeSupported",
                        "type": "ze_bool_t"
                    }
                ],
                "name": "zes_oc_capabilities_t",
                "type": "struct"
            },
            "zes_overclock_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesOverclock",
                "desc": "Overclock properties",
                "details": [
                    "Information on the overclock domain type and all the contols that are part of the domain."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_OVERCLOCK_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] The hardware block that this overclock domain controls (GPU, VRAM, ...)",
                        "name": "domainType",
                        "type": "zes_overclock_domain_t"
                    },
                    {
                        "desc": "[out] Returns the overclock controls that are supported (a bit for each of enum zes_overclock_control_t). If no bits are set, the domain doesn't support overclocking.",
                        "name": "AvailableControls",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Type of V-F curve programming that is permitted:.",
                        "name": "VFProgramType",
                        "type": "zes_vf_program_type_t"
                    },
                    {
                        "desc": "[out] Number of VF points that can be programmed - max_num_points",
                        "name": "NumberOfVFPoints",
                        "type": "uint32_t"
                    }
                ],
                "name": "zes_overclock_properties_t",
                "type": "struct",
                "version": "1.5"
            },
            "zes_pci_address_t": {
                "class": "zesDevice",
                "desc": "PCI address",
                "members": [
                    {
                        "desc": "[out] BDF domain",
                        "name": "domain",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] BDF bus",
                        "name": "bus",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] BDF device",
                        "name": "device",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] BDF function",
                        "name": "function",
                        "type": "uint32_t"
                    }
                ],
                "name": "zes_pci_address_t",
                "type": "struct"
            },
            "zes_pci_bar_properties_1_2_t": {
                "base": "zes_base_properties_t",
                "class": "zesDevice",
                "desc": "Properties of a pci bar, including the resizable bar.",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_PCI_BAR_PROPERTIES_1_2",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] The type of bar",
                        "name": "type",
                        "type": "zes_pci_bar_type_t"
                    },
                    {
                        "desc": "[out] The index of the bar",
                        "name": "index",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Base address of the bar.",
                        "name": "base",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Size of the bar.",
                        "name": "size",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Support for Resizable Bar on this device.",
                        "name": "resizableBarSupported",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Resizable Bar enabled on this device",
                        "name": "resizableBarEnabled",
                        "type": "ze_bool_t"
                    }
                ],
                "name": "zes_pci_bar_properties_1_2_t",
                "type": "struct",
                "version": "1.2"
            },
            "zes_pci_bar_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesDevice",
                "desc": "Properties of a pci bar",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_PCI_BAR_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] The type of bar",
                        "name": "type",
                        "type": "zes_pci_bar_type_t"
                    },
                    {
                        "desc": "[out] The index of the bar",
                        "name": "index",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Base address of the bar.",
                        "name": "base",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Size of the bar.",
                        "name": "size",
                        "type": "uint64_t"
                    }
                ],
                "name": "zes_pci_bar_properties_t",
                "type": "struct"
            },
            "zes_pci_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesDevice",
                "desc": "Static PCI properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_PCI_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] The BDF address",
                        "name": "address",
                        "type": "zes_pci_address_t"
                    },
                    {
                        "desc": "[out] Fastest port configuration supported by the device (sum of all lanes)",
                        "name": "maxSpeed",
                        "type": "zes_pci_speed_t"
                    },
                    {
                        "desc": "[out] Indicates whether the `rxCounter` and `txCounter` members of zes_pci_stats_t will have valid values",
                        "name": "haveBandwidthCounters",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Indicates whether the `packetCounter` member of zes_pci_stats_t will have a valid value",
                        "name": "havePacketCounters",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Indicates whether the `replayCounter` member of zes_pci_stats_t will have a valid value",
                        "name": "haveReplayCounters",
                        "type": "ze_bool_t"
                    }
                ],
                "name": "zes_pci_properties_t",
                "type": "struct"
            },
            "zes_pci_speed_t": {
                "class": "zesDevice",
                "desc": "PCI speed",
                "members": [
                    {
                        "desc": "[out] The link generation. A value of -1 means that this property is unknown.",
                        "name": "gen",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The number of lanes. A value of -1 means that this property is unknown.",
                        "name": "width",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The maximum bandwidth in bytes/sec (sum of all lanes). A value of -1 means that this property is unknown.",
                        "name": "maxBandwidth",
                        "type": "int64_t"
                    }
                ],
                "name": "zes_pci_speed_t",
                "type": "struct"
            },
            "zes_pci_state_t": {
                "base": "zes_base_state_t",
                "class": "zesDevice",
                "desc": "Dynamic PCI state",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_PCI_STATE",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] The current status of the port",
                        "name": "status",
                        "type": "zes_pci_link_status_t"
                    },
                    {
                        "desc": "[out] If status is ZES_PCI_LINK_STATUS_QUALITY_ISSUES, \nthen this gives a combination of zes_pci_link_qual_issue_flag_t for quality issues that have been detected;\notherwise, 0 indicates there are no quality issues with the link at this time.\"\n",
                        "name": "qualityIssues",
                        "type": "zes_pci_link_qual_issue_flags_t"
                    },
                    {
                        "desc": "[out] If status is ZES_PCI_LINK_STATUS_STABILITY_ISSUES, \nthen this gives a combination of zes_pci_link_stab_issue_flag_t for reasons for the connection instability;\notherwise, 0 indicates there are no connection stability issues at this time.\"\n",
                        "name": "stabilityIssues",
                        "type": "zes_pci_link_stab_issue_flags_t"
                    },
                    {
                        "desc": "[out] The current port configure speed",
                        "name": "speed",
                        "type": "zes_pci_speed_t"
                    }
                ],
                "name": "zes_pci_state_t",
                "type": "struct"
            },
            "zes_pci_stats_t": {
                "class": "zesDevice",
                "desc": "PCI stats counters",
                "details": [
                    "Percent replays is calculated by taking two snapshots (s1, s2) and using the equation: %replay = 10^6 * (s2.replayCounter - s1.replayCounter) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))",
                    "Percent throughput is calculated by taking two snapshots (s1, s2) and using the equation: %bw = 10^6 * ((s2.rxCounter - s1.rxCounter) + (s2.txCounter - s1.txCounter)) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))"
                ],
                "members": [
                    {
                        "desc": "[out] Monotonic timestamp counter in microseconds when the measurement was made.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                        "name": "timestamp",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic counter for the number of replay packets (sum of all lanes). Will always be 0 when the `haveReplayCounters` member of zes_pci_properties_t is FALSE.",
                        "name": "replayCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic counter for the number of packets (sum of all lanes). Will always be 0 when the `havePacketCounters` member of zes_pci_properties_t is FALSE.",
                        "name": "packetCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic counter for the number of bytes received (sum of all lanes). Will always be 0 when the `haveBandwidthCounters` member of zes_pci_properties_t is FALSE.",
                        "name": "rxCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Monotonic counter for the number of bytes transmitted (including replays) (sum of all lanes). Will always be 0 when the `haveBandwidthCounters` member of zes_pci_properties_t is FALSE.",
                        "name": "txCounter",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] The current speed of the link (sum of all lanes)",
                        "name": "speed",
                        "type": "zes_pci_speed_t"
                    }
                ],
                "name": "zes_pci_stats_t",
                "type": "struct"
            },
            "zes_perf_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesPerformanceFactor",
                "desc": "Static information about a Performance Factor domain",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_PERF_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] True if this Performance Factor affects accelerators located on a sub-device",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Bitfield of accelerator engine types that are affected by this Performance Factor.",
                        "name": "engines",
                        "type": "zes_engine_type_flags_t"
                    }
                ],
                "name": "zes_perf_properties_t",
                "type": "struct"
            },
            "zes_power_burst_limit_t": {
                "class": "zesPower",
                "desc": "Burst power limit",
                "details": [
                    "The power controller (Punit) will throttle the operating frequency of the device if the power averaged over a few milliseconds exceeds a limit known as PL2. Typically PL2 > PL1 so that it permits the frequency to burst higher for short periods than would be otherwise permitted by PL1."
                ],
                "members": [
                    {
                        "desc": "[in,out] indicates if the limit is enabled (true) or ignored (false)",
                        "name": "enabled",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] power limit in milliwatts",
                        "name": "power",
                        "type": "int32_t"
                    }
                ],
                "name": "zes_power_burst_limit_t",
                "type": "struct"
            },
            "zes_power_energy_counter_t": {
                "class": "zesPower",
                "desc": "Energy counter snapshot",
                "details": [
                    "Average power is calculated by taking two snapshots (s1, s2) and using the equation: PowerWatts = (s2.energy - s1.energy) / (s2.timestamp - s1.timestamp)"
                ],
                "members": [
                    {
                        "desc": "[out] The monotonic energy counter in microjoules.",
                        "name": "energy",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Microsecond timestamp when energy was captured.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                        "name": "timestamp",
                        "type": "uint64_t"
                    }
                ],
                "name": "zes_power_energy_counter_t",
                "type": "struct"
            },
            "zes_power_ext_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesPower",
                "desc": "Extension properties related to device power settings",
                "details": [
                    "This structure may be returned from zesPowerGetProperties via the `pNext` member of zes_power_properties_t.",
                    "This structure may also be returned from zesPowerGetProperties via the `pNext` member of zes_power_ext_properties_t",
                    "Used for determining the power domain level, i.e. card-level v/s package-level v/s stack-level & the factory default power limits."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_POWER_EXT_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] domain that the power limit belongs to.",
                        "name": "domain",
                        "type": "zes_power_domain_t"
                    },
                    {
                        "desc": "[out] the factory default limit of the part.",
                        "name": "defaultLimit",
                        "type": "zes_power_limit_ext_desc_t*"
                    }
                ],
                "name": "zes_power_ext_properties_t",
                "type": "struct",
                "version": "1.4"
            },
            "zes_power_limit_ext_desc_t": {
                "base": "zes_base_desc_t",
                "class": "zesPower",
                "desc": "Device power/current limit descriptor.",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_POWER_LIMIT_EXT_DESC",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in,out] duration type over which the power draw is measured, i.e. sustained, burst, peak, or critical.",
                        "name": "level",
                        "type": "zes_power_level_t"
                    },
                    {
                        "desc": "[out] source of power used by the system, i.e. AC or DC.",
                        "name": "source",
                        "type": "zes_power_source_t"
                    },
                    {
                        "desc": "[out] unit used for specifying limit, i.e. current units (milliamps) or power units (milliwatts).",
                        "name": "limitUnit",
                        "type": "zes_limit_unit_t"
                    },
                    {
                        "desc": "[out] indicates if the power limit state (enabled/ignored) can be set (false) or is locked (true).",
                        "name": "enabledStateLocked",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] indicates if the limit is enabled (true) or ignored (false). If enabledStateIsLocked is True, this value is ignored.",
                        "name": "enabled",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] indicates if the interval can be modified (false) or is fixed (true).",
                        "name": "intervalValueLocked",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] power averaging window in milliseconds. If intervalValueLocked is true, this value is ignored.",
                        "name": "interval",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] indicates if the limit can be set (false) or if the limit is fixed (true).",
                        "name": "limitValueLocked",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] limit value. If limitValueLocked is true, this value is ignored. The value should be provided in the unit specified by limitUnit.",
                        "name": "limit",
                        "type": "int32_t"
                    }
                ],
                "name": "zes_power_limit_ext_desc_t",
                "type": "struct",
                "version": "1.4"
            },
            "zes_power_peak_limit_t": {
                "class": "zesPower",
                "desc": "Peak power limit",
                "details": [
                    "The power controller (Punit) will reactively/proactively throttle the operating frequency of the device when the instantaneous/100usec power exceeds this limit. The limit is known as PL4 or Psys. It expresses the maximum power that can be drawn from the power supply.",
                    "If this power limit is removed or set too high, the power supply will generate an interrupt when it detects an overcurrent condition and the power controller will throttle the device frequencies down to min. It is thus better to tune the PL4 value in order to avoid such excursions."
                ],
                "members": [
                    {
                        "desc": "[in,out] power limit in milliwatts for the AC power source.",
                        "name": "powerAC",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[in,out] power limit in milliwatts for the DC power source. On input, this is ignored if the product does not have a battery. On output, this will be -1 if the product does not have a battery.",
                        "name": "powerDC",
                        "type": "int32_t"
                    }
                ],
                "name": "zes_power_peak_limit_t",
                "type": "struct"
            },
            "zes_power_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesPower",
                "desc": "Properties related to device power settings",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_POWER_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Software can change the power limits of this domain assuming the user has permissions.",
                        "name": "canControl",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if this power domain supports the energy threshold event (ZES_EVENT_TYPE_FLAG_ENERGY_THRESHOLD_CROSSED).",
                        "name": "isEnergyThresholdSupported",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] (Deprecated) The factory default TDP power limit of the part in milliwatts. A value of -1 means that this is not known.",
                        "name": "defaultLimit",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] (Deprecated) The minimum power limit in milliwatts that can be requested. A value of -1 means that this is not known.",
                        "name": "minLimit",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] (Deprecated) The maximum power limit in milliwatts that can be requested. A value of -1 means that this is not known.",
                        "name": "maxLimit",
                        "type": "int32_t"
                    }
                ],
                "name": "zes_power_properties_t",
                "type": "struct"
            },
            "zes_power_sustained_limit_t": {
                "class": "zesPower",
                "desc": "Sustained power limits",
                "details": [
                    "The power controller (Punit) will throttle the operating frequency if the power averaged over a window (typically seconds) exceeds this limit."
                ],
                "members": [
                    {
                        "desc": "[in,out] indicates if the limit is enabled (true) or ignored (false)",
                        "name": "enabled",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] power limit in milliwatts",
                        "name": "power",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[in,out] power averaging window (Tau) in milliseconds",
                        "name": "interval",
                        "type": "int32_t"
                    }
                ],
                "name": "zes_power_sustained_limit_t",
                "type": "struct"
            },
            "zes_process_state_t": {
                "base": "zes_base_state_t",
                "class": "zesDevice",
                "desc": "Contains information about a process that has an open connection with this device",
                "details": [
                    "The application can use the process ID to query the OS for the owner and the path to the executable."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_PROCESS_STATE",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] Host OS process ID.",
                        "name": "processId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Device memory size in bytes allocated by this process (may not necessarily be resident on the device at the time of reading).",
                        "name": "memSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] The size of shared device memory mapped into this process (may not necessarily be resident on the device at the time of reading).",
                        "name": "sharedSize",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Bitfield of accelerator engine types being used by this process.",
                        "name": "engines",
                        "type": "zes_engine_type_flags_t"
                    }
                ],
                "name": "zes_process_state_t",
                "type": "struct"
            },
            "zes_psu_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesPsu",
                "desc": "Static properties of the power supply",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_PSU_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] True if the power supply has a fan",
                        "name": "haveFan",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] The maximum electrical current in milliamperes that can be drawn. A value of -1 indicates that this property cannot be determined.",
                        "name": "ampLimit",
                        "type": "int32_t"
                    }
                ],
                "name": "zes_psu_properties_t",
                "type": "struct"
            },
            "zes_psu_state_t": {
                "base": "zes_base_state_t",
                "class": "zesPsu",
                "desc": "Dynamic state of the power supply",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_PSU_STATE",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] The current PSU voltage status",
                        "name": "voltStatus",
                        "type": "zes_psu_voltage_status_t"
                    },
                    {
                        "desc": "[out] Indicates if the fan has failed",
                        "name": "fanFailed",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Read the current heatsink temperature in degrees Celsius. A value of -1 indicates that this property cannot be determined.",
                        "name": "temperature",
                        "type": "int32_t"
                    },
                    {
                        "desc": "[out] The amps being drawn in milliamperes. A value of -1 indicates that this property cannot be determined.",
                        "name": "current",
                        "type": "int32_t"
                    }
                ],
                "name": "zes_psu_state_t",
                "type": "struct"
            },
            "zes_ras_config_t": {
                "base": "zes_base_config_t",
                "class": "zesRas",
                "desc": "RAS error configuration - thresholds used for triggering RAS events (ZES_EVENT_TYPE_FLAG_RAS_CORRECTABLE_ERRORS, ZES_EVENT_TYPE_FLAG_RAS_UNCORRECTABLE_ERRORS)",
                "details": [
                    "The driver maintains a total counter which is updated every time a hardware block covered by the corresponding RAS error set notifies that an error has occurred. When this total count goes above the totalThreshold specified below, a RAS event is triggered.",
                    "The driver also maintains a counter for each category of RAS error (see zes_ras_state_t for a breakdown). Each time a hardware block of that category notifies that an error has occurred, that corresponding category counter is updated. When it goes above the threshold specified in detailedThresholds, a RAS event is triggered."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_RAS_CONFIG",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in,out] If the total RAS errors exceeds this threshold, the event will be triggered. A value of 0ULL disables triggering the event based on the total counter.",
                        "name": "totalThreshold",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[in,out] If the RAS errors for each category exceed the threshold for that category, the event will be triggered. A value of 0ULL will disable an event being triggered for that category.",
                        "name": "detailedThresholds",
                        "type": "zes_ras_state_t"
                    }
                ],
                "name": "zes_ras_config_t",
                "type": "struct"
            },
            "zes_ras_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesRas",
                "desc": "RAS properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_RAS_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] The type of RAS error",
                        "name": "type",
                        "type": "zes_ras_error_type_t"
                    },
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    }
                ],
                "name": "zes_ras_properties_t",
                "type": "struct"
            },
            "zes_ras_state_exp_t": {
                "class": "zesRas",
                "desc": "Extension structure for providing RAS error counters for different error sets",
                "members": [
                    {
                        "desc": "[out] category for which error counter is provided.",
                        "name": "category",
                        "type": "zes_ras_error_category_exp_t"
                    },
                    {
                        "desc": "[out] Current value of RAS counter for specific error category.",
                        "name": "errorCounter",
                        "type": "uint64_t"
                    }
                ],
                "name": "zes_ras_state_exp_t",
                "type": "struct",
                "version": "1.7"
            },
            "zes_ras_state_t": {
                "base": "zes_base_state_t",
                "class": "zesRas",
                "desc": "RAS error details",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_RAS_STATE",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in][out] Breakdown of error by category",
                        "name": "category[ZES_MAX_RAS_ERROR_CATEGORY_COUNT]",
                        "type": "uint64_t"
                    }
                ],
                "name": "zes_ras_state_t",
                "type": "struct"
            },
            "zes_reset_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesDevice",
                "desc": "Device reset properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_RESET_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[in] If set to true, all applications that are currently using the device will be forcibly killed.\n",
                        "name": "force",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in] Type of reset needs to be performed",
                        "name": "resetType",
                        "type": "zes_reset_type_t"
                    }
                ],
                "name": "zes_reset_properties_t",
                "type": "struct",
                "version": "1.7"
            },
            "zes_sched_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesScheduler",
                "desc": "Properties related to scheduler component",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_SCHED_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Software can change the scheduler component configuration assuming the user has permissions.",
                        "name": "canControl",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Bitfield of accelerator engine types that are managed by this scheduler component. Note that there can be more than one scheduler component for the same type of accelerator engine.",
                        "name": "engines",
                        "type": "zes_engine_type_flags_t"
                    },
                    {
                        "desc": "[out] Bitfield of scheduler modes that can be configured for this scheduler component (bitfield of 1<<zes_sched_mode_t).",
                        "name": "supportedModes",
                        "type": "uint32_t"
                    }
                ],
                "name": "zes_sched_properties_t",
                "type": "struct"
            },
            "zes_sched_timeout_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesDevice",
                "desc": "Configuration for timeout scheduler mode (ZES_SCHED_MODE_TIMEOUT)",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[in,out] The maximum time in microseconds that the scheduler will wait for a batch of work submitted to a hardware engine to complete or to be preempted so as to run another context.\nIf this time is exceeded, the hardware engine is reset and the context terminated.\nIf set to ZES_SCHED_WATCHDOG_DISABLE, a running workload can run as long as it wants without being terminated, but preemption attempts to run other contexts are permitted but not enforced.\n",
                        "name": "watchdogTimeout",
                        "type": "uint64_t"
                    }
                ],
                "name": "zes_sched_timeout_properties_t",
                "type": "struct"
            },
            "zes_sched_timeslice_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesDevice",
                "desc": "Configuration for timeslice scheduler mode (ZES_SCHED_MODE_TIMESLICE)",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[in,out] The average interval in microseconds that a submission for a context will run on a hardware engine before being preempted out to run a pending submission for another context.",
                        "name": "interval",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[in,out] The maximum time in microseconds that the scheduler will wait to preempt a workload running on an engine before deciding to reset the hardware engine and terminating the associated context.",
                        "name": "yieldTimeout",
                        "type": "uint64_t"
                    }
                ],
                "name": "zes_sched_timeslice_properties_t",
                "type": "struct"
            },
            "zes_standby_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesStandby",
                "desc": "Standby hardware component properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_STANDBY_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] Which standby hardware component this controls",
                        "name": "type",
                        "type": "zes_standby_type_t"
                    },
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    }
                ],
                "name": "zes_standby_properties_t",
                "type": "struct"
            },
            "zes_temp_config_t": {
                "base": "zes_base_config_t",
                "class": "zesTemperature",
                "desc": "Temperature configuration - which events should be triggered and the trigger conditions.",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_TEMP_CONFIG",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in,out] Indicates if event ZES_EVENT_TYPE_FLAG_TEMP_CRITICAL should be triggered by the driver.",
                        "name": "enableCritical",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] Configuration controlling if and when event ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD1 should be triggered by the driver.",
                        "name": "threshold1",
                        "type": "zes_temp_threshold_t"
                    },
                    {
                        "desc": "[in,out] Configuration controlling if and when event ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD2 should be triggered by the driver.",
                        "name": "threshold2",
                        "type": "zes_temp_threshold_t"
                    }
                ],
                "name": "zes_temp_config_t",
                "type": "struct"
            },
            "zes_temp_properties_t": {
                "base": "zes_base_properties_t",
                "class": "zesTemperature",
                "desc": "Temperature sensor properties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZES_STRUCTURE_TYPE_TEMP_PROPERTIES",
                        "name": "stype",
                        "type": "zes_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] Which part of the device the temperature sensor measures",
                        "name": "type",
                        "type": "zes_temp_sensors_t"
                    },
                    {
                        "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                        "name": "onSubdevice",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                        "name": "subdeviceId",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] Will contain the maximum temperature for the specific device in degrees Celsius.",
                        "name": "maxTemperature",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Indicates if the critical temperature event ZES_EVENT_TYPE_FLAG_TEMP_CRITICAL is supported",
                        "name": "isCriticalTempSupported",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if the temperature threshold 1 event ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD1 is supported",
                        "name": "isThreshold1Supported",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[out] Indicates if the temperature threshold 2 event ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD2 is supported",
                        "name": "isThreshold2Supported",
                        "type": "ze_bool_t"
                    }
                ],
                "name": "zes_temp_properties_t",
                "type": "struct"
            },
            "zes_temp_threshold_t": {
                "class": "zesTemperature",
                "desc": "Temperature sensor threshold",
                "members": [
                    {
                        "desc": "[in,out] Trigger an event when the temperature crosses from below the threshold to above.",
                        "name": "enableLowToHigh",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] Trigger an event when the temperature crosses from above the threshold to below.",
                        "name": "enableHighToLow",
                        "type": "ze_bool_t"
                    },
                    {
                        "desc": "[in,out] The threshold in degrees Celsius.",
                        "name": "threshold",
                        "type": "double"
                    }
                ],
                "name": "zes_temp_threshold_t",
                "type": "struct"
            },
            "zes_uuid_t": {
                "class": "zesDevice",
                "desc": "Device universal unique id (UUID)",
                "members": [
                    {
                        "desc": "[out] opaque data representing a device UUID",
                        "name": "id[ZES_MAX_UUID_SIZE]",
                        "type": "uint8_t"
                    }
                ],
                "name": "zes_uuid_t",
                "type": "struct",
                "version": "1.7"
            },
            "zes_vf_property_t": {
                "class": "zesOverclock",
                "desc": "Overclock VF properties",
                "details": [
                    "Provides all the VF capabilities supported by the device for the overclock domain."
                ],
                "members": [
                    {
                        "desc": "[out] Read the minimum frequency that can be be programmed in the custom V-F point..",
                        "name": "MinFreq",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Read the maximum frequency that can be be programmed in the custom V-F point..",
                        "name": "MaxFreq",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Read the frequency step that can be be programmed in the custom V-F point..",
                        "name": "StepFreq",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Read the minimum voltage that can be be programmed in the custom V-F point..",
                        "name": "MinVolt",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Read the maximum voltage that can be be programmed in the custom V-F point..",
                        "name": "MaxVolt",
                        "type": "double"
                    },
                    {
                        "desc": "[out] Read the voltage step that can be be programmed in the custom V-F point.",
                        "name": "StepVolt",
                        "type": "double"
                    }
                ],
                "name": "zes_vf_property_t",
                "type": "struct",
                "version": "1.5"
            },
            "zet_base_desc_t": {
                "desc": "Base for all descriptor types",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "name": "stype",
                        "type": "zet_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    }
                ],
                "name": "zet_base_desc_t",
                "type": "struct"
            },
            "zet_base_properties_t": {
                "desc": "Base for all properties types",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "name": "stype",
                        "type": "zet_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    }
                ],
                "name": "zet_base_properties_t",
                "type": "struct"
            },
            "zet_debug_config_t": {
                "class": "zetDebug",
                "desc": "Debug configuration provided to zetDebugAttach",
                "members": [
                    {
                        "desc": "[in] the host process identifier",
                        "name": "pid",
                        "type": "uint32_t"
                    }
                ],
                "name": "zet_debug_config_t",
                "type": "struct"
            },
            "zet_debug_event_info_detached_t": {
                "class": "zetDebug",
                "desc": "Event information for ZET_DEBUG_EVENT_TYPE_DETACHED",
                "members": [
                    {
                        "desc": "[out] the detach reason",
                        "name": "reason",
                        "type": "zet_debug_detach_reason_t"
                    }
                ],
                "name": "zet_debug_event_info_detached_t",
                "type": "struct"
            },
            "zet_debug_event_info_module_t": {
                "class": "zetDebug",
                "desc": "Event information for ZET_DEBUG_EVENT_TYPE_MODULE_LOAD and ZET_DEBUG_EVENT_TYPE_MODULE_UNLOAD",
                "members": [
                    {
                        "desc": "[out] the module format",
                        "name": "format",
                        "type": "zet_module_debug_info_format_t"
                    },
                    {
                        "desc": "[out] the begin address of the in-memory module (inclusive)",
                        "name": "moduleBegin",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] the end address of the in-memory module (exclusive)",
                        "name": "moduleEnd",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] the load address of the module on the device",
                        "name": "load",
                        "type": "uint64_t"
                    }
                ],
                "name": "zet_debug_event_info_module_t",
                "type": "struct"
            },
            "zet_debug_event_info_page_fault_t": {
                "class": "zetDebug",
                "desc": "Event information for ZET_DEBUG_EVENT_TYPE_PAGE_FAULT",
                "members": [
                    {
                        "desc": "[out] the faulting address",
                        "name": "address",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] the alignment mask",
                        "name": "mask",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] the page fault reason",
                        "name": "reason",
                        "type": "zet_debug_page_fault_reason_t"
                    }
                ],
                "name": "zet_debug_event_info_page_fault_t",
                "type": "struct",
                "version": "1.1"
            },
            "zet_debug_event_info_thread_stopped_t": {
                "class": "zetDebug",
                "desc": "Event information for ZET_DEBUG_EVENT_TYPE_THREAD_STOPPED and ZET_DEBUG_EVENT_TYPE_THREAD_UNAVAILABLE",
                "members": [
                    {
                        "desc": "[out] the stopped/unavailable thread",
                        "name": "thread",
                        "type": "ze_device_thread_t"
                    }
                ],
                "name": "zet_debug_event_info_thread_stopped_t",
                "type": "struct"
            },
            "zet_debug_event_t": {
                "class": "zetDebug",
                "desc": "A debug event on the device.",
                "members": [
                    {
                        "desc": "[out] the event type",
                        "name": "type",
                        "type": "zet_debug_event_type_t"
                    },
                    {
                        "desc": "[out] returns 0 (none) or a combination of zet_debug_event_flag_t",
                        "name": "flags",
                        "type": "zet_debug_event_flags_t"
                    },
                    {
                        "desc": "[out] event type specific information",
                        "name": "info",
                        "type": "zet_debug_event_info_t"
                    }
                ],
                "name": "zet_debug_event_t",
                "type": "struct"
            },
            "zet_debug_memory_space_desc_t": {
                "base": "zet_base_desc_t",
                "class": "zetDebug",
                "desc": "Device memory space descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZET_STRUCTURE_TYPE_DEBUG_MEMORY_SPACE_DESC",
                        "name": "stype",
                        "type": "zet_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] type of memory space",
                        "name": "type",
                        "type": "zet_debug_memory_space_type_t"
                    },
                    {
                        "desc": "[in] the virtual address within the memory space",
                        "name": "address",
                        "type": "uint64_t"
                    }
                ],
                "name": "zet_debug_memory_space_desc_t",
                "type": "struct"
            },
            "zet_debug_regset_properties_t": {
                "base": "zet_base_properties_t",
                "class": "zetDebug",
                "desc": "Device register set properties queried using zetDebugGetRegisterSetProperties.",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZET_STRUCTURE_TYPE_DEBUG_REGSET_PROPERTIES",
                        "name": "stype",
                        "type": "zet_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] device-specific register set type",
                        "name": "type",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] device-specific version of this register set",
                        "name": "version",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] general register set flags",
                        "name": "generalFlags",
                        "type": "zet_debug_regset_flags_t"
                    },
                    {
                        "desc": "[out] device-specific register set flags",
                        "name": "deviceFlags",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] number of registers in the set",
                        "name": "count",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] the size of a register in bits",
                        "name": "bitSize",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] the size required for reading or writing a register in bytes",
                        "name": "byteSize",
                        "type": "uint32_t"
                    }
                ],
                "name": "zet_debug_regset_properties_t",
                "type": "struct"
            },
            "zet_device_debug_properties_t": {
                "base": "zet_base_properties_t",
                "class": "zetDevice",
                "desc": "Device debug properties queried using zetDeviceGetDebugProperties.",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZET_STRUCTURE_TYPE_DEVICE_DEBUG_PROPERTIES",
                        "name": "stype",
                        "type": "zet_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] returns 0 (none) or a valid combination of zet_device_debug_property_flag_t",
                        "name": "flags",
                        "type": "zet_device_debug_property_flags_t"
                    }
                ],
                "name": "zet_device_debug_properties_t",
                "type": "struct"
            },
            "zet_metric_calculate_exp_desc_t": {
                "base": "zet_base_desc_t",
                "class": "zetMetric",
                "desc": "Metrics calculation descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZET_STRUCTURE_TYPE_METRIC_CALCULATE_EXP_DESC",
                        "name": "stype",
                        "type": "zet_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] number of reports to skip during calculation",
                        "name": "rawReportSkipCount",
                        "type": "uint32_t"
                    }
                ],
                "name": "zet_metric_calculate_exp_desc_t",
                "type": "struct",
                "version": "1.6"
            },
            "zet_metric_global_timestamps_resolution_exp_t": {
                "base": "zet_base_desc_t",
                "class": "zetMetric",
                "desc": "Metric timestamps resolution",
                "details": [
                    "This structure may be returned from zetMetricGroupGetProperties via the `pNext` member of zet_metric_group_properties_t.",
                    "Used for mapping metric timestamps to other timers."
                ],
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZET_STRUCTURE_TYPE_METRIC_GLOBAL_TIMESTAMPS_RESOLUTION_EXP",
                        "name": "stype",
                        "type": "zet_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[out] Returns the resolution of metrics timer (used for timestamps) in cycles/sec.",
                        "name": "timerResolution",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] Returns the number of valid bits in the timestamp value.",
                        "name": "timestampValidBits",
                        "type": "uint64_t"
                    }
                ],
                "name": "zet_metric_global_timestamps_resolution_exp_t",
                "type": "struct",
                "version": "1.5"
            },
            "zet_metric_group_properties_t": {
                "base": "zet_base_properties_t",
                "class": "zetMetricGroup",
                "desc": "Metric group properties queried using zetMetricGroupGetProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZET_STRUCTURE_TYPE_METRIC_GROUP_PROPERTIES",
                        "name": "stype",
                        "type": "zet_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] metric group name",
                        "name": "name[ZET_MAX_METRIC_GROUP_NAME]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] metric group description",
                        "name": "description[ZET_MAX_METRIC_GROUP_DESCRIPTION]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] metric group sampling type.\nreturns a combination of zet_metric_group_sampling_type_flag_t.\n",
                        "name": "samplingType",
                        "type": "zet_metric_group_sampling_type_flags_t"
                    },
                    {
                        "desc": "[out] metric group domain number. Cannot use multiple, simultaneous metric groups from the same domain.",
                        "name": "domain",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] metric count belonging to this group",
                        "name": "metricCount",
                        "type": "uint32_t"
                    }
                ],
                "name": "zet_metric_group_properties_t",
                "type": "struct"
            },
            "zet_metric_properties_t": {
                "base": "zet_base_properties_t",
                "class": "zetMetric",
                "desc": "Metric properties queried using zetMetricGetProperties",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZET_STRUCTURE_TYPE_METRIC_PROPERTIES",
                        "name": "stype",
                        "type": "zet_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] metric name",
                        "name": "name[ZET_MAX_METRIC_NAME]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] metric description",
                        "name": "description[ZET_MAX_METRIC_DESCRIPTION]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] metric component",
                        "name": "component[ZET_MAX_METRIC_COMPONENT]",
                        "type": "char"
                    },
                    {
                        "desc": "[out] number of tier",
                        "name": "tierNumber",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] metric type",
                        "name": "metricType",
                        "type": "zet_metric_type_t"
                    },
                    {
                        "desc": "[out] metric result type",
                        "name": "resultType",
                        "type": "zet_value_type_t"
                    },
                    {
                        "desc": "[out] metric result units",
                        "name": "resultUnits[ZET_MAX_METRIC_RESULT_UNITS]",
                        "type": "char"
                    }
                ],
                "name": "zet_metric_properties_t",
                "type": "struct"
            },
            "zet_metric_query_pool_desc_t": {
                "base": "zet_base_desc_t",
                "class": "zetMetricQueryPool",
                "desc": "Metric query pool description",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZET_STRUCTURE_TYPE_METRIC_QUERY_POOL_DESC",
                        "name": "stype",
                        "type": "zet_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] Query pool type.",
                        "init": "ZET_METRIC_QUERY_POOL_TYPE_PERFORMANCE",
                        "name": "type",
                        "type": "zet_metric_query_pool_type_t"
                    },
                    {
                        "desc": "[in] Internal slots count within query pool object.",
                        "name": "count",
                        "type": "uint32_t"
                    }
                ],
                "name": "zet_metric_query_pool_desc_t",
                "type": "struct"
            },
            "zet_metric_streamer_desc_t": {
                "base": "zet_base_desc_t",
                "class": "zetMetricStreamer",
                "desc": "Metric streamer descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZET_STRUCTURE_TYPE_METRIC_STREAMER_DESC",
                        "name": "stype",
                        "type": "zet_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in,out] number of collected reports after which notification event will be signaled. If the requested value is not supported exactly, then the driver may use a value that is the closest supported approximation and shall update this member during zetMetricStreamerOpen.\n",
                        "name": "notifyEveryNReports",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[in,out] streamer sampling period in nanoseconds. If the requested value is not supported exactly, then the driver may use a value that is the closest supported approximation and shall update this member during zetMetricStreamerOpen.\n",
                        "name": "samplingPeriod",
                        "type": "uint32_t"
                    }
                ],
                "name": "zet_metric_streamer_desc_t",
                "type": "struct"
            },
            "zet_profile_free_register_token_t": {
                "class": "zetKernel",
                "desc": "Profile free register token detailing unused registers in the current function",
                "members": [
                    {
                        "desc": "[out] type of token",
                        "name": "type",
                        "type": "zet_profile_token_type_t"
                    },
                    {
                        "desc": "[out] total size of the token, in bytes",
                        "name": "size",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] number of register sequences immediately following this structure",
                        "name": "count",
                        "type": "uint32_t"
                    }
                ],
                "name": "zet_profile_free_register_token_t",
                "type": "struct"
            },
            "zet_profile_properties_t": {
                "base": "zet_base_properties_t",
                "class": "zetKernel",
                "desc": "Profiling meta-data for instrumentation",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZET_STRUCTURE_TYPE_PROFILE_PROPERTIES",
                        "name": "stype",
                        "type": "zet_structure_type_t"
                    },
                    {
                        "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "void*"
                    },
                    {
                        "desc": "[out] indicates which flags were enabled during compilation.\nreturns 0 (none) or a combination of zet_profile_flag_t\n",
                        "name": "flags",
                        "type": "zet_profile_flags_t"
                    },
                    {
                        "desc": "[out] number of tokens immediately following this structure",
                        "name": "numTokens",
                        "type": "uint32_t"
                    }
                ],
                "name": "zet_profile_properties_t",
                "type": "struct"
            },
            "zet_profile_register_sequence_t": {
                "class": "zetKernel",
                "desc": "Profile register sequence detailing consecutive bytes, all of which are unused",
                "members": [
                    {
                        "desc": "[out] starting byte in the register table, representing the start of unused bytes in the current function",
                        "name": "start",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] number of consecutive bytes in the sequence, starting from start",
                        "name": "count",
                        "type": "uint32_t"
                    }
                ],
                "name": "zet_profile_register_sequence_t",
                "type": "struct"
            },
            "zet_tracer_exp_desc_t": {
                "base": "zet_base_desc_t",
                "class": "zetTracerExp",
                "desc": "Tracer descriptor",
                "members": [
                    {
                        "desc": "[in] type of this structure",
                        "init": "ZET_STRUCTURE_TYPE_TRACER_EXP_DESC",
                        "name": "stype",
                        "type": "zet_structure_type_t"
                    },
                    {
                        "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                        "init": "nullptr",
                        "name": "pNext",
                        "type": "const void*"
                    },
                    {
                        "desc": "[in] pointer passed to every tracer's callbacks",
                        "name": "pUserData",
                        "type": "void*"
                    }
                ],
                "name": "zet_tracer_exp_desc_t",
                "type": "struct"
            },
            "zet_typed_value_t": {
                "desc": "Typed value",
                "members": [
                    {
                        "desc": "[out] type of value",
                        "name": "type",
                        "type": "zet_value_type_t"
                    },
                    {
                        "desc": "[out] value",
                        "name": "value",
                        "type": "zet_value_t"
                    }
                ],
                "name": "zet_typed_value_t",
                "type": "struct"
            }
        },
        "typedef": {
            "ze_bool_t": {
                "desc": "compiler-independent type",
                "name": "ze_bool_t",
                "type": "typedef",
                "value": "uint8_t"
            },
            "ze_kernel_max_group_size_ext_properties_t": {
                "desc": "compiler-independent type",
                "name": "ze_kernel_max_group_size_ext_properties_t",
                "type": "typedef",
                "value": "ze_kernel_max_group_size_properties_ext_t",
                "version": "1.7"
            },
            "ze_rtas_builder_packed_geometry_exp_flags_t": {
                "class": "zeRTASBuilder",
                "desc": "Packed ray tracing acceleration structure builder geometry flags (see ze_rtas_builder_geometry_exp_flags_t)",
                "name": "ze_rtas_builder_packed_geometry_exp_flags_t",
                "type": "typedef",
                "value": "uint8_t",
                "version": "1.7"
            },
            "ze_rtas_builder_packed_geometry_type_exp_t": {
                "class": "zeRTASBuilder",
                "desc": "Packed ray tracing acceleration structure builder geometry type (see ze_rtas_builder_geometry_type_exp_t)",
                "name": "ze_rtas_builder_packed_geometry_type_exp_t",
                "type": "typedef",
                "value": "uint8_t",
                "version": "1.7"
            },
            "ze_rtas_builder_packed_input_data_format_exp_t": {
                "class": "zeRTASBuilder",
                "desc": "Packed ray tracing acceleration structure data buffer element format (see ze_rtas_builder_input_data_format_exp_t)",
                "name": "ze_rtas_builder_packed_input_data_format_exp_t",
                "type": "typedef",
                "value": "uint8_t",
                "version": "1.7"
            },
            "ze_rtas_builder_packed_instance_exp_flags_t": {
                "class": "zeRTASBuilder",
                "desc": "Packed ray tracing acceleration structure builder instance flags (see ze_rtas_builder_instance_exp_flags_t)",
                "name": "ze_rtas_builder_packed_instance_exp_flags_t",
                "type": "typedef",
                "value": "uint8_t",
                "version": "1.7"
            },
            "zet_core_callbacks_t": {
                "class": "zetTracerExp",
                "desc": "Alias the existing callbacks definition for 'core' callbacks",
                "name": "zet_core_callbacks_t",
                "type": "typedef",
                "value": "ze_callbacks_t"
            }
        },
        "union": {
            "zet_debug_event_info_t": {
                "class": "zetDebug",
                "desc": "Event type-specific information",
                "members": [
                    {
                        "desc": "[out] type == ZET_DEBUG_EVENT_TYPE_DETACHED",
                        "name": "detached",
                        "type": "zet_debug_event_info_detached_t"
                    },
                    {
                        "desc": "[out] type == ZET_DEBUG_EVENT_TYPE_MODULE_LOAD or ZET_DEBUG_EVENT_TYPE_MODULE_UNLOAD",
                        "name": "module",
                        "type": "zet_debug_event_info_module_t"
                    },
                    {
                        "desc": "[out] type == ZET_DEBUG_EVENT_TYPE_THREAD_STOPPED or ZET_DEBUG_EVENT_TYPE_THREAD_UNAVAILABLE",
                        "name": "thread",
                        "type": "zet_debug_event_info_thread_stopped_t"
                    },
                    {
                        "desc": "[out] type == ZET_DEBUG_EVENT_TYPE_PAGE_FAULT",
                        "name": "page_fault",
                        "type": "zet_debug_event_info_page_fault_t",
                        "version": "1.1"
                    }
                ],
                "name": "zet_debug_event_info_t",
                "type": "union"
            },
            "zet_value_t": {
                "desc": "Union of values",
                "members": [
                    {
                        "desc": "[out] 32-bit unsigned-integer",
                        "name": "ui32",
                        "type": "uint32_t"
                    },
                    {
                        "desc": "[out] 32-bit unsigned-integer",
                        "name": "ui64",
                        "type": "uint64_t"
                    },
                    {
                        "desc": "[out] 32-bit floating-point",
                        "name": "fp32",
                        "type": "float"
                    },
                    {
                        "desc": "[out] 64-bit floating-point",
                        "name": "fp64",
                        "type": "double"
                    },
                    {
                        "desc": "[out] 8-bit boolean",
                        "name": "b8",
                        "type": "ze_bool_t"
                    }
                ],
                "name": "zet_value_t",
                "type": "union"
            }
        }
    },
    "specs": [
        [
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero API common types",
                    "ordinal": 0,
                    "type": "header"
                },
                "name": "common",
                "objects": [
                    {
                        "desc": "Generates generic $OneApi API versions",
                        "name": "$X_MAKE_VERSION( _major, _minor )",
                        "type": "macro",
                        "value": "(( _major << 16 )|( _minor & 0x0000ffff))"
                    },
                    {
                        "desc": "Extracts $OneApi API major version",
                        "name": "$X_MAJOR_VERSION( _ver )",
                        "type": "macro",
                        "value": "( _ver >> 16 )"
                    },
                    {
                        "desc": "Extracts $OneApi API minor version",
                        "name": "$X_MINOR_VERSION( _ver )",
                        "type": "macro",
                        "value": "( _ver & 0x0000ffff )"
                    },
                    {
                        "altvalue": "",
                        "condition": "defined(_WIN32)",
                        "desc": "Calling convention for all API functions",
                        "name": "$X_APICALL",
                        "type": "macro",
                        "value": "__cdecl"
                    },
                    {
                        "condition": "defined(_WIN32)",
                        "desc": "Microsoft-specific dllexport storage-class attribute",
                        "name": "$X_APIEXPORT",
                        "type": "macro",
                        "value": "__declspec(dllexport)"
                    },
                    {
                        "altvalue": "",
                        "condition": "__GNUC__ >= 4",
                        "desc": "GCC-specific dllexport storage-class attribute",
                        "name": "$X_APIEXPORT",
                        "type": "macro",
                        "value": "__attribute__ ((visibility (\"default\")))"
                    },
                    {
                        "condition": "defined(_WIN32)",
                        "desc": "Microsoft-specific dllexport storage-class attribute",
                        "name": "$X_DLLEXPORT",
                        "type": "macro",
                        "value": "__declspec(dllexport)"
                    },
                    {
                        "altvalue": "",
                        "condition": "__GNUC__ >= 4",
                        "desc": "GCC-specific dllexport storage-class attribute",
                        "name": "$X_DLLEXPORT",
                        "type": "macro",
                        "value": "__attribute__ ((visibility (\"default\")))"
                    },
                    {
                        "desc": "compiler-independent type",
                        "name": "$x_bool_t",
                        "type": "typedef",
                        "value": "uint8_t"
                    },
                    {
                        "class": "$xDriver",
                        "desc": "Handle of a driver instance",
                        "name": "$x_driver_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Handle of driver's device object",
                        "name": "$x_device_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xContext",
                        "desc": "Handle of driver's context object",
                        "name": "$x_context_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xCommandQueue",
                        "desc": "Handle of driver's command queue object",
                        "name": "$x_command_queue_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Handle of driver's command list object",
                        "name": "$x_command_list_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xFence",
                        "desc": "Handle of driver's fence object",
                        "name": "$x_fence_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xEventPool",
                        "desc": "Handle of driver's event pool object",
                        "name": "$x_event_pool_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xEvent",
                        "desc": "Handle of driver's event object",
                        "name": "$x_event_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xImage",
                        "desc": "Handle of driver's image object",
                        "name": "$x_image_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xModule",
                        "desc": "Handle of driver's module object",
                        "name": "$x_module_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xModuleBuildLog",
                        "desc": "Handle of module's build log object",
                        "name": "$x_module_build_log_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Handle of driver's kernel object",
                        "name": "$x_kernel_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xSampler",
                        "desc": "Handle of driver's sampler object",
                        "name": "$x_sampler_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xPhysicalMem",
                        "desc": "Handle of physical memory object",
                        "name": "$x_physical_mem_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$xFabricVertex",
                        "desc": "Handle of driver's fabric vertex object",
                        "name": "$x_fabric_vertex_handle_t",
                        "type": "handle",
                        "version": "1.4"
                    },
                    {
                        "class": "$xFabricEdge",
                        "desc": "Handle of driver's fabric edge object",
                        "name": "$x_fabric_edge_handle_t",
                        "type": "handle",
                        "version": "1.4"
                    },
                    {
                        "desc": "Maximum IPC handle size",
                        "name": "$X_MAX_IPC_HANDLE_SIZE",
                        "type": "macro",
                        "value": "64"
                    },
                    {
                        "desc": "IPC handle to a memory allocation",
                        "members": [
                            {
                                "desc": "[out] Opaque data representing an IPC handle",
                                "name": "data[$X_MAX_IPC_HANDLE_SIZE]",
                                "type": "char"
                            }
                        ],
                        "name": "$x_ipc_mem_handle_t",
                        "type": "struct"
                    },
                    {
                        "desc": "IPC handle to a event pool allocation",
                        "members": [
                            {
                                "desc": "[out] Opaque data representing an IPC handle",
                                "name": "data[$X_MAX_IPC_HANDLE_SIZE]",
                                "type": "char"
                            }
                        ],
                        "name": "$x_ipc_event_pool_handle_t",
                        "type": "struct"
                    },
                    {
                        "desc": "Generic macro for enumerator bit masks",
                        "name": "$X_BIT( _i )",
                        "type": "macro",
                        "value": "( 1 << _i )"
                    },
                    {
                        "desc": "Defines Return/Error codes",
                        "etors": [
                            {
                                "desc": "[Core] success",
                                "name": "$X_RESULT_SUCCESS",
                                "value": "0"
                            },
                            {
                                "desc": "[Core] synchronization primitive not signaled",
                                "name": "$X_RESULT_NOT_READY",
                                "value": "1"
                            },
                            {
                                "desc": "[Core] device hung, reset, was removed, or driver update occurred",
                                "name": "$X_RESULT_ERROR_DEVICE_LOST",
                                "value": "0x70000001"
                            },
                            {
                                "desc": "[Core] insufficient host memory to satisfy call",
                                "name": "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY",
                                "value": "0x70000002"
                            },
                            {
                                "desc": "[Core] insufficient device memory to satisfy call",
                                "name": "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY",
                                "value": "0x70000003"
                            },
                            {
                                "desc": "[Core] error occurred when building module, see build log for details",
                                "name": "$X_RESULT_ERROR_MODULE_BUILD_FAILURE",
                                "value": "0x70000004"
                            },
                            {
                                "desc": "[Core] error occurred when linking modules, see build log for details",
                                "name": "$X_RESULT_ERROR_MODULE_LINK_FAILURE",
                                "value": "0x70000005"
                            },
                            {
                                "desc": "[Core] device requires a reset",
                                "name": "$X_RESULT_ERROR_DEVICE_REQUIRES_RESET",
                                "value": "0x70000006",
                                "version": "1.2"
                            },
                            {
                                "desc": "[Core] device currently in low power state",
                                "name": "$X_RESULT_ERROR_DEVICE_IN_LOW_POWER_STATE",
                                "value": "0x70000007",
                                "version": "1.2"
                            },
                            {
                                "desc": "[Core, Experimental] device is not represented by a fabric vertex",
                                "name": "$X_RESULT_EXP_ERROR_DEVICE_IS_NOT_VERTEX",
                                "value": "0x7ff00001",
                                "version": "1.4"
                            },
                            {
                                "desc": "[Core, Experimental] fabric vertex does not represent a device",
                                "name": "$X_RESULT_EXP_ERROR_VERTEX_IS_NOT_DEVICE",
                                "value": "0x7ff00002",
                                "version": "1.4"
                            },
                            {
                                "desc": "[Core, Experimental] fabric vertex represents a remote device or subdevice",
                                "name": "$X_RESULT_EXP_ERROR_REMOTE_DEVICE",
                                "value": "0x7ff00003",
                                "version": "1.4"
                            },
                            {
                                "desc": "[Core, Experimental] operands of comparison are not compatible",
                                "name": "$X_RESULT_EXP_ERROR_OPERANDS_INCOMPATIBLE",
                                "value": "0x7ff00004",
                                "version": "1.7"
                            },
                            {
                                "desc": "[Core, Experimental] ray tracing acceleration structure build operation failed due to insufficient resources, retry with a larger acceleration structure buffer allocation",
                                "name": "$X_RESULT_EXP_RTAS_BUILD_RETRY",
                                "value": "0x7ff00005",
                                "version": "1.7"
                            },
                            {
                                "desc": "[Core, Experimental] ray tracing acceleration structure build operation deferred to parallel operation join",
                                "name": "$X_RESULT_EXP_RTAS_BUILD_DEFERRED",
                                "value": "0x7ff00006",
                                "version": "1.7"
                            },
                            {
                                "desc": "[Sysman] access denied due to permission level",
                                "name": "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS",
                                "value": "0x70010000"
                            },
                            {
                                "desc": "[Sysman] resource already in use and simultaneous access not allowed or resource was removed",
                                "name": "$X_RESULT_ERROR_NOT_AVAILABLE",
                                "value": "0x70010001"
                            },
                            {
                                "desc": "[Common] external required dependency is unavailable or missing",
                                "name": "$X_RESULT_ERROR_DEPENDENCY_UNAVAILABLE",
                                "value": "0x70020000"
                            },
                            {
                                "desc": "[Tools] data may have been dropped",
                                "name": "$X_RESULT_WARNING_DROPPED_DATA",
                                "value": "0x70020001",
                                "version": "1.4"
                            },
                            {
                                "desc": "[Validation] driver is not initialized",
                                "name": "$X_RESULT_ERROR_UNINITIALIZED",
                                "value": "0x78000001"
                            },
                            {
                                "desc": "[Validation] generic error code for unsupported versions",
                                "name": "$X_RESULT_ERROR_UNSUPPORTED_VERSION",
                                "value": "0x78000002"
                            },
                            {
                                "desc": "[Validation] generic error code for unsupported features",
                                "name": "$X_RESULT_ERROR_UNSUPPORTED_FEATURE",
                                "value": "0x78000003"
                            },
                            {
                                "desc": "[Validation] generic error code for invalid arguments",
                                "name": "$X_RESULT_ERROR_INVALID_ARGUMENT",
                                "value": "0x78000004"
                            },
                            {
                                "desc": "[Validation] handle argument is not valid",
                                "name": "$X_RESULT_ERROR_INVALID_NULL_HANDLE",
                                "value": "0x78000005"
                            },
                            {
                                "desc": "[Validation] object pointed to by handle still in-use by device",
                                "name": "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE",
                                "value": "0x78000006"
                            },
                            {
                                "desc": "[Validation] pointer argument may not be nullptr",
                                "name": "$X_RESULT_ERROR_INVALID_NULL_POINTER",
                                "value": "0x78000007"
                            },
                            {
                                "desc": "[Validation] size argument is invalid (e.g., must not be zero)",
                                "name": "$X_RESULT_ERROR_INVALID_SIZE",
                                "value": "0x78000008"
                            },
                            {
                                "desc": "[Validation] size argument is not supported by the device (e.g., too large)",
                                "name": "$X_RESULT_ERROR_UNSUPPORTED_SIZE",
                                "value": "0x78000009"
                            },
                            {
                                "desc": "[Validation] alignment argument is not supported by the device (e.g., too small)",
                                "name": "$X_RESULT_ERROR_UNSUPPORTED_ALIGNMENT",
                                "value": "0x7800000a"
                            },
                            {
                                "desc": "[Validation] synchronization object in invalid state",
                                "name": "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT",
                                "value": "0x7800000b"
                            },
                            {
                                "desc": "[Validation] enumerator argument is not valid",
                                "name": "$X_RESULT_ERROR_INVALID_ENUMERATION",
                                "value": "0x7800000c"
                            },
                            {
                                "desc": "[Validation] enumerator argument is not supported by the device",
                                "name": "$X_RESULT_ERROR_UNSUPPORTED_ENUMERATION",
                                "value": "0x7800000d"
                            },
                            {
                                "desc": "[Validation] image format is not supported by the device",
                                "name": "$X_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT",
                                "value": "0x7800000e"
                            },
                            {
                                "desc": "[Validation] native binary is not supported by the device",
                                "name": "$X_RESULT_ERROR_INVALID_NATIVE_BINARY",
                                "value": "0x7800000f"
                            },
                            {
                                "desc": "[Validation] global variable is not found in the module",
                                "name": "$X_RESULT_ERROR_INVALID_GLOBAL_NAME",
                                "value": "0x78000010"
                            },
                            {
                                "desc": "[Validation] kernel name is not found in the module",
                                "name": "$X_RESULT_ERROR_INVALID_KERNEL_NAME",
                                "value": "0x78000011"
                            },
                            {
                                "desc": "[Validation] function name is not found in the module",
                                "name": "$X_RESULT_ERROR_INVALID_FUNCTION_NAME",
                                "value": "0x78000012"
                            },
                            {
                                "desc": "[Validation] group size dimension is not valid for the kernel or device",
                                "name": "$X_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION",
                                "value": "0x78000013"
                            },
                            {
                                "desc": "[Validation] global width dimension is not valid for the kernel or device",
                                "name": "$X_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION",
                                "value": "0x78000014"
                            },
                            {
                                "desc": "[Validation] kernel argument index is not valid for kernel",
                                "name": "$X_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX",
                                "value": "0x78000015"
                            },
                            {
                                "desc": "[Validation] kernel argument size does not match kernel",
                                "name": "$X_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE",
                                "value": "0x78000016"
                            },
                            {
                                "desc": "[Validation] value of kernel attribute is not valid for the kernel or device",
                                "name": "$X_RESULT_ERROR_INVALID_KERNEL_ATTRIBUTE_VALUE",
                                "value": "0x78000017"
                            },
                            {
                                "desc": "[Validation] module with imports needs to be linked before kernels can be created from it.",
                                "name": "$X_RESULT_ERROR_INVALID_MODULE_UNLINKED",
                                "value": "0x78000018"
                            },
                            {
                                "desc": "[Validation] command list type does not match command queue type",
                                "name": "$X_RESULT_ERROR_INVALID_COMMAND_LIST_TYPE",
                                "value": "0x78000019"
                            },
                            {
                                "desc": "[Validation] copy operations do not support overlapping regions of memory",
                                "name": "$X_RESULT_ERROR_OVERLAPPING_REGIONS",
                                "value": "0x7800001a"
                            },
                            {
                                "desc": "[Sysman] an action is required to complete the desired operation",
                                "name": "$X_RESULT_WARNING_ACTION_REQUIRED",
                                "value": "0x7800001b"
                            },
                            {
                                "desc": "[Core] unknown or internal error",
                                "name": "$X_RESULT_ERROR_UNKNOWN",
                                "value": "0x7ffffffe"
                            }
                        ],
                        "name": "$x_result_t",
                        "type": "enum"
                    },
                    {
                        "desc": "Defines structure types",
                        "etors": [
                            {
                                "desc": "$x_driver_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DRIVER_PROPERTIES",
                                "value": "0x1"
                            },
                            {
                                "desc": "$x_driver_ipc_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DRIVER_IPC_PROPERTIES",
                                "value": "0x2"
                            },
                            {
                                "desc": "$x_device_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_PROPERTIES",
                                "value": "0x3"
                            },
                            {
                                "desc": "$x_device_compute_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_COMPUTE_PROPERTIES",
                                "value": "0x4"
                            },
                            {
                                "desc": "$x_device_module_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_MODULE_PROPERTIES",
                                "value": "0x5"
                            },
                            {
                                "desc": "$x_command_queue_group_properties_t",
                                "name": "$X_STRUCTURE_TYPE_COMMAND_QUEUE_GROUP_PROPERTIES",
                                "value": "0x6"
                            },
                            {
                                "desc": "$x_device_memory_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_MEMORY_PROPERTIES",
                                "value": "0x7"
                            },
                            {
                                "desc": "$x_device_memory_access_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_MEMORY_ACCESS_PROPERTIES",
                                "value": "0x8"
                            },
                            {
                                "desc": "$x_device_cache_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_CACHE_PROPERTIES",
                                "value": "0x9"
                            },
                            {
                                "desc": "$x_device_image_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_IMAGE_PROPERTIES",
                                "value": "0xa"
                            },
                            {
                                "desc": "$x_device_p2p_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_P2P_PROPERTIES",
                                "value": "0xb"
                            },
                            {
                                "desc": "$x_device_external_memory_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_EXTERNAL_MEMORY_PROPERTIES",
                                "value": "0xc"
                            },
                            {
                                "desc": "$x_context_desc_t",
                                "name": "$X_STRUCTURE_TYPE_CONTEXT_DESC",
                                "value": "0xd"
                            },
                            {
                                "desc": "$x_command_queue_desc_t",
                                "name": "$X_STRUCTURE_TYPE_COMMAND_QUEUE_DESC",
                                "value": "0xe"
                            },
                            {
                                "desc": "$x_command_list_desc_t",
                                "name": "$X_STRUCTURE_TYPE_COMMAND_LIST_DESC",
                                "value": "0xf"
                            },
                            {
                                "desc": "$x_event_pool_desc_t",
                                "name": "$X_STRUCTURE_TYPE_EVENT_POOL_DESC",
                                "value": "0x10"
                            },
                            {
                                "desc": "$x_event_desc_t",
                                "name": "$X_STRUCTURE_TYPE_EVENT_DESC",
                                "value": "0x11"
                            },
                            {
                                "desc": "$x_fence_desc_t",
                                "name": "$X_STRUCTURE_TYPE_FENCE_DESC",
                                "value": "0x12"
                            },
                            {
                                "desc": "$x_image_desc_t",
                                "name": "$X_STRUCTURE_TYPE_IMAGE_DESC",
                                "value": "0x13"
                            },
                            {
                                "desc": "$x_image_properties_t",
                                "name": "$X_STRUCTURE_TYPE_IMAGE_PROPERTIES",
                                "value": "0x14"
                            },
                            {
                                "desc": "$x_device_mem_alloc_desc_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_MEM_ALLOC_DESC",
                                "value": "0x15"
                            },
                            {
                                "desc": "$x_host_mem_alloc_desc_t",
                                "name": "$X_STRUCTURE_TYPE_HOST_MEM_ALLOC_DESC",
                                "value": "0x16"
                            },
                            {
                                "desc": "$x_memory_allocation_properties_t",
                                "name": "$X_STRUCTURE_TYPE_MEMORY_ALLOCATION_PROPERTIES",
                                "value": "0x17"
                            },
                            {
                                "desc": "$x_external_memory_export_desc_t",
                                "name": "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_DESC",
                                "value": "0x18"
                            },
                            {
                                "desc": "$x_external_memory_import_fd_t",
                                "name": "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_FD",
                                "value": "0x19"
                            },
                            {
                                "desc": "$x_external_memory_export_fd_t",
                                "name": "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_FD",
                                "value": "0x1a"
                            },
                            {
                                "desc": "$x_module_desc_t",
                                "name": "$X_STRUCTURE_TYPE_MODULE_DESC",
                                "value": "0x1b"
                            },
                            {
                                "desc": "$x_module_properties_t",
                                "name": "$X_STRUCTURE_TYPE_MODULE_PROPERTIES",
                                "value": "0x1c"
                            },
                            {
                                "desc": "$x_kernel_desc_t",
                                "name": "$X_STRUCTURE_TYPE_KERNEL_DESC",
                                "value": "0x1d"
                            },
                            {
                                "desc": "$x_kernel_properties_t",
                                "name": "$X_STRUCTURE_TYPE_KERNEL_PROPERTIES",
                                "value": "0x1e"
                            },
                            {
                                "desc": "$x_sampler_desc_t",
                                "name": "$X_STRUCTURE_TYPE_SAMPLER_DESC",
                                "value": "0x1f"
                            },
                            {
                                "desc": "$x_physical_mem_desc_t",
                                "name": "$X_STRUCTURE_TYPE_PHYSICAL_MEM_DESC",
                                "value": "0x20"
                            },
                            {
                                "desc": "$x_kernel_preferred_group_size_properties_t",
                                "name": "$X_STRUCTURE_TYPE_KERNEL_PREFERRED_GROUP_SIZE_PROPERTIES",
                                "value": "0x21",
                                "version": "1.2"
                            },
                            {
                                "desc": "$x_external_memory_import_win32_handle_t",
                                "name": "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_WIN32",
                                "value": "0x22",
                                "version": "1.2"
                            },
                            {
                                "desc": "$x_external_memory_export_win32_handle_t",
                                "name": "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_WIN32",
                                "value": "0x23",
                                "version": "1.2"
                            },
                            {
                                "desc": "$x_device_raytracing_ext_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_RAYTRACING_EXT_PROPERTIES",
                                "value": "0x00010001",
                                "version": "1.0"
                            },
                            {
                                "desc": "$x_raytracing_mem_alloc_ext_desc_t",
                                "name": "$X_STRUCTURE_TYPE_RAYTRACING_MEM_ALLOC_EXT_DESC",
                                "value": "0x10002",
                                "version": "1.0"
                            },
                            {
                                "desc": "$x_float_atomic_ext_properties_t",
                                "name": "$X_STRUCTURE_TYPE_FLOAT_ATOMIC_EXT_PROPERTIES",
                                "value": "0x10003",
                                "version": "1.1"
                            },
                            {
                                "desc": "$x_cache_reservation_ext_desc_t",
                                "name": "$X_STRUCTURE_TYPE_CACHE_RESERVATION_EXT_DESC",
                                "value": "0x10004",
                                "version": "1.2"
                            },
                            {
                                "desc": "$x_eu_count_ext_t",
                                "name": "$X_STRUCTURE_TYPE_EU_COUNT_EXT",
                                "value": "0x10005",
                                "version": "1.3"
                            },
                            {
                                "desc": "$x_srgb_ext_desc_t",
                                "name": "$X_STRUCTURE_TYPE_SRGB_EXT_DESC",
                                "value": "0x10006",
                                "version": "1.3"
                            },
                            {
                                "desc": "$x_linkage_inspection_ext_desc_t",
                                "name": "$X_STRUCTURE_TYPE_LINKAGE_INSPECTION_EXT_DESC",
                                "value": "0x10007",
                                "version": "1.3"
                            },
                            {
                                "desc": "$x_pci_ext_properties_t",
                                "name": "$X_STRUCTURE_TYPE_PCI_EXT_PROPERTIES",
                                "value": "0x10008",
                                "version": "1.3"
                            },
                            {
                                "desc": "$x_driver_memory_free_ext_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DRIVER_MEMORY_FREE_EXT_PROPERTIES",
                                "value": "0x10009",
                                "version": "1.3"
                            },
                            {
                                "desc": "$x_memory_free_ext_desc_t",
                                "name": "$X_STRUCTURE_TYPE_MEMORY_FREE_EXT_DESC",
                                "value": "0x1000a",
                                "version": "1.3"
                            },
                            {
                                "desc": "$x_memory_compression_hints_ext_desc_t",
                                "name": "$X_STRUCTURE_TYPE_MEMORY_COMPRESSION_HINTS_EXT_DESC",
                                "value": "0x1000b",
                                "version": "1.3"
                            },
                            {
                                "desc": "$x_image_allocation_ext_properties_t",
                                "name": "$X_STRUCTURE_TYPE_IMAGE_ALLOCATION_EXT_PROPERTIES",
                                "value": "0x1000c",
                                "version": "1.3"
                            },
                            {
                                "desc": "$x_device_luid_ext_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_LUID_EXT_PROPERTIES",
                                "value": "0x1000d",
                                "version": "1.4"
                            },
                            {
                                "desc": "$x_device_memory_ext_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_MEMORY_EXT_PROPERTIES",
                                "value": "0x1000e",
                                "version": "1.4"
                            },
                            {
                                "desc": "$x_device_ip_version_ext_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_IP_VERSION_EXT",
                                "value": "0x1000f",
                                "version": "1.5"
                            },
                            {
                                "desc": "$x_image_view_planar_ext_desc_t",
                                "name": "$X_STRUCTURE_TYPE_IMAGE_VIEW_PLANAR_EXT_DESC",
                                "value": "0x10010",
                                "version": "1.5"
                            },
                            {
                                "desc": "$x_event_query_kernel_timestamps_ext_properties_t",
                                "name": "$X_STRUCTURE_TYPE_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_PROPERTIES",
                                "value": "0x10011",
                                "version": "1.6"
                            },
                            {
                                "desc": "$x_event_query_kernel_timestamps_results_ext_properties_t",
                                "name": "$X_STRUCTURE_TYPE_EVENT_QUERY_KERNEL_TIMESTAMPS_RESULTS_EXT_PROPERTIES",
                                "value": "0x10012",
                                "version": "1.6"
                            },
                            {
                                "desc": "$x_kernel_max_group_size_ext_properties_t",
                                "name": "$X_STRUCTURE_TYPE_KERNEL_MAX_GROUP_SIZE_EXT_PROPERTIES",
                                "value": "0x10013",
                                "version": "1.7"
                            },
                            {
                                "desc": "$x_relaxed_allocation_limits_exp_desc_t",
                                "name": "$X_STRUCTURE_TYPE_RELAXED_ALLOCATION_LIMITS_EXP_DESC",
                                "value": "0x00020001",
                                "version": "1.1"
                            },
                            {
                                "desc": "$x_module_program_exp_desc_t",
                                "name": "$X_STRUCTURE_TYPE_MODULE_PROGRAM_EXP_DESC",
                                "value": "0x00020002",
                                "version": "1.0"
                            },
                            {
                                "desc": "$x_scheduling_hint_exp_properties_t",
                                "name": "$X_STRUCTURE_TYPE_SCHEDULING_HINT_EXP_PROPERTIES",
                                "value": "0x00020003",
                                "version": "1.2"
                            },
                            {
                                "desc": "$x_scheduling_hint_exp_desc_t",
                                "name": "$X_STRUCTURE_TYPE_SCHEDULING_HINT_EXP_DESC",
                                "value": "0x00020004",
                                "version": "1.2"
                            },
                            {
                                "desc": "$x_image_view_planar_exp_desc_t",
                                "name": "$X_STRUCTURE_TYPE_IMAGE_VIEW_PLANAR_EXP_DESC",
                                "value": "0x00020005",
                                "version": "1.2"
                            },
                            {
                                "desc": "$x_device_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_PROPERTIES_1_2",
                                "value": "0x00020006",
                                "version": "1.2"
                            },
                            {
                                "desc": "$x_image_memory_properties_exp_t",
                                "name": "$X_STRUCTURE_TYPE_IMAGE_MEMORY_EXP_PROPERTIES",
                                "value": "0x00020007",
                                "version": "1.2"
                            },
                            {
                                "desc": "$x_context_power_saving_hint_exp_desc_t",
                                "name": "$X_STRUCTURE_TYPE_POWER_SAVING_HINT_EXP_DESC",
                                "value": "0x00020008",
                                "version": "1.2"
                            },
                            {
                                "desc": "$x_copy_bandwidth_exp_properties_t",
                                "name": "$X_STRUCTURE_TYPE_COPY_BANDWIDTH_EXP_PROPERTIES",
                                "value": "0x00020009",
                                "version": "1.4"
                            },
                            {
                                "desc": "$x_device_p2p_bandwidth_exp_properties_t",
                                "name": "$X_STRUCTURE_TYPE_DEVICE_P2P_BANDWIDTH_EXP_PROPERTIES",
                                "value": "0x0002000A",
                                "version": "1.4"
                            },
                            {
                                "desc": "$x_fabric_vertex_exp_properties_t",
                                "name": "$X_STRUCTURE_TYPE_FABRIC_VERTEX_EXP_PROPERTIES",
                                "value": "0x0002000B",
                                "version": "1.4"
                            },
                            {
                                "desc": "$x_fabric_edge_exp_properties_t",
                                "name": "$X_STRUCTURE_TYPE_FABRIC_EDGE_EXP_PROPERTIES",
                                "value": "0x0002000C",
                                "version": "1.4"
                            },
                            {
                                "desc": "$x_memory_sub_allocations_exp_properties_t",
                                "name": "$X_STRUCTURE_TYPE_MEMORY_SUB_ALLOCATIONS_EXP_PROPERTIES",
                                "value": "0x0002000D",
                                "version": "1.5"
                            },
                            {
                                "desc": "$x_rtas_builder_exp_desc_t",
                                "name": "$X_STRUCTURE_TYPE_RTAS_BUILDER_EXP_DESC",
                                "value": "0x0002000E",
                                "version": "1.7"
                            },
                            {
                                "desc": "$x_rtas_builder_build_op_exp_desc_t",
                                "name": "$X_STRUCTURE_TYPE_RTAS_BUILDER_BUILD_OP_EXP_DESC",
                                "value": "0x0002000F",
                                "version": "1.7"
                            },
                            {
                                "desc": "$x_rtas_builder_exp_properties_t",
                                "name": "$X_STRUCTURE_TYPE_RTAS_BUILDER_EXP_PROPERTIES",
                                "value": "0x00020010",
                                "version": "1.7"
                            },
                            {
                                "desc": "$x_rtas_parallel_operation_exp_properties_t",
                                "name": "$X_STRUCTURE_TYPE_RTAS_PARALLEL_OPERATION_EXP_PROPERTIES",
                                "value": "0x00020011",
                                "version": "1.7"
                            },
                            {
                                "desc": "$x_rtas_device_exp_properties_t",
                                "name": "$X_STRUCTURE_TYPE_RTAS_DEVICE_EXP_PROPERTIES",
                                "value": "0x00020012",
                                "version": "1.7"
                            },
                            {
                                "desc": "$x_rtas_geometry_aabbs_exp_cb_params_t",
                                "name": "$X_STRUCTURE_TYPE_RTAS_GEOMETRY_AABBS_EXP_CB_PARAMS",
                                "value": "0x00020013",
                                "version": "1.7"
                            }
                        ],
                        "name": "$x_structure_type_t",
                        "type": "enum"
                    },
                    {
                        "desc": "External memory type flags",
                        "etors": [
                            {
                                "desc": "an opaque POSIX file descriptor handle",
                                "name": "$X_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_FD",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "a file descriptor handle for a Linux dma_buf",
                                "name": "$X_EXTERNAL_MEMORY_TYPE_FLAG_DMA_BUF",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "an NT handle",
                                "name": "$X_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_WIN32",
                                "value": "$X_BIT(2)",
                                "version": "1.2"
                            },
                            {
                                "desc": "a global share (KMT) handle",
                                "name": "$X_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_WIN32_KMT",
                                "value": "$X_BIT(3)",
                                "version": "1.2"
                            },
                            {
                                "desc": "an NT handle referring to a Direct3D 10 or 11 texture resource",
                                "name": "$X_EXTERNAL_MEMORY_TYPE_FLAG_D3D11_TEXTURE",
                                "value": "$X_BIT(4)",
                                "version": "1.2"
                            },
                            {
                                "desc": "a global share (KMT) handle referring to a Direct3D 10 or 11 texture resource",
                                "name": "$X_EXTERNAL_MEMORY_TYPE_FLAG_D3D11_TEXTURE_KMT",
                                "value": "$X_BIT(5)",
                                "version": "1.2"
                            },
                            {
                                "desc": "an NT handle referring to a Direct3D 12 heap resource",
                                "name": "$X_EXTERNAL_MEMORY_TYPE_FLAG_D3D12_HEAP",
                                "value": "$X_BIT(6)",
                                "version": "1.2"
                            },
                            {
                                "desc": "an NT handle referring to a Direct3D 12 committed resource",
                                "name": "$X_EXTERNAL_MEMORY_TYPE_FLAG_D3D12_RESOURCE",
                                "value": "$X_BIT(7)",
                                "version": "1.2"
                            }
                        ],
                        "name": "$x_external_memory_type_flags_t",
                        "type": "enum"
                    },
                    {
                        "desc": "Bandwidth unit",
                        "etors": [
                            {
                                "desc": "The unit used for bandwidth is unknown",
                                "name": "$X_BANDWIDTH_UNIT_UNKNOWN",
                                "value": "0"
                            },
                            {
                                "desc": "Bandwidth is provided in bytes/nanosec",
                                "name": "$X_BANDWIDTH_UNIT_BYTES_PER_NANOSEC",
                                "value": "1"
                            },
                            {
                                "desc": "Bandwidth is provided in bytes/clock",
                                "name": "$X_BANDWIDTH_UNIT_BYTES_PER_CLOCK",
                                "value": "2"
                            }
                        ],
                        "name": "$x_bandwidth_unit_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "desc": "Latency unit",
                        "etors": [
                            {
                                "desc": "The unit used for latency is unknown",
                                "name": "$X_LATENCY_UNIT_UNKNOWN",
                                "value": "0"
                            },
                            {
                                "desc": "Latency is provided in nanosecs",
                                "name": "$X_LATENCY_UNIT_NANOSEC",
                                "value": "1"
                            },
                            {
                                "desc": "Latency is provided in clocks",
                                "name": "$X_LATENCY_UNIT_CLOCK",
                                "value": "2"
                            },
                            {
                                "desc": "Latency is provided in hops (normalized so that the lowest latency link has a latency of 1 hop)",
                                "name": "$X_LATENCY_UNIT_HOP",
                                "value": "3"
                            }
                        ],
                        "name": "$x_latency_unit_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "desc": "Maximum universal unique id (UUID) size in bytes",
                        "name": "$X_MAX_UUID_SIZE",
                        "type": "macro",
                        "value": "16",
                        "version": "1.4"
                    },
                    {
                        "desc": "Universal unique id (UUID)",
                        "members": [
                            {
                                "desc": "[out] opaque data representing a UUID",
                                "name": "id[$X_MAX_UUID_SIZE]",
                                "type": "uint8_t"
                            }
                        ],
                        "name": "$x_uuid_t",
                        "type": "struct",
                        "version": "1.4"
                    },
                    {
                        "desc": "Base for all callback function parameter types",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            }
                        ],
                        "name": "$x_base_cb_params_t",
                        "type": "struct"
                    },
                    {
                        "desc": "Base for all properties types",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            }
                        ],
                        "name": "$x_base_properties_t",
                        "type": "struct"
                    },
                    {
                        "desc": "Base for all descriptor types",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            }
                        ],
                        "name": "$x_base_desc_t",
                        "type": "struct"
                    },
                    {
                        "category": "Device",
                        "desc": "Forces driver to only report devices (and sub-devices) as specified by values",
                        "name": "$X_AFFINITY_MASK",
                        "type": "env",
                        "values": "Hex String"
                    },
                    {
                        "category": "Device",
                        "default": "0",
                        "desc": "Forces driver to report devices from lowest to highest PCI bus ID",
                        "name": "$X_ENABLE_PCI_ID_DEVICE_ORDER",
                        "type": "env",
                        "values": "0, 1"
                    },
                    {
                        "category": "Memory",
                        "default": "0",
                        "desc": "Forces all shared allocations into device memory",
                        "name": "$X_SHARED_FORCE_DEVICE_ALLOC",
                        "type": "env",
                        "values": "0, 1"
                    },
                    {
                        "category": "Device",
                        "desc": "Defines the device hierarchy model exposed by Level Zero driver implementation",
                        "name": "$X_FLAT_DEVICE_HIERARCHY",
                        "type": "env",
                        "values": "String",
                        "version": "1.7"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs",
                    "ordinal": 1,
                    "type": "header"
                },
                "name": "driver",
                "objects": [
                    {
                        "class": "$x",
                        "desc": "Supported initialization flags",
                        "etors": [
                            {
                                "desc": "only initialize GPU drivers",
                                "name": "$X_INIT_FLAG_GPU_ONLY",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "only initialize VPU drivers",
                                "name": "$X_INIT_FLAG_VPU_ONLY",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$x_init_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$x",
                        "decl": "static",
                        "desc": "Initialize the $OneApi driver(s)",
                        "details": [
                            "The application must call this function before calling any other function.",
                            "If this function is not called then all other functions will return $X_RESULT_ERROR_UNINITIALIZED.",
                            "Only one instance of each driver will be initialized per process.",
                            "The application may call this function multiple times with different flags or environment variables enabled.",
                            "The application must call this function after forking new processes. Each forked process must call this function.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe for scenarios where multiple libraries may initialize the driver(s) simultaneously."
                        ],
                        "hash": "5d0f0a237e08f18d9633efe31fd66345ebcd05516be66e64efb9c2b83d64b349",
                        "name": "Init",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] initialization flags.\nmust be 0 (default) or a combination of $x_init_flag_t.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_init_flags_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x3 < flags`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "clGetPlatformIDs"
                        ],
                        "class": "$xDriver",
                        "decl": "static",
                        "desc": "Retrieves driver instances",
                        "details": [
                            "A driver represents a collection of physical devices.",
                            "Multiple calls to this function will return identical driver handles, in the same order.",
                            "The application may pass nullptr for pDrivers when only querying the number of drivers.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "c075c24db932dc7ae2f6afded783352a374cf0811dd2037e1b362d24d80670ce",
                        "name": "Get",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in,out] pointer to the number of driver instances.\nif count is zero, then the loader shall update the value with the total number of drivers available.\nif count is greater than the number of drivers available, then the loader shall update the value with the correct number of drivers available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of driver instance handles.\nif count is less than the number of drivers available, then the loader shall only retrieve that number of drivers.\n",
                                "name": "phDrivers",
                                "type": "$x_driver_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xDriver",
                        "desc": "Supported API versions",
                        "details": [
                            "API versions contain major and minor attributes, use $X_MAJOR_VERSION and $X_MINOR_VERSION"
                        ],
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_API_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "version 1.1",
                                "name": "$X_API_VERSION_1_1",
                                "value": "$X_MAKE_VERSION( 1, 1 )",
                                "version": "1.1"
                            },
                            {
                                "desc": "version 1.2",
                                "name": "$X_API_VERSION_1_2",
                                "value": "$X_MAKE_VERSION( 1, 2 )",
                                "version": "1.2"
                            },
                            {
                                "desc": "version 1.3",
                                "name": "$X_API_VERSION_1_3",
                                "value": "$X_MAKE_VERSION( 1, 3 )",
                                "version": "1.3"
                            },
                            {
                                "desc": "version 1.4",
                                "name": "$X_API_VERSION_1_4",
                                "value": "$X_MAKE_VERSION( 1, 4 )",
                                "version": "1.4"
                            },
                            {
                                "desc": "version 1.5",
                                "name": "$X_API_VERSION_1_5",
                                "value": "$X_MAKE_VERSION( 1, 5 )",
                                "version": "1.5"
                            },
                            {
                                "desc": "version 1.6",
                                "name": "$X_API_VERSION_1_6",
                                "value": "$X_MAKE_VERSION( 1, 6 )",
                                "version": "1.6"
                            },
                            {
                                "desc": "version 1.7",
                                "name": "$X_API_VERSION_1_7",
                                "value": "$X_MAKE_VERSION( 1, 7 )",
                                "version": "1.7"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_API_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 7 )"
                            }
                        ],
                        "name": "$x_api_version_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xDriver",
                        "desc": "Returns the API version supported by the specified driver",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "4aeb05f8ea502a5a979a88d1e84cb6f237eed4d53f73fd96e47287706c95a15d",
                        "name": "GetApiVersion",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the driver instance",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[out] api version",
                                "name": "version",
                                "type": "$x_api_version_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == version`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "Maximum driver universal unique id (UUID) size in bytes",
                        "name": "$X_MAX_DRIVER_UUID_SIZE",
                        "type": "macro",
                        "value": "16"
                    },
                    {
                        "desc": "Driver universal unique id (UUID)",
                        "members": [
                            {
                                "desc": "[out] opaque data representing a driver UUID",
                                "name": "id[$X_MAX_DRIVER_UUID_SIZE]",
                                "type": "uint8_t"
                            }
                        ],
                        "name": "$x_driver_uuid_t",
                        "type": "struct"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDriver",
                        "desc": "Driver properties queried using $xDriverGetProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DRIVER_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] universal unique identifier.",
                                "name": "uuid",
                                "type": "$x_driver_uuid_t"
                            },
                            {
                                "desc": "[out] driver version\nThe driver version is a non-zero, monotonically increasing value where higher values always indicate a more recent version.\n",
                                "name": "driverVersion",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_driver_properties_t",
                        "type": "struct"
                    },
                    {
                        "analogue": [
                            "**clGetPlatformInfo**"
                        ],
                        "class": "$xDriver",
                        "desc": "Retrieves properties of the driver.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "52b34612e97cab4b40e1216a0aaa42f0d590535dbe465643e92ef750b724d254",
                        "name": "GetProperties",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the driver instance",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for driver properties",
                                "name": "pDriverProperties",
                                "type": "$x_driver_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pDriverProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xDriver",
                        "desc": "Supported IPC property flags",
                        "etors": [
                            {
                                "desc": "Supports passing memory allocations between processes. See $xMemGetIpcHandle.",
                                "name": "$X_IPC_PROPERTY_FLAG_MEMORY",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Supports passing event pools between processes. See $xEventPoolGetIpcHandle.",
                                "name": "$X_IPC_PROPERTY_FLAG_EVENT_POOL",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$x_ipc_property_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDriver",
                        "desc": "IPC properties queried using $xDriverGetIpcProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DRIVER_IPC_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] 0 (none) or a valid combination of $x_ipc_property_flag_t",
                                "name": "flags",
                                "type": "$x_ipc_property_flags_t"
                            }
                        ],
                        "name": "$x_driver_ipc_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xDriver",
                        "desc": "Retrieves IPC attributes of the driver",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "3f55d5186d2c4daedc8426a8adfb98ad27492c060c20748bebad12ec50bd5293",
                        "name": "GetIpcProperties",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the driver instance",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for IPC properties",
                                "name": "pIpcProperties",
                                "type": "$x_driver_ipc_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pIpcProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "Maximum extension name string size",
                        "name": "$X_MAX_EXTENSION_NAME",
                        "type": "macro",
                        "value": "256"
                    },
                    {
                        "class": "$xDriver",
                        "desc": "Extension properties queried using $xDriverGetExtensionProperties",
                        "members": [
                            {
                                "desc": "[out] extension name",
                                "name": "name[$X_MAX_EXTENSION_NAME]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] extension version using $X_MAKE_VERSION",
                                "name": "version",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_driver_extension_properties_t",
                        "type": "struct"
                    },
                    {
                        "analogue": [
                            "**vkEnumerateInstanceExtensionProperties**"
                        ],
                        "class": "$xDriver",
                        "desc": "Retrieves extension properties",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "8e44ae247d11d858ca4bad79512a3bf69323a900b1ac782903bb513479bba13a",
                        "name": "GetExtensionProperties",
                        "params": [
                            {
                                "desc": "[in] handle of the driver instance",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of extension properties.\nif count is zero, then the driver shall update the value with the total number of extension properties available.\nif count is greater than the number of extension properties available, then the driver shall update the value with the correct number of extension properties available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of query results for extension properties.\nif count is less than the number of extension properties available, then driver shall only retrieve that number of extension properties.\n",
                                "name": "pExtensionProperties",
                                "type": "$x_driver_extension_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xDriver",
                        "desc": "Retrieves function pointer for vendor-specific or experimental extensions",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "06b81bd7c84e1d4a4ce904b9123444ca519be82720267c97f602201ac5009dc8",
                        "name": "GetExtensionFunctionAddress",
                        "params": [
                            {
                                "desc": "[in] handle of the driver instance",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in] extension function name",
                                "name": "name",
                                "type": "const char*"
                            },
                            {
                                "desc": "[out] pointer to function pointer",
                                "name": "ppFunctionAddress",
                                "type": "void**"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == name`",
                                    "`nullptr == ppFunctionAddress`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.1"
                    },
                    {
                        "attribute": "singleton",
                        "desc": "C++ wrapper for a driver instance handle",
                        "members": [
                            {
                                "desc": "[in] handle of the driver instance",
                                "name": "handle",
                                "type": "$x_driver_handle_t"
                            }
                        ],
                        "name": "$xDriver",
                        "type": "class"
                    },
                    {
                        "class": "$xDriver",
                        "desc": "Retrieves a string describing the last error code returned by the driver in the current thread.",
                        "details": [
                            "String returned is thread local.",
                            "String is only updated on calls returning an error, i.e., not on calls returning $X_RESULT_SUCCESS.",
                            "String may be empty if driver considers error code is already explicit enough to describe cause.",
                            "Memory pointed to by ppString is owned by the driver.",
                            "String returned is null-terminated."
                        ],
                        "hash": "a3ac6b1e67b0b263ef01af2319655f3a1efe1b2d8483fa6eb1ce4f0e80af0612",
                        "name": "GetLastErrorDescription",
                        "params": [
                            {
                                "desc": "[in] handle of the driver instance",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to a null-terminated array of characters describing cause of error.",
                                "name": "ppString",
                                "type": "const char**"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ppString`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.6"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Device",
                    "ordinal": 2,
                    "type": "header"
                },
                "name": "device",
                "objects": [
                    {
                        "class": "$xDevice",
                        "decl": "static",
                        "desc": "Retrieves devices within a driver",
                        "details": [
                            "Multiple calls to this function will return identical device handles, in the same order.",
                            "The number and order of handles returned from this function is affected by the $X_AFFINITY_MASK and $X_ENABLE_PCI_ID_DEVICE_ORDER environment variables.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "b2ba8b3e2881214c2cd5fba7e747a86a0f5b47cd65f3e8f3736de88857fb4c1f",
                        "name": "Get",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the driver instance",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of devices.\nif count is zero, then the driver shall update the value with the total number of devices available.\nif count is greater than the number of devices available, then the driver shall update the value with the correct number of devices available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of devices.\nif count is less than the number of devices available, then driver shall only retrieve that number of devices.\n",
                                "name": "phDevices",
                                "type": "$x_device_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Retrieves the root-device of a device handle",
                        "details": [
                            "When the device handle passed does not belong to any root-device, nullptr is returned.",
                            "Multiple calls to this function will return the same device handle.",
                            "The root-device handle returned by this function does not have access automatically to the resources\ncreated with the associated sub-device, unless those resources have been created with a context\nexplicitly containing both handles.\n",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "0bbac157544da3d3020c75b2f762fe8dd1478b32e281d59fae2769988693f2a3",
                        "name": "GetRootDevice",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the device object",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] parent root device.",
                                "name": "phRootDevice",
                                "type": "$x_device_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phRootDevice`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "analogue": [
                            "clCreateSubDevices"
                        ],
                        "class": "$xDevice",
                        "desc": "Retrieves a sub-device from a device",
                        "details": [
                            "When the device handle passed does not contain any sub-device, a pCount of 0 is returned.",
                            "Multiple calls to this function will return identical device handles, in the same order.",
                            "The number of handles returned from this function is affected by the $X_AFFINITY_MASK environment variable.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "c5cfde4e916b948e35c7cd02c26f6a6bd17741a8b1f3e8227fb3c5285222dee0",
                        "name": "GetSubDevices",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the device object",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of sub-devices.\nif count is zero, then the driver shall update the value with the total number of sub-devices available.\nif count is greater than the number of sub-devices available, then the driver shall update the value with the correct number of sub-devices available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of sub-devices.\nif count is less than the number of sub-devices available, then driver shall only retrieve that number of sub-devices.\n",
                                "name": "phSubdevices",
                                "type": "$x_device_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Supported device types",
                        "etors": [
                            {
                                "desc": "Graphics Processing Unit",
                                "name": "$X_DEVICE_TYPE_GPU",
                                "value": "1"
                            },
                            {
                                "desc": "Central Processing Unit",
                                "name": "$X_DEVICE_TYPE_CPU",
                                "value": "2"
                            },
                            {
                                "desc": "Field Programmable Gate Array",
                                "name": "$X_DEVICE_TYPE_FPGA",
                                "value": "3"
                            },
                            {
                                "desc": "Memory Copy Accelerator",
                                "name": "$X_DEVICE_TYPE_MCA",
                                "value": "4"
                            },
                            {
                                "desc": "Vision Processing Unit",
                                "name": "$X_DEVICE_TYPE_VPU",
                                "value": "5"
                            }
                        ],
                        "name": "$x_device_type_t",
                        "type": "enum"
                    },
                    {
                        "desc": "Maximum device universal unique id (UUID) size in bytes",
                        "name": "$X_MAX_DEVICE_UUID_SIZE",
                        "type": "macro",
                        "value": "16"
                    },
                    {
                        "desc": "Device universal unique id (UUID)",
                        "members": [
                            {
                                "desc": "[out] opaque data representing a device UUID",
                                "name": "id[$X_MAX_DEVICE_UUID_SIZE]",
                                "type": "uint8_t"
                            }
                        ],
                        "name": "$x_device_uuid_t",
                        "type": "struct"
                    },
                    {
                        "desc": "Maximum device name string size",
                        "name": "$X_MAX_DEVICE_NAME",
                        "type": "macro",
                        "value": "256"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Supported device property flags",
                        "etors": [
                            {
                                "desc": "Device is integrated with the Host.",
                                "name": "$X_DEVICE_PROPERTY_FLAG_INTEGRATED",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Device handle used for query represents a sub-device.",
                                "name": "$X_DEVICE_PROPERTY_FLAG_SUBDEVICE",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Device supports error correction memory access.",
                                "name": "$X_DEVICE_PROPERTY_FLAG_ECC",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "Device supports on-demand page-faulting.",
                                "name": "$X_DEVICE_PROPERTY_FLAG_ONDEMANDPAGING",
                                "value": "$X_BIT(3)"
                            }
                        ],
                        "name": "$x_device_property_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Device properties queried using $xDeviceGetProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] generic device type",
                                "name": "type",
                                "type": "$x_device_type_t"
                            },
                            {
                                "desc": "[out] vendor id from PCI configuration",
                                "name": "vendorId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] device id from PCI configuration\nNote, the device id uses little-endian format.\n",
                                "name": "deviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] 0 (none) or a valid combination of $x_device_property_flag_t",
                                "name": "flags",
                                "type": "$x_device_property_flags_t"
                            },
                            {
                                "desc": "[out] sub-device id. Only valid if $X_DEVICE_PROPERTY_FLAG_SUBDEVICE is set.",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Clock rate for device core.",
                                "name": "coreClockRate",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum memory allocation size.",
                                "name": "maxMemAllocSize",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Maximum number of logical hardware contexts.",
                                "name": "maxHardwareContexts",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum priority for command queues. Higher value is higher priority.",
                                "name": "maxCommandQueuePriority",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum number of threads per EU.",
                                "name": "numThreadsPerEU",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] The physical EU simd width.",
                                "name": "physicalEUSimdWidth",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum number of EUs per sub-slice.",
                                "name": "numEUsPerSubslice",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum number of sub-slices per slice.",
                                "name": "numSubslicesPerSlice",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum number of slices.",
                                "name": "numSlices",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Returns the resolution of device timer used for profiling, timestamps, etc. When stype==$X_STRUCTURE_TYPE_DEVICE_PROPERTIES the units are in nanoseconds. When stype==$X_STRUCTURE_TYPE_DEVICE_PROPERTIES_1_2 units are in cycles/sec",
                                "name": "timerResolution",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Returns the number of valid bits in the timestamp value.",
                                "name": "timestampValidBits",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Returns the number of valid bits in the kernel timestamp values",
                                "name": "kernelTimestampValidBits",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] universal unique identifier. Note: Subdevices will have their own uuid.",
                                "name": "uuid",
                                "type": "$x_device_uuid_t"
                            },
                            {
                                "desc": "[out] Device name",
                                "name": "name[$X_MAX_DEVICE_NAME]",
                                "type": "char"
                            }
                        ],
                        "name": "$x_device_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Device thread identifier.",
                        "members": [
                            {
                                "desc": "[in,out] the slice number.\nMust be `UINT32_MAX` (all) or less than the `numSlices` member of $x_device_properties_t.\n",
                                "name": "slice",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in,out] the sub-slice number within its slice.\nMust be `UINT32_MAX` (all) or less than the `numSubslicesPerSlice` member of $x_device_properties_t.\n",
                                "name": "subslice",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in,out] the EU number within its sub-slice.\nMust be `UINT32_MAX` (all) or less than the `numEUsPerSubslice` member of $x_device_properties_t.\n",
                                "name": "eu",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in,out] the thread number within its EU.\nMust be `UINT32_MAX` (all) or less than the `numThreadsPerEU` member of $x_device_properties_t.\n",
                                "name": "thread",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_device_thread_t",
                        "type": "struct"
                    },
                    {
                        "analogue": [
                            "clGetDeviceInfo"
                        ],
                        "class": "$xDevice",
                        "desc": "Retrieves properties of the device.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "3db75068efff2256a55cef1327ecc78abc4667e68c27a09621c6312ae779c145",
                        "name": "GetProperties",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for device properties",
                                "name": "pDeviceProperties",
                                "type": "$x_device_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pDeviceProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "Maximum number of subgroup sizes supported.",
                        "name": "$X_SUBGROUPSIZE_COUNT",
                        "type": "macro",
                        "value": "8"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Device compute properties queried using $xDeviceGetComputeProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_COMPUTE_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] Maximum items per compute group. (groupSizeX * groupSizeY * groupSizeZ) <= maxTotalGroupSize",
                                "name": "maxTotalGroupSize",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum items for X dimension in group",
                                "name": "maxGroupSizeX",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum items for Y dimension in group",
                                "name": "maxGroupSizeY",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum items for Z dimension in group",
                                "name": "maxGroupSizeZ",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum groups that can be launched for x dimension",
                                "name": "maxGroupCountX",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum groups that can be launched for y dimension",
                                "name": "maxGroupCountY",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum groups that can be launched for z dimension",
                                "name": "maxGroupCountZ",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum shared local memory per group.",
                                "name": "maxSharedLocalMemory",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Number of subgroup sizes supported. This indicates number of entries in subGroupSizes.",
                                "name": "numSubGroupSizes",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Size group sizes supported.",
                                "name": "subGroupSizes[$X_SUBGROUPSIZE_COUNT]",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_device_compute_properties_t",
                        "type": "struct"
                    },
                    {
                        "analogue": [
                            "clGetDeviceInfo"
                        ],
                        "class": "$xDevice",
                        "desc": "Retrieves compute properties of the device.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "7f1420ab7455a639874a23c83d2643e649a65a1340bad17572fed4071c94142b",
                        "name": "GetComputeProperties",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for compute properties",
                                "name": "pComputeProperties",
                                "type": "$x_device_compute_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pComputeProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "Maximum native kernel universal unique id (UUID) size in bytes",
                        "name": "$X_MAX_NATIVE_KERNEL_UUID_SIZE",
                        "type": "macro",
                        "value": "16"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Native kernel universal unique id (UUID)",
                        "members": [
                            {
                                "desc": "[out] opaque data representing a native kernel UUID",
                                "name": "id[$X_MAX_NATIVE_KERNEL_UUID_SIZE]",
                                "type": "uint8_t"
                            }
                        ],
                        "name": "$x_native_kernel_uuid_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Supported device module flags",
                        "etors": [
                            {
                                "desc": "Device supports 16-bit floating-point operations",
                                "name": "$X_DEVICE_MODULE_FLAG_FP16",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Device supports 64-bit floating-point operations",
                                "name": "$X_DEVICE_MODULE_FLAG_FP64",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Device supports 64-bit atomic operations",
                                "name": "$X_DEVICE_MODULE_FLAG_INT64_ATOMICS",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "Device supports four component dot product and accumulate operations",
                                "name": "$X_DEVICE_MODULE_FLAG_DP4A",
                                "value": "$X_BIT(3)"
                            }
                        ],
                        "name": "$x_device_module_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Supported floating-Point capability flags",
                        "etors": [
                            {
                                "desc": "Supports denorms",
                                "name": "$X_DEVICE_FP_FLAG_DENORM",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Supports INF and quiet NaNs",
                                "name": "$X_DEVICE_FP_FLAG_INF_NAN",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Supports rounding to nearest even rounding mode",
                                "name": "$X_DEVICE_FP_FLAG_ROUND_TO_NEAREST",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "Supports rounding to zero.",
                                "name": "$X_DEVICE_FP_FLAG_ROUND_TO_ZERO",
                                "value": "$X_BIT(3)"
                            },
                            {
                                "desc": "Supports rounding to both positive and negative INF.",
                                "name": "$X_DEVICE_FP_FLAG_ROUND_TO_INF",
                                "value": "$X_BIT(4)"
                            },
                            {
                                "desc": "Supports IEEE754-2008 fused multiply-add.",
                                "name": "$X_DEVICE_FP_FLAG_FMA",
                                "value": "$X_BIT(5)"
                            },
                            {
                                "desc": "Supports rounding as defined by IEEE754 for divide and sqrt operations.",
                                "name": "$X_DEVICE_FP_FLAG_ROUNDED_DIVIDE_SQRT",
                                "value": "$X_BIT(6)"
                            },
                            {
                                "desc": "Uses software implementation for basic floating-point operations.",
                                "name": "$X_DEVICE_FP_FLAG_SOFT_FLOAT",
                                "value": "$X_BIT(7)"
                            }
                        ],
                        "name": "$x_device_fp_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Device module properties queried using $xDeviceGetModuleProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_MODULE_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] Maximum supported SPIR-V version.\nReturns zero if SPIR-V is not supported.\nContains major and minor attributes, use $X_MAJOR_VERSION and $X_MINOR_VERSION.\n",
                                "name": "spirvVersionSupported",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] 0 or a valid combination of $x_device_module_flag_t",
                                "name": "flags",
                                "type": "$x_device_module_flags_t"
                            },
                            {
                                "desc": "[out] Capabilities for half-precision floating-point operations.\nreturns 0 (if $X_DEVICE_MODULE_FLAG_FP16 is not set) or a combination of $x_device_fp_flag_t.\n",
                                "name": "fp16flags",
                                "type": "$x_device_fp_flags_t"
                            },
                            {
                                "desc": "[out] Capabilities for single-precision floating-point operations.\nreturns a combination of $x_device_fp_flag_t.\n",
                                "name": "fp32flags",
                                "type": "$x_device_fp_flags_t"
                            },
                            {
                                "desc": "[out] Capabilities for double-precision floating-point operations.\nreturns 0 (if $X_DEVICE_MODULE_FLAG_FP64 is not set) or a combination of $x_device_fp_flag_t.\n",
                                "name": "fp64flags",
                                "type": "$x_device_fp_flags_t"
                            },
                            {
                                "desc": "[out] Maximum kernel argument size that is supported.",
                                "name": "maxArgumentsSize",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum size of internal buffer that holds output of printf calls from kernel.",
                                "name": "printfBufferSize",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Compatibility UUID of supported native kernel.\nUUID may or may not be the same across driver release, devices, or operating systems.\nApplication is responsible for ensuring UUID matches before creating module using\npreviously created native kernel.\n",
                                "name": "nativeKernelSupported",
                                "type": "$x_native_kernel_uuid_t"
                            }
                        ],
                        "name": "$x_device_module_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Retrieves module properties of the device",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "9e5d1ce3fb67ea2e00c710fc6eef0fe7caf842ce5ddb43fc56f009765f1ffcc1",
                        "name": "GetModuleProperties",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for module properties",
                                "name": "pModuleProperties",
                                "type": "$x_device_module_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pModuleProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Supported command queue group property flags",
                        "etors": [
                            {
                                "desc": "Command queue group supports enqueing compute commands.",
                                "name": "$X_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COMPUTE",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Command queue group supports enqueing copy commands.",
                                "name": "$X_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COPY",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Command queue group supports cooperative kernels.\nSee $xCommandListAppendLaunchCooperativeKernel for more details.\n",
                                "name": "$X_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COOPERATIVE_KERNELS",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "Command queue groups supports metric queries.",
                                "name": "$X_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_METRICS",
                                "value": "$X_BIT(3)"
                            }
                        ],
                        "name": "$x_command_queue_group_property_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Command queue group properties queried using $xDeviceGetCommandQueueGroupProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_COMMAND_QUEUE_GROUP_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] 0 (none) or a valid combination of $x_command_queue_group_property_flag_t",
                                "name": "flags",
                                "type": "$x_command_queue_group_property_flags_t"
                            },
                            {
                                "desc": "[out] maximum `pattern_size` supported by command queue group.\nSee $xCommandListAppendMemoryFill for more details.\n",
                                "name": "maxMemoryFillPatternSize",
                                "type": "size_t"
                            },
                            {
                                "desc": "[out] the number of physical engines within the group.",
                                "name": "numQueues",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_command_queue_group_properties_t",
                        "type": "struct"
                    },
                    {
                        "analogue": [
                            "**vkGetPhysicalDeviceQueueFamilyProperties**"
                        ],
                        "class": "$xDevice",
                        "desc": "Retrieves command queue group properties of the device.",
                        "details": [
                            "Properties are reported for each physical command queue type supported by the device.",
                            "Multiple calls to this function will return properties in the same order.",
                            "The order in which the properties are returned defines the command queue group's ordinal.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "4d89248f9e54ca673c3e133ddd0a3b5a7ab46bc27866a7f6978f5b43860cd6b0",
                        "name": "GetCommandQueueGroupProperties",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of command queue group properties.\nif count is zero, then the driver shall update the value with the total number of command queue group properties available.\nif count is greater than the number of command queue group properties available, then the driver shall update the value with the correct number of command queue group properties available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of query results for command queue group properties.\nif count is less than the number of command queue group properties available, then driver shall only retrieve that number of command queue group properties.\n",
                                "name": "pCommandQueueGroupProperties",
                                "type": "$x_command_queue_group_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Supported device memory property flags",
                        "etors": [
                            {
                                "desc": "reserved for future use",
                                "name": "$X_DEVICE_MEMORY_PROPERTY_FLAG_TBD",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$x_device_memory_property_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Device local memory properties queried using $xDeviceGetMemoryProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_MEMORY_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] 0 (none) or a valid combination of $x_device_memory_property_flag_t",
                                "name": "flags",
                                "type": "$x_device_memory_property_flags_t"
                            },
                            {
                                "desc": "[out] Maximum clock rate for device memory.",
                                "name": "maxClockRate",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum bus width between device and memory.",
                                "name": "maxBusWidth",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Total memory size in bytes that is available to the device.",
                                "name": "totalSize",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Memory name",
                                "name": "name[$X_MAX_DEVICE_NAME]",
                                "type": "char"
                            }
                        ],
                        "name": "$x_device_memory_properties_t",
                        "type": "struct"
                    },
                    {
                        "analogue": [
                            "clGetDeviceInfo"
                        ],
                        "class": "$xDevice",
                        "desc": "Retrieves local memory properties of the device.",
                        "details": [
                            "Properties are reported for each physical memory type supported by the device.",
                            "Multiple calls to this function will return properties in the same order.",
                            "The order in which the properties are returned defines the device's local memory ordinal.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "f28eb5727554e11a61cdab0d97af8c41880e56e379c2594800a0226c6e72340b",
                        "name": "GetMemoryProperties",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of memory properties.\nif count is zero, then the driver shall update the value with the total number of memory properties available.\nif count is greater than the number of memory properties available, then the driver shall update the value with the correct number of memory properties available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of query results for memory properties.\nif count is less than the number of memory properties available, then driver shall only retrieve that number of memory properties.\n",
                                "name": "pMemProperties",
                                "type": "$x_device_memory_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Memory access capability flags",
                        "details": [
                            "Supported access capabilities for different types of memory allocations"
                        ],
                        "etors": [
                            {
                                "desc": "Supports load/store access",
                                "name": "$X_MEMORY_ACCESS_CAP_FLAG_RW",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Supports atomic access",
                                "name": "$X_MEMORY_ACCESS_CAP_FLAG_ATOMIC",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Supports concurrent access",
                                "name": "$X_MEMORY_ACCESS_CAP_FLAG_CONCURRENT",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "Supports concurrent atomic access",
                                "name": "$X_MEMORY_ACCESS_CAP_FLAG_CONCURRENT_ATOMIC",
                                "value": "$X_BIT(3)"
                            }
                        ],
                        "name": "$x_memory_access_cap_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Device memory access properties queried using $xDeviceGetMemoryAccessProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_MEMORY_ACCESS_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] host memory capabilities.\nreturns 0 (unsupported) or a combination of $x_memory_access_cap_flag_t.\n",
                                "name": "hostAllocCapabilities",
                                "type": "$x_memory_access_cap_flags_t"
                            },
                            {
                                "desc": "[out] device memory capabilities.\nreturns 0 (unsupported) or a combination of $x_memory_access_cap_flag_t.\n",
                                "name": "deviceAllocCapabilities",
                                "type": "$x_memory_access_cap_flags_t"
                            },
                            {
                                "desc": "[out] shared, single-device memory capabilities.\nreturns 0 (unsupported) or a combination of $x_memory_access_cap_flag_t.\n",
                                "name": "sharedSingleDeviceAllocCapabilities",
                                "type": "$x_memory_access_cap_flags_t"
                            },
                            {
                                "desc": "[out] shared, cross-device memory capabilities.\nreturns 0 (unsupported) or a combination of $x_memory_access_cap_flag_t.\n",
                                "name": "sharedCrossDeviceAllocCapabilities",
                                "type": "$x_memory_access_cap_flags_t"
                            },
                            {
                                "desc": "[out] shared, system memory capabilities.\nreturns 0 (unsupported) or a combination of $x_memory_access_cap_flag_t.\n",
                                "name": "sharedSystemAllocCapabilities",
                                "type": "$x_memory_access_cap_flags_t"
                            }
                        ],
                        "name": "$x_device_memory_access_properties_t",
                        "type": "struct"
                    },
                    {
                        "analogue": [
                            "clGetDeviceInfo"
                        ],
                        "class": "$xDevice",
                        "desc": "Retrieves memory access properties of the device.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "e874d3ac0d34ac6938b4be6d38888e2f568d939aef6960e1d5803d6258142613",
                        "name": "GetMemoryAccessProperties",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for memory access properties",
                                "name": "pMemAccessProperties",
                                "type": "$x_device_memory_access_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pMemAccessProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Supported cache control property flags",
                        "etors": [
                            {
                                "desc": "Device support User Cache Control (i.e. SLM section vs Generic Cache)",
                                "name": "$X_DEVICE_CACHE_PROPERTY_FLAG_USER_CONTROL",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$x_device_cache_property_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Device cache properties queried using $xDeviceGetCacheProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_CACHE_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] 0 (none) or a valid combination of $x_device_cache_property_flag_t",
                                "name": "flags",
                                "type": "$x_device_cache_property_flags_t"
                            },
                            {
                                "desc": "[out] Per-cache size, in bytes",
                                "name": "cacheSize",
                                "type": "size_t"
                            }
                        ],
                        "name": "$x_device_cache_properties_t",
                        "type": "struct"
                    },
                    {
                        "analogue": [
                            "clGetDeviceInfo"
                        ],
                        "class": "$xDevice",
                        "desc": "Retrieves cache properties of the device",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "493480cf46dd0872dca7d72ddd49bbe4b0cdac57b58f634fee06939ba2d4822c",
                        "name": "GetCacheProperties",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of cache properties.\nif count is zero, then the driver shall update the value with the total number of cache properties available.\nif count is greater than the number of cache properties available, then the driver shall update the value with the correct number of cache properties available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of query results for cache properties.\nif count is less than the number of cache properties available, then driver shall only retrieve that number of cache properties.\n",
                                "name": "pCacheProperties",
                                "type": "$x_device_cache_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Device image properties queried using $xDeviceGetImageProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_IMAGE_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] Maximum image dimensions for 1D resources. if 0, then 1D images are unsupported.",
                                "name": "maxImageDims1D",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum image dimensions for 2D resources. if 0, then 2D images are unsupported.",
                                "name": "maxImageDims2D",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum image dimensions for 3D resources. if 0, then 3D images are unsupported.",
                                "name": "maxImageDims3D",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Maximum image buffer size in bytes. if 0, then buffer images are unsupported.",
                                "name": "maxImageBufferSize",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Maximum image array slices. if 0, then image arrays are unsupported.",
                                "name": "maxImageArraySlices",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Max samplers that can be used in kernel. if 0, then sampling is unsupported.",
                                "name": "maxSamplers",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Returns the maximum number of simultaneous image objects that can be read from by a kernel. if 0, then reading images is unsupported.",
                                "name": "maxReadImageArgs",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Returns the maximum number of simultaneous image objects that can be written to by a kernel. if 0, then writing images is unsupported.",
                                "name": "maxWriteImageArgs",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_device_image_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Retrieves image properties of the device",
                        "details": [
                            "See $xImageGetProperties for format-specific capabilities.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "bde7a513c160408c6c590644da9f96a3e8c341222d50c1f4cb015595727aafa7",
                        "name": "GetImageProperties",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for image properties",
                                "name": "pImageProperties",
                                "type": "$x_device_image_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pImageProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Device external memory import and export properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_EXTERNAL_MEMORY_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] Supported external memory import types for memory allocations.",
                                "name": "memoryAllocationImportTypes",
                                "type": "$x_external_memory_type_flags_t"
                            },
                            {
                                "desc": "[out] Supported external memory export types for memory allocations.",
                                "name": "memoryAllocationExportTypes",
                                "type": "$x_external_memory_type_flags_t"
                            },
                            {
                                "desc": "[out] Supported external memory import types for images.",
                                "name": "imageImportTypes",
                                "type": "$x_external_memory_type_flags_t"
                            },
                            {
                                "desc": "[out] Supported external memory export types for images.",
                                "name": "imageExportTypes",
                                "type": "$x_external_memory_type_flags_t"
                            }
                        ],
                        "name": "$x_device_external_memory_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Retrieves external memory import and export of the device",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "d81f59bbdb025bf574b919caac089a8ce331897bda578e170f4ade841f7100d4",
                        "name": "GetExternalMemoryProperties",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for external memory properties",
                                "name": "pExternalMemoryProperties",
                                "type": "$x_device_external_memory_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pExternalMemoryProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Supported device peer-to-peer property flags",
                        "etors": [
                            {
                                "desc": "Device supports access between peer devices.",
                                "name": "$X_DEVICE_P2P_PROPERTY_FLAG_ACCESS",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Device supports atomics between peer devices.",
                                "name": "$X_DEVICE_P2P_PROPERTY_FLAG_ATOMICS",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$x_device_p2p_property_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Device peer-to-peer properties queried using $xDeviceGetP2PProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_P2P_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] 0 (none) or a valid combination of $x_device_p2p_property_flag_t",
                                "name": "flags",
                                "type": "$x_device_p2p_property_flags_t"
                            }
                        ],
                        "name": "$x_device_p2p_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Retrieves peer-to-peer properties between one device and a peer devices",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "3c9fd37471b51c83bbd77b22c8ded7aa056bcf0badc076f48796a83f2cd0635e",
                        "name": "GetP2PProperties",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the device performing the access",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] handle of the peer device with the allocation",
                                "name": "hPeerDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] Peer-to-Peer properties between source and peer device",
                                "name": "pP2PProperties",
                                "type": "$x_device_p2p_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`",
                                    "`nullptr == hPeerDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pP2PProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Queries if one device can directly access peer device allocations",
                        "details": [
                            "Any device can access any other device within a node through a scale-up fabric.",
                            {
                                "The following are conditions for CanAccessPeer query.": [
                                    "If both device and peer device are the same then return true.",
                                    "If both sub-device and peer sub-device are the same then return true.",
                                    "If both are sub-devices and share the same parent device then return true.",
                                    "If both device and remote device are connected by a direct or indirect scale-up fabric or over PCIe (same root complex or shared PCIe switch) then true.",
                                    "If both sub-device and remote parent device (and vice-versa) are connected by a direct or indirect scale-up fabric or over PCIe (same root complex or shared PCIe switch) then true."
                                ]
                            },
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "c0efe8786ca9d0204583c7af454d4d27a3c5bff533ae3c4a002d017c0f444943",
                        "name": "CanAccessPeer",
                        "ordinal": "2",
                        "params": [
                            {
                                "desc": "[in] handle of the device performing the access",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] handle of the peer device with the allocation",
                                "name": "hPeerDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[out] returned access capability",
                                "name": "value",
                                "type": "$x_bool_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`",
                                    "`nullptr == hPeerDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == value`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Returns current status of the device.",
                        "details": [
                            "Once a device is reset, this call will update the OS handle attached to the device handle.",
                            "The application may call this function from simultaneous threads with the same device handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "e3087067d8407e296898a321ddf329a3f60a83925f6853e4fa1d5770f3cb9a7d",
                        "name": "GetStatus",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_SUCCESS": [
                                    "Device is available for use."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": [
                                    "Device is lost; must be reset for use."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Returns synchronized Host and device global timestamps.",
                        "details": [
                            "The application may call this function from simultaneous threads with the same device handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "2ad37bd9529ed6bc957d68b53699066d3294f886224528d4eb06cb86782c44f2",
                        "name": "GetGlobalTimestamps",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[out] value of the Host's global timestamp that correlates with the Device's global timestamp value",
                                "name": "hostTimestamp",
                                "type": "uint64_t*"
                            },
                            {
                                "desc": "[out] value of the Device's global timestamp that correlates with the Host's global timestamp value",
                                "name": "deviceTimestamp",
                                "type": "uint64_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == hostTimestamp`",
                                    "`nullptr == deviceTimestamp`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.1"
                    },
                    {
                        "attribute": "singleton",
                        "desc": "C++ wrapper for a device",
                        "members": [
                            {
                                "desc": "[in] handle of device object",
                                "name": "handle",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDriver",
                                "type": "$xDriver*"
                            }
                        ],
                        "name": "$xDevice",
                        "owner": "$xDriver",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Context",
                    "ordinal": 3,
                    "type": "header"
                },
                "name": "context",
                "objects": [
                    {
                        "class": "$xContext",
                        "desc": "Supported context creation flags",
                        "etors": [
                            {
                                "desc": "reserved for future use",
                                "name": "$X_CONTEXT_FLAG_TBD",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$x_context_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xContext",
                        "desc": "Context descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_CONTEXT_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of $x_context_flag_t;\ndefault behavior may use implicit driver-based heuristics.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_context_flags_t"
                            }
                        ],
                        "name": "$x_context_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xContext",
                        "decl": "static",
                        "desc": "Creates a context for the driver.",
                        "details": [
                            "The application must only use the context for the driver which was provided during creation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "8edd2e5e988c895b42b55522617a91bdfd520226584f6e1b1f0f7df457718278",
                        "name": "Create",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the driver object",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in] pointer to context descriptor",
                                "name": "desc",
                                "type": "const $x_context_desc_t*"
                            },
                            {
                                "desc": "[out] pointer to handle of context object created",
                                "name": "phContext",
                                "type": "$x_context_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x1 < desc->flags`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xContext",
                        "decl": "static",
                        "desc": "Creates a context for the driver.",
                        "details": [
                            "The application must only use the context for the driver which was provided during creation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "d71315745f374bebe2c15c3fe1ae79886e18dd91495169b5d2c7359baae5dc9e",
                        "name": "CreateEx",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the driver object",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in] pointer to context descriptor",
                                "name": "desc",
                                "type": "const $x_context_desc_t*"
                            },
                            {
                                "desc": "[in][optional] number of device handles; must be 0 if `nullptr == phDevices`",
                                "name": "numDevices",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numDevices)] array of device handles which context has visibility.\nif nullptr, then all devices and any sub-devices supported by the driver instance are\nvisible to the context.\notherwise, the context only has visibility to the devices and any sub-devices of the\ndevices in this array.\n",
                                "name": "phDevices",
                                "type": "$x_device_handle_t*"
                            },
                            {
                                "desc": "[out] pointer to handle of context object created",
                                "name": "phContext",
                                "type": "$x_context_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x1 < desc->flags`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phDevices) && (0 < numDevices)`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.1"
                    },
                    {
                        "class": "$xContext",
                        "decl": "static",
                        "desc": "Destroys a context.",
                        "details": [
                            "The application must ensure the device is not currently referencing the context before it is deleted.",
                            "The implementation of this function may immediately free all Host and Device allocations associated with this context.",
                            "The application must **not** call this function from simultaneous threads with the same context handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "4627daecdd8fd1df84623741b0b5b7011262fb3e245fc429c30dc820555e3a2a",
                        "name": "Destroy",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in][release] handle of context object to destroy",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xContext",
                        "desc": "Returns current status of the context.",
                        "details": [
                            "The application may call this function from simultaneous threads with the same context handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "916b95db8d91275de73f2f168f5c3e402ea64d5fa6c33be1074d0955da333d48",
                        "name": "GetStatus",
                        "params": [
                            {
                                "desc": "[in] handle of context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_SUCCESS": [
                                    "Context is available for use."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": [
                                    "Context is invalid; due to device lost or reset."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for context",
                        "members": [
                            {
                                "desc": "[in] handle of context object",
                                "name": "handle",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDriver",
                                "type": "$xDriver*"
                            }
                        ],
                        "name": "$xContext",
                        "owner": "$xDriver",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Command Queue",
                    "ordinal": 4,
                    "type": "header"
                },
                "name": "cmdqueue",
                "objects": [
                    {
                        "class": "$xCommandQueue",
                        "desc": "Supported command queue flags",
                        "etors": [
                            {
                                "desc": "command queue should be optimized for submission to a single device engine.\ndriver **must** disable any implicit optimizations for distributing work across multiple engines.\nthis flag should be used when applications want full control over multi-engine submission and scheduling.\n",
                                "name": "$X_COMMAND_QUEUE_FLAG_EXPLICIT_ONLY",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "To be used only when creating immediate command lists. Commands appended to the immediate command\nlist are executed in-order, with driver implementation enforcing dependencies between them.\nApplication is not required to have the signal event of a given command being the wait event of\nthe next to define an in-order list, and application is allowed to pass signal and wait events\nto each appended command to implement more complex dependency graphs.\n",
                                "name": "$X_COMMAND_QUEUE_FLAG_IN_ORDER",
                                "value": "$X_BIT(1)",
                                "version": "1.7"
                            }
                        ],
                        "name": "$x_command_queue_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xCommandQueue",
                        "desc": "Supported command queue modes",
                        "etors": [
                            {
                                "desc": "implicit default behavior; uses driver-based heuristics",
                                "name": "$X_COMMAND_QUEUE_MODE_DEFAULT",
                                "value": "0"
                            },
                            {
                                "desc": "Device execution always completes immediately on execute;\nHost thread is blocked using wait on implicit synchronization object\n",
                                "name": "$X_COMMAND_QUEUE_MODE_SYNCHRONOUS",
                                "value": "1"
                            },
                            {
                                "desc": "Device execution is scheduled and will complete in future;\nexplicit synchronization object must be used to determine completeness\n",
                                "name": "$X_COMMAND_QUEUE_MODE_ASYNCHRONOUS",
                                "value": "2"
                            }
                        ],
                        "name": "$x_command_queue_mode_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xCommandQueue",
                        "desc": "Supported command queue priorities",
                        "etors": [
                            {
                                "desc": "[default] normal priority",
                                "name": "$X_COMMAND_QUEUE_PRIORITY_NORMAL",
                                "value": "0"
                            },
                            {
                                "desc": "lower priority than normal",
                                "name": "$X_COMMAND_QUEUE_PRIORITY_PRIORITY_LOW",
                                "value": "1"
                            },
                            {
                                "desc": "higher priority than normal",
                                "name": "$X_COMMAND_QUEUE_PRIORITY_PRIORITY_HIGH",
                                "value": "2"
                            }
                        ],
                        "name": "$x_command_queue_priority_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xCommandQueue",
                        "desc": "Command Queue descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_COMMAND_QUEUE_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] command queue group ordinal",
                                "name": "ordinal",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] command queue index within the group;\nmust be zero if $X_COMMAND_QUEUE_FLAG_EXPLICIT_ONLY is not set\n",
                                "name": "index",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] usage flags.\nmust be 0 (default) or a valid combination of $x_command_queue_flag_t;\ndefault behavior may use implicit driver-based heuristics to balance latency and throughput.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_command_queue_flags_t"
                            },
                            {
                                "desc": "[in] operation mode",
                                "init": "$X_COMMAND_QUEUE_MODE_DEFAULT",
                                "name": "mode",
                                "type": "$x_command_queue_mode_t"
                            },
                            {
                                "desc": "[in] priority",
                                "init": "$X_COMMAND_QUEUE_PRIORITY_NORMAL",
                                "name": "priority",
                                "type": "$x_command_queue_priority_t"
                            }
                        ],
                        "name": "$x_command_queue_desc_t",
                        "type": "struct"
                    },
                    {
                        "analogue": [
                            "**clCreateCommandQueue**"
                        ],
                        "class": "$xCommandQueue",
                        "decl": "static",
                        "desc": "Creates a command queue on the context.",
                        "details": [
                            "A command queue represents a logical input stream to the device, tied to a physical input stream.",
                            "The application must only use the command queue for the device, or its sub-devices, which was provided during creation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "0fff59d7fcec87793ced6fca06c635a891faa7d965539e68560156d45620faed",
                        "name": "Create",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device object",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] pointer to command queue descriptor",
                                "name": "desc",
                                "type": "const $x_command_queue_desc_t*"
                            },
                            {
                                "desc": "[out] pointer to handle of command queue object created",
                                "name": "phCommandQueue",
                                "type": "$x_command_queue_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phCommandQueue`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x3 < desc->flags`",
                                    "`$X_COMMAND_QUEUE_MODE_ASYNCHRONOUS < desc->mode`",
                                    "`$X_COMMAND_QUEUE_PRIORITY_PRIORITY_HIGH < desc->priority`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "**clReleaseCommandQueue**"
                        ],
                        "class": "$xCommandQueue",
                        "decl": "static",
                        "desc": "Destroys a command queue.",
                        "details": [
                            "The application must destroy all fence handles created from the command queue before destroying the command queue itself",
                            "The application must ensure the device is not currently referencing the command queue before it is deleted",
                            "The implementation of this function may immediately free all Host and Device allocations associated with this command queue",
                            "The application must **not** call this function from simultaneous threads with the same command queue handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "d2b4274520dcb902a966ba04f31f4c7e3976a1a6e0b6ad73d64713baa10785d4",
                        "name": "Destroy",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in][release] handle of command queue object to destroy",
                                "name": "hCommandQueue",
                                "type": "$x_command_queue_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandQueue`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "vkQueueSubmit"
                        ],
                        "class": "$xCommandQueue",
                        "desc": "Executes a command list in a command queue.",
                        "details": [
                            "The command lists are submitted to the device in the order they are received, whether from multiple calls (on the same or different threads) or a single call with multiple command lists.",
                            "The application must ensure the command lists are accessible by the device on which the command queue was created.",
                            "The application must ensure the device is not currently referencing the command list since the implementation is allowed to modify the contents of the command list for submission.",
                            "The application must only execute command lists created with an identical command queue group ordinal to the command queue.",
                            "The application must use a fence created using the same command queue.",
                            "The application must ensure the command queue, command list and fence were created on the same context.",
                            "The application must ensure the command lists being executed are not immediate command lists.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "38c40fa4b4a7b503a5f43b59ef659ef84d37e12cc3ea04d378c665a7de3b6c4c",
                        "name": "ExecuteCommandLists",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the command queue",
                                "name": "hCommandQueue",
                                "type": "$x_command_queue_handle_t"
                            },
                            {
                                "desc": "[in] number of command lists to execute",
                                "name": "numCommandLists",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][range(0, numCommandLists)] list of handles of the command lists to execute",
                                "name": "phCommandLists",
                                "type": "$x_command_list_handle_t*"
                            },
                            {
                                "desc": "[in][optional] handle of the fence to signal on completion",
                                "name": "hFence",
                                "type": "$x_fence_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandQueue`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phCommandLists`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`0 == numCommandLists`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_COMMAND_LIST_TYPE": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandQueue",
                        "desc": "Synchronizes a command queue by waiting on the host.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "7f909e35eca980d6b02b05a87d35661018470382d0016a1ca2a41a47e879116c",
                        "name": "Synchronize",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the command queue",
                                "name": "hCommandQueue",
                                "type": "$x_command_queue_handle_t"
                            },
                            {
                                "desc": "[in] if non-zero, then indicates the maximum time (in nanoseconds) to yield before returning $X_RESULT_SUCCESS or $X_RESULT_NOT_READY;\nif zero, then immediately returns the status of the command queue;\nif `UINT64_MAX`, then function will not return until complete or device is lost.\nDue to external dependencies, timeout may be rounded to the closest value allowed by the accuracy of those dependencies.\n",
                                "name": "timeout",
                                "type": "uint64_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandQueue`"
                                ]
                            },
                            {
                                "$X_RESULT_NOT_READY": [
                                    "timeout expired"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for command queue",
                        "members": [
                            {
                                "desc": "[in] handle of command queue object",
                                "name": "handle",
                                "type": "$x_command_queue_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$xDevice*"
                            },
                            {
                                "desc": "[in] descriptor of the command queue object",
                                "name": "desc",
                                "type": "$x_command_queue_desc_t"
                            }
                        ],
                        "name": "$xCommandQueue",
                        "owner": "$xDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Command List",
                    "ordinal": 5,
                    "type": "header"
                },
                "name": "cmdlist",
                "objects": [
                    {
                        "class": "$xCommandList",
                        "desc": "Supported command list creation flags",
                        "etors": [
                            {
                                "desc": "driver may reorder commands (e.g., kernels, copies) between barriers and synchronization primitives.\nusing this flag may increase Host overhead of $xCommandListClose.\ntherefore, this flag should **not** be set for low-latency usage-models.\n",
                                "name": "$X_COMMAND_LIST_FLAG_RELAXED_ORDERING",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "driver may perform additional optimizations that increase execution throughput. \nusing this flag may increase Host overhead of $xCommandListClose and $xCommandQueueExecuteCommandLists.\ntherefore, this flag should **not** be set for low-latency usage-models.\n",
                                "name": "$X_COMMAND_LIST_FLAG_MAXIMIZE_THROUGHPUT",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "command list should be optimized for submission to a single command queue and device engine.\ndriver **must** disable any implicit optimizations for distributing work across multiple engines.\nthis flag should be used when applications want full control over multi-engine submission and scheduling.\n",
                                "name": "$X_COMMAND_LIST_FLAG_EXPLICIT_ONLY",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "commands appended to this command list are executed in-order, with driver implementation\nenforcing dependencies between them. Application is not required to have the signal event\nof a given command being the wait event of the next to define an in-order list, and\napplication is allowed to pass signal and wait events to each appended command to implement\nmore complex dependency graphs. Cannot be combined with $X_COMMAND_LIST_FLAG_RELAXED_ORDERING.\n",
                                "name": "$X_COMMAND_LIST_FLAG_IN_ORDER",
                                "value": "$X_BIT(3)",
                                "version": "1.7"
                            }
                        ],
                        "name": "$x_command_list_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xCommandList",
                        "desc": "Command List descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_COMMAND_LIST_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] command queue group ordinal to which this command list will be submitted",
                                "name": "commandQueueGroupOrdinal",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] usage flags.\nmust be 0 (default) or a valid combination of $x_command_list_flag_t;\ndefault behavior may use implicit driver-based heuristics to balance latency and throughput.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_command_list_flags_t"
                            }
                        ],
                        "name": "$x_command_list_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xCommandList",
                        "decl": "static",
                        "desc": "Creates a command list on the context.",
                        "details": [
                            "A command list represents a sequence of commands for execution on a command queue.",
                            "The command list is created in the 'open' state.",
                            "The application must only use the command list for the device, or its sub-devices, which was provided during creation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "c4a08a29b43c24b0e9b379381e5e67cfd9f1a893a6a265d9ecc9e42d00b140a3",
                        "name": "Create",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device object",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] pointer to command list descriptor",
                                "name": "desc",
                                "type": "const $x_command_list_desc_t*"
                            },
                            {
                                "desc": "[out] pointer to handle of command list object created",
                                "name": "phCommandList",
                                "type": "$x_command_list_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0xf < desc->flags`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "decl": "static",
                        "desc": "Creates an immediate command list on the context.",
                        "details": [
                            "An immediate command list is used for low-latency submission of commands.",
                            "An immediate command list creates an implicit command queue.",
                            "Immediate command lists must not be passed to $xCommandQueueExecuteCommandLists.",
                            "Commands appended into an immediate command list may execute synchronously, by blocking until the command is complete.",
                            "The command list is created in the 'open' state and never needs to be closed.",
                            "The application must only use the command list for the device, or its sub-devices, which was provided during creation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "1563ad20ea2a985de2198858084ef59027e1f44676ac696ddf7356143ad9a544",
                        "name": "CreateImmediate",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device object",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] pointer to command queue descriptor",
                                "name": "altdesc",
                                "type": "const $x_command_queue_desc_t*"
                            },
                            {
                                "desc": "[out] pointer to handle of command list object created",
                                "name": "phCommandList",
                                "type": "$x_command_list_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == altdesc`",
                                    "`nullptr == phCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x3 < altdesc->flags`",
                                    "`$X_COMMAND_QUEUE_MODE_ASYNCHRONOUS < altdesc->mode`",
                                    "`$X_COMMAND_QUEUE_PRIORITY_PRIORITY_HIGH < altdesc->priority`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "decl": "static",
                        "desc": "Destroys a command list.",
                        "details": [
                            "The application must ensure the device is not currently referencing the command list before it is deleted.",
                            "The implementation of this function may immediately free all Host and Device allocations associated with this command list.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "bda478b6a2926bea888c8c1b4c9a333a3a13205d3fc16d3ae0972b97335fc4ff",
                        "name": "Destroy",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in][release] handle of command list object to destroy",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Closes a command list; ready to be executed by a command queue.",
                        "details": [
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "90afb0f4260abf7f09ed295975efc80087058f86a66e73983dd9c9b30f8b2a48",
                        "name": "Close",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of command list object to close",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Reset a command list to initial (empty) state; ready for appending commands.",
                        "details": [
                            "The application must ensure the device is not currently referencing the command list before it is reset",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "66bc9e2b7766eb06b0315ded3a6c40ea09ad7181fb12b2ad53d2c3d801085382",
                        "name": "Reset",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of command list object to reset",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Appends a memory write of the device's global timestamp value into a command list.",
                        "details": [
                            "The application must ensure the events are accessible by the device on which the command list was created.",
                            "The timestamp frequency can be queried from the `timerResolution` member of $x_device_properties_t.",
                            "The number of valid bits in the timestamp value can be queried from the `timestampValidBits` member of $x_device_properties_t.",
                            "The application must ensure the memory pointed to by dstptr is accessible by the device on which the command list was created.",
                            "The application must ensure the command list and events were created, and the memory was allocated, on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "620d2dca06e6c6bb04322005bce81b51791428e2067de2e40dd0b139ebe9dd89",
                        "name": "AppendWriteGlobalTimestamp",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to memory where timestamp value will be written; must be 8byte-aligned.",
                                "name": "dstptr",
                                "type": "uint64_t*"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before executing query; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before executing query",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == dstptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Synchronizes an immediate command list by waiting on the host for the completion of all commands previously submitted to it.",
                        "details": [
                            "The application must call this function only with command lists created with $xCommandListCreateImmediate.",
                            "Waiting on one immediate command list shall not block the concurrent execution of commands appended to other\nimmediate command lists created with either a different ordinal or different index.\n",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "676e5a921f37f7e6bd62bdf18bd9d693decf69aadc86ebc33cc12bd5184a7414",
                        "name": "HostSynchronize",
                        "params": [
                            {
                                "desc": "[in] handle of the immediate command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] if non-zero, then indicates the maximum time (in nanoseconds) to yield before returning $X_RESULT_SUCCESS or $X_RESULT_NOT_READY;\nif zero, then immediately returns the status of the immediate command list;\nif `UINT64_MAX`, then function will not return until complete or device is lost.\nDue to external dependencies, timeout may be rounded to the closest value allowed by the accuracy of those dependencies.\n",
                                "name": "timeout",
                                "type": "uint64_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_NOT_READY": [
                                    "timeout expired"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ARGUMENT": [
                                    "handle does not correspond to an immediate command list"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.6"
                    },
                    {
                        "desc": "C++ wrapper for command list",
                        "members": [
                            {
                                "desc": "[in] handle of command list object",
                                "name": "handle",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$xDevice*"
                            },
                            {
                                "desc": "[in] descriptor of the command list object",
                                "name": "desc",
                                "type": "$x_command_list_desc_t"
                            }
                        ],
                        "name": "$xCommandList",
                        "owner": "$xDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Barrier",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "barrier",
                "objects": [
                    {
                        "analogue": [
                            "**vkCmdPipelineBarrier**",
                            "clEnqueueBarrierWithWaitList"
                        ],
                        "class": "$xCommandList",
                        "desc": "Appends an execution and global memory barrier into a command list.",
                        "details": [
                            "The application must ensure the events are accessible by the device on which the command list was created.",
                            "If numWaitEvents is zero, then all previous commands, enqueued on same command queue, must complete prior to the execution of the barrier. This is not the case when numWaitEvents is non-zero.",
                            "If numWaitEvents is non-zero, then only all phWaitEvents must be signaled prior to the execution of the barrier.",
                            "This command blocks all following commands from beginning until the execution of the barrier completes.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "5a1b934c89a448d55bf286086ad31aa09ca2ccdf5e12b073074de61f54adaec1",
                        "name": "AppendBarrier",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before executing barrier; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before executing barrier",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Appends a global memory ranges barrier into a command list.",
                        "details": [
                            "The application must ensure the events are accessible by the device on which the command list was created.",
                            "If numWaitEvents is zero, then all previous commands are completed prior to the execution of the barrier.",
                            "If numWaitEvents is non-zero, then then all phWaitEvents must be signaled prior to the execution of the barrier.",
                            "This command blocks all following commands from beginning until the execution of the barrier completes.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "fae8b64e8c86fd1906d766d41853886f1dbdb52d56a653b71bda797ae302cd7c",
                        "name": "AppendMemoryRangesBarrier",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] number of memory ranges",
                                "name": "numRanges",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][range(0, numRanges)] array of sizes of memory range",
                                "name": "pRangeSizes",
                                "type": "const size_t*"
                            },
                            {
                                "desc": "[in][range(0, numRanges)] array of memory ranges",
                                "name": "pRanges",
                                "type": "const void**"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before executing barrier; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before executing barrier",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pRangeSizes`",
                                    "`nullptr == pRanges`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xContext",
                        "desc": "Ensures in-bound writes to the device are globally observable.",
                        "details": [
                            "This is a special-case system level barrier that can be used to ensure global observability of writes; \ntypically needed after a producer (e.g., NIC) performs direct writes to the device's memory (e.g., Direct RDMA writes).\nThis is typically required when the memory corresponding to the writes is subsequently accessed from a remote device.\n",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "704009b09d19e5a30335258a0ad70ee6527d0d08e5c7dee4a0b17e6849931bc6",
                        "name": "SystemBarrier",
                        "params": [
                            {
                                "desc": "[in] handle of context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            }
                        ],
                        "type": "function"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Copies",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "copy",
                "objects": [
                    {
                        "analogue": [
                            "**clEnqueueCopyBuffer**",
                            "**clEnqueueReadBuffer**",
                            "**clEnqueueWriteBuffer**",
                            "**clEnqueueSVMMemcpy**"
                        ],
                        "class": "$xCommandList",
                        "desc": "Copies host, device, or shared memory.",
                        "details": [
                            "The application must ensure the memory pointed to by dstptr and srcptr is accessible by the device on which the command list was created.",
                            "The implementation must not access the memory pointed to by dstptr and srcptr as they are free to be modified by either the Host or device up until execution.",
                            "The application must ensure the events are accessible by the device on which the command list was created.",
                            "The application must ensure the command list and events were created, and the memory was allocated, on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "ad0b0d6ec34781d2d948dae898bcef13d0c53606d2e15f44083e0344c71b0c58",
                        "name": "AppendMemoryCopy",
                        "params": [
                            {
                                "desc": "[in] handle of command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] pointer to destination memory to copy to",
                                "name": "dstptr",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] pointer to source memory to copy from",
                                "name": "srcptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] size in bytes to copy",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == dstptr`",
                                    "`nullptr == srcptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "**clEnqueueFillBuffer**",
                            "**clEnqueueSVMMemFill**"
                        ],
                        "class": "$xCommandList",
                        "desc": "Initializes host, device, or shared memory.",
                        "details": [
                            "The application must ensure the memory pointed to by dstptr is accessible by the device on which the command list was created.",
                            "The implementation must not access the memory pointed to by dstptr as it is free to be modified by either the Host or device up until execution.",
                            "The value to initialize memory to is described by the pattern and the pattern size.",
                            "The pattern size must be a power-of-two and less than or equal to the `maxMemoryFillPatternSize` member of $x_command_queue_group_properties_t.",
                            "The application must ensure the events are accessible by the device on which the command list was created.",
                            "The application must ensure the command list and events were created, and the memory was allocated, on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "c98cfd3f97d313db11ecb3c767d90077c416d84b29f1a71de2b5f7e92750fe2b",
                        "name": "AppendMemoryFill",
                        "params": [
                            {
                                "desc": "[in] handle of command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] pointer to memory to initialize",
                                "name": "ptr",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] pointer to value to initialize memory to",
                                "name": "pattern",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] size in bytes of the value to initialize memory to",
                                "name": "pattern_size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] size in bytes to initialize",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`",
                                    "`nullptr == pattern`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Copy region descriptor",
                        "members": [
                            {
                                "desc": "[in] The origin x offset for region in bytes",
                                "name": "originX",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] The origin y offset for region in rows",
                                "name": "originY",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] The origin z offset for region in slices",
                                "name": "originZ",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] The region width relative to origin in bytes",
                                "name": "width",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] The region height relative to origin in rows",
                                "name": "height",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] The region depth relative to origin in slices. Set this to 0 for 2D copy.",
                                "name": "depth",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_copy_region_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Copies a region from a 2D or 3D array of host, device, or shared memory.",
                        "details": [
                            "The application must ensure the memory pointed to by dstptr and srcptr is accessible by the device on which the command list was created.",
                            "The implementation must not access the memory pointed to by dstptr and srcptr as they are free to be modified by either the Host or device up until execution.",
                            "The region width, height, and depth for both src and dst must be same. The origins can be different.",
                            "The src and dst regions cannot be overlapping.",
                            "The application must ensure the events are accessible by the device on which the command list was created.",
                            "The application must ensure the command list and events were created, and the memory was allocated, on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "2d8ebe2228f5e110d96df47e805d946a86399f0753caf8daef271d41b4f1d53b",
                        "name": "AppendMemoryCopyRegion",
                        "params": [
                            {
                                "desc": "[in] handle of command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] pointer to destination memory to copy to",
                                "name": "dstptr",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] pointer to destination region to copy to",
                                "name": "dstRegion",
                                "type": "const $x_copy_region_t*"
                            },
                            {
                                "desc": "[in] destination pitch in bytes",
                                "name": "dstPitch",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] destination slice pitch in bytes. This is required for 3D region copies where the `depth` member of $x_copy_region_t is not 0, otherwise it's ignored.",
                                "name": "dstSlicePitch",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] pointer to source memory to copy from",
                                "name": "srcptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] pointer to source region to copy from",
                                "name": "srcRegion",
                                "type": "const $x_copy_region_t*"
                            },
                            {
                                "desc": "[in] source pitch in bytes",
                                "name": "srcPitch",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] source slice pitch in bytes. This is required for 3D region copies where the `depth` member of $x_copy_region_t is not 0, otherwise it's ignored.",
                                "name": "srcSlicePitch",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == dstptr`",
                                    "`nullptr == dstRegion`",
                                    "`nullptr == srcptr`",
                                    "`nullptr == srcRegion`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_OVERLAPPING_REGIONS": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Copies host, device, or shared memory from another context.",
                        "details": [
                            "The current active and source context must be from the same driver.",
                            "The application must ensure the memory pointed to by dstptr and srcptr is accessible by the device on which the command list was created.",
                            "The implementation must not access the memory pointed to by dstptr and srcptr as they are free to be modified by either the Host or device up until execution.",
                            "The application must ensure the events are accessible by the device on which the command list was created.",
                            "The application must ensure the command list and events were created, and the memory was allocated, on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "ee5b4182bb618a4229df230e3badddbd2d5b26d047bdc5ec1ab6d04ae1550c6c",
                        "name": "AppendMemoryCopyFromContext",
                        "params": [
                            {
                                "desc": "[in] handle of command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] pointer to destination memory to copy to",
                                "name": "dstptr",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] handle of source context object",
                                "name": "hContextSrc",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to source memory to copy from",
                                "name": "srcptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] size in bytes to copy",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hContextSrc`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == dstptr`",
                                    "`nullptr == srcptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "**clEnqueueCopyImage**"
                        ],
                        "class": "$xCommandList",
                        "desc": "Copies an image.",
                        "details": [
                            "The application must ensure the image and events are accessible by the device on which the command list was created.",
                            "The application must ensure the image format descriptors for both source and destination images are the same.",
                            "The application must ensure the command list, images and events were created on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "8b5c252b1ea29a9d0b4c115d15fd74725a40ada1f7ddf99f800127e5be286176",
                        "name": "AppendImageCopy",
                        "params": [
                            {
                                "desc": "[in] handle of command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] handle of destination image to copy to",
                                "name": "hDstImage",
                                "type": "$x_image_handle_t"
                            },
                            {
                                "desc": "[in] handle of source image to copy from",
                                "name": "hSrcImage",
                                "type": "$x_image_handle_t"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hDstImage`",
                                    "`nullptr == hSrcImage`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Region descriptor",
                        "members": [
                            {
                                "desc": "[in] The origin x offset for region in pixels",
                                "name": "originX",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] The origin y offset for region in pixels",
                                "name": "originY",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] The origin z offset for region in pixels",
                                "name": "originZ",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] The region width relative to origin in pixels",
                                "name": "width",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] The region height relative to origin in pixels",
                                "name": "height",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] The region depth relative to origin. For 1D or 2D images, set this to 1.",
                                "name": "depth",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_image_region_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Copies a region of an image to another image.",
                        "details": [
                            "The application must ensure the image and events are accessible by the device on which the command list was created.",
                            "The region width and height for both src and dst must be same. The origins can be different.",
                            "The src and dst regions cannot be overlapping.",
                            "The application must ensure the image format descriptors for both source and destination images are the same.",
                            "The application must ensure the command list, images and events were created, and the memory was allocated, on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "cb41a9b8f263f1632d7297d926863861d60424af7e33f9e18e2f2062cde4f127",
                        "name": "AppendImageCopyRegion",
                        "params": [
                            {
                                "desc": "[in] handle of command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] handle of destination image to copy to",
                                "name": "hDstImage",
                                "type": "$x_image_handle_t"
                            },
                            {
                                "desc": "[in] handle of source image to copy from",
                                "name": "hSrcImage",
                                "type": "$x_image_handle_t"
                            },
                            {
                                "desc": "[in][optional] destination region descriptor",
                                "name": "pDstRegion",
                                "type": "const $x_image_region_t*"
                            },
                            {
                                "desc": "[in][optional] source region descriptor",
                                "name": "pSrcRegion",
                                "type": "const $x_image_region_t*"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hDstImage`",
                                    "`nullptr == hSrcImage`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_OVERLAPPING_REGIONS": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "clEnqueueReadImage"
                        ],
                        "class": "$xCommandList",
                        "desc": "Copies from an image to device or shared memory.",
                        "details": [
                            "The application must ensure the memory pointed to by dstptr is accessible by the device on which the command list was created.",
                            "The implementation must not access the memory pointed to by dstptr as it is free to be modified by either the Host or device up until execution.",
                            "The application must ensure the image and events are accessible by the device on which the command list was created.",
                            "The application must ensure the image format descriptor for the source image is a single-planar format.",
                            "The application must ensure the command list, image and events were created, and the memory was allocated, on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "8d4253ce44a753f3cf8a1bc966e8d8dd97134804940ce1c7b24767e061c98661",
                        "name": "AppendImageCopyToMemory",
                        "params": [
                            {
                                "desc": "[in] handle of command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] pointer to destination memory to copy to",
                                "name": "dstptr",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] handle of source image to copy from",
                                "name": "hSrcImage",
                                "type": "$x_image_handle_t"
                            },
                            {
                                "desc": "[in][optional] source region descriptor",
                                "name": "pSrcRegion",
                                "type": "const $x_image_region_t*"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hSrcImage`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == dstptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "clEnqueueWriteImage"
                        ],
                        "class": "$xCommandList",
                        "desc": "Copies to an image from device or shared memory.",
                        "details": [
                            "The application must ensure the memory pointed to by srcptr is accessible by the device on which the command list was created.",
                            "The implementation must not access the memory pointed to by srcptr as it is free to be modified by either the Host or device up until execution.",
                            "The application must ensure the image and events are accessible by the device on which the command list was created.",
                            "The application must ensure the image format descriptor for the destination image is a single-planar format.",
                            "The application must ensure the command list, image and events were created, and the memory was allocated, on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "4e7bba1af5d32a613c3426d3b97aacb5359b92cde5fe83b7743046c68290060a",
                        "name": "AppendImageCopyFromMemory",
                        "params": [
                            {
                                "desc": "[in] handle of command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] handle of destination image to copy to",
                                "name": "hDstImage",
                                "type": "$x_image_handle_t"
                            },
                            {
                                "desc": "[in] pointer to source memory to copy from",
                                "name": "srcptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in][optional] destination region descriptor",
                                "name": "pDstRegion",
                                "type": "const $x_image_region_t*"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hDstImage`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == srcptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "clEnqueueSVMMigrateMem"
                        ],
                        "class": "$xCommandList",
                        "desc": "Asynchronously prefetches shared memory to the device associated with the specified command list",
                        "details": [
                            "This is a hint to improve performance only and is not required for correctness.",
                            "Only prefetching to the device associated with the specified command list is supported.\nPrefetching to the host or to a peer device is not supported.\n",
                            "Prefetching may not be supported for all allocation types for all devices.\nIf memory prefetching is not supported for the specified memory range the prefetch hint may be ignored.\n",
                            "Prefetching may only be supported at a device-specific granularity, such as at a page boundary.\nIn this case, the memory range may be expanded such that the start and end of the range satisfy granularity requirements.\n",
                            "The application must ensure the memory pointed to by ptr is accessible by the device on which the command list was created.",
                            "The application must ensure the command list was created, and the memory was allocated, on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "1fb509b4db2cea1d6ae38f5b63e959b39668825e1cb46d868ec6343758967c46",
                        "name": "AppendMemoryPrefetch",
                        "params": [
                            {
                                "desc": "[in] handle of command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] pointer to start of the memory range to prefetch",
                                "name": "ptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] size in bytes of the memory range to prefetch",
                                "name": "size",
                                "type": "size_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Supported memory advice hints",
                        "etors": [
                            {
                                "desc": "hint that memory will be read from frequently and written to rarely",
                                "name": "$X_MEMORY_ADVICE_SET_READ_MOSTLY",
                                "value": "0"
                            },
                            {
                                "desc": "removes the effect of $X_MEMORY_ADVICE_SET_READ_MOSTLY",
                                "name": "$X_MEMORY_ADVICE_CLEAR_READ_MOSTLY",
                                "value": "1"
                            },
                            {
                                "desc": "hint that the preferred memory location is the specified device",
                                "name": "$X_MEMORY_ADVICE_SET_PREFERRED_LOCATION",
                                "value": "2"
                            },
                            {
                                "desc": "removes the effect of $X_MEMORY_ADVICE_SET_PREFERRED_LOCATION",
                                "name": "$X_MEMORY_ADVICE_CLEAR_PREFERRED_LOCATION",
                                "value": "3"
                            },
                            {
                                "desc": "hints that memory will mostly be accessed non-atomically",
                                "name": "$X_MEMORY_ADVICE_SET_NON_ATOMIC_MOSTLY",
                                "value": "4"
                            },
                            {
                                "desc": "removes the effect of $X_MEMORY_ADVICE_SET_NON_ATOMIC_MOSTLY",
                                "name": "$X_MEMORY_ADVICE_CLEAR_NON_ATOMIC_MOSTLY",
                                "value": "5"
                            },
                            {
                                "desc": "hints that memory should be cached",
                                "name": "$X_MEMORY_ADVICE_BIAS_CACHED",
                                "value": "6"
                            },
                            {
                                "desc": "hints that memory should be not be cached",
                                "name": "$X_MEMORY_ADVICE_BIAS_UNCACHED",
                                "value": "7"
                            },
                            {
                                "desc": "hint that the preferred memory location is host memory",
                                "name": "$X_MEMORY_ADVICE_SET_SYSTEM_MEMORY_PREFERRED_LOCATION",
                                "value": "8",
                                "version": "1.7"
                            },
                            {
                                "desc": "removes the effect of $X_MEMORY_ADVICE_SET_SYSTEM_MEMORY_PREFERRED_LOCATION",
                                "name": "$X_MEMORY_ADVICE_CLEAR_SYSTEM_MEMORY_PREFERRED_LOCATION",
                                "value": "9",
                                "version": "1.7"
                            }
                        ],
                        "name": "$x_memory_advice_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Provides advice about the use of a shared memory range",
                        "details": [
                            "Memory advice is a performance hint only and is not required for functional correctness.",
                            "Memory advice can be used to override driver heuristics to explicitly control shared memory behavior.",
                            "Not all memory advice hints may be supported for all allocation types for all devices.\nIf a memory advice hint is not supported by the device it will be ignored.\n",
                            "Memory advice may only be supported at a device-specific granularity, such as at a page boundary.\nIn this case, the memory range may be expanded such that the start and end of the range satisfy granularity requirements.\n",
                            "The application must ensure the memory pointed to by ptr is accessible by the device on which the command list was created.",
                            "The application must ensure the command list was created, and memory was allocated, on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle, and the memory was allocated.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "284b6017b356f12150bfd94c56b8eaae692b7502a585c5ad79087a09f1ae1ed6",
                        "name": "AppendMemAdvise",
                        "params": [
                            {
                                "desc": "[in] handle of command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] device associated with the memory advice",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] Pointer to the start of the memory range",
                                "name": "ptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] Size in bytes of the memory range",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] Memory advice for the memory range",
                                "name": "advice",
                                "type": "$x_memory_advice_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$X_MEMORY_ADVICE_CLEAR_SYSTEM_MEMORY_PREFERRED_LOCATION < advice`"
                                ]
                            }
                        ],
                        "type": "function"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Event",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "event",
                "objects": [
                    {
                        "class": "$xEventPool",
                        "desc": "Supported event pool creation flags",
                        "etors": [
                            {
                                "desc": "signals and waits are also visible to host",
                                "name": "$X_EVENT_POOL_FLAG_HOST_VISIBLE",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "signals and waits may be shared across processes",
                                "name": "$X_EVENT_POOL_FLAG_IPC",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Indicates all events in pool will contain kernel timestamps",
                                "name": "$X_EVENT_POOL_FLAG_KERNEL_TIMESTAMP",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "Indicates all events in pool will contain kernel timestamps synchronized to host time domain; cannot be combined with $X_EVENT_POOL_FLAG_KERNEL_TIMESTAMP",
                                "name": "$X_EVENT_POOL_FLAG_KERNEL_MAPPED_TIMESTAMP",
                                "value": "$X_BIT(3)",
                                "version": "1.6"
                            }
                        ],
                        "name": "$x_event_pool_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xEventPool",
                        "desc": "Event pool descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_EVENT_POOL_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of $x_event_pool_flag_t;\ndefault behavior is signals and waits are visible to the entire device and peer devices.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_event_pool_flags_t"
                            },
                            {
                                "desc": "[in] number of events within the pool; must be greater than 0",
                                "name": "count",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_event_pool_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xEventPool",
                        "decl": "static",
                        "desc": "Creates a pool of events on the context.",
                        "details": [
                            "The application must only use events within the pool for the device(s), or their sub-devices, which were provided during creation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "b766373037a279d893108dd2ae00346b45a8f997d2351d2ae2acb71af7490306",
                        "name": "Create",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to event pool descriptor",
                                "name": "desc",
                                "type": "const $x_event_pool_desc_t*"
                            },
                            {
                                "desc": "[in][optional] number of device handles; must be 0 if `nullptr == phDevices`",
                                "name": "numDevices",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numDevices)] array of device handles which have visibility to the event pool.\nif nullptr, then event pool is visible to all devices supported by the driver instance.\n",
                                "name": "phDevices",
                                "type": "$x_device_handle_t*"
                            },
                            {
                                "desc": "[out] pointer handle of event pool object created",
                                "name": "phEventPool",
                                "type": "$x_event_pool_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phEventPool`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0xf < desc->flags`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`0 == desc->count`",
                                    "`(nullptr == phDevices) && (0 < numDevices)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xEventPool",
                        "decl": "static",
                        "desc": "Deletes an event pool object.",
                        "details": [
                            "The application must destroy all event handles created from the pool before destroying the pool itself.",
                            "The application must ensure the device is not currently referencing the any event within the pool before it is deleted.",
                            "The implementation of this function may immediately free all Host and Device allocations associated with this event pool.",
                            "The application must **not** call this function from simultaneous threads with the same event pool handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "f8855b3fc30da423b2dd84592ba09412ba317e9db14de9dab889e6dbc3b6088f",
                        "name": "Destroy",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in][release] handle of event pool object to destroy",
                                "name": "hEventPool",
                                "type": "$x_event_pool_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEventPool`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xEvent",
                        "desc": "Supported event scope flags",
                        "etors": [
                            {
                                "desc": "cache hierarchies are flushed or invalidated sufficient for local sub-device access",
                                "name": "$X_EVENT_SCOPE_FLAG_SUBDEVICE",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "cache hierarchies are flushed or invalidated sufficient for global device access and peer device access",
                                "name": "$X_EVENT_SCOPE_FLAG_DEVICE",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "cache hierarchies are flushed or invalidated sufficient for device and host access",
                                "name": "$X_EVENT_SCOPE_FLAG_HOST",
                                "value": "$X_BIT(2)"
                            }
                        ],
                        "name": "$x_event_scope_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xEvent",
                        "desc": "Event descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_EVENT_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] index of the event within the pool; must be less than the count specified during pool creation",
                                "name": "index",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] defines the scope of relevant cache hierarchies to flush on a signal action before the event is triggered.\nmust be 0 (default) or a valid combination of $x_event_scope_flag_t;\ndefault behavior is synchronization within the command list only, no additional cache hierarchies are flushed.\n",
                                "init": "0",
                                "name": "signal",
                                "type": "$x_event_scope_flags_t"
                            },
                            {
                                "desc": "[in] defines the scope of relevant cache hierarchies to invalidate on a wait action after the event is complete.\nmust be 0 (default) or a valid combination of $x_event_scope_flag_t;\ndefault behavior is synchronization within the command list only, no additional cache hierarchies are invalidated.\n",
                                "init": "0",
                                "name": "wait",
                                "type": "$x_event_scope_flags_t"
                            }
                        ],
                        "name": "$x_event_desc_t",
                        "type": "struct"
                    },
                    {
                        "analogue": [
                            "**clCreateUserEvent**",
                            "vkCreateEvent"
                        ],
                        "class": "$xEvent",
                        "decl": "static",
                        "desc": "Creates an event from the pool.",
                        "details": [
                            "An event is used to communicate fine-grain host-to-device, device-to-host or device-to-device dependencies have completed.",
                            "The application must ensure the location in the pool is not being used by another event.",
                            "The application must **not** call this function from simultaneous threads with the same event pool handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "d97c70e94ec9c407da18c97bd320458316894526b0a335697c0e6c71d82adfda",
                        "name": "Create",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the event pool",
                                "name": "hEventPool",
                                "type": "$x_event_pool_handle_t"
                            },
                            {
                                "desc": "[in] pointer to event descriptor",
                                "name": "desc",
                                "type": "const $x_event_desc_t*"
                            },
                            {
                                "desc": "[out] pointer to handle of event object created",
                                "name": "phEvent",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEventPool`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phEvent`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x7 < desc->signal`",
                                    "`0x7 < desc->wait`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "**clReleaseEvent**",
                            "vkDestroyEvent"
                        ],
                        "class": "$xEvent",
                        "decl": "static",
                        "desc": "Deletes an event object.",
                        "details": [
                            "The application must ensure the device is not currently referencing the event before it is deleted.",
                            "The implementation of this function may immediately free all Host and Device allocations associated with this event.",
                            "The application must **not** call this function from simultaneous threads with the same event handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "0e82f51d7da70ece36da3299c7607c0ce273c15a6401a026d89b8a6e24b52985",
                        "name": "Destroy",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in][release] handle of event object to destroy",
                                "name": "hEvent",
                                "type": "$x_event_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEvent`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xEventPool",
                        "desc": "Gets an IPC event pool handle for the specified event handle that can be shared with another process.",
                        "details": [
                            "Event pool must have been created with $X_EVENT_POOL_FLAG_IPC.",
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "2f8ced4177908de888f5d37c91b0670f09a938c357511e1e33edd2930e4ec7d6",
                        "name": "GetIpcHandle",
                        "params": [
                            {
                                "desc": "[in] handle of event pool object",
                                "name": "hEventPool",
                                "type": "$x_event_pool_handle_t"
                            },
                            {
                                "desc": "[out] Returned IPC event handle",
                                "name": "phIpc",
                                "type": "$x_ipc_event_pool_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEventPool`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phIpc`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xEventPool",
                        "decl": "static",
                        "desc": "Returns an IPC event pool handle to the driver",
                        "details": [
                            "This call must be used for IPC handles previously obtained with $xEventPoolGetIpcHandle.",
                            "Upon call, driver may release any underlying resources associated with the IPC handle.\nFor instance, it may close the file descriptor contained in the IPC handle, if such type of handle is being used by the driver.\n",
                            "This call does not destroy the original event pool for which the IPC handle was created.",
                            "This function may **not** be called from simultaneous threads with the same IPC handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "2b0ef05d5c246265c1815378f9139e736a46e5a4ee09f61371d1a37db17c579f",
                        "name": "PutIpcHandle",
                        "params": [
                            {
                                "desc": "[in] handle of the context object associated with the IPC event pool handle",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] IPC event pool handle",
                                "name": "hIpc",
                                "type": "$x_ipc_event_pool_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.6"
                    },
                    {
                        "class": "$xEventPool",
                        "decl": "static",
                        "desc": "Opens an IPC event pool handle to retrieve an event pool handle from another process.",
                        "details": [
                            "Multiple calls to this function with the same IPC handle will return unique event pool handles.",
                            "The event handle in this process should not be freed with $xEventPoolDestroy, but rather with $xEventPoolCloseIpcHandle.",
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "f22842988b4dc4537adb8fdb8930c1c09a19d59a39e4418c89d2d7f1da73048a",
                        "name": "OpenIpcHandle",
                        "params": [
                            {
                                "desc": "[in] handle of the context object to associate with the IPC event pool handle",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] IPC event pool handle",
                                "name": "hIpc",
                                "type": "$x_ipc_event_pool_handle_t"
                            },
                            {
                                "desc": "[out] pointer handle of event pool object created",
                                "name": "phEventPool",
                                "type": "$x_event_pool_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phEventPool`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xEventPool",
                        "desc": "Closes an IPC event handle in the current process.",
                        "details": [
                            "Closes an IPC event handle by destroying events that were opened in this process using $xEventPoolOpenIpcHandle.",
                            "The application must **not** call this function from simultaneous threads with the same event pool handle."
                        ],
                        "hash": "b867e4bc3459a957dde62c99f5ec23d76254605f57fd81dbd3486622cd6db675",
                        "name": "CloseIpcHandle",
                        "params": [
                            {
                                "desc": "[in][release] handle of event pool object",
                                "name": "hEventPool",
                                "type": "$x_event_pool_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEventPool`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "**clSetUserEventStatus**",
                            "vkCmdSetEvent"
                        ],
                        "class": "$xCommandList",
                        "desc": "Appends a signal of the event from the device into a command list.",
                        "details": [
                            "The application must ensure the events are accessible by the device on which the command list was created.",
                            "The duration of an event created from an event pool that was created using $X_EVENT_POOL_FLAG_KERNEL_TIMESTAMP or $X_EVENT_POOL_FLAG_KERNEL_MAPPED_TIMESTAMP flags is undefined. However, for consistency and orthogonality the event will report correctly as signaled when used by other event API functionality.",
                            "The application must ensure the command list and events were created on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "ef0d28011f775d958ceb555be2b1461cc174bf0b645a7086af4617a238d567d1",
                        "name": "AppendSignalEvent",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] handle of the event",
                                "name": "hEvent",
                                "type": "$x_event_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hEvent`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Appends wait on event(s) on the device into a command list.",
                        "details": [
                            "The application must ensure the events are accessible by the device on which the command list was created.",
                            "The application must ensure the command list and events were created on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "ba8886530b42c816643a1fd9bc79e7b1599c5488c322575de5cb14cb4422e611",
                        "name": "AppendWaitOnEvents",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] number of events to wait on before continuing",
                                "name": "numEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][range(0, numEvents)] handles of the events to wait on before continuing",
                                "name": "phEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phEvents`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "clSetUserEventStatus"
                        ],
                        "class": "$xEvent",
                        "desc": "Signals a event from host.",
                        "details": [
                            "The duration of an event created from an event pool that was created using $X_EVENT_POOL_FLAG_KERNEL_TIMESTAMP or $X_EVENT_POOL_FLAG_KERNEL_MAPPED_TIMESTAMP flags is undefined. However, for consistency and orthogonality the event will report correctly as signaled when used by other event API functionality.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "069d419381dc35e214bcc3c367f3db0a6fd811f4843e17fb2da82d90f0a1b2d3",
                        "name": "HostSignal",
                        "params": [
                            {
                                "desc": "[in] handle of the event",
                                "name": "hEvent",
                                "type": "$x_event_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEvent`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "clWaitForEvents"
                        ],
                        "class": "$xEvent",
                        "desc": "The current host thread waits on an event to be signaled.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "c445c77f74f40b78d313229255edf133072db6ecbeec3b9130ee1dd0f547964a",
                        "name": "HostSynchronize",
                        "params": [
                            {
                                "desc": "[in] handle of the event",
                                "name": "hEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in] if non-zero, then indicates the maximum time (in nanoseconds) to yield before returning $X_RESULT_SUCCESS or $X_RESULT_NOT_READY;\nif zero, then operates exactly like $xEventQueryStatus;\nif `UINT64_MAX`, then function will not return until complete or device is lost.\nDue to external dependencies, timeout may be rounded to the closest value allowed by the accuracy of those dependencies.\n",
                                "name": "timeout",
                                "type": "uint64_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEvent`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_NOT_READY": [
                                    "timeout expired"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "**clGetEventInfo**",
                            "vkGetEventStatus"
                        ],
                        "class": "$xEvent",
                        "desc": "Queries an event object's status on the host.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "1091660d20f5595dad7bbbf969b0a8e9238f218438ff4f2c908b93135147cfa6",
                        "name": "QueryStatus",
                        "params": [
                            {
                                "desc": "[in] handle of the event",
                                "name": "hEvent",
                                "type": "$x_event_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEvent`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_NOT_READY": [
                                    "not signaled"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "vkResetEvent"
                        ],
                        "class": "$xCommandList",
                        "desc": "Appends a reset of an event back to not signaled state into a command list.",
                        "details": [
                            "The application must ensure the events are accessible by the device on which the command list was created.",
                            "The application must ensure the command list and events were created on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "fd917b07e15d242dc28ee8d79b2e3827e834a35da1af31c0f46d031b02255c25",
                        "name": "AppendEventReset",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] handle of the event",
                                "name": "hEvent",
                                "type": "$x_event_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hEvent`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "vkResetEvent"
                        ],
                        "class": "$xEvent",
                        "desc": "The current host thread resets an event back to not signaled state.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "cb686654e319bb98f202bace7ac3af520e7df43764c02d371a2fea219c0693ae",
                        "name": "HostReset",
                        "params": [
                            {
                                "desc": "[in] handle of the event",
                                "name": "hEvent",
                                "type": "$x_event_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEvent`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xEvent",
                        "desc": "Kernel timestamp clock data",
                        "details": [
                            "The timestamp frequency can be queried from the `timerResolution` member of $x_device_properties_t.",
                            "The number of valid bits in the timestamp value can be queried from the `kernelTimestampValidBits` member of $x_device_properties_t."
                        ],
                        "members": [
                            {
                                "desc": "[out] device clock at start of kernel execution",
                                "name": "kernelStart",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] device clock at end of kernel execution",
                                "name": "kernelEnd",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$x_kernel_timestamp_data_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xEvent",
                        "desc": "Kernel timestamp result",
                        "members": [
                            {
                                "desc": "[out] wall-clock data",
                                "name": "global",
                                "type": "$x_kernel_timestamp_data_t"
                            },
                            {
                                "desc": "[out] context-active data; only includes clocks while device context was actively executing.",
                                "name": "context",
                                "type": "$x_kernel_timestamp_data_t"
                            }
                        ],
                        "name": "$x_kernel_timestamp_result_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xEvent",
                        "desc": "Queries an event's timestamp value on the host.",
                        "details": [
                            "The application must ensure the event was created from an event pool that was created using $X_EVENT_POOL_FLAG_KERNEL_TIMESTAMP or $X_EVENT_POOL_FLAG_KERNEL_MAPPED_TIMESTAMP flag.",
                            "The destination memory will be unmodified if the event has not been signaled.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "d4389b8347228d4d121f41bcb0f912329fe59812baa02f9af059d27e6c922aa7",
                        "name": "QueryKernelTimestamp",
                        "params": [
                            {
                                "desc": "[in] handle of the event",
                                "name": "hEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to memory for where timestamp result will be written.",
                                "name": "dstptr",
                                "type": "$x_kernel_timestamp_result_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEvent`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == dstptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_NOT_READY": [
                                    "not signaled"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Appends a query of an events' timestamp value(s) into a command list.",
                        "details": [
                            "The application must ensure the events are accessible by the device on which the command list was created.",
                            "The application must ensure the events were created from an event pool that was created using $X_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag.",
                            "The application must ensure the memory pointed to by both dstptr and pOffsets is accessible by the device on which the command list was created.",
                            "The value(s) written to the destination buffer are undefined if any timestamp event has not been signaled.",
                            "If pOffsets is nullptr, then multiple results will be appended sequentially into memory in the same order as phEvents.",
                            "The application must ensure the command list and events were created, and the memory was allocated, on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "4c4995873967303d865550c3b2d867bec5a54cbe91822e9d506aefb30a154a51",
                        "name": "AppendQueryKernelTimestamps",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] the number of timestamp events to query",
                                "name": "numEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][range(0, numEvents)] handles of timestamp events to query",
                                "name": "phEvents",
                                "type": "$x_event_handle_t*"
                            },
                            {
                                "desc": "[in,out] pointer to memory where $x_kernel_timestamp_result_t will be written; must be size-aligned.",
                                "name": "dstptr",
                                "type": "void*"
                            },
                            {
                                "desc": "[in][optional][range(0, numEvents)] offset, in bytes, to write results; address must be 4byte-aligned and offsets must be size-aligned.",
                                "name": "pOffsets",
                                "type": "const size_t*"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before executing query; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before executing query",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phEvents`",
                                    "`nullptr == dstptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for event pool",
                        "members": [
                            {
                                "desc": "[in] handle of event pool object",
                                "name": "handle",
                                "type": "$x_event_pool_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pContext",
                                "type": "$xContext*"
                            },
                            {
                                "desc": "[in] descriptor of the event pool object",
                                "name": "desc",
                                "type": "$x_event_pool_desc_t"
                            }
                        ],
                        "name": "$xEventPool",
                        "owner": "$xContext",
                        "type": "class"
                    },
                    {
                        "desc": "C++ wrapper for event",
                        "members": [
                            {
                                "desc": "[in] handle of event object",
                                "name": "handle",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pEventPool",
                                "type": "$xEventPool*"
                            },
                            {
                                "desc": "[in] descriptor of the event object",
                                "name": "desc",
                                "type": "$x_event_desc_t"
                            }
                        ],
                        "name": "$xEvent",
                        "owner": "$xEventPool",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Fence",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "fence",
                "objects": [
                    {
                        "class": "$xFence",
                        "desc": "Supported fence creation flags",
                        "etors": [
                            {
                                "desc": "fence is created in the signaled state, otherwise not signaled.",
                                "name": "$X_FENCE_FLAG_SIGNALED",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$x_fence_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xFence",
                        "desc": "Fence descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_FENCE_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of $x_fence_flag_t.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_fence_flags_t"
                            }
                        ],
                        "name": "$x_fence_desc_t",
                        "type": "struct"
                    },
                    {
                        "analogue": [
                            "**vkCreateFence**"
                        ],
                        "class": "$xFence",
                        "decl": "static",
                        "desc": "Creates a fence for the command queue.",
                        "details": [
                            "A fence is a heavyweight synchronization primitive used to communicate to the host that command list execution has completed.",
                            "The application must only use the fence for the command queue which was provided during creation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "ada252e261c878d9688538087a5aa2ffc445069217ec7523d9ab1d72ae4e6fb9",
                        "name": "Create",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of command queue",
                                "name": "hCommandQueue",
                                "type": "$x_command_queue_handle_t"
                            },
                            {
                                "desc": "[in] pointer to fence descriptor",
                                "name": "desc",
                                "type": "const $x_fence_desc_t*"
                            },
                            {
                                "desc": "[out] pointer to handle of fence object created",
                                "name": "phFence",
                                "type": "$x_fence_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandQueue`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phFence`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x1 < desc->flags`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "**vkDestroyFence**"
                        ],
                        "class": "$xFence",
                        "decl": "static",
                        "desc": "Deletes a fence object.",
                        "details": [
                            "The application must ensure the device is not currently referencing the fence before it is deleted.",
                            "The implementation of this function may immediately free all Host and Device allocations associated with this fence.",
                            "The application must **not** call this function from simultaneous threads with the same fence handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "422e69b1e222a70a59ec747e63eeaa1f7ea8d690dd3d4cefa6940ea6841f901c",
                        "name": "Destroy",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in][release] handle of fence object to destroy",
                                "name": "hFence",
                                "type": "$x_fence_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFence`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "**vkWaitForFences**"
                        ],
                        "class": "$xFence",
                        "desc": "The current host thread waits on a fence to be signaled.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "ee76f2ad28be311148d0c6979eb3176567fdef2271f753006ada6aba2240efdd",
                        "name": "HostSynchronize",
                        "params": [
                            {
                                "desc": "[in] handle of the fence",
                                "name": "hFence",
                                "type": "$x_fence_handle_t"
                            },
                            {
                                "desc": "[in] if non-zero, then indicates the maximum time (in nanoseconds) to yield before returning $X_RESULT_SUCCESS or $X_RESULT_NOT_READY;\nif zero, then operates exactly like $xFenceQueryStatus;\nif `UINT64_MAX`, then function will not return until complete or device is lost.\nDue to external dependencies, timeout may be rounded to the closest value allowed by the accuracy of those dependencies.\n",
                                "name": "timeout",
                                "type": "uint64_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFence`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_NOT_READY": [
                                    "timeout expired"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "**vkGetFenceStatus**"
                        ],
                        "class": "$xFence",
                        "desc": "Queries a fence object's status.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "54d115edc2a41acd09d4b8170e56d9826a2b5706f11c6104736eb5860d23c5bc",
                        "name": "QueryStatus",
                        "params": [
                            {
                                "desc": "[in] handle of the fence",
                                "name": "hFence",
                                "type": "$x_fence_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFence`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_NOT_READY": [
                                    "not signaled"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "**vkResetFences**"
                        ],
                        "class": "$xFence",
                        "desc": "Reset a fence back to the not signaled state.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "7d06912d2e703c85cf1c3bb4e5b71884212ddfcc87d33f46c5463b83293ed855",
                        "name": "Reset",
                        "params": [
                            {
                                "desc": "[in] handle of the fence",
                                "name": "hFence",
                                "type": "$x_fence_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFence`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for fence",
                        "members": [
                            {
                                "desc": "[in] handle of fence object",
                                "name": "handle",
                                "type": "$x_fence_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pCommandQueue",
                                "type": "$xCommandQueue*"
                            },
                            {
                                "desc": "[in] descriptor of the fence object",
                                "name": "desc",
                                "type": "$x_fence_desc_t"
                            }
                        ],
                        "name": "$xFence",
                        "owner": "$xCommandQueue",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Images",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "image",
                "objects": [
                    {
                        "class": "$xImage",
                        "desc": "Supported image creation flags",
                        "etors": [
                            {
                                "desc": "kernels will write contents",
                                "name": "$X_IMAGE_FLAG_KERNEL_WRITE",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "device should not cache contents",
                                "name": "$X_IMAGE_FLAG_BIAS_UNCACHED",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$x_image_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xImage",
                        "desc": "Supported image types",
                        "etors": [
                            {
                                "desc": "1D",
                                "name": "$X_IMAGE_TYPE_1D",
                                "value": "0"
                            },
                            {
                                "desc": "1D array",
                                "name": "$X_IMAGE_TYPE_1DARRAY",
                                "value": "1"
                            },
                            {
                                "desc": "2D",
                                "name": "$X_IMAGE_TYPE_2D",
                                "value": "2"
                            },
                            {
                                "desc": "2D array",
                                "name": "$X_IMAGE_TYPE_2DARRAY",
                                "value": "3"
                            },
                            {
                                "desc": "3D",
                                "name": "$X_IMAGE_TYPE_3D",
                                "value": "4"
                            },
                            {
                                "desc": "Buffer",
                                "name": "$X_IMAGE_TYPE_BUFFER",
                                "value": "5"
                            }
                        ],
                        "name": "$x_image_type_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xImage",
                        "desc": "Supported image format layouts",
                        "etors": [
                            {
                                "desc": "8-bit single component layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_8",
                                "value": "0"
                            },
                            {
                                "desc": "16-bit single component layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_16",
                                "value": "1"
                            },
                            {
                                "desc": "32-bit single component layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_32",
                                "value": "2"
                            },
                            {
                                "desc": "2-component 8-bit layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_8_8",
                                "value": "3"
                            },
                            {
                                "desc": "4-component 8-bit layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_8_8_8_8",
                                "value": "4"
                            },
                            {
                                "desc": "2-component 16-bit layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_16_16",
                                "value": "5"
                            },
                            {
                                "desc": "4-component 16-bit layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_16_16_16_16",
                                "value": "6"
                            },
                            {
                                "desc": "2-component 32-bit layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_32_32",
                                "value": "7"
                            },
                            {
                                "desc": "4-component 32-bit layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_32_32_32_32",
                                "value": "8"
                            },
                            {
                                "desc": "4-component 10_10_10_2 layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_10_10_10_2",
                                "value": "9"
                            },
                            {
                                "desc": "3-component 11_11_10 layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_11_11_10",
                                "value": "10"
                            },
                            {
                                "desc": "3-component 5_6_5 layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_5_6_5",
                                "value": "11"
                            },
                            {
                                "desc": "4-component 5_5_5_1 layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_5_5_5_1",
                                "value": "12"
                            },
                            {
                                "desc": "4-component 4_4_4_4 layout",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_4_4_4_4",
                                "value": "13"
                            },
                            {
                                "desc": "Media Format: Y8. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_Y8",
                                "value": "14"
                            },
                            {
                                "desc": "Media Format: NV12. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_NV12",
                                "value": "15"
                            },
                            {
                                "desc": "Media Format: YUYV. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_YUYV",
                                "value": "16"
                            },
                            {
                                "desc": "Media Format: VYUY. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_VYUY",
                                "value": "17"
                            },
                            {
                                "desc": "Media Format: YVYU. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_YVYU",
                                "value": "18"
                            },
                            {
                                "desc": "Media Format: UYVY. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_UYVY",
                                "value": "19"
                            },
                            {
                                "desc": "Media Format: AYUV. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_AYUV",
                                "value": "20"
                            },
                            {
                                "desc": "Media Format: P010. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_P010",
                                "value": "21"
                            },
                            {
                                "desc": "Media Format: Y410. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_Y410",
                                "value": "22"
                            },
                            {
                                "desc": "Media Format: P012. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_P012",
                                "value": "23"
                            },
                            {
                                "desc": "Media Format: Y16. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_Y16",
                                "value": "24"
                            },
                            {
                                "desc": "Media Format: P016. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_P016",
                                "value": "25"
                            },
                            {
                                "desc": "Media Format: Y216. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_Y216",
                                "value": "26"
                            },
                            {
                                "desc": "Media Format: P216. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_P216",
                                "value": "27"
                            },
                            {
                                "desc": "Media Format: P8. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_P8",
                                "value": "28"
                            },
                            {
                                "desc": "Media Format: YUY2. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_YUY2",
                                "value": "29"
                            },
                            {
                                "desc": "Media Format: A8P8. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_A8P8",
                                "value": "30"
                            },
                            {
                                "desc": "Media Format: IA44. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_IA44",
                                "value": "31"
                            },
                            {
                                "desc": "Media Format: AI44. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_AI44",
                                "value": "32"
                            },
                            {
                                "desc": "Media Format: Y416. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_Y416",
                                "value": "33"
                            },
                            {
                                "desc": "Media Format: Y210. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_Y210",
                                "value": "34"
                            },
                            {
                                "desc": "Media Format: I420. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_I420",
                                "value": "35"
                            },
                            {
                                "desc": "Media Format: YV12. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_YV12",
                                "value": "36"
                            },
                            {
                                "desc": "Media Format: 400P. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_400P",
                                "value": "37"
                            },
                            {
                                "desc": "Media Format: 422H. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_422H",
                                "value": "38"
                            },
                            {
                                "desc": "Media Format: 422V. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_422V",
                                "value": "39"
                            },
                            {
                                "desc": "Media Format: 444P. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_444P",
                                "value": "40"
                            },
                            {
                                "desc": "Media Format: RGBP. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_RGBP",
                                "value": "41"
                            },
                            {
                                "desc": "Media Format: BRGP. Format type and swizzle is ignored for this.",
                                "name": "$X_IMAGE_FORMAT_LAYOUT_BRGP",
                                "value": "42"
                            }
                        ],
                        "name": "$x_image_format_layout_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xImage",
                        "desc": "Supported image format types",
                        "etors": [
                            {
                                "desc": "Unsigned integer",
                                "name": "$X_IMAGE_FORMAT_TYPE_UINT",
                                "value": "0"
                            },
                            {
                                "desc": "Signed integer",
                                "name": "$X_IMAGE_FORMAT_TYPE_SINT",
                                "value": "1"
                            },
                            {
                                "desc": "Unsigned normalized integer",
                                "name": "$X_IMAGE_FORMAT_TYPE_UNORM",
                                "value": "2"
                            },
                            {
                                "desc": "Signed normalized integer",
                                "name": "$X_IMAGE_FORMAT_TYPE_SNORM",
                                "value": "3"
                            },
                            {
                                "desc": "Float",
                                "name": "$X_IMAGE_FORMAT_TYPE_FLOAT",
                                "value": "4"
                            }
                        ],
                        "name": "$x_image_format_type_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xImage",
                        "desc": "Supported image format component swizzle into channel",
                        "etors": [
                            {
                                "desc": "Red component",
                                "name": "$X_IMAGE_FORMAT_SWIZZLE_R",
                                "value": "0"
                            },
                            {
                                "desc": "Green component",
                                "name": "$X_IMAGE_FORMAT_SWIZZLE_G",
                                "value": "1"
                            },
                            {
                                "desc": "Blue component",
                                "name": "$X_IMAGE_FORMAT_SWIZZLE_B",
                                "value": "2"
                            },
                            {
                                "desc": "Alpha component",
                                "name": "$X_IMAGE_FORMAT_SWIZZLE_A",
                                "value": "3"
                            },
                            {
                                "desc": "Zero",
                                "name": "$X_IMAGE_FORMAT_SWIZZLE_0",
                                "value": "4"
                            },
                            {
                                "desc": "One",
                                "name": "$X_IMAGE_FORMAT_SWIZZLE_1",
                                "value": "5"
                            },
                            {
                                "desc": "Don't care",
                                "name": "$X_IMAGE_FORMAT_SWIZZLE_X",
                                "value": "6"
                            }
                        ],
                        "name": "$x_image_format_swizzle_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xImage",
                        "desc": "Image format ",
                        "members": [
                            {
                                "desc": "[in] image format component layout (e.g. N-component layouts and media formats)",
                                "name": "layout",
                                "type": "$x_image_format_layout_t"
                            },
                            {
                                "desc": "[in] image format type",
                                "name": "type",
                                "type": "$x_image_format_type_t"
                            },
                            {
                                "desc": "[in] image component swizzle into channel x",
                                "name": "x",
                                "type": "$x_image_format_swizzle_t"
                            },
                            {
                                "desc": "[in] image component swizzle into channel y",
                                "name": "y",
                                "type": "$x_image_format_swizzle_t"
                            },
                            {
                                "desc": "[in] image component swizzle into channel z",
                                "name": "z",
                                "type": "$x_image_format_swizzle_t"
                            },
                            {
                                "desc": "[in] image component swizzle into channel w",
                                "name": "w",
                                "type": "$x_image_format_swizzle_t"
                            }
                        ],
                        "name": "$x_image_format_t",
                        "type": "struct"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xImage",
                        "desc": "Image descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_IMAGE_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of $x_image_flag_t;\ndefault is read-only, cached access.\n",
                                "name": "flags",
                                "type": "$x_image_flags_t"
                            },
                            {
                                "desc": "[in] image type. Media format layouts are unsupported for $X_IMAGE_TYPE_BUFFER",
                                "name": "type",
                                "type": "$x_image_type_t"
                            },
                            {
                                "desc": "[in] image format",
                                "name": "format",
                                "type": "$x_image_format_t"
                            },
                            {
                                "desc": "[in] width dimension.\n$X_IMAGE_TYPE_BUFFER: size in bytes; see the `maxImageBufferSize` member of $x_device_image_properties_t for limits.\n$X_IMAGE_TYPE_1D, $X_IMAGE_TYPE_1DARRAY: width in pixels; see the `maxImageDims1D` member of $x_device_image_properties_t for limits.\n$X_IMAGE_TYPE_2D, $X_IMAGE_TYPE_2DARRAY: width in pixels; see the `maxImageDims2D` member of $x_device_image_properties_t for limits.\n$X_IMAGE_TYPE_3D: width in pixels; see the `maxImageDims3D` member of $x_device_image_properties_t for limits.\n",
                                "init": "0",
                                "name": "width",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[in] height dimension.\n$X_IMAGE_TYPE_2D, $X_IMAGE_TYPE_2DARRAY: height in pixels; see the `maxImageDims2D` member of $x_device_image_properties_t for limits.\n$X_IMAGE_TYPE_3D: height in pixels; see the `maxImageDims3D` member of $x_device_image_properties_t for limits.\nother: ignored.\n",
                                "init": "0",
                                "name": "height",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] depth dimension.\n$X_IMAGE_TYPE_3D: depth in pixels; see the `maxImageDims3D` member of $x_device_image_properties_t for limits.\nother: ignored.\n",
                                "init": "0",
                                "name": "depth",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] array levels.\n$X_IMAGE_TYPE_1DARRAY, $X_IMAGE_TYPE_2DARRAY: see the `maxImageArraySlices` member of $x_device_image_properties_t for limits.\nother: ignored.\n",
                                "init": "1",
                                "name": "arraylevels",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] mipmap levels (must be 0)",
                                "init": "0",
                                "name": "miplevels",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_image_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xImage",
                        "desc": "Supported sampler filtering flags",
                        "etors": [
                            {
                                "desc": "device supports point filtering",
                                "name": "$X_IMAGE_SAMPLER_FILTER_FLAG_POINT",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "device supports linear filtering",
                                "name": "$X_IMAGE_SAMPLER_FILTER_FLAG_LINEAR",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$x_image_sampler_filter_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xImage",
                        "desc": "Image properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_IMAGE_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] supported sampler filtering.\nreturns 0 (unsupported) or a combination of $x_image_sampler_filter_flag_t.\n",
                                "name": "samplerFilterFlags",
                                "type": "$x_image_sampler_filter_flags_t"
                            }
                        ],
                        "name": "$x_image_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xImage",
                        "decl": "static",
                        "desc": "Retrieves supported properties of an image.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "19e802dcabe70d5e46b59da4ba1036ac340f7aae39c7b88b44178df36b38965d",
                        "name": "GetProperties",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] pointer to image descriptor",
                                "name": "desc",
                                "type": "const $x_image_desc_t*"
                            },
                            {
                                "desc": "[out] pointer to image properties",
                                "name": "pImageProperties",
                                "type": "$x_image_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == pImageProperties`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x3 < desc->flags`",
                                    "`$X_IMAGE_TYPE_BUFFER < desc->type`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "analogue": [
                            "clCreateImage"
                        ],
                        "class": "$xImage",
                        "decl": "static",
                        "desc": "Creates an image on the context.",
                        "details": [
                            "The application must only use the image for the device, or its sub-devices, which was provided during creation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "37d7431438c499a5f9055ba6c00fef0f485edcce804fb643e9246d207a44f3bf",
                        "name": "Create",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] pointer to image descriptor",
                                "name": "desc",
                                "type": "const $x_image_desc_t*"
                            },
                            {
                                "desc": "[out] pointer to handle of image object created",
                                "name": "phImage",
                                "type": "$x_image_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phImage`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x3 < desc->flags`",
                                    "`$X_IMAGE_TYPE_BUFFER < desc->type`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xImage",
                        "decl": "static",
                        "desc": "Deletes an image object.",
                        "details": [
                            "The application must ensure the device is not currently referencing the image before it is deleted.",
                            "The implementation of this function may immediately free all Host and Device allocations associated with this image.",
                            "The application must **not** call this function from simultaneous threads with the same image handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "fd023d402207b0213a1e9c7aeaf42f03639cc86e3a20b6267eb86975e7996b94",
                        "name": "Destroy",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in][release] handle of image object to destroy",
                                "name": "hImage",
                                "type": "$x_image_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hImage`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for image",
                        "members": [
                            {
                                "desc": "[in] handle of image object",
                                "name": "handle",
                                "type": "$x_image_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$xDevice*"
                            },
                            {
                                "desc": "[in] descriptor of the image object",
                                "name": "desc",
                                "type": "$x_image_desc_t"
                            }
                        ],
                        "name": "$xImage",
                        "owner": "$xDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Memory",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "memory",
                "objects": [
                    {
                        "class": "$xMem",
                        "desc": "Supported memory allocation flags",
                        "etors": [
                            {
                                "desc": "device should cache allocation",
                                "name": "$X_DEVICE_MEM_ALLOC_FLAG_BIAS_CACHED",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "device should not cache allocation (UC)",
                                "name": "$X_DEVICE_MEM_ALLOC_FLAG_BIAS_UNCACHED",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "optimize shared allocation for first access on the device",
                                "name": "$X_DEVICE_MEM_ALLOC_FLAG_BIAS_INITIAL_PLACEMENT",
                                "value": "$X_BIT(2)",
                                "version": "1.2"
                            }
                        ],
                        "name": "$x_device_mem_alloc_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xMem",
                        "desc": "Device memory allocation descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_MEM_ALLOC_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] flags specifying additional allocation controls.\nmust be 0 (default) or a valid combination of $x_device_mem_alloc_flag_t;\ndefault behavior may use implicit driver-based heuristics.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_device_mem_alloc_flags_t"
                            },
                            {
                                "desc": "[in] ordinal of the device's local memory to allocate from.\nmust be less than the count returned from $xDeviceGetMemoryProperties.\n",
                                "init": "0",
                                "name": "ordinal",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_device_mem_alloc_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xMem",
                        "desc": "Supported host memory allocation flags",
                        "etors": [
                            {
                                "desc": "host should cache allocation",
                                "name": "$X_HOST_MEM_ALLOC_FLAG_BIAS_CACHED",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "host should not cache allocation (UC)",
                                "name": "$X_HOST_MEM_ALLOC_FLAG_BIAS_UNCACHED",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "host memory should be allocated write-combined (WC)",
                                "name": "$X_HOST_MEM_ALLOC_FLAG_BIAS_WRITE_COMBINED",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "optimize shared allocation for first access on the host",
                                "name": "$X_HOST_MEM_ALLOC_FLAG_BIAS_INITIAL_PLACEMENT",
                                "value": "$X_BIT(3)",
                                "version": "1.2"
                            }
                        ],
                        "name": "$x_host_mem_alloc_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xMem",
                        "desc": "Host memory allocation descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_HOST_MEM_ALLOC_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] flags specifying additional allocation controls.\nmust be 0 (default) or a valid combination of $x_host_mem_alloc_flag_t;\ndefault behavior may use implicit driver-based heuristics.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_host_mem_alloc_flags_t"
                            }
                        ],
                        "name": "$x_host_mem_alloc_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xMem",
                        "decl": "static",
                        "desc": "Allocates shared memory on the context.",
                        "details": [
                            "Shared allocations share ownership between the host and one or more devices.",
                            "Shared allocations may optionally be associated with a device by passing a handle to the device.",
                            "Devices supporting only single-device shared access capabilities may access shared memory associated with the device.\nFor these devices, ownership of the allocation is shared between the host and the associated device only.\n",
                            "Passing nullptr as the device handle does not associate the shared allocation with any device.\nFor allocations with no associated device, ownership of the allocation is shared between the host and all devices supporting cross-device shared access capabilities.\n",
                            "The application must only use the memory allocation for the context and device, or its sub-devices, which was provided during allocation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "b6604184ed449716c988b49b2743e1ee23375834a00cf2a5255175ad95f829a8",
                        "name": "AllocShared",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to device memory allocation descriptor",
                                "name": "device_desc",
                                "type": "const $x_device_mem_alloc_desc_t*"
                            },
                            {
                                "desc": "[in] pointer to host memory allocation descriptor",
                                "name": "host_desc",
                                "type": "const $x_host_mem_alloc_desc_t*"
                            },
                            {
                                "desc": "[in] size in bytes to allocate; must be less than or equal to the `maxMemAllocSize` member of $x_device_properties_t",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] minimum alignment in bytes for the allocation; must be a power of two",
                                "name": "alignment",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in][optional] device handle to associate with",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[out] pointer to shared allocation",
                                "name": "pptr",
                                "type": "void**"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == device_desc`",
                                    "`nullptr == host_desc`",
                                    "`nullptr == pptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x7 < device_desc->flags`",
                                    "`0xf < host_desc->flags`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_SIZE": [
                                    "`0 == size`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": [
                                    "Must be zero or a power-of-two",
                                    "`0 != (alignment & (alignment - 1))`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xMem",
                        "decl": "static",
                        "desc": "Allocates device memory on the context.",
                        "details": [
                            "Device allocations are owned by a specific device.",
                            "In general, a device allocation may only be accessed by the device that owns it.",
                            "The application must only use the memory allocation for the context and device, or its sub-devices, which was provided during allocation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "221cb83b773fc3543fec9b5986d0c3171fe46e99d294e9c26d4c8ec021b50ed4",
                        "name": "AllocDevice",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to device memory allocation descriptor",
                                "name": "device_desc",
                                "type": "const $x_device_mem_alloc_desc_t*"
                            },
                            {
                                "desc": "[in] size in bytes to allocate; must be less than or equal to the `maxMemAllocSize` member of $x_device_properties_t",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] minimum alignment in bytes for the allocation; must be a power of two",
                                "name": "alignment",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[out] pointer to device allocation",
                                "name": "pptr",
                                "type": "void**"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == device_desc`",
                                    "`nullptr == pptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x7 < device_desc->flags`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_SIZE": [
                                    "`0 == size`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": [
                                    "Must be zero or a power-of-two",
                                    "`0 != (alignment & (alignment - 1))`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xMem",
                        "decl": "static",
                        "desc": "Allocates host memory on the context.",
                        "details": [
                            "Host allocations are owned by the host process.",
                            "Host allocations are accessible by the host and all devices within the driver's context.",
                            "Host allocations are frequently used as staging areas to transfer data to or from devices.",
                            "The application must only use the memory allocation for the context which was provided during allocation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "3756f52aa6a061b6c344cccfb4ad13bbf4b6f60fcdb1cfecb30fdc1140edfda6",
                        "name": "AllocHost",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to host memory allocation descriptor",
                                "name": "host_desc",
                                "type": "const $x_host_mem_alloc_desc_t*"
                            },
                            {
                                "desc": "[in] size in bytes to allocate; must be less than or equal to the `maxMemAllocSize` member of $x_device_properties_t",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] minimum alignment in bytes for the allocation; must be a power of two",
                                "name": "alignment",
                                "type": "size_t"
                            },
                            {
                                "desc": "[out] pointer to host allocation",
                                "name": "pptr",
                                "type": "void**"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == host_desc`",
                                    "`nullptr == pptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0xf < host_desc->flags`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_SIZE": [
                                    "`0 == size`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": [
                                    "Must be zero or a power-of-two",
                                    "`0 != (alignment & (alignment - 1))`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xMem",
                        "decl": "static",
                        "desc": "Frees allocated host memory, device memory, or shared memory on the context.",
                        "details": [
                            "The application must ensure the device is not currently referencing the memory before it is freed",
                            "The implementation of this function may immediately free all Host and Device allocations associated with this memory",
                            "The application must **not** call this function from simultaneous threads with the same pointer.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "4c1bb0de95e46858cf61841939a95f972747df5580b9e905615a2d85fd753976",
                        "name": "Free",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in][release] pointer to memory to free",
                                "name": "ptr",
                                "type": "void*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xMem",
                        "desc": "Memory allocation type",
                        "etors": [
                            {
                                "desc": "the memory pointed to is of unknown type",
                                "name": "$X_MEMORY_TYPE_UNKNOWN",
                                "value": "0"
                            },
                            {
                                "desc": "the memory pointed to is a host allocation",
                                "name": "$X_MEMORY_TYPE_HOST",
                                "value": "1"
                            },
                            {
                                "desc": "the memory pointed to is a device allocation",
                                "name": "$X_MEMORY_TYPE_DEVICE",
                                "value": "2"
                            },
                            {
                                "desc": "the memory pointed to is a shared ownership allocation",
                                "name": "$X_MEMORY_TYPE_SHARED",
                                "value": "3"
                            }
                        ],
                        "name": "$x_memory_type_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xMem",
                        "desc": "Memory allocation properties queried using $xMemGetAllocProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_MEMORY_ALLOCATION_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] type of allocated memory",
                                "name": "type",
                                "type": "$x_memory_type_t"
                            },
                            {
                                "desc": "[out] identifier for this allocation",
                                "name": "id",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] page size used for allocation",
                                "name": "pageSize",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$x_memory_allocation_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xMem",
                        "decl": "static",
                        "desc": "Retrieves attributes of a memory allocation",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The application may query attributes of a memory allocation unrelated to the context.\nWhen this occurs, the returned allocation type will be $X_MEMORY_TYPE_UNKNOWN, and the returned identifier and associated device is unspecified.\n"
                        ],
                        "hash": "024e68ebb28cbd45122caa812337ed9737a93ee4cc7990e2188197ffcc2ae39f",
                        "name": "GetAllocProperties",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] memory pointer to query",
                                "name": "ptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in,out] query result for memory allocation properties",
                                "name": "pMemAllocProperties",
                                "type": "$x_memory_allocation_properties_t*"
                            },
                            {
                                "desc": "[out][optional] device associated with this allocation",
                                "name": "phDevice",
                                "type": "$x_device_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`",
                                    "`nullptr == pMemAllocProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xMem",
                        "decl": "static",
                        "desc": "Retrieves the base address and/or size of an allocation",
                        "details": [
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "972da021a01a0357817c10cdfccea16c42a3cca55a6c36436267aa45e7a55dab",
                        "name": "GetAddressRange",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] memory pointer to query",
                                "name": "ptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in,out][optional] base address of the allocation",
                                "name": "pBase",
                                "type": "void**"
                            },
                            {
                                "desc": "[in,out][optional] size of the allocation",
                                "name": "pSize",
                                "type": "size_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xMem",
                        "decl": "static",
                        "desc": "Creates an IPC memory handle for the specified allocation",
                        "details": [
                            "Takes a pointer to a device memory allocation and creates an IPC memory handle for exporting it for use in another process.",
                            "The pointer must be base pointer of a device or host memory allocation; i.e. the value returned from $xMemAllocDevice or from $xMemAllocHost, respectively.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "0c93fecc4e19c55c79ca9d1b7001f7c9fcdc783c6cb181c18cae4924ae0e7b4a",
                        "name": "GetIpcHandle",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to the device memory allocation",
                                "name": "ptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] Returned IPC memory handle",
                                "name": "pIpcHandle",
                                "type": "$x_ipc_mem_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`",
                                    "`nullptr == pIpcHandle`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xMem",
                        "decl": "static",
                        "desc": "Creates an IPC memory handle out of a file descriptor",
                        "details": [
                            "Handle passed must be a valid file descriptor obtained with $x_external_memory_export_fd_t via $xMemGetAllocProperties.",
                            "Returned IPC handle may contain metadata in addition to the file descriptor.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "85dd8fd011ef561b945d46995f774fa76385cef8b350475fb4fa35684277399e",
                        "name": "GetIpcHandleFromFileDescriptorExp",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] file descriptor",
                                "name": "handle",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Returned IPC memory handle",
                                "name": "pIpcHandle",
                                "type": "$x_ipc_mem_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pIpcHandle`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.6"
                    },
                    {
                        "class": "$xMem",
                        "decl": "static",
                        "desc": "Gets the file descriptor contained in an IPC memory handle",
                        "details": [
                            "IPC memory handle must be a valid handle obtained with $xMemGetIpcHandle.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "4f0cd196b792fa6c5010f1779f899fc5252608ccded499cc460199f47343f4b6",
                        "name": "GetFileDescriptorFromIpcHandleExp",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] IPC memory handle",
                                "name": "ipcHandle",
                                "type": "$x_ipc_mem_handle_t"
                            },
                            {
                                "desc": "[out] Returned file descriptor",
                                "name": "pHandle",
                                "type": "uint64_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pHandle`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.6"
                    },
                    {
                        "class": "$xMem",
                        "decl": "static",
                        "desc": "Returns an IPC memory handle to the driver",
                        "details": [
                            "This call may be used for IPC handles previously obtained with either $xMemGetIpcHandle or with $x_external_memory_export_fd_t via $xMemGetAllocProperties.\n",
                            "Upon call, driver may release any underlying resources associated with the IPC handle.\nFor instance, it may close the file descriptor contained in the IPC handle, if such type of handle is being used by the driver.\n",
                            "This call does not free the original allocation for which the IPC handle was created.",
                            "This function may **not** be called from simultaneous threads with the same IPC handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "34244e7493a2b2f9d15f3f02f77e55814209a257d38057e839b02653d59f6608",
                        "name": "PutIpcHandle",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] IPC memory handle",
                                "name": "handle",
                                "type": "$x_ipc_mem_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.6"
                    },
                    {
                        "class": "$xMem",
                        "desc": "Supported IPC memory flags",
                        "etors": [
                            {
                                "desc": "device should cache allocation",
                                "name": "$X_IPC_MEMORY_FLAG_BIAS_CACHED",
                                "value": "$X_BIT(0)",
                                "version": "1.2"
                            },
                            {
                                "desc": "device should not cache allocation (UC)",
                                "name": "$X_IPC_MEMORY_FLAG_BIAS_UNCACHED",
                                "value": "$X_BIT(1)",
                                "version": "1.2"
                            }
                        ],
                        "name": "$x_ipc_memory_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xMem",
                        "decl": "static",
                        "desc": "Opens an IPC memory handle to retrieve a device pointer on the context.",
                        "details": [
                            "Takes an IPC memory handle from a remote process and associates it with a device pointer usable in this process.",
                            "The device pointer in this process should not be freed with $xMemFree, but rather with $xMemCloseIpcHandle.",
                            "Multiple calls to this function with the same IPC handle will return unique pointers.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "4c72e60d813bc0a5b107447c8fa631b5bbab875a991dbc25647bc34a281fd554",
                        "name": "OpenIpcHandle",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device to associate with the IPC memory handle",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] IPC memory handle",
                                "name": "handle",
                                "type": "$x_ipc_mem_handle_t"
                            },
                            {
                                "desc": "[in] flags controlling the operation.\nmust be 0 (default) or a valid combination of $x_ipc_memory_flag_t.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_ipc_memory_flags_t"
                            },
                            {
                                "desc": "[out] pointer to device allocation in this process",
                                "name": "pptr",
                                "type": "void**"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x3 < flags`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pptr`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xMem",
                        "decl": "static",
                        "desc": "Closes an IPC memory handle",
                        "details": [
                            "Closes an IPC memory handle by unmapping memory that was opened in this process using $xMemOpenIpcHandle.",
                            "The application must **not** call this function from simultaneous threads with the same pointer.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "1b6b175814390040738d87ef1f94dc36e59d432b77e807f87deb87214188070b",
                        "name": "CloseIpcHandle",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in][release] pointer to device allocation in this process",
                                "name": "ptr",
                                "type": "const void*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xMem",
                        "desc": "Additional allocation descriptor for exporting external memory",
                        "details": [
                            "This structure may be passed to $xMemAllocDevice and $xMemAllocHost, via the `pNext` member of $x_device_mem_alloc_desc_t or $x_host_mem_alloc_desc_t, respectively, to indicate an exportable memory allocation.",
                            "This structure may be passed to $xImageCreate, via the `pNext` member of $x_image_desc_t, to indicate an exportable image."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] flags specifying memory export types for this allocation.\nmust be 0 (default) or a valid combination of $x_external_memory_type_flags_t\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_external_memory_type_flags_t"
                            }
                        ],
                        "name": "$x_external_memory_export_desc_t",
                        "type": "struct"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xMem",
                        "desc": "Additional allocation descriptor for importing external memory as a file descriptor",
                        "details": [
                            "This structure may be passed to $xMemAllocDevice or $xMemAllocHost, via the `pNext` member of $x_device_mem_alloc_desc_t or of $x_host_mem_alloc_desc_t, respectively, to import memory from a file descriptor.",
                            "This structure may be passed to $xImageCreate, via the `pNext` member of $x_image_desc_t, to import memory from a file descriptor."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_FD",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] flags specifying the memory import type for the file descriptor.\nmust be 0 (default) or a valid combination of $x_external_memory_type_flags_t\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_external_memory_type_flags_t"
                            },
                            {
                                "desc": "[in] the file descriptor handle to import",
                                "name": "fd",
                                "type": "int"
                            }
                        ],
                        "name": "$x_external_memory_import_fd_t",
                        "type": "struct"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xMem",
                        "desc": "Exports an allocation as a file descriptor",
                        "details": [
                            "This structure may be passed to $xMemGetAllocProperties, via the `pNext` member of $x_memory_allocation_properties_t, to export a memory allocation as a file descriptor.",
                            "This structure may be passed to $xImageGetAllocPropertiesExt, via the `pNext` member of $x_image_allocation_ext_properties_t, to export an image as a file descriptor.",
                            "The requested memory export type must have been specified when the allocation was made."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_FD",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] flags specifying the memory export type for the file descriptor.\nmust be 0 (default) or a valid combination of $x_external_memory_type_flags_t\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_external_memory_type_flags_t"
                            },
                            {
                                "desc": "[out] the exported file descriptor handle representing the allocation.",
                                "name": "fd",
                                "type": "int"
                            }
                        ],
                        "name": "$x_external_memory_export_fd_t",
                        "type": "struct"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xMem",
                        "desc": "Additional allocation descriptor for importing external memory as a Win32 handle",
                        "details": [
                            "When `handle` is `nullptr`, `name` must not be `nullptr`.",
                            "When `name` is `nullptr`, `handle` must not be `nullptr`.",
                            "When `flags` is $X_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_WIN32_KMT, `name` must be `nullptr`.",
                            "This structure may be passed to $xMemAllocDevice or $xMemAllocHost, via the `pNext` member of $x_device_mem_alloc_desc_t or of $x_host_mem_alloc_desc_t, respectively, to import memory from a Win32 handle.",
                            "This structure may be passed to $xImageCreate, via the `pNext` member of $x_image_desc_t, to import memory from a Win32 handle."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_WIN32_HANDLE",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] flags specifying the memory import type for the Win32 handle.\nmust be 0 (default) or a valid combination of $x_external_memory_type_flags_t\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_external_memory_type_flags_t"
                            },
                            {
                                "desc": "[in][optional] the Win32 handle to import",
                                "name": "handle",
                                "type": "void*"
                            },
                            {
                                "desc": "[in][optional] name of a memory object to import",
                                "name": "name",
                                "type": "const void*"
                            }
                        ],
                        "name": "$x_external_memory_import_win32_handle_t",
                        "type": "struct",
                        "version": "1.2"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xMem",
                        "desc": "Exports an allocation as a Win32 handle",
                        "details": [
                            "This structure may be passed to $xMemGetAllocProperties, via the `pNext` member of $x_memory_allocation_properties_t, to export a memory allocation as a Win32 handle.",
                            "This structure may be passed to $xImageGetAllocPropertiesExt, via the `pNext` member of $x_image_allocation_ext_properties_t, to export an image as a Win32 handle.",
                            "The requested memory export type must have been specified when the allocation was made."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_WIN32_HANDLE",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] flags specifying the memory export type for the Win32 handle.\nmust be 0 (default) or a valid combination of $x_external_memory_type_flags_t\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_external_memory_type_flags_t"
                            },
                            {
                                "desc": "[out] the exported Win32 handle representing the allocation.",
                                "name": "handle",
                                "type": "void*"
                            }
                        ],
                        "name": "$x_external_memory_export_win32_handle_t",
                        "type": "struct",
                        "version": "1.2"
                    },
                    {
                        "desc": "C++ wrapper for memory allocation",
                        "members": [],
                        "name": "$xMem",
                        "owner": "$xContext",
                        "type": "class"
                    },
                    {
                        "class": "$xMem",
                        "desc": "atomic access attribute flags",
                        "etors": [
                            {
                                "desc": "Atomics on the pointer are not allowed",
                                "name": "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_NO_ATOMICS",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Host atomics on the pointer are not allowed",
                                "name": "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_NO_HOST_ATOMICS",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Host atomics on the pointer are allowed. Requires $X_MEMORY_ACCESS_CAP_FLAG_ATOMIC returned by $xDeviceGetMemoryAccessProperties.",
                                "name": "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_HOST_ATOMICS",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "Device atomics on the pointer are not allowed",
                                "name": "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_NO_DEVICE_ATOMICS",
                                "value": "$X_BIT(3)"
                            },
                            {
                                "desc": "Device atomics on the pointer are allowed. Requires $X_MEMORY_ACCESS_CAP_FLAG_ATOMIC returned by $xDeviceGetMemoryAccessProperties.",
                                "name": "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_DEVICE_ATOMICS",
                                "value": "$X_BIT(4)"
                            },
                            {
                                "desc": "Concurrent atomics on the pointer from both host and device are not allowed",
                                "name": "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_NO_SYSTEM_ATOMICS",
                                "value": "$X_BIT(5)"
                            },
                            {
                                "desc": "Concurrent atomics on the pointer from both host and device are allowed. Requires $X_MEMORY_ACCESS_CAP_FLAG_CONCURRENT_ATOMIC returned by $xDeviceGetMemoryAccessProperties.",
                                "name": "$X_MEMORY_ATOMIC_ATTR_EXP_FLAG_SYSTEM_ATOMICS",
                                "value": "$X_BIT(6)"
                            }
                        ],
                        "name": "$x_memory_atomic_attr_exp_flags_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$xMem",
                        "desc": "Sets atomic access attributes for a shared allocation",
                        "details": [
                            "If the shared-allocation is owned by multiple devices (i.e. nullptr\nwas passed to $xMemAllocShared when creating it), then hDevice may be\npassed to set the attributes in that specific device. If nullptr is\npassed in hDevice, then the atomic attributes are set in all devices\nassociated with the allocation.\n",
                            "If the atomic access attribute select is not supported by the driver,\n$X_RESULT_INVALID_ARGUMENT is returned.\n",
                            "The atomic access attribute may be only supported at a device-specific\ngranularity, such as at a page boundary. In this case, the memory range\nmay be expanded such that the start and end of the range satisfy granularity\nrequirements.\n",
                            "When calling this function multiple times with different flags, only the\nattributes from last call are honored.\n",
                            "The application must not call this function for shared-allocations currently\nbeing used by the device.\n",
                            "The application must **not** call this function from simultaneous threads\nwith the same pointer.\n",
                            "The implementation of this function should be lock-free.\n"
                        ],
                        "hash": "741bf3ff2078c00b3af694e94f4efb8488e24ba16934c94b28d614daef51a2c7",
                        "name": "SetAtomicAccessAttributeExp",
                        "params": [
                            {
                                "desc": "[in] handle of context",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] device associated with the memory advice",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] Pointer to the start of the memory range",
                                "name": "ptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] Size in bytes of the memory range",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] Atomic access attributes to set for the specified range.\nMust be 0 (default) or a valid combination of $x_memory_atomic_attr_exp_flag_t.\n",
                                "name": "attr",
                                "type": "$x_memory_atomic_attr_exp_flags_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x7f < attr`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "class": "$xMem",
                        "desc": "Retrieves the atomic access attributes previously set for a shared allocation",
                        "details": [
                            "The application may call this function from simultaneous threads\nwith the same pointer.\n",
                            "The implementation of this function should be lock-free.\n"
                        ],
                        "hash": "219d80b819a20dcbd0a22583d0d62eeedd17df0717c2c5a09bd67d859ef386cc",
                        "name": "GetAtomicAccessAttributeExp",
                        "params": [
                            {
                                "desc": "[in] handle of context",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] device associated with the memory advice",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] Pointer to the start of the memory range",
                                "name": "ptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] Size in bytes of the memory range",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[out] Atomic access attributes for the specified range",
                                "name": "pAttr",
                                "type": "$x_memory_atomic_attr_exp_flags_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`",
                                    "`nullptr == pAttr`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Module",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "module",
                "objects": [
                    {
                        "class": "$xModule",
                        "desc": "Supported module creation input formats",
                        "etors": [
                            {
                                "desc": "Format is SPIRV IL format",
                                "name": "$X_MODULE_FORMAT_IL_SPIRV",
                                "value": "0"
                            },
                            {
                                "desc": "Format is device native format",
                                "name": "$X_MODULE_FORMAT_NATIVE",
                                "value": "1"
                            }
                        ],
                        "name": "$x_module_format_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xModule",
                        "desc": "Specialization constants - User defined constants",
                        "members": [
                            {
                                "desc": "[in] Number of specialization constants.",
                                "name": "numConstants",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][range(0, numConstants)] Array of IDs that is sized to numConstants.",
                                "name": "pConstantIds",
                                "type": "const uint32_t*"
                            },
                            {
                                "desc": "[in][range(0, numConstants)] Array of pointers to values that is sized to numConstants.",
                                "name": "pConstantValues",
                                "type": "const void**"
                            }
                        ],
                        "name": "$x_module_constants_t",
                        "type": "struct"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xModule",
                        "desc": "Module descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_MODULE_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] Module format passed in with pInputModule",
                                "name": "format",
                                "type": "$x_module_format_t"
                            },
                            {
                                "desc": "[in] size of input IL or ISA from pInputModule.",
                                "init": "0",
                                "name": "inputSize",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] pointer to IL or ISA",
                                "init": "nullptr",
                                "name": "pInputModule",
                                "type": "const uint8_t*"
                            },
                            {
                                "desc": "[in][optional] string containing one or more (comma-separated) compiler flags. If unsupported, flag is ignored with a warning.\n  - \"-$x-opt-disable\"\n       - Disable optimizations\n  - \"-$x-opt-level\"\n       - Specifies optimization level for compiler. Levels are implementation specific.\n           - 0 is no optimizations (equivalent to -$x-opt-disable)\n           - 1 is optimize minimally (may be the same as 2)\n           - 2 is optimize more (default)\n  - \"-$x-opt-greater-than-4GB-buffer-required\"\n       - Use 64-bit offset calculations for buffers.\n  - \"-$x-opt-large-register-file\"\n       - Increase number of registers available to threads.\n  - \"-$x-opt-has-buffer-offset-arg\"\n       - Extend stateless to stateful optimization to more\n         cases with the use of additional offset (e.g. 64-bit\n         pointer to binding table with 32-bit offset).\n  - \"-g\"\n       - Include debugging information.\n",
                                "init": "nullptr",
                                "name": "pBuildFlags",
                                "type": "const char*"
                            },
                            {
                                "desc": "[in][optional] pointer to specialization constants. Valid only for SPIR-V input. This must be set to nullptr if no specialization constants are provided.",
                                "init": "nullptr",
                                "name": "pConstants",
                                "type": "const $x_module_constants_t*"
                            }
                        ],
                        "name": "$x_module_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xModule",
                        "decl": "static",
                        "desc": "Creates a module on the context.",
                        "details": [
                            "Compiles the module for execution on the device.",
                            "The application must only use the module for the device, or its sub-devices, which was provided during creation.",
                            "The module can be copied to other devices and contexts within the same driver instance by using $xModuleGetNativeBinary.",
                            "A build log can optionally be returned to the caller. The caller is responsible for destroying build log using $xModuleBuildLogDestroy.",
                            "The module descriptor constants are only supported for SPIR-V specialization constants.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "b34a64869725f23bc70f32249655438e27344e57a8634b883ff29d0d8987507a",
                        "name": "Create",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] pointer to module descriptor",
                                "name": "desc",
                                "type": "const $x_module_desc_t*"
                            },
                            {
                                "desc": "[out] pointer to handle of module object created",
                                "name": "phModule",
                                "type": "$x_module_handle_t*"
                            },
                            {
                                "desc": "[out][optional] pointer to handle of module's build log.",
                                "name": "phBuildLog",
                                "type": "$x_module_build_log_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == desc->pInputModule`",
                                    "`nullptr == phModule`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$X_MODULE_FORMAT_NATIVE < desc->format`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NATIVE_BINARY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`0 == desc->inputSize`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_MODULE_BUILD_FAILURE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xModule",
                        "decl": "static",
                        "desc": "Destroys module",
                        "details": [
                            "The application must destroy all kernel handles created from the module before destroying the module itself.",
                            "The application must ensure the device is not currently referencing the module before it is deleted.",
                            "The implementation of this function may immediately free all Host and Device allocations associated with this module.",
                            "The application must **not** call this function from simultaneous threads with the same module handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "349b769d72d44bcbeb8306573eb07e65478f28d404576327cdd45381da9e8b96",
                        "name": "Destroy",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in][release] handle of the module",
                                "name": "hModule",
                                "type": "$x_module_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hModule`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xModule",
                        "decl": "static",
                        "desc": "Dynamically link modules together that share import/export linkage dependencies.",
                        "details": [
                            "Modules support SPIR-V import and export linkage types for functions and global variables. See the SPIR-V specification for linkage details.",
                            "Modules can have both import and export linkage.",
                            "Modules that do not have any imports or exports do not need to be linked.",
                            "All module import requirements must be satisfied via linking before kernel objects can be created from them.",
                            "Modules cannot be partially linked. Unsatisfiable import dependencies in the set of modules passed to $xModuleDynamicLink will result in  $X_RESULT_ERROR_MODULE_LINK_FAILURE being returned.",
                            "Modules will only be linked once. A module can be used in multiple link calls if it has exports but its imports will not be re-linked.",
                            "Ambiguous dependencies, where multiple modules satisfy the same import dependencies for a module, are not allowed.",
                            "The application must ensure the modules being linked were created on the same context.",
                            "The application may call this function from simultaneous threads as long as the import modules being linked are not the same.",
                            "ModuleGetNativeBinary can be called on any module regardless of whether it is linked or not.",
                            "A link log can optionally be returned to the caller. The caller is responsible for destroying the link log using $xModuleBuildLogDestroy.",
                            "The link log may contain a list of the unresolved import dependencies if present.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "a8c15c9dd068b5439579d4b2caf5406794937dae5b690d508861538dc48fe0dc",
                        "name": "DynamicLink",
                        "params": [
                            {
                                "desc": "[in] number of modules to be linked pointed to by phModules.",
                                "name": "numModules",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][range(0, numModules)] pointer to an array of modules to dynamically link together.",
                                "name": "phModules",
                                "type": "$x_module_handle_t*"
                            },
                            {
                                "desc": "[out][optional] pointer to handle of dynamic link log.",
                                "name": "phLinkLog",
                                "type": "$x_module_build_log_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phModules`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_MODULE_LINK_FAILURE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xModuleBuildLog",
                        "decl": "static",
                        "desc": "Destroys module build log object",
                        "details": [
                            "The implementation of this function may immediately free all Host allocations associated with this object.",
                            "The application must **not** call this function from simultaneous threads with the same build log handle.",
                            "The implementation of this function should be lock-free.",
                            "This function can be called before or after $xModuleDestroy for the associated module."
                        ],
                        "hash": "9c101cf3fd365132a5537247d01f3cefa6f7b60ba9c15da3f2380f61a4f6fa5c",
                        "name": "Destroy",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in][release] handle of the module build log object.",
                                "name": "hModuleBuildLog",
                                "type": "$x_module_build_log_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hModuleBuildLog`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xModuleBuildLog",
                        "desc": "Retrieves text string for build log.",
                        "details": [
                            "The caller can pass nullptr for pBuildLog when querying only for size.",
                            "The caller must provide memory for build log.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "2e8534b4dfea4cf845efe49987825ea8f684cf88eb1011b027e2081c50bf786b",
                        "name": "GetString",
                        "params": [
                            {
                                "desc": "[in] handle of the module build log object.",
                                "name": "hModuleBuildLog",
                                "type": "$x_module_build_log_handle_t"
                            },
                            {
                                "desc": "[in,out] size of build log string.",
                                "name": "pSize",
                                "type": "size_t*"
                            },
                            {
                                "desc": "[in,out][optional] pointer to null-terminated string of the log.",
                                "name": "pBuildLog",
                                "type": "char*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hModuleBuildLog`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pSize`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xModule",
                        "desc": "Retrieve native binary from Module.",
                        "details": [
                            "The native binary output can be cached to disk and new modules can be later constructed from the cached copy.",
                            "The native binary will retain debugging information that is associated with a module.",
                            "The caller can pass nullptr for pModuleNativeBinary when querying only for size.",
                            "The implementation will copy the native binary into a buffer supplied by the caller.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "043affb5d74a5738f6f15766b94cb19bb925ed422b5fde9a86bd8be47b341aca",
                        "name": "GetNativeBinary",
                        "params": [
                            {
                                "desc": "[in] handle of the module",
                                "name": "hModule",
                                "type": "$x_module_handle_t"
                            },
                            {
                                "desc": "[in,out] size of native binary in bytes.",
                                "name": "pSize",
                                "type": "size_t*"
                            },
                            {
                                "desc": "[in,out][optional] byte pointer to native binary",
                                "name": "pModuleNativeBinary",
                                "type": "uint8_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hModule`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pSize`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xModule",
                        "desc": "Retrieve global variable pointer from Module.",
                        "details": [
                            "The application may query global pointer from any module that either exports or imports it.",
                            "The application must dynamically link a module that imports a global before the global pointer can be queried from it.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "5b39f769e7f1b56183210d7ad1290017dbf8c68582d982875b94d07e8e0a549c",
                        "name": "GetGlobalPointer",
                        "params": [
                            {
                                "desc": "[in] handle of the module",
                                "name": "hModule",
                                "type": "$x_module_handle_t"
                            },
                            {
                                "desc": "[in] name of global variable in module",
                                "name": "pGlobalName",
                                "type": "const char*"
                            },
                            {
                                "desc": "[in,out][optional] size of global variable",
                                "name": "pSize",
                                "type": "size_t*"
                            },
                            {
                                "desc": "[in,out][optional] device visible pointer",
                                "name": "pptr",
                                "type": "void**"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hModule`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pGlobalName`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_GLOBAL_NAME": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xModule",
                        "desc": "Retrieve all kernel names in the module.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "0e05374b34a6bf84f993c6c127a9c2e7affdbc11fe96cbedcfa8e306bd18cc21",
                        "name": "GetKernelNames",
                        "params": [
                            {
                                "desc": "[in] handle of the module",
                                "name": "hModule",
                                "type": "$x_module_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of names.\nif count is zero, then the driver shall update the value with the total number of names available.\nif count is greater than the number of names available, then the driver shall update the value with the correct number of names available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of names of functions.\nif count is less than the number of names available, then driver shall only retrieve that number of names.\n",
                                "name": "pNames",
                                "type": "const char**"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hModule`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xModule",
                        "desc": "Supported module property flags",
                        "etors": [
                            {
                                "desc": "Module has imports (i.e. imported global variables and/or kernels). See $xModuleDynamicLink.",
                                "name": "$X_MODULE_PROPERTY_FLAG_IMPORTS",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$x_module_property_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xModule",
                        "desc": "Module properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_MODULE_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] 0 (none) or a valid combination of $x_module_property_flag_t",
                                "name": "flags",
                                "type": "$x_module_property_flags_t"
                            }
                        ],
                        "name": "$x_module_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xModule",
                        "desc": "Retrieve module properties.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "05d743ee99c69140edb1b2ba1472983681c919b507e3ff448c63fa93efa224dc",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] handle of the module",
                                "name": "hModule",
                                "type": "$x_module_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for module properties.",
                                "name": "pModuleProperties",
                                "type": "$x_module_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hModule`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pModuleProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Supported kernel creation flags",
                        "etors": [
                            {
                                "desc": "force all device allocations to be resident during execution",
                                "name": "$X_KERNEL_FLAG_FORCE_RESIDENCY",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "application is responsible for all residency of device allocations.\ndriver may disable implicit residency management.\n",
                                "name": "$X_KERNEL_FLAG_EXPLICIT_RESIDENCY",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$x_kernel_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xKernel",
                        "desc": "Kernel descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_KERNEL_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of $x_kernel_flag_t;\ndefault behavior may use driver-based residency.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_kernel_flags_t"
                            },
                            {
                                "desc": "[in] null-terminated name of kernel in module",
                                "init": "nullptr",
                                "name": "pKernelName",
                                "type": "const char*"
                            }
                        ],
                        "name": "$x_kernel_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xKernel",
                        "decl": "static",
                        "desc": "Create a kernel from the module.",
                        "details": [
                            "Modules that have unresolved imports need to be dynamically linked before a kernel can be created from them. (See $xModuleDynamicLink)",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "76d6698c139b3689b63608d2178879f6ae7ccb9025990393832bb7d232e91ac3",
                        "name": "Create",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the module",
                                "name": "hModule",
                                "type": "$x_module_handle_t"
                            },
                            {
                                "desc": "[in] pointer to kernel descriptor",
                                "name": "desc",
                                "type": "const $x_kernel_desc_t*"
                            },
                            {
                                "desc": "[out] handle of the Function object",
                                "name": "phKernel",
                                "type": "$x_kernel_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hModule`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == desc->pKernelName`",
                                    "`nullptr == phKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x3 < desc->flags`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_KERNEL_NAME": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_MODULE_UNLINKED": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xKernel",
                        "decl": "static",
                        "desc": "Destroys a kernel object",
                        "details": [
                            "The application must ensure the device is not currently referencing the kernel before it is deleted.",
                            "The implementation of this function may immediately free all Host and Device allocations associated with this kernel.",
                            "The application must **not** call this function from simultaneous threads with the same kernel handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "ed12e35d0da3fca93345ffe837868fd6a3023aa6b0fd30c19f4d5ea8b42f38d0",
                        "name": "Destroy",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in][release] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xModule",
                        "desc": "Retrieve a function pointer from a module by name",
                        "details": [
                            "The function pointer is unique for the device on which the module was created.",
                            "The function pointer is no longer valid if module is destroyed.",
                            "The function name should only refer to callable functions within the module.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "d316b47d5880386648c2751e90d316a28a7ae230f11cb4fa1375a9e332cc7c82",
                        "name": "GetFunctionPointer",
                        "params": [
                            {
                                "desc": "[in] handle of the module",
                                "name": "hModule",
                                "type": "$x_module_handle_t"
                            },
                            {
                                "desc": "[in] Name of function to retrieve function pointer for.",
                                "name": "pFunctionName",
                                "type": "const char*"
                            },
                            {
                                "desc": "[out] pointer to function.",
                                "name": "pfnFunction",
                                "type": "void**"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hModule`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pFunctionName`",
                                    "`nullptr == pfnFunction`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_FUNCTION_NAME": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Set group size for a kernel.",
                        "details": [
                            "The group size will be used when a $xCommandListAppendLaunchKernel variant is called.",
                            "The application must **not** call this function from simultaneous threads with the same kernel handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "794a9f8c8ae2f9f273a023823511de300ddc95d22eca649281b91efe28fccf74",
                        "name": "SetGroupSize",
                        "params": [
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in] group size for X dimension to use for this kernel",
                                "name": "groupSizeX",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] group size for Y dimension to use for this kernel",
                                "name": "groupSizeY",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] group size for Z dimension to use for this kernel",
                                "name": "groupSizeZ",
                                "type": "uint32_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Query a suggested group size for a kernel given a global size for each dimension.",
                        "details": [
                            "This function ignores the group size that is set using $xKernelSetGroupSize.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "3ddaa55cddcdc68068314af08f3053ce0c6ce9bbb37edf06da21812e5a669b77",
                        "name": "SuggestGroupSize",
                        "params": [
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in] global width for X dimension",
                                "name": "globalSizeX",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] global width for Y dimension",
                                "name": "globalSizeY",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] global width for Z dimension",
                                "name": "globalSizeZ",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] recommended size of group for X dimension",
                                "name": "groupSizeX",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[out] recommended size of group for Y dimension",
                                "name": "groupSizeY",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[out] recommended size of group for Z dimension",
                                "name": "groupSizeZ",
                                "type": "uint32_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == groupSizeX`",
                                    "`nullptr == groupSizeY`",
                                    "`nullptr == groupSizeZ`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Query a suggested max group count for a cooperative kernel.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "35146bbbfe48d099b66c9436975ff150cb0aeeb0f86e25226681b3e3676fb233",
                        "name": "SuggestMaxCooperativeGroupCount",
                        "params": [
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[out] recommended total group count.",
                                "name": "totalGroupCount",
                                "type": "uint32_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == totalGroupCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Set kernel argument for a kernel.",
                        "details": [
                            "The argument values will be used when a $xCommandListAppendLaunchKernel variant is called.",
                            "The application must **not** call this function from simultaneous threads with the same kernel handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "0b8a841d505ec3d9908a00d179af05f65deb76b9d366b1aeb087f885106e55dc",
                        "name": "SetArgumentValue",
                        "params": [
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in] argument index in range [0, num args - 1]",
                                "name": "argIndex",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] size of argument type",
                                "name": "argSize",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in][optional] argument value represented as matching arg type. If null then argument value is considered null.",
                                "name": "pArgValue",
                                "type": "const void*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Kernel indirect access flags",
                        "etors": [
                            {
                                "desc": "Indicates that the kernel accesses host allocations indirectly.",
                                "name": "$X_KERNEL_INDIRECT_ACCESS_FLAG_HOST",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Indicates that the kernel accesses device allocations indirectly.",
                                "name": "$X_KERNEL_INDIRECT_ACCESS_FLAG_DEVICE",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Indicates that the kernel accesses shared allocations indirectly.",
                                "name": "$X_KERNEL_INDIRECT_ACCESS_FLAG_SHARED",
                                "value": "$X_BIT(2)"
                            }
                        ],
                        "name": "$x_kernel_indirect_access_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Sets kernel indirect access flags.",
                        "details": [
                            "The application should specify which allocations will be indirectly accessed by the kernel to allow driver to optimize which allocations are made resident",
                            "This function may **not** be called from simultaneous threads with the same Kernel handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "3fa02e042af4c1e07f7d75e582ef89ee505f9c6c5d60aecd76a42ad941087eae",
                        "name": "SetIndirectAccess",
                        "params": [
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in] kernel indirect access flags",
                                "name": "flags",
                                "type": "$x_kernel_indirect_access_flags_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x7 < flags`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Retrieve kernel indirect access flags.",
                        "details": [
                            "This function may be called from simultaneous threads with the same Kernel handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "e95327d9eb9e3e93fa04fcb25411b5f5aa78220c63165ca3f7b0e1d3a8d51771",
                        "name": "GetIndirectAccess",
                        "params": [
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[out] query result for kernel indirect access flags.",
                                "name": "pFlags",
                                "type": "$x_kernel_indirect_access_flags_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pFlags`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Retrieve all declared kernel attributes (i.e. can be specified with __attribute__ in runtime language).",
                        "details": [
                            "This function may be called from simultaneous threads with the same Kernel handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "0505f799e0856339ac55ee4d2dde294e63feea2656afcf18943cb69bb6dfdc03",
                        "name": "GetSourceAttributes",
                        "params": [
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to size of string in bytes, including null-terminating character.",
                                "name": "pSize",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional] pointer to application-managed character array (string data).\nIf NULL, the string length of the kernel source attributes, including a null-terminating character, is returned in pSize.\nOtherwise, pString must point to valid application memory that is greater than or equal to *pSize bytes in length, and on return the pointed-to string will contain a space-separated list of kernel source attributes.\n",
                                "name": "pString",
                                "type": "char**"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pSize`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Supported Cache Config flags",
                        "etors": [
                            {
                                "desc": "Large SLM size",
                                "name": "$X_CACHE_CONFIG_FLAG_LARGE_SLM",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Large General Data size",
                                "name": "$X_CACHE_CONFIG_FLAG_LARGE_DATA",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$x_cache_config_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Sets the preferred cache configuration.",
                        "details": [
                            "The cache configuration will be used when a $xCommandListAppendLaunchKernel variant is called.",
                            "The application must **not** call this function from simultaneous threads with the same kernel handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "a298b03ab502760766b10871da1128b64b08c721c71553ec0b42aba86b5b1859",
                        "name": "SetCacheConfig",
                        "ordinal": "2",
                        "params": [
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in] cache configuration.\nmust be 0 (default configuration) or a valid combination of $x_cache_config_flag_t.\n",
                                "name": "flags",
                                "type": "$x_cache_config_flags_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x3 < flags`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "Maximum kernel universal unique id (UUID) size in bytes",
                        "name": "$X_MAX_KERNEL_UUID_SIZE",
                        "type": "macro",
                        "value": "16"
                    },
                    {
                        "desc": "Maximum module universal unique id (UUID) size in bytes",
                        "name": "$X_MAX_MODULE_UUID_SIZE",
                        "type": "macro",
                        "value": "16"
                    },
                    {
                        "desc": "Kernel universal unique id (UUID)",
                        "members": [
                            {
                                "desc": "[out] opaque data representing a kernel UUID",
                                "name": "kid[$X_MAX_KERNEL_UUID_SIZE]",
                                "type": "uint8_t"
                            },
                            {
                                "desc": "[out] opaque data representing the kernel's module UUID",
                                "name": "mid[$X_MAX_MODULE_UUID_SIZE]",
                                "type": "uint8_t"
                            }
                        ],
                        "name": "$x_kernel_uuid_t",
                        "type": "struct"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xKernel",
                        "desc": "Kernel properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_KERNEL_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] number of kernel arguments.",
                                "name": "numKernelArgs",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] required group size in the X dimension,\nor zero if there is no required group size\n",
                                "name": "requiredGroupSizeX",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] required group size in the Y dimension,\nor zero if there is no required group size\n",
                                "name": "requiredGroupSizeY",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] required group size in the Z dimension,\nor zero if there is no required group size\n",
                                "name": "requiredGroupSizeZ",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] required number of subgroups per thread group,\nor zero if there is no required number of subgroups\n",
                                "name": "requiredNumSubGroups",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] required subgroup size,\nor zero if there is no required subgroup size\n",
                                "name": "requiredSubgroupSize",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] maximum subgroup size",
                                "name": "maxSubgroupSize",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] maximum number of subgroups per thread group",
                                "name": "maxNumSubgroups",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] local memory size used by each thread group",
                                "name": "localMemSize",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] private memory size allocated by compiler used by each thread",
                                "name": "privateMemSize",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] spill memory size allocated by compiler",
                                "name": "spillMemSize",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] universal unique identifier.",
                                "name": "uuid",
                                "type": "$x_kernel_uuid_t"
                            }
                        ],
                        "name": "$x_kernel_properties_t",
                        "type": "struct"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xKernel",
                        "desc": "Additional kernel preferred group size properties",
                        "details": [
                            "This structure may be passed to $xKernelGetProperties, via the `pNext` member of $x_kernel_properties_t, to query additional kernel preferred group size properties."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_KERNEL_PREFERRED_GROUP_SIZE_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] preferred group size multiple",
                                "name": "preferredMultiple",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_kernel_preferred_group_size_properties_t",
                        "type": "struct",
                        "version": "1.2"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Retrieve kernel properties.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "22a35d4f66aae19b29b00d6c04c50cefd7deb1733a439cd388769fd2a7ab68b1",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for kernel properties.",
                                "name": "pKernelProperties",
                                "type": "$x_kernel_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pKernelProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Retrieve kernel name from Kernel.",
                        "details": [
                            "The caller can pass nullptr for pName when querying only for size.",
                            "The implementation will copy the kernel name into a buffer supplied by the caller.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "688cd9a40f353689c2635349ed4eb5ad3a874d0c2fa19479596e7da9354e851f",
                        "name": "GetName",
                        "params": [
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in,out] size of kernel name string, including null terminator, in bytes.",
                                "name": "pSize",
                                "type": "size_t*"
                            },
                            {
                                "desc": "[in,out][optional] char pointer to kernel name.",
                                "name": "pName",
                                "type": "char*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pSize`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Kernel dispatch group count.",
                        "members": [
                            {
                                "desc": "[in] number of thread groups in X dimension",
                                "init": "0",
                                "name": "groupCountX",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] number of thread groups in Y dimension",
                                "init": "0",
                                "name": "groupCountY",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] number of thread groups in Z dimension",
                                "init": "0",
                                "name": "groupCountZ",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_group_count_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Launch kernel over one or more work groups.",
                        "details": [
                            "The application must ensure the kernel and events are accessible by the device on which the command list was created.",
                            "This may **only** be called for a command list created with command queue group ordinal that supports compute.",
                            "The application must ensure the command list, kernel and events were created on the same context.",
                            "This function may **not** be called from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "f59a9452458084e6dda68853fb764998f378a3ad1d5a09acd70d1bb53ec8d2d0",
                        "name": "AppendLaunchKernel",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in] thread group launch arguments",
                                "name": "pLaunchFuncArgs",
                                "type": "const $x_group_count_t*"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pLaunchFuncArgs`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Launch kernel cooperatively over one or more work groups.",
                        "details": [
                            "The application must ensure the kernel and events are accessible by the device on which the command list was created.",
                            "This may **only** be called for a command list created with command queue group ordinal that supports compute.",
                            "This may only be used for a command list that are submitted to command queue with cooperative flag set.",
                            "The application must ensure the command list, kernel and events were created on the same context.",
                            "This function may **not** be called from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free.",
                            "Use $xKernelSuggestMaxCooperativeGroupCount to recommend max group count for device for cooperative functions that device supports."
                        ],
                        "hash": "4ee4429a16ce3462d77f81121aa8fcdc54b7f6c86f719551f85d09ceef345b47",
                        "name": "AppendLaunchCooperativeKernel",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in] thread group launch arguments",
                                "name": "pLaunchFuncArgs",
                                "type": "const $x_group_count_t*"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pLaunchFuncArgs`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Launch kernel over one or more work groups using indirect arguments.",
                        "details": [
                            "The application must ensure the kernel and events are accessible by the device on which the command list was created.",
                            "The application must ensure the launch arguments are visible to the device on which the command list was created.",
                            "The implementation must not access the contents of the launch arguments as they are free to be modified by either the Host or device up until execution.",
                            "This may **only** be called for a command list created with command queue group ordinal that supports compute.",
                            "The application must ensure the command list, kernel and events were created, and the memory was allocated, on the same context.",
                            "This function may **not** be called from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "2abb2eb1e4c7084a2166e1780de252181b9e2ec652c5003523f7c83d6822431e",
                        "name": "AppendLaunchKernelIndirect",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in] pointer to device buffer that will contain thread group launch arguments",
                                "name": "pLaunchArgumentsBuffer",
                                "type": "const $x_group_count_t*"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pLaunchArgumentsBuffer`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xCommandList",
                        "desc": "Launch multiple kernels over one or more work groups using an array of indirect arguments.",
                        "details": [
                            "The application must ensure the kernel and events are accessible by the device on which the command list was created.",
                            "The application must ensure the array of launch arguments and count buffer are visible to the device on which the command list was created.",
                            "The implementation must not access the contents of the array of launch arguments or count buffer as they are free to be modified by either the Host or device up until execution.",
                            "This may **only** be called for a command list created with command queue group ordinal that supports compute.",
                            "The application must enusre the command list, kernel and events were created, and the memory was allocated, on the same context.",
                            "This function may **not** be called from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "6371eb9530a0bb3b56b9423b7dfdccc85af50cfcfcd5cb5983bc1adc1a29eec7",
                        "name": "AppendLaunchMultipleKernelsIndirect",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] maximum number of kernels to launch",
                                "name": "numKernels",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][range(0, numKernels)] handles of the kernel objects",
                                "name": "phKernels",
                                "type": "$x_kernel_handle_t*"
                            },
                            {
                                "desc": "[in] pointer to device memory location that will contain the actual number of kernels to launch; value must be less than or equal to numKernels",
                                "name": "pCountBuffer",
                                "type": "const uint32_t*"
                            },
                            {
                                "desc": "[in][range(0, numKernels)] pointer to device buffer that will contain a contiguous array of thread group launch arguments",
                                "name": "pLaunchArgumentsBuffer",
                                "type": "const $x_group_count_t*"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phKernels`",
                                    "`nullptr == pCountBuffer`",
                                    "`nullptr == pLaunchArgumentsBuffer`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for module",
                        "members": [
                            {
                                "desc": "[in] handle of module object",
                                "name": "handle",
                                "type": "$x_module_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$xDevice*"
                            },
                            {
                                "desc": "[in] descriptor of the module object",
                                "name": "desc",
                                "type": "$x_module_desc_t"
                            }
                        ],
                        "name": "$xModule",
                        "owner": "$xDevice",
                        "type": "class"
                    },
                    {
                        "desc": "C++ wrapper for buildlog",
                        "members": [
                            {
                                "desc": "[in] handle of the buildlog object",
                                "name": "handle",
                                "type": "$x_module_build_log_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pModule",
                                "type": "$xModule*"
                            }
                        ],
                        "name": "$xModuleBuildLog",
                        "owner": "$xModule",
                        "type": "class"
                    },
                    {
                        "desc": "C++ wrapper for kernel",
                        "members": [
                            {
                                "desc": "[in] handle of kernel object",
                                "name": "handle",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pModule",
                                "type": "$xModule*"
                            },
                            {
                                "desc": "[in] descriptor of the kernel object",
                                "name": "desc",
                                "type": "$x_kernel_desc_t"
                            }
                        ],
                        "name": "$xKernel",
                        "owner": "$xModule",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for supporting module programs.",
                    "ordinal": 1000,
                    "type": "header",
                    "version": "1.0"
                },
                "name": "program",
                "objects": [
                    {
                        "desc": "Module Program Extension Name",
                        "name": "$X_MODULE_PROGRAM_EXP_NAME",
                        "type": "macro",
                        "value": "\"$X_experimental_module_program\"",
                        "version": "1.0"
                    },
                    {
                        "desc": "Module Program Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_MODULE_PROGRAM_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_MODULE_PROGRAM_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_module_program_exp_version_t",
                        "type": "enum",
                        "version": "1.0"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xModule",
                        "desc": "Module extended descriptor to support multiple input modules.",
                        "details": [
                            "Implementation must support $X_experimental_module_program extension",
                            "Modules support import and export linkage for functions and global variables.",
                            "SPIR-V import and export linkage types are used. See SPIR-V specification for linkage details.",
                            "pInputModules, pBuildFlags, and pConstants from $x_module_desc_t is ignored.",
                            "Format in $x_module_desc_t needs to be set to $X_MODULE_FORMAT_IL_SPIRV."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_MODULE_PROGRAM_EXP_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] Count of input modules",
                                "name": "count",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][range(0, count)] sizes of each input IL module in pInputModules.",
                                "name": "inputSizes",
                                "type": "const size_t*"
                            },
                            {
                                "desc": "[in][range(0, count)] pointer to an array of IL (e.g. SPIR-V modules). Valid only for SPIR-V input.",
                                "init": "nullptr",
                                "name": "pInputModules",
                                "type": "const uint8_t**"
                            },
                            {
                                "desc": "[in][optional][range(0, count)] array of strings containing build flags. See pBuildFlags in $x_module_desc_t.",
                                "init": "nullptr",
                                "name": "pBuildFlags",
                                "type": "const char**"
                            },
                            {
                                "desc": "[in][optional][range(0, count)] pointer to array of specialization constant strings. Valid only for SPIR-V input. This must be set to nullptr if no specialization constants are provided.",
                                "init": "nullptr",
                                "name": "pConstants",
                                "type": "const $x_module_constants_t**"
                            }
                        ],
                        "name": "$x_module_program_exp_desc_t",
                        "type": "struct"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for Raytracing",
                    "ordinal": 1000,
                    "type": "header",
                    "version": "1.0"
                },
                "name": "raytracing",
                "objects": [
                    {
                        "desc": "Raytracing Extension Name",
                        "name": "$X_RAYTRACING_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_raytracing\"",
                        "version": "1.0"
                    },
                    {
                        "desc": "Raytracing Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_RAYTRACING_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_RAYTRACING_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_raytracing_ext_version_t",
                        "type": "enum",
                        "version": "1.0"
                    },
                    {
                        "class": "$xContext",
                        "desc": "Supported raytracing capability flags",
                        "etors": [
                            {
                                "desc": "Supports rayquery",
                                "name": "$X_DEVICE_RAYTRACING_EXT_FLAG_RAYQUERY",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$x_device_raytracing_ext_flags_t",
                        "type": "enum",
                        "version": "1.0"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xContext",
                        "desc": "Raytracing properties queried using $xDeviceGetModuleProperties",
                        "details": [
                            "This structure may be returned from $xDeviceGetModuleProperties, via the `pNext` member of $x_device_module_properties_t."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_RAYTRACING_EXT_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] 0 or a valid combination of $x_device_raytracing_ext_flags_t",
                                "name": "flags",
                                "type": "$x_device_raytracing_ext_flags_t"
                            },
                            {
                                "desc": "[out] Maximum number of BVH levels supported",
                                "name": "maxBVHLevels",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_device_raytracing_ext_properties_t",
                        "type": "struct",
                        "version": "1.0"
                    },
                    {
                        "class": "$xContext",
                        "desc": "Supported raytracing memory allocation flags",
                        "etors": [
                            {
                                "desc": "reserved for future use",
                                "name": "$X_RAYTRACING_MEM_ALLOC_EXT_FLAG_TBD",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$x_raytracing_mem_alloc_ext_flags_t",
                        "type": "enum",
                        "version": "1.0"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xContext",
                        "desc": "Raytracing memory allocation descriptor",
                        "details": [
                            "This structure must be passed to $xMemAllocShared or $xMemAllocDevice, via the `pNext` member of $x_device_mem_alloc_desc_t, for any memory allocation that is to be accessed by raytracing fixed-function of the device."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_RAYTRACING_MEM_ALLOC_EXT_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] flags specifying additional allocation controls.\nmust be 0 (default) or a valid combination of $x_raytracing_mem_alloc_ext_flag_t;\ndefault behavior may use implicit driver-based heuristics.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_raytracing_mem_alloc_ext_flags_t"
                            }
                        ],
                        "name": "$x_raytracing_mem_alloc_ext_desc_t",
                        "type": "struct",
                        "version": "1.0"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Memory Residency",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "residency",
                "objects": [
                    {
                        "class": "$xContext",
                        "desc": "Makes memory resident for the device.",
                        "details": [
                            "The application must ensure the memory is resident before being referenced by the device",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "0ede25c0fa4f257fa909c006790cbb66b632bedf075bfb9e5fb177b24b03519c",
                        "name": "MakeMemoryResident",
                        "params": [
                            {
                                "desc": "[in] handle of context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] pointer to memory to make resident",
                                "name": "ptr",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] size in bytes to make resident",
                                "name": "size",
                                "type": "size_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xContext",
                        "desc": "Allows memory to be evicted from the device.",
                        "details": [
                            "The application must ensure the device is not currently referencing the memory before it is evicted",
                            "The application may free the memory without evicting; the memory is implicitly evicted when freed.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "eb552c266e77cf372042990ed27a9e7e43deac5ad505858cb25a4b4db649a9eb",
                        "name": "EvictMemory",
                        "params": [
                            {
                                "desc": "[in] handle of context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] pointer to memory to evict",
                                "name": "ptr",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] size in bytes to evict",
                                "name": "size",
                                "type": "size_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xContext",
                        "desc": "Makes image resident for the device.",
                        "details": [
                            "The application must ensure the image is resident before being referenced by the device",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "57b4676a6a5206cc9915a2ad3c7a130d70c9ea65c6484b0508523ea12eee4ae9",
                        "name": "MakeImageResident",
                        "params": [
                            {
                                "desc": "[in] handle of context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] handle of image to make resident",
                                "name": "hImage",
                                "type": "$x_image_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`",
                                    "`nullptr == hImage`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xContext",
                        "desc": "Allows image to be evicted from the device.",
                        "details": [
                            "The application must ensure the device is not currently referencing the image before it is evicted",
                            "The application may destroy the image without evicting; the image is implicitly evicted when destroyed.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "d8cabc0188f6ec7818a2001141f1a486d3e3811a48f2acd9df2e4931f119800c",
                        "name": "EvictImage",
                        "params": [
                            {
                                "desc": "[in] handle of context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] handle of image to make evict",
                                "name": "hImage",
                                "type": "$x_image_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`",
                                    "`nullptr == hImage`"
                                ]
                            }
                        ],
                        "type": "function"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Sampler",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "sampler",
                "objects": [
                    {
                        "class": "$xSampler",
                        "desc": "Sampler addressing modes",
                        "etors": [
                            {
                                "desc": "No coordinate modifications for out-of-bounds image access.",
                                "name": "$X_SAMPLER_ADDRESS_MODE_NONE",
                                "value": "0"
                            },
                            {
                                "desc": "Out-of-bounds coordinates are wrapped back around.",
                                "name": "$X_SAMPLER_ADDRESS_MODE_REPEAT",
                                "value": "1"
                            },
                            {
                                "desc": "Out-of-bounds coordinates are clamped to edge.",
                                "name": "$X_SAMPLER_ADDRESS_MODE_CLAMP",
                                "value": "2"
                            },
                            {
                                "desc": "Out-of-bounds coordinates are clamped to border color which is (0.0f, 0.0f, 0.0f, 0.0f) if image format swizzle contains alpha, otherwise (0.0f, 0.0f, 0.0f, 1.0f).",
                                "name": "$X_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER",
                                "value": "3"
                            },
                            {
                                "desc": "Out-of-bounds coordinates are mirrored starting from edge.",
                                "name": "$X_SAMPLER_ADDRESS_MODE_MIRROR",
                                "value": "4"
                            }
                        ],
                        "name": "$x_sampler_address_mode_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xSampler",
                        "desc": "Sampler filtering modes",
                        "etors": [
                            {
                                "desc": "No coordinate modifications for out of bounds image access.",
                                "name": "$X_SAMPLER_FILTER_MODE_NEAREST",
                                "value": "0"
                            },
                            {
                                "desc": "Out-of-bounds coordinates are wrapped back around.",
                                "name": "$X_SAMPLER_FILTER_MODE_LINEAR",
                                "value": "1"
                            }
                        ],
                        "name": "$x_sampler_filter_mode_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xSampler",
                        "desc": "Sampler descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_SAMPLER_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] Sampler addressing mode to determine how out-of-bounds coordinates are handled.",
                                "init": "$X_SAMPLER_ADDRESS_MODE_NONE",
                                "name": "addressMode",
                                "type": "$x_sampler_address_mode_t"
                            },
                            {
                                "desc": "[in] Sampler filter mode to determine how samples are filtered.",
                                "init": "$X_SAMPLER_FILTER_MODE_NEAREST",
                                "name": "filterMode",
                                "type": "$x_sampler_filter_mode_t"
                            },
                            {
                                "desc": "[in] Are coordinates normalized [0, 1] or not.",
                                "init": "true",
                                "name": "isNormalized",
                                "type": "$x_bool_t"
                            }
                        ],
                        "name": "$x_sampler_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xSampler",
                        "decl": "static",
                        "desc": "Creates sampler on the context.",
                        "details": [
                            "The application must only use the sampler for the device, or its sub-devices, which was provided during creation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "b33474012d5f4ab6617800730d2ba440d0c77fd32ee352ba18d8bdc33ce9948d",
                        "name": "Create",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] pointer to sampler descriptor",
                                "name": "desc",
                                "type": "const $x_sampler_desc_t*"
                            },
                            {
                                "desc": "[out] handle of the sampler",
                                "name": "phSampler",
                                "type": "$x_sampler_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phSampler`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$X_SAMPLER_ADDRESS_MODE_MIRROR < desc->addressMode`",
                                    "`$X_SAMPLER_FILTER_MODE_LINEAR < desc->filterMode`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xSampler",
                        "decl": "static",
                        "desc": "Destroys sampler object",
                        "details": [
                            "The application must ensure the device is not currently referencing the sampler before it is deleted.",
                            "The implementation of this function may immediately free all Host and Device allocations associated with this sampler.",
                            "The application must **not** call this function from simultaneous threads with the same sampler handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "d7fa8a6bd2aa22fb9d7517a0588c9dfac772618e2475bbb7258b1cfcf08d6b1b",
                        "name": "Destroy",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in][release] handle of the sampler",
                                "name": "hSampler",
                                "type": "$x_sampler_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hSampler`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "c++ wrapper for sampler",
                        "members": [
                            {
                                "desc": "[in] handle of the sample object",
                                "name": "handle",
                                "type": "$x_sampler_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$xDevice*"
                            },
                            {
                                "desc": "[in] sampler descriptor",
                                "name": "desc",
                                "type": "$x_sampler_desc_t"
                            }
                        ],
                        "name": "$xSampler",
                        "owner": "$xDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero APIs for Virtual Memory Management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "virtual",
                "objects": [
                    {
                        "class": "$xVirtualMem",
                        "desc": "Virtual memory page access attributes",
                        "etors": [
                            {
                                "desc": "Indicates the memory page is inaccessible.",
                                "name": "$X_MEMORY_ACCESS_ATTRIBUTE_NONE",
                                "value": "0"
                            },
                            {
                                "desc": "Indicates the memory page supports read write access.",
                                "name": "$X_MEMORY_ACCESS_ATTRIBUTE_READWRITE",
                                "value": "1"
                            },
                            {
                                "desc": "Indicates the memory page supports read-only access.",
                                "name": "$X_MEMORY_ACCESS_ATTRIBUTE_READONLY",
                                "value": "2"
                            }
                        ],
                        "name": "$x_memory_access_attribute_t",
                        "type": "enum"
                    },
                    {
                        "class": "$xVirtualMem",
                        "decl": "static",
                        "desc": "Reserves pages in virtual address space.",
                        "details": [
                            "The application must only use the memory allocation on the context for which it was created.",
                            "The starting address and size must be page aligned. See $xVirtualMemQueryPageSize.",
                            "If pStart is not null then implementation will attempt to reserve starting from that address. If not available then will find another suitable starting address.",
                            "The application may call this function from simultaneous threads.",
                            "The access attributes will default to none to indicate reservation is inaccessible.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "a9216049788e72f4182b91847f59a63dd476ba819dbb07d9dfa072504c8c9111",
                        "name": "Reserve",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in][optional] pointer to start of region to reserve. If nullptr then implementation will choose a start address.",
                                "name": "pStart",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] size in bytes to reserve; must be page aligned.",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[out] pointer to virtual reservation.",
                                "name": "pptr",
                                "type": "void**"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_SIZE": [
                                    "`0 == size`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xVirtualMem",
                        "decl": "static",
                        "desc": "Free pages in a reserved virtual address range.",
                        "details": [
                            "Any existing virtual mappings for the range will be unmapped.",
                            "Physical allocations objects that were mapped to this range will not be destroyed. These need to be destroyed explicitly.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "a7fee129027162635fb937d37429f1359a7ac34e03bb296b4c304dc926147771",
                        "name": "Free",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to start of region to free.",
                                "name": "ptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] size in bytes to free; must be page aligned.",
                                "name": "size",
                                "type": "size_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_SIZE": [
                                    "`0 == size`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xVirtualMem",
                        "decl": "static",
                        "desc": "Queries page size to use for aligning virtual memory reservations and physical memory allocations.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "797592efbb6fa316e5659e501c55e0f8c7459e921366c683633e74afc0ba2129",
                        "name": "QueryPageSize",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device object",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] unaligned allocation size in bytes",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[out] pointer to page size to use for start address and size alignments.",
                                "name": "pagesize",
                                "type": "size_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pagesize`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_SIZE": [
                                    "`0 == size`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xPhysicalMem",
                        "desc": "Supported physical memory creation flags",
                        "etors": [
                            {
                                "desc": "reserved for future use.",
                                "name": "$X_PHYSICAL_MEM_FLAG_TBD",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$x_physical_mem_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xPhysicalMem",
                        "desc": "Physical memory descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_PHYSICAL_MEM_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] creation flags.\nmust be 0 (default) or a valid combination of $x_physical_mem_flag_t.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_physical_mem_flags_t"
                            },
                            {
                                "desc": "[in] size in bytes to reserve; must be page aligned.",
                                "name": "size",
                                "type": "size_t"
                            }
                        ],
                        "name": "$x_physical_mem_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xPhysicalMem",
                        "decl": "static",
                        "desc": "Creates a physical memory object for the context.",
                        "details": [
                            "The application must only use the physical memory object on the context for which it was created.",
                            "The size must be page aligned. See $xVirtualMemQueryPageSize.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "3de3c1906550f4638327299921e87c8da20a0c90deb23b74806b8e38f093849c",
                        "name": "Create",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device object",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] pointer to physical memory descriptor.",
                                "name": "desc",
                                "type": "$x_physical_mem_desc_t*"
                            },
                            {
                                "desc": "[out] pointer to handle of physical memory object created",
                                "name": "phPhysicalMemory",
                                "type": "$x_physical_mem_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phPhysicalMemory`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x1 < desc->flags`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_SIZE": [
                                    "`0 == desc->size`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xPhysicalMem",
                        "decl": "static",
                        "desc": "Destroys a physical memory object.",
                        "details": [
                            "The application must ensure the device is not currently referencing the physical memory object before it is deleted",
                            "The application must **not** call this function from simultaneous threads with the same physical memory handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "0fccce8a4051a0e4fdc9e5e92d333ca3f493ba7e252afac6ae8f98734614f90f",
                        "name": "Destroy",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in][release] handle of physical memory object to destroy",
                                "name": "hPhysicalMemory",
                                "type": "$x_physical_mem_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hPhysicalMemory`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xVirtualMem",
                        "decl": "static",
                        "desc": "Maps pages in virtual address space to pages from physical memory object.",
                        "details": [
                            "The virtual address range must have been reserved using $xVirtualMemReserve.",
                            "The application must only use the mapped memory allocation on the context for which it was created.",
                            "The virtual start address and size must be page aligned. See $xVirtualMemQueryPageSize.",
                            "The application should use, for the starting address and size, the same size alignment used for the physical allocation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "6c2094655bab4890d0ef07d9e5b7e92dc48dc3f2ba18b68517c369adad3c58e9",
                        "name": "Map",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to start of virtual address range to map.",
                                "name": "ptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] size in bytes of virtual address range to map; must be page aligned.",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] handle to physical memory object.",
                                "name": "hPhysicalMemory",
                                "type": "$x_physical_mem_handle_t"
                            },
                            {
                                "desc": "[in] offset into physical memory allocation object; must be page aligned.",
                                "name": "offset",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] specifies page access attributes to apply to the virtual address range.",
                                "name": "access",
                                "type": "$x_memory_access_attribute_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hPhysicalMemory`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$X_MEMORY_ACCESS_ATTRIBUTE_READONLY < access`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_SIZE": [
                                    "`0 == size`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xVirtualMem",
                        "decl": "static",
                        "desc": "Unmaps pages in virtual address space from pages from a physical memory object.",
                        "details": [
                            "The page access attributes for virtual address range will revert back to none.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "742bd0bf1e65a4ea16e347ffad8506f2d55b406c4892fe841499d04124a7b60e",
                        "name": "Unmap",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to start of region to unmap.",
                                "name": "ptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] size in bytes to unmap; must be page aligned.",
                                "name": "size",
                                "type": "size_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": [
                                    "Address must be page aligned"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_SIZE": [
                                    "`0 == size`",
                                    "Size must be page aligned"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xVirtualMem",
                        "decl": "static",
                        "desc": "Set memory access attributes for a virtual address range.",
                        "details": [
                            "This function may be called from simultaneous threads with the same function handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "db21a82c9040758010176726f744e6cbe096eadc04091fd2d5a56da599954fca",
                        "name": "SetAccessAttribute",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to start of reserved virtual address region.",
                                "name": "ptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] size in bytes; must be page aligned.",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] specifies page access attributes to apply to the virtual address range.",
                                "name": "access",
                                "type": "$x_memory_access_attribute_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$X_MEMORY_ACCESS_ATTRIBUTE_READONLY < access`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": [
                                    "Address must be page aligned"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_SIZE": [
                                    "`0 == size`",
                                    "Size must be page aligned"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$xVirtualMem",
                        "decl": "static",
                        "desc": "Get memory access attribute for a virtual address range.",
                        "details": [
                            "If size and outSize are equal then the pages in the specified virtual address range have the same access attributes.",
                            "This function may be called from simultaneous threads with the same function handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "f0e84aa4b432103d1d37e611679e51aa6fd33d4d4dd01816b6554852dbc8264d",
                        "name": "GetAccessAttribute",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to start of virtual address region for query.",
                                "name": "ptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] size in bytes; must be page aligned.",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[out] query result for page access attribute.",
                                "name": "access",
                                "type": "$x_memory_access_attribute_t*"
                            },
                            {
                                "desc": "[out] query result for size of virtual address range, starting at ptr, that shares same access attribute.",
                                "name": "outSize",
                                "type": "size_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`",
                                    "`nullptr == access`",
                                    "`nullptr == outSize`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_ALIGNMENT": [
                                    "Address must be page aligned"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_SIZE": [
                                    "`0 == size`",
                                    "Size must be page aligned"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for virtual memory allocation",
                        "members": [],
                        "name": "$xVirtualMem",
                        "owner": "$xContext",
                        "type": "class"
                    },
                    {
                        "desc": "C++ wrapper for physical memory allocation",
                        "members": [
                            {
                                "desc": "[in] handle of physical memory object",
                                "name": "handle",
                                "type": "$x_physical_mem_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pContext",
                                "type": "$xContext*"
                            },
                            {
                                "desc": "[in] descriptor of the physical memory object",
                                "name": "desc",
                                "type": "$x_physical_mem_desc_t"
                            }
                        ],
                        "name": "$xPhysicalMem",
                        "owner": "$xContext",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for Floating-Point Atomics",
                    "ordinal": 1100,
                    "type": "header",
                    "version": "1.1"
                },
                "name": "floatAtomics",
                "objects": [
                    {
                        "desc": "Floating-Point Atomics Extension Name",
                        "name": "$X_FLOAT_ATOMICS_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_float_atomics\"",
                        "version": "1.1"
                    },
                    {
                        "desc": "Floating-Point Atomics Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_FLOAT_ATOMICS_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_FLOAT_ATOMICS_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_float_atomics_ext_version_t",
                        "type": "enum",
                        "version": "1.1"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Supported floating-point atomic capability flags",
                        "etors": [
                            {
                                "desc": "Supports atomic load, store, and exchange",
                                "name": "$X_DEVICE_FP_ATOMIC_EXT_FLAG_GLOBAL_LOAD_STORE",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Supports atomic add and subtract",
                                "name": "$X_DEVICE_FP_ATOMIC_EXT_FLAG_GLOBAL_ADD",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Supports atomic min and max",
                                "name": "$X_DEVICE_FP_ATOMIC_EXT_FLAG_GLOBAL_MIN_MAX",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "Supports atomic load, store, and exchange",
                                "name": "$X_DEVICE_FP_ATOMIC_EXT_FLAG_LOCAL_LOAD_STORE",
                                "value": "$X_BIT(16)"
                            },
                            {
                                "desc": "Supports atomic add and subtract",
                                "name": "$X_DEVICE_FP_ATOMIC_EXT_FLAG_LOCAL_ADD",
                                "value": "$X_BIT(17)"
                            },
                            {
                                "desc": "Supports atomic min and max",
                                "name": "$X_DEVICE_FP_ATOMIC_EXT_FLAG_LOCAL_MIN_MAX",
                                "value": "$X_BIT(18)"
                            }
                        ],
                        "name": "$x_device_fp_atomic_ext_flags_t",
                        "type": "enum",
                        "version": "1.1"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Device floating-point atomic properties queried using $xDeviceGetModuleProperties",
                        "details": [
                            "This structure may be returned from $xDeviceGetModuleProperties, via the `pNext` member of $x_device_module_properties_t."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_FLOAT_ATOMIC_EXT_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] Capabilities for half-precision floating-point atomic operations",
                                "name": "fp16Flags",
                                "type": "$x_device_fp_atomic_ext_flags_t"
                            },
                            {
                                "desc": "[out] Capabilities for single-precision floating-point atomic operations",
                                "name": "fp32Flags",
                                "type": "$x_device_fp_atomic_ext_flags_t"
                            },
                            {
                                "desc": "[out] Capabilities for double-precision floating-point atomic operations",
                                "name": "fp64Flags",
                                "type": "$x_device_fp_atomic_ext_flags_t"
                            }
                        ],
                        "name": "$x_float_atomic_ext_properties_t",
                        "type": "struct",
                        "version": "1.1"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for supporting kernel global work offset.",
                    "ordinal": 1100,
                    "type": "header",
                    "version": "1.1"
                },
                "name": "globaloffset",
                "objects": [
                    {
                        "desc": "Global Offset Extension Name",
                        "name": "$X_GLOBAL_OFFSET_EXP_NAME",
                        "type": "macro",
                        "value": "\"$X_experimental_global_offset\"",
                        "version": "1.1"
                    },
                    {
                        "desc": "Global Offset Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_GLOBAL_OFFSET_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_GLOBAL_OFFSET_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_global_offset_exp_version_t",
                        "type": "enum",
                        "version": "1.1"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Set global work offset for a kernel.",
                        "details": [
                            "The global work offset will be used when a $xCommandListAppendLaunchKernel() variant is called.",
                            "The application must **not** call this function from simultaneous threads with the same kernel handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "fa00f796d961e703ea19fdcf427500db930f497ba9902bd6df6371187c8cf785",
                        "name": "SetGlobalOffsetExp",
                        "params": [
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in] global offset for X dimension to use for this kernel",
                                "name": "offsetX",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] global offset for Y dimension to use for this kernel",
                                "name": "offsetY",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] global offset for Z dimension to use for this kernel",
                                "name": "offsetZ",
                                "type": "uint32_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.1"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for supporting relaxed allocation limits.",
                    "ordinal": 1100,
                    "type": "header",
                    "version": "1.1"
                },
                "name": "relaxedAllocLimits",
                "objects": [
                    {
                        "desc": "Relaxed Allocation Limits Extension Name",
                        "name": "$X_RELAXED_ALLOCATION_LIMITS_EXP_NAME",
                        "type": "macro",
                        "value": "\"$X_experimental_relaxed_allocation_limits\"",
                        "version": "1.1"
                    },
                    {
                        "desc": "Relaxed Allocation Limits Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_RELAXED_ALLOCATION_LIMITS_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_RELAXED_ALLOCATION_LIMITS_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_relaxed_allocation_limits_exp_version_t",
                        "type": "enum",
                        "version": "1.1"
                    },
                    {
                        "class": "$xMem",
                        "desc": "Supported relaxed memory allocation flags",
                        "etors": [
                            {
                                "desc": "Allocation size may exceed the `maxMemAllocSize` member of $x_device_properties_t.",
                                "name": "$X_RELAXED_ALLOCATION_LIMITS_EXP_FLAG_MAX_SIZE",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$x_relaxed_allocation_limits_exp_flags_t",
                        "type": "enum",
                        "version": "1.1"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xMem",
                        "desc": "Relaxed limits memory allocation descriptor",
                        "details": [
                            "This structure may be passed to $xMemAllocShared or $xMemAllocDevice, via the `pNext` member of $x_device_mem_alloc_desc_t.",
                            "This structure may also be passed to $xMemAllocHost, via the `pNext` member of $x_host_mem_alloc_desc_t."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_RELAXED_ALLOCATION_LIMITS_EXP_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] flags specifying allocation limits to relax.\nmust be 0 (default) or a valid combination of $x_relaxed_allocation_limits_exp_flag_t;\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_relaxed_allocation_limits_exp_flags_t"
                            }
                        ],
                        "name": "$x_relaxed_allocation_limits_exp_desc_t",
                        "type": "struct",
                        "version": "1.1"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for Cache Reservation",
                    "ordinal": 1200,
                    "type": "header",
                    "version": "1.2"
                },
                "name": "cacheReservation",
                "objects": [
                    {
                        "desc": "Cache_Reservation Extension Name",
                        "name": "$X_CACHE_RESERVATION_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_cache_reservation\"",
                        "version": "1.2"
                    },
                    {
                        "desc": "Cache_Reservation Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_CACHE_RESERVATION_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_CACHE_RESERVATION_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_cache_reservation_ext_version_t",
                        "type": "enum",
                        "version": "1.2"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Cache Reservation Region",
                        "etors": [
                            {
                                "desc": "[DEPRECATED] utilize driver default scheme. Use $X_CACHE_EXT_REGION_DEFAULT.",
                                "name": "$X_CACHE_EXT_REGION_$X_CACHE_REGION_DEFAULT",
                                "value": "0"
                            },
                            {
                                "desc": "[DEPRECATED] utilize reserved region. Use $X_CACHE_EXT_REGION_RESERVED.",
                                "name": "$X_CACHE_EXT_REGION_$X_CACHE_RESERVE_REGION",
                                "value": "1"
                            },
                            {
                                "desc": "[DEPRECATED] utilize non-reserverd region. Use $X_CACHE_EXT_REGION_NON_RESERVED.",
                                "name": "$X_CACHE_EXT_REGION_$X_CACHE_NON_RESERVED_REGION",
                                "value": "2"
                            },
                            {
                                "desc": "utilize driver default scheme",
                                "name": "$X_CACHE_EXT_REGION_DEFAULT",
                                "value": "0",
                                "version": "1.7"
                            },
                            {
                                "desc": "utilize reserved region",
                                "name": "$X_CACHE_EXT_REGION_RESERVED",
                                "value": "1",
                                "version": "1.7"
                            },
                            {
                                "desc": "utilize non-reserverd region",
                                "name": "$X_CACHE_EXT_REGION_NON_RESERVED",
                                "value": "2",
                                "version": "1.7"
                            }
                        ],
                        "name": "$x_cache_ext_region_t",
                        "type": "enum",
                        "version": "1.2"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xDevice",
                        "desc": "CacheReservation structure",
                        "details": [
                            "This structure must be passed to $xDeviceGetCacheProperties via the `pNext` member of $x_device_cache_properties_t",
                            "Used for determining the max cache reservation allowed on device. Size of zero means no reservation available."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_CACHE_RESERVATION_EXT_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] max cache reservation size",
                                "name": "maxCacheReservationSize",
                                "type": "size_t"
                            }
                        ],
                        "name": "$x_cache_reservation_ext_desc_t",
                        "type": "struct",
                        "version": "1.2"
                    },
                    {
                        "analogue": [
                            "None"
                        ],
                        "class": "$xDevice",
                        "decl": "static",
                        "desc": "Reserve Cache on Device",
                        "details": [
                            "The application may call this function but may not be successful as some other application may have reserve prior"
                        ],
                        "hash": "c490e6bf5354109695b33536ac7b380214713bbf13b772512d880dd17781417b",
                        "name": "ReserveCacheExt",
                        "params": [
                            {
                                "desc": "[in] handle of the device object",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] cache level where application want to reserve. If zero, then the driver shall default to last level of cache and attempt to reserve in that cache.",
                                "name": "cacheLevel",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] value for reserving size, in bytes. If zero, then the driver shall remove prior reservation",
                                "name": "cacheReservationSize",
                                "type": "size_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.2"
                    },
                    {
                        "class": "$xDevice",
                        "decl": "static",
                        "desc": "Assign VA section to use reserved section",
                        "details": [
                            "The application may call this function to assign VA to particular reservartion region"
                        ],
                        "hash": "c076c37bb4879633219acc29a0bda1fe2d289b5da21655ae9da5d8a21b0e00e0",
                        "name": "SetCacheAdviceExt",
                        "params": [
                            {
                                "desc": "[in] handle of the device object",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] memory pointer to query",
                                "name": "ptr",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] region size, in pages",
                                "name": "regionSize",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] reservation region",
                                "name": "cacheRegion",
                                "type": "$x_cache_ext_region_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == ptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$X_CACHE_EXT_REGION_NON_RESERVED < cacheRegion`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.2"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for supporting event query timestamps.",
                    "ordinal": 1200,
                    "type": "header",
                    "version": "1.2"
                },
                "name": "eventquerytimestamps",
                "objects": [
                    {
                        "desc": "Event Query Timestamps Extension Name",
                        "name": "$X_EVENT_QUERY_TIMESTAMPS_EXP_NAME",
                        "type": "macro",
                        "value": "\"$X_experimental_event_query_timestamps\"",
                        "version": "1.2"
                    },
                    {
                        "desc": "Event Query Timestamps Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_EVENT_QUERY_TIMESTAMPS_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_EVENT_QUERY_TIMESTAMPS_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_event_query_timestamps_exp_version_t",
                        "type": "enum",
                        "version": "1.2"
                    },
                    {
                        "analogue": [
                            "None"
                        ],
                        "class": "$xEvent",
                        "decl": "static",
                        "desc": "Query event timestamps for a device or sub-device.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe.",
                            "The implementation must support $X_experimental_event_query_timestamps.",
                            "The implementation must return all timestamps for the specified event and device pair.",
                            "The implementation must return all timestamps for all sub-devices when device handle is parent device.",
                            "The implementation may return all timestamps for sub-devices when device handle is sub-device or may return 0 for count."
                        ],
                        "hash": "d82c2f32f452c9fff17b3a5272be146346fc845655fd7e4567a55514b33343bc",
                        "name": "QueryTimestampsExp",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the event",
                                "name": "hEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device to query",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of timestamp results.\nif count is zero, then the driver shall update the value with the total number of timestamps available.\nif count is greater than the number of timestamps available, then the driver shall update the value with the correct number of timestamps available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of timestamp results.\nif count is less than the number of timestamps available, then driver shall only retrieve that number of timestamps.",
                                "name": "pTimestamps",
                                "type": "$x_kernel_timestamp_result_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEvent`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.2"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for supporting image memory properties.",
                    "ordinal": 1200,
                    "type": "header",
                    "version": "1.2"
                },
                "name": "imagememoryproperties",
                "objects": [
                    {
                        "desc": "Image Memory Properties Extension Name",
                        "name": "$X_IMAGE_MEMORY_PROPERTIES_EXP_NAME",
                        "type": "macro",
                        "value": "\"$X_experimental_image_memory_properties\"",
                        "version": "1.2"
                    },
                    {
                        "desc": "Image Memory Properties Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_IMAGE_MEMORY_PROPERTIES_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_IMAGE_MEMORY_PROPERTIES_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_image_memory_properties_exp_version_t",
                        "type": "enum",
                        "version": "1.2"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xImage",
                        "desc": "Image memory properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_IMAGE_MEMORY_PROPERTIES_EXP",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] size of image allocation in bytes.",
                                "name": "size",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] size of image row in bytes.",
                                "name": "rowPitch",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] size of image slice in bytes.",
                                "name": "slicePitch",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$x_image_memory_properties_exp_t",
                        "type": "struct",
                        "version": "1.2"
                    },
                    {
                        "analogue": [
                            "None"
                        ],
                        "class": "$xImage",
                        "decl": "static",
                        "desc": "Query image memory properties.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe.",
                            "The implementation must support $X_experimental_image_memory_properties extension."
                        ],
                        "hash": "573043a1d9ef253c5802bfac3cdf26568142e4e0748351fc4cd7a6a4cfc4856a",
                        "name": "GetMemoryPropertiesExp",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of image object",
                                "name": "hImage",
                                "type": "$x_image_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for image memory properties.",
                                "name": "pMemoryProperties",
                                "type": "$x_image_memory_properties_exp_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hImage`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pMemoryProperties`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.2"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for supporting image views.",
                    "ordinal": 1200,
                    "type": "header",
                    "version": "1.2"
                },
                "name": "imageview",
                "objects": [
                    {
                        "desc": "Image View Extension Name",
                        "name": "$X_IMAGE_VIEW_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_image_view\"",
                        "version": "1.5"
                    },
                    {
                        "desc": "Image View Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_IMAGE_VIEW_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_IMAGE_VIEW_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_image_view_ext_version_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "analogue": [
                            "None"
                        ],
                        "class": "$xImage",
                        "decl": "static",
                        "desc": "Create image view on the context.",
                        "details": [
                            "The application must only use the image view for the device, or its sub-devices, which was provided during creation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe.",
                            "The implementation must support $X_extension_image_view extension.",
                            "Image views are treated as images from the API.",
                            "Image views provide a mechanism to redescribe how an image is interpreted (e.g. different format).",
                            "Image views become disabled when their corresponding image resource is destroyed.",
                            "Use $xImageDestroy to destroy image view objects."
                        ],
                        "hash": "32d72203dc99f10d2d5a31ec2905a7b10ca523c1c0cd07a2cd5ea03ef489ec35",
                        "name": "ViewCreateExt",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] pointer to image descriptor",
                                "name": "desc",
                                "type": "const $x_image_desc_t*"
                            },
                            {
                                "desc": "[in] handle of image object to create view from",
                                "name": "hImage",
                                "type": "$x_image_handle_t"
                            },
                            {
                                "desc": "[out] pointer to handle of image object created for view",
                                "name": "phImageView",
                                "type": "$x_image_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`",
                                    "`nullptr == hImage`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phImageView`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x3 < desc->flags`",
                                    "`$X_IMAGE_TYPE_BUFFER < desc->type`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT": []
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "desc": "Image View Extension Name",
                        "name": "$X_IMAGE_VIEW_EXP_NAME",
                        "type": "macro",
                        "value": "\"$X_experimental_image_view\"",
                        "version": "1.2"
                    },
                    {
                        "desc": "Image View Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_IMAGE_VIEW_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_IMAGE_VIEW_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_image_view_exp_version_t",
                        "type": "enum",
                        "version": "1.2"
                    },
                    {
                        "analogue": [
                            "None"
                        ],
                        "class": "$xImage",
                        "decl": "static",
                        "desc": "Create image view on the context.",
                        "details": [
                            "The application must only use the image view for the device, or its sub-devices, which was provided during creation.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe.",
                            "The implementation must support $X_experimental_image_view extension.",
                            "Image views are treated as images from the API.",
                            "Image views provide a mechanism to redescribe how an image is interpreted (e.g. different format).",
                            "Image views become disabled when their corresponding image resource is destroyed.",
                            "Use $xImageDestroy to destroy image view objects.",
                            "Note: This function is deprecated and replaced by $xImageViewCreateExt."
                        ],
                        "hash": "5fa8627a9e4828cd94d2b51124c3c538f44a677552dd0358bf7d53a84b0c25ac",
                        "name": "ViewCreateExp",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in] pointer to image descriptor",
                                "name": "desc",
                                "type": "const $x_image_desc_t*"
                            },
                            {
                                "desc": "[in] handle of image object to create view from",
                                "name": "hImage",
                                "type": "$x_image_handle_t"
                            },
                            {
                                "desc": "[out] pointer to handle of image object created for view",
                                "name": "phImageView",
                                "type": "$x_image_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`",
                                    "`nullptr == hImage`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phImageView`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x3 < desc->flags`",
                                    "`$X_IMAGE_TYPE_BUFFER < desc->type`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT": []
                            }
                        ],
                        "type": "function",
                        "version": "1.2"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for supporting image views for planar images.",
                    "ordinal": 1200,
                    "type": "header",
                    "version": "1.2"
                },
                "name": "imageviewplanar",
                "objects": [
                    {
                        "desc": "Image View Planar Extension Name",
                        "name": "$X_IMAGE_VIEW_PLANAR_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_image_view_planar\"",
                        "version": "1.5"
                    },
                    {
                        "desc": "Image View Planar Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_IMAGE_VIEW_PLANAR_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_IMAGE_VIEW_PLANAR_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_image_view_planar_ext_version_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xImage",
                        "desc": "Image view planar descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_IMAGE_VIEW_PLANAR_EXT_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] the 0-based plane index (e.g. NV12 is 0 = Y plane, 1 UV plane)",
                                "name": "planeIndex",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_image_view_planar_ext_desc_t",
                        "type": "struct",
                        "version": "1.5"
                    },
                    {
                        "desc": "Image View Planar Extension Name",
                        "name": "$X_IMAGE_VIEW_PLANAR_EXP_NAME",
                        "type": "macro",
                        "value": "\"$X_experimental_image_view_planar\"",
                        "version": "1.2"
                    },
                    {
                        "desc": "Image View Planar Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_IMAGE_VIEW_PLANAR_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_IMAGE_VIEW_PLANAR_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_image_view_planar_exp_version_t",
                        "type": "enum",
                        "version": "1.2"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xImage",
                        "desc": "Image view planar descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_IMAGE_VIEW_PLANAR_EXP_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] the 0-based plane index (e.g. NV12 is 0 = Y plane, 1 UV plane)",
                                "name": "planeIndex",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_image_view_planar_exp_desc_t",
                        "type": "struct",
                        "version": "1.2"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for specifying kernel scheduling hints.",
                    "ordinal": 1200,
                    "type": "header",
                    "version": "1.2"
                },
                "name": "kernelSchedulingHints",
                "objects": [
                    {
                        "desc": "Kernel Scheduling Hints Extension Name",
                        "name": "$X_KERNEL_SCHEDULING_HINTS_EXP_NAME",
                        "type": "macro",
                        "value": "\"$X_experimental_scheduling_hints\"",
                        "version": "1.2"
                    },
                    {
                        "desc": "Kernel Scheduling Hints Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_SCHEDULING_HINTS_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_SCHEDULING_HINTS_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_scheduling_hints_exp_version_t",
                        "type": "enum",
                        "version": "1.2"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Supported kernel scheduling hint flags",
                        "etors": [
                            {
                                "desc": "Hint that the kernel prefers oldest-first scheduling",
                                "name": "$X_SCHEDULING_HINT_EXP_FLAG_OLDEST_FIRST",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Hint that the kernel prefers round-robin scheduling",
                                "name": "$X_SCHEDULING_HINT_EXP_FLAG_ROUND_ROBIN",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Hint that the kernel prefers stall-based round-robin scheduling",
                                "name": "$X_SCHEDULING_HINT_EXP_FLAG_STALL_BASED_ROUND_ROBIN",
                                "value": "$X_BIT(2)"
                            }
                        ],
                        "name": "$x_scheduling_hint_exp_flags_t",
                        "type": "enum",
                        "version": "1.2"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Device kernel scheduling hint properties queried using $xDeviceGetModuleProperties",
                        "details": [
                            "This structure may be returned from $xDeviceGetModuleProperties, via the `pNext` member of $x_device_module_properties_t."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_SCHEDULING_HINT_EXP_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] Supported kernel scheduling hints.\nMay be 0 (none) or a valid combination of $x_scheduling_hint_exp_flag_t.\n",
                                "name": "schedulingHintFlags",
                                "type": "$x_scheduling_hint_exp_flags_t"
                            }
                        ],
                        "name": "$x_scheduling_hint_exp_properties_t",
                        "type": "struct",
                        "version": "1.2"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xKernel",
                        "desc": "Kernel scheduling hint descriptor",
                        "details": [
                            "This structure may be passed to $xKernelSchedulingHintExp."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_SCHEDULING_HINT_EXP_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] flags specifying kernel scheduling hints.\nmust be 0 (default) or a valid combination of $x_scheduling_hint_exp_flag_t.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_scheduling_hint_exp_flags_t"
                            }
                        ],
                        "name": "$x_scheduling_hint_exp_desc_t",
                        "type": "struct",
                        "version": "1.2"
                    },
                    {
                        "class": "$xKernel",
                        "desc": "Provide kernel scheduling hints that may improve performance",
                        "details": [
                            "The scheduling hints may improve performance only and are not required for correctness.",
                            "If a specified scheduling hint is unsupported it will be silently ignored.",
                            "If two conflicting scheduling hints are specified there is no defined behavior;\nthe hints may be ignored or one hint may be chosen arbitrarily.\n",
                            "The application must not call this function from simultaneous threads with the same kernel handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "110b8a3075cc45ff59fe652e291c497f8b213359b3a8ede04e6b64701f778c93",
                        "name": "SchedulingHintExp",
                        "params": [
                            {
                                "desc": "[in] handle of the kernel object",
                                "name": "hKernel",
                                "type": "$x_kernel_handle_t"
                            },
                            {
                                "desc": "[in] pointer to kernel scheduling hint descriptor",
                                "name": "pHint",
                                "type": "$x_scheduling_hint_exp_desc_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pHint`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x7 < pHint->flags`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.2"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for One-Definition-Rule Linkage Types",
                    "ordinal": 1200,
                    "type": "header",
                    "version": "1.2"
                },
                "name": "linkonceodr",
                "objects": [
                    {
                        "desc": "Linkonce ODR Extension Name",
                        "name": "$X_LINKONCE_ODR_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_linkonce_odr\"",
                        "version": "1.2"
                    },
                    {
                        "desc": "Linkonce ODR Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_LINKONCE_ODR_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_LINKONCE_ODR_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_linkonce_odr_ext_version_t",
                        "type": "enum",
                        "version": "1.2"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for supporting power saving hint.",
                    "ordinal": 1200,
                    "type": "header",
                    "version": "1.2"
                },
                "name": "powersavinghint",
                "objects": [
                    {
                        "desc": "Power Saving Hint Extension Name",
                        "name": "$X_CONTEXT_POWER_SAVING_HINT_EXP_NAME",
                        "type": "macro",
                        "value": "\"$X_experimental_power_saving_hint\"",
                        "version": "1.2"
                    },
                    {
                        "desc": "Power Saving Hint Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_POWER_SAVING_HINT_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_POWER_SAVING_HINT_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_power_saving_hint_exp_version_t",
                        "type": "enum",
                        "version": "1.2"
                    },
                    {
                        "class": "$xContext",
                        "desc": "Supported device types",
                        "etors": [
                            {
                                "desc": "Minumum power savings. The device will make no attempt to save power while executing work submitted to this context.",
                                "name": "$X_POWER_SAVING_HINT_TYPE_MIN",
                                "value": "0"
                            },
                            {
                                "desc": "Maximum power savings. The device will do everything to bring power to a minimum while executing work submitted to this context.",
                                "name": "$X_POWER_SAVING_HINT_TYPE_MAX",
                                "value": "100"
                            }
                        ],
                        "name": "$x_power_saving_hint_type_t",
                        "type": "enum",
                        "version": "1.2"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xContext",
                        "desc": "Extended context descriptor containing power saving hint.",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_CONTEXT_POWER_SAVING_HINT_EXP_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] power saving hint (default value = 0). This is value from [0,100] and can use pre-defined settings from $x_power_saving_hint_type_t.\n",
                                "init": "0",
                                "name": "hint",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_context_power_saving_hint_exp_desc_t",
                        "type": "struct",
                        "version": "1.2"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for Subgroups",
                    "ordinal": 1200,
                    "type": "header",
                    "version": "1.2"
                },
                "name": "subgroups",
                "objects": [
                    {
                        "desc": "Subgroups Extension Name",
                        "name": "$X_SUBGROUPS_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_subgroups\"",
                        "version": "1.2"
                    },
                    {
                        "desc": "Subgroups Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_SUBGROUP_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_SUBGROUP_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_subgroup_ext_version_t",
                        "type": "enum",
                        "version": "1.2"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for EU Count",
                    "ordinal": 1300,
                    "type": "header",
                    "version": "1.3"
                },
                "name": "EUCount",
                "objects": [
                    {
                        "desc": "EU Count Extension Name",
                        "name": "$X_EU_COUNT_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_eu_count\"",
                        "version": "1.3"
                    },
                    {
                        "desc": "EU Count Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_EU_COUNT_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_EU_COUNT_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_eu_count_ext_version_t",
                        "type": "enum",
                        "version": "1.3"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xDevice",
                        "desc": "EU count queried using $xDeviceGetProperties",
                        "details": [
                            "This structure may be returned from $xDeviceGetProperties via the `pNext` member of $x_device_properties_t.",
                            "Used for determining the total number of EUs available on device."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_EU_COUNT_EXT",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] Total number of EUs available",
                                "name": "numTotalEUs",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_eu_count_ext_t",
                        "type": "struct",
                        "version": "1.3"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for PCI Properties",
                    "ordinal": 1300,
                    "type": "header",
                    "version": "1.3"
                },
                "name": "PCIProperties",
                "objects": [
                    {
                        "desc": "PCI Properties Extension Name",
                        "name": "$X_PCI_PROPERTIES_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_pci_properties\"",
                        "version": "1.3"
                    },
                    {
                        "desc": "PCI Properties Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_PCI_PROPERTIES_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_PCI_PROPERTIES_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_pci_properties_ext_version_t",
                        "type": "enum",
                        "version": "1.3"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Device PCI address",
                        "details": [
                            "This structure may be passed to $xDevicePciGetPropertiesExt as an attribute of $x_pci_ext_properties_t.",
                            "A PCI BDF address is the bus:device:function address of the device and is useful for locating the device in the PCI switch fabric."
                        ],
                        "members": [
                            {
                                "desc": "[out] PCI domain number",
                                "name": "domain",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] PCI BDF bus number",
                                "name": "bus",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] PCI BDF device number",
                                "name": "device",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] PCI BDF function number",
                                "name": "function",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_pci_address_ext_t",
                        "type": "struct",
                        "version": "1.3"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Device PCI speed",
                        "members": [
                            {
                                "desc": "[out] The link generation. A value of -1 means that this property is unknown.",
                                "name": "genVersion",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[out] The number of lanes. A value of -1 means that this property is unknown.",
                                "name": "width",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[out] The theoretical maximum bandwidth in bytes/sec (sum of all lanes). A value of -1 means that this property is unknown.",
                                "name": "maxBandwidth",
                                "type": "int64_t"
                            }
                        ],
                        "name": "$x_pci_speed_ext_t",
                        "type": "struct",
                        "version": "1.3"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Static PCI properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_PCI_EXT_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] The BDF address",
                                "name": "address",
                                "type": "$x_pci_address_ext_t"
                            },
                            {
                                "desc": "[out] Fastest port configuration supported by the device (sum of all lanes)",
                                "name": "maxSpeed",
                                "type": "$x_pci_speed_ext_t"
                            }
                        ],
                        "name": "$x_pci_ext_properties_t",
                        "type": "struct"
                    },
                    {
                        "analogue": [
                            "None"
                        ],
                        "class": "$xDevice",
                        "decl": "static",
                        "desc": "Get PCI properties - address, max speed",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "44e9f8dd96a5b149313aec8d704fc3335e63766d2449fa074376ecd43a46def8",
                        "name": "PciGetPropertiesExt",
                        "params": [
                            {
                                "desc": "[in] handle of the device object.",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] returns the PCI properties of the device.",
                                "name": "pPciProperties",
                                "type": "$x_pci_ext_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pPciProperties`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.3"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for sRGB",
                    "ordinal": 1300,
                    "type": "header",
                    "version": "1.3"
                },
                "name": "SRGB",
                "objects": [
                    {
                        "desc": "sRGB Extension Name",
                        "name": "$X_SRGB_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_srgb\"",
                        "version": "1.3"
                    },
                    {
                        "desc": "sRGB Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_SRGB_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_SRGB_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_srgb_ext_version_t",
                        "type": "enum",
                        "version": "1.3"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xImage",
                        "desc": "sRGB image descriptor",
                        "details": [
                            "This structure may be passed to $xImageCreate via the `pNext` member of $x_image_desc_t",
                            "Used for specifying that the image is in sRGB format."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_SRGB_EXT_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] Is sRGB.",
                                "name": "sRGB",
                                "type": "ze_bool_t"
                            }
                        ],
                        "name": "$x_srgb_ext_desc_t",
                        "type": "struct",
                        "version": "1.3"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for Image Copy To/From Memory",
                    "ordinal": 1300,
                    "type": "header",
                    "version": "1.3"
                },
                "name": "imageCopy",
                "objects": [
                    {
                        "desc": "Image Copy Extension Name",
                        "name": "$X_IMAGE_COPY_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_image_copy\"",
                        "version": "1.3"
                    },
                    {
                        "desc": "Image Copy Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_IMAGE_COPY_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_IMAGE_COPY_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_image_copy_ext_version_t",
                        "type": "enum",
                        "version": "1.3"
                    },
                    {
                        "analogue": [
                            "clEnqueueReadImage"
                        ],
                        "class": "$xCommandList",
                        "desc": "Copies from an image to device or shared memory.",
                        "details": [
                            "The application must ensure the memory pointed to by dstptr is accessible by the device on which the command list was created.",
                            "The implementation must not access the memory pointed to by dstptr as it is free to be modified by either the Host or device up until execution.",
                            "The application must ensure the image and events are accessible by the device on which the command list was created.",
                            "The application must ensure the image format descriptor for the source image is a single-planar format.",
                            "The application must ensure that the rowPitch is set to 0 if image is a 1D image. Otherwise the rowPitch must be greater than or equal to the element size in bytes x width.",
                            "If rowPitch is set to 0, the appropriate row pitch is calculated based on the size of each element in bytes multiplied by width",
                            "The application must ensure that the slicePitch is set to 0 if image is a 1D or 2D image. Otherwise this value must be greater than or equal to rowPitch x height.",
                            "If slicePitch is set to 0, the appropriate slice pitch is calculated based on the rowPitch x height.",
                            "The application must ensure the command list, image and events were created, and the memory was allocated, on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "4617cd10fe0fef8e74a0917d936ab8ebe8cb9dd0b2b07c389fff02bf2f560cb2",
                        "name": "AppendImageCopyToMemoryExt",
                        "params": [
                            {
                                "desc": "[in] handle of command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] pointer to destination memory to copy to",
                                "name": "dstptr",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] handle of source image to copy from",
                                "name": "hSrcImage",
                                "type": "$x_image_handle_t"
                            },
                            {
                                "desc": "[in][optional] source region descriptor",
                                "name": "pSrcRegion",
                                "type": "const $x_image_region_t*"
                            },
                            {
                                "desc": "[in] size in bytes of the 1D slice of the 2D region of a 2D or 3D image or each image of a 1D or 2D image array being written",
                                "name": "destRowPitch",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] size in bytes of the 2D slice of the 3D region of a 3D image or each image of a 1D or 2D image array being written",
                                "name": "destSlicePitch",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hSrcImage`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == dstptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.3"
                    },
                    {
                        "analogue": [
                            "clEnqueueWriteImage"
                        ],
                        "class": "$xCommandList",
                        "desc": "Copies to an image from device or shared memory.",
                        "details": [
                            "The application must ensure the memory pointed to by srcptr is accessible by the device on which the command list was created.",
                            "The implementation must not access the memory pointed to by srcptr as it is free to be modified by either the Host or device up until execution.",
                            "The application must ensure the image and events are accessible by the device on which the command list was created.",
                            "The application must ensure the image format descriptor for the destination image is a single-planar format.",
                            "The application must ensure that the rowPitch is set to 0 if image is a 1D image. Otherwise the rowPitch must be greater than or equal to the element size in bytes x width.",
                            "If rowPitch is set to 0, the appropriate row pitch is calculated based on the size of each element in bytes multiplied by width",
                            "The application must ensure that the slicePitch is set to 0 if image is a 1D or 2D image. Otherwise this value must be greater than or equal to rowPitch x height.",
                            "If slicePitch is set to 0, the appropriate slice pitch is calculated based on the rowPitch x height.",
                            "The application must ensure the command list, image and events were created, and the memory was allocated, on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "428b2da065561bcb61dbc49bdbb0b4efc20aa473a76b1c3f2b149009c6b9678a",
                        "name": "AppendImageCopyFromMemoryExt",
                        "params": [
                            {
                                "desc": "[in] handle of command list",
                                "name": "hCommandList",
                                "type": "$x_command_list_handle_t"
                            },
                            {
                                "desc": "[in] handle of destination image to copy to",
                                "name": "hDstImage",
                                "type": "$x_image_handle_t"
                            },
                            {
                                "desc": "[in] pointer to source memory to copy from",
                                "name": "srcptr",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in][optional] destination region descriptor",
                                "name": "pDstRegion",
                                "type": "const $x_image_region_t*"
                            },
                            {
                                "desc": "[in] size in bytes of the 1D slice of the 2D region of a 2D or 3D image or each image of a 1D or 2D image array being read",
                                "name": "srcRowPitch",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] size in bytes of the 2D slice of the 3D region of a 3D image or each image of a 1D or 2D image array being read",
                                "name": "srcSlicePitch",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in][optional] number of events to wait on before launching; must be 0 if `nullptr == phWaitEvents`",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hDstImage`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == srcptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.3"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for Querying Image Allocation Properties.",
                    "ordinal": 1300,
                    "type": "header",
                    "version": "1.3"
                },
                "name": "imageQueryAllocProperties",
                "objects": [
                    {
                        "desc": "Image Query Allocation Properties Extension Name",
                        "name": "$X_IMAGE_QUERY_ALLOC_PROPERTIES_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_image_query_alloc_properties\"",
                        "version": "1.3"
                    },
                    {
                        "desc": "Image Query Allocation Properties Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_IMAGE_QUERY_ALLOC_PROPERTIES_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_IMAGE_QUERY_ALLOC_PROPERTIES_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_image_query_alloc_properties_ext_version_t",
                        "type": "enum",
                        "version": "1.3"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xImage",
                        "desc": "Image allocation properties queried using $xImageGetAllocPropertiesExt",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_IMAGE_ALLOCATION_EXT_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] identifier for this allocation",
                                "name": "id",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$x_image_allocation_ext_properties_t",
                        "type": "struct",
                        "version": "1.3"
                    },
                    {
                        "class": "$xImage",
                        "decl": "static",
                        "desc": "Retrieves attributes of an image allocation",
                        "details": [
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "dcc53f74863a6355f6486f556dc2c973c0e7519afd59371a5917b491e378f8ff",
                        "name": "GetAllocPropertiesExt",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of image object to query",
                                "name": "hImage",
                                "type": "$x_image_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for image allocation properties",
                                "name": "pImageAllocProperties",
                                "type": "$x_image_allocation_ext_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hImage`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pImageAllocProperties`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.3"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for Linkage Inspection",
                    "ordinal": 1300,
                    "type": "header",
                    "version": "1.3"
                },
                "name": "linkageInspection",
                "objects": [
                    {
                        "desc": "Linkage Inspection Extension Name",
                        "name": "$X_LINKAGE_INSPECTION_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_linkage_inspection\"",
                        "version": "1.3"
                    },
                    {
                        "desc": "Linkage Inspection Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_LINKAGE_INSPECTION_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_LINKAGE_INSPECTION_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_linkage_inspection_ext_version_t",
                        "type": "enum",
                        "version": "1.3"
                    },
                    {
                        "class": "$xModule",
                        "desc": "Supported module linkage inspection flags",
                        "etors": [
                            {
                                "desc": "List all imports of modules",
                                "name": "$X_LINKAGE_INSPECTION_EXT_FLAG_IMPORTS",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "List all imports of modules that do not have a corresponding export",
                                "name": "$X_LINKAGE_INSPECTION_EXT_FLAG_UNRESOLVABLE_IMPORTS",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "List all exports of modules",
                                "name": "$X_LINKAGE_INSPECTION_EXT_FLAG_EXPORTS",
                                "value": "$X_BIT(2)"
                            }
                        ],
                        "name": "$x_linkage_inspection_ext_flags_t",
                        "type": "enum",
                        "version": "1.3"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xModule",
                        "desc": "Module linkage inspection descriptor",
                        "details": [
                            "This structure may be passed to $xModuleInspectLinkageExt."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_LINKAGE_INSPECTION_EXT_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] flags specifying module linkage inspection.\nmust be 0 (default) or a valid combination of $x_linkage_inspection_ext_flag_t.\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_linkage_inspection_ext_flags_t"
                            }
                        ],
                        "name": "$x_linkage_inspection_ext_desc_t",
                        "type": "struct",
                        "version": "1.3"
                    },
                    {
                        "analogue": [
                            "None"
                        ],
                        "class": "$xModule",
                        "decl": "static",
                        "desc": "List Imports & Exports",
                        "details": [
                            "List all the import & unresolveable import dependencies & exports of a set of modules"
                        ],
                        "hash": "4a77c63603dfa3295f8a24068e27b55c8f35aec421582f4ec1d313e101578aee",
                        "name": "InspectLinkageExt",
                        "params": [
                            {
                                "desc": "[in] pointer to linkage inspection descriptor structure.",
                                "name": "pInspectDesc",
                                "type": "$x_linkage_inspection_ext_desc_t*"
                            },
                            {
                                "desc": "[in] number of modules to be inspected pointed to by phModules.",
                                "name": "numModules",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][range(0, numModules)] pointer to an array of modules to be inspected for import dependencies.",
                                "name": "phModules",
                                "type": "$x_module_handle_t*"
                            },
                            {
                                "desc": "[out] pointer to handle of linkage inspection log. Log object will contain separate lists of imports, un-resolvable imports, and exports.",
                                "name": "phLog",
                                "type": "$x_module_build_log_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pInspectDesc`",
                                    "`nullptr == phModules`",
                                    "`nullptr == phLog`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x7 < pInspectDesc->flags`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.3"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for supporting memory compression hints.",
                    "ordinal": 1300,
                    "type": "header",
                    "version": "1.3"
                },
                "name": "memoryCompressionHints",
                "objects": [
                    {
                        "desc": "Memory Compression Hints Extension Name",
                        "name": "$X_MEMORY_COMPRESSION_HINTS_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_memory_compression_hints\"",
                        "version": "1.3"
                    },
                    {
                        "desc": "Memory Compression Hints Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_MEMORY_COMPRESSION_HINTS_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_MEMORY_COMPRESSION_HINTS_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_memory_compression_hints_ext_version_t",
                        "type": "enum",
                        "version": "1.3"
                    },
                    {
                        "class": "$xMem",
                        "desc": "Supported memory compression hints flags",
                        "etors": [
                            {
                                "desc": "Hint Driver implementation to make allocation compressible",
                                "name": "$X_MEMORY_COMPRESSION_HINTS_EXT_FLAG_COMPRESSED",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Hint Driver implementation to make allocation not compressible",
                                "name": "$X_MEMORY_COMPRESSION_HINTS_EXT_FLAG_UNCOMPRESSED",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$x_memory_compression_hints_ext_flags_t",
                        "type": "enum",
                        "version": "1.3"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xMem",
                        "desc": "Compression hints memory allocation descriptor",
                        "details": [
                            "This structure may be passed to $xMemAllocShared or $xMemAllocDevice, via the `pNext` member of $x_device_mem_alloc_desc_t.",
                            "This structure may be passed to $xMemAllocHost, via the `pNext` member of $x_host_mem_alloc_desc_t.",
                            "This structure may be passed to $xImageCreate, via the `pNext` member of $x_image_desc_t."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_MEMORY_COMPRESSION_HINTS_EXT_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] flags specifying if allocation should be compressible or not.\nMust be set to one of the $x_memory_compression_hints_ext_flag_t;\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$x_memory_compression_hints_ext_flags_t"
                            }
                        ],
                        "name": "$x_memory_compression_hints_ext_desc_t",
                        "type": "struct",
                        "version": "1.3"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for Memory Free Policies",
                    "ordinal": 1300,
                    "type": "header",
                    "version": "1.3"
                },
                "name": "memoryFreePolicies",
                "objects": [
                    {
                        "desc": "Memory Free Policies Extension Name",
                        "name": "$X_MEMORY_FREE_POLICIES_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_memory_free_policies\"",
                        "version": "1.3"
                    },
                    {
                        "desc": "Memory Free Policies Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_MEMORY_FREE_POLICIES_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_MEMORY_FREE_POLICIES_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_memory_free_policies_ext_version_t",
                        "type": "enum",
                        "version": "1.3"
                    },
                    {
                        "class": "$xDriver",
                        "desc": "Supported memory free policy capability flags",
                        "etors": [
                            {
                                "desc": "blocks until all commands using the memory are complete before freeing",
                                "name": "$X_DRIVER_MEMORY_FREE_POLICY_EXT_FLAG_BLOCKING_FREE",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "schedules the memory to be freed but does not free immediately",
                                "name": "$X_DRIVER_MEMORY_FREE_POLICY_EXT_FLAG_DEFER_FREE",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$x_driver_memory_free_policy_ext_flags_t",
                        "type": "enum",
                        "version": "1.3"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDriver",
                        "desc": "Driver memory free properties queried using $xDriverGetProperties",
                        "details": [
                            "All drivers must support an immediate free policy, which is the default free policy.",
                            "This structure may be returned from $xDriverGetProperties, via the `pNext` member of $x_driver_properties_t."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DRIVER_MEMORY_FREE_EXT_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] Supported memory free policies.\nmust be 0 or a combination of $x_driver_memory_free_policy_ext_flag_t.\n",
                                "name": "freePolicies",
                                "type": "$x_driver_memory_free_policy_ext_flags_t"
                            }
                        ],
                        "name": "$x_driver_memory_free_ext_properties_t",
                        "type": "struct",
                        "version": "1.3"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xMem",
                        "desc": "Memory free descriptor with free policy",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_MEMORY_FREE_EXT_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] flags specifying the memory free policy.\nmust be 0 (default) or a supported $x_driver_memory_free_policy_ext_flag_t;\ndefault behavior is to free immediately.\n",
                                "name": "freePolicy",
                                "type": "$x_driver_memory_free_policy_ext_flags_t"
                            }
                        ],
                        "name": "$x_memory_free_ext_desc_t",
                        "type": "struct",
                        "version": "1.3"
                    },
                    {
                        "class": "$xMem",
                        "desc": "Frees allocated host memory, device memory, or shared memory using the specified free policy.",
                        "details": [
                            "The memory free policy is specified by the memory free descriptor.",
                            "The application must **not** call this function from simultaneous threads with the same pointer.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "2c1348cec3a26ca51bbb7430b0b2a6af88216b9711c2afcfd991b5c34880f198",
                        "name": "FreeExt",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$x_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to memory free descriptor",
                                "name": "pMemFreeDesc",
                                "type": "const $x_memory_free_ext_desc_t*"
                            },
                            {
                                "desc": "[in][release] pointer to memory to free",
                                "name": "ptr",
                                "type": "void*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pMemFreeDesc`",
                                    "`nullptr == ptr`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x3 < pMemFreeDesc->freePolicy`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.3"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for Bandwidth",
                    "ordinal": 1400,
                    "type": "header",
                    "version": "1.4"
                },
                "name": "bandwidth",
                "objects": [
                    {
                        "desc": "Bandwidth Extension Name",
                        "name": "$X_BANDWIDTH_PROPERTIES_EXP_NAME",
                        "type": "macro",
                        "value": "\"$X_experimental_bandwidth_properties\"",
                        "version": "1.4"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "P2P Bandwidth Properties",
                        "details": [
                            "This structure may be passed to $xDeviceGetP2PProperties by having the pNext member of $x_device_p2p_properties_t point at this struct."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_P2P_BANDWIDTH_EXP_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] total logical design bandwidth for all links connecting the two devices",
                                "name": "logicalBandwidth",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] total physical design bandwidth for all links connecting the two devices",
                                "name": "physicalBandwidth",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] bandwidth unit",
                                "name": "bandwidthUnit",
                                "type": "$x_bandwidth_unit_t"
                            },
                            {
                                "desc": "[out] average logical design latency for all links connecting the two devices",
                                "name": "logicalLatency",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] average physical design latency for all links connecting the two devices",
                                "name": "physicalLatency",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] latency unit",
                                "name": "latencyUnit",
                                "type": "$x_latency_unit_t"
                            }
                        ],
                        "name": "$x_device_p2p_bandwidth_exp_properties_t",
                        "type": "struct",
                        "version": "1.4"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xCommandQueue",
                        "desc": "Copy Bandwidth Properties",
                        "details": [
                            "This structure may be passed to $xDeviceGetCommandQueueGroupProperties by having the pNext member of $x_command_queue_group_properties_t point at this struct."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_COPY_BANDWIDTH_EXP_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] design bandwidth supported by this engine type for copy operations",
                                "name": "copyBandwidth",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] copy bandwidth unit",
                                "name": "copyBandwidthUnit",
                                "type": "$x_bandwidth_unit_t"
                            }
                        ],
                        "name": "$x_copy_bandwidth_exp_properties_t",
                        "type": "struct",
                        "version": "1.4"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for Device Local Identifier (LUID)",
                    "ordinal": 1400,
                    "type": "header",
                    "version": "1.4"
                },
                "name": "deviceLUID",
                "objects": [
                    {
                        "desc": "Device Local Identifier (LUID) Extension Name",
                        "name": "$X_DEVICE_LUID_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_device_luid\"",
                        "version": "1.4"
                    },
                    {
                        "desc": "Device Local Identifier (LUID) Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_DEVICE_LUID_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_DEVICE_LUID_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_device_luid_ext_version_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "desc": "Maximum device local identifier (LUID) size in bytes",
                        "name": "$X_MAX_DEVICE_LUID_SIZE_EXT",
                        "type": "macro",
                        "value": "8",
                        "version": "1.4"
                    },
                    {
                        "desc": "Device local identifier (LUID)",
                        "members": [
                            {
                                "desc": "[out] opaque data representing a device LUID",
                                "name": "id[$X_MAX_DEVICE_LUID_SIZE_EXT]",
                                "type": "uint8_t"
                            }
                        ],
                        "name": "$x_device_luid_ext_t",
                        "type": "struct"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Device LUID properties queried using $xDeviceGetProperties",
                        "details": [
                            "This structure may be returned from $xDeviceGetProperties, via the `pNext` member of $x_device_properties_t."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_LUID_EXT_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] locally unique identifier (LUID).\nThe returned LUID can be cast to a LUID object and must be equal to the locally\nunique identifier of an IDXGIAdapter1 object that corresponds to the device.\n",
                                "name": "luid",
                                "type": "$x_device_luid_ext_t"
                            },
                            {
                                "desc": "[out] node mask.\nThe returned node mask must contain exactly one bit.\nIf the device is running on an operating system that supports the Direct3D 12 API\nand the device corresponds to an individual device in a linked device adapter, the\nreturned node mask identifies the Direct3D 12 node corresponding to the device.\nOtherwise, the returned node mask must be 1.\n",
                                "name": "nodeMask",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_device_luid_ext_properties_t",
                        "type": "struct",
                        "version": "1.4"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for Fabric Topology Discovery",
                    "ordinal": 1400,
                    "type": "header",
                    "version": "1.4"
                },
                "name": "fabric",
                "objects": [
                    {
                        "desc": "Fabric Topology Discovery Extension Name",
                        "name": "$X_FABRIC_EXP_NAME",
                        "type": "macro",
                        "value": "\"$X_experimental_fabric\"",
                        "version": "1.4"
                    },
                    {
                        "desc": "Maximum fabric edge model string size",
                        "name": "$X_MAX_FABRIC_EDGE_MODEL_EXP_SIZE",
                        "type": "macro",
                        "value": "256"
                    },
                    {
                        "class": "$xFabricVertex",
                        "desc": "Fabric Vertex types",
                        "etors": [
                            {
                                "desc": "Fabric vertex type is unknown",
                                "name": "$X_FABRIC_VERTEX_EXP_TYPE_UNKNOWN",
                                "value": "0"
                            },
                            {
                                "desc": "Fabric vertex represents a device",
                                "name": "$X_FABRIC_VERTEX_EXP_TYPE_DEVICE",
                                "value": "1"
                            },
                            {
                                "desc": "Fabric vertex represents a subdevice",
                                "name": "$X_FABRIC_VERTEX_EXP_TYPE_SUBDEVICE",
                                "value": "2"
                            },
                            {
                                "desc": "Fabric vertex represents a switch",
                                "name": "$X_FABRIC_VERTEX_EXP_TYPE_SWITCH",
                                "value": "3"
                            }
                        ],
                        "name": "$x_fabric_vertex_exp_type_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "class": "$xFabricEdge",
                        "desc": "Fabric edge duplexity",
                        "etors": [
                            {
                                "desc": "Fabric edge duplexity is unknown",
                                "name": "$X_FABRIC_EDGE_EXP_DUPLEXITY_UNKNOWN",
                                "value": "0"
                            },
                            {
                                "desc": "Fabric edge is half duplex, i.e. stated bandwidth is obtained in only one direction at time",
                                "name": "$X_FABRIC_EDGE_EXP_DUPLEXITY_HALF_DUPLEX",
                                "value": "1"
                            },
                            {
                                "desc": "Fabric edge is full duplex, i.e. stated bandwidth is supported in both directions simultaneously",
                                "name": "$X_FABRIC_EDGE_EXP_DUPLEXITY_FULL_DUPLEX",
                                "value": "2"
                            }
                        ],
                        "name": "$x_fabric_edge_exp_duplexity_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "class": "$xFabricVertex",
                        "desc": "PCI address",
                        "details": [
                            "A PCI BDF address is the bus:device:function address of the device and is useful for locating the device in the PCI switch fabric."
                        ],
                        "members": [
                            {
                                "desc": "[out] PCI domain number",
                                "name": "domain",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] PCI BDF bus number",
                                "name": "bus",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] PCI BDF device number",
                                "name": "device",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] PCI BDF function number",
                                "name": "function",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_fabric_vertex_pci_exp_address_t",
                        "type": "struct",
                        "version": "1.4"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xFabricVertex",
                        "desc": "Fabric Vertex properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_FABRIC_VERTEX_EXP_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] universal unique identifier. If the vertex is co-located with a device/subdevice, then this uuid will match that of the corresponding device/subdevice",
                                "name": "uuid",
                                "type": "$x_uuid_t"
                            },
                            {
                                "desc": "[out] does the fabric vertex represent a device, subdevice, or switch?",
                                "name": "type",
                                "type": "$x_fabric_vertex_exp_type_t"
                            },
                            {
                                "desc": "[out] does the fabric vertex live on the local node or on a remote node?",
                                "name": "remote",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] B/D/F address of fabric vertex & associated device/subdevice if available",
                                "name": "address",
                                "type": "$x_fabric_vertex_pci_exp_address_t"
                            }
                        ],
                        "name": "$x_fabric_vertex_exp_properties_t",
                        "type": "struct",
                        "version": "1.4"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xFabricEdge",
                        "desc": "Fabric Edge properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_FABRIC_EDGE_EXP_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] universal unique identifier.",
                                "name": "uuid",
                                "type": "$x_uuid_t"
                            },
                            {
                                "desc": "[out] Description of fabric edge technology. Will be set to the string \"unkown\" if this cannot be determined for this edge",
                                "name": "model[$X_MAX_FABRIC_EDGE_MODEL_EXP_SIZE]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] design bandwidth",
                                "name": "bandwidth",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] bandwidth unit",
                                "name": "bandwidthUnit",
                                "type": "$x_bandwidth_unit_t"
                            },
                            {
                                "desc": "[out] design latency",
                                "name": "latency",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] latency unit",
                                "name": "latencyUnit",
                                "type": "$x_latency_unit_t"
                            },
                            {
                                "desc": "[out] Duplexity of the fabric edge",
                                "name": "duplexity",
                                "type": "$x_fabric_edge_exp_duplexity_t"
                            }
                        ],
                        "name": "$x_fabric_edge_exp_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$xFabricVertex",
                        "decl": "static",
                        "desc": "Retrieves fabric vertices within a driver",
                        "details": [
                            "A fabric vertex represents either a device or a switch connected to other fabric vertices.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "d95d0f4e7b30317032c06f72141ea77bdaa408eec0d94a5f8e94b612889802d4",
                        "name": "GetExp",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the driver instance",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of fabric vertices.\nif count is zero, then the driver shall update the value with the total number of fabric vertices available.\nif count is greater than the number of fabric vertices available, then the driver shall update the value with the correct number of fabric vertices available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of fabric vertices.\nif count is less than the number of fabric vertices available, then driver shall only retrieve that number of fabric vertices.\n",
                                "name": "phVertices",
                                "type": "$x_fabric_vertex_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.4"
                    },
                    {
                        "class": "$xFabricVertex",
                        "desc": "Retrieves a fabric sub-vertex from a fabric vertex",
                        "details": [
                            "Multiple calls to this function will return identical fabric vertex handles, in the same order.",
                            "The number of handles returned from this function is affected by the $X_AFFINITY_MASK environment variable.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "f12d9729896b900bb80da1ed058c5f42c956bd8995514decb6cc13de518fd077",
                        "name": "GetSubVerticesExp",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the fabric vertex object",
                                "name": "hVertex",
                                "type": "$x_fabric_vertex_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of sub-vertices.\nif count is zero, then the driver shall update the value with the total number of sub-vertices available.\nif count is greater than the number of sub-vertices available, then the driver shall update the value with the correct number of sub-vertices available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of sub-vertices.\nif count is less than the number of sub-vertices available, then driver shall only retrieve that number of sub-vertices.\n",
                                "name": "phSubvertices",
                                "type": "$x_fabric_vertex_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hVertex`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.4"
                    },
                    {
                        "class": "$xFabricVertex",
                        "desc": "Retrieves properties of the fabric vertex.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "cc72a57c989ca854178c03c56d017118e98d002902a43a962d8f3e1fc6dd3adf",
                        "name": "GetPropertiesExp",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the fabric vertex",
                                "name": "hVertex",
                                "type": "$x_fabric_vertex_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for fabric vertex properties",
                                "name": "pVertexProperties",
                                "type": "$x_fabric_vertex_exp_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hVertex`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pVertexProperties`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.4"
                    },
                    {
                        "class": "$xFabricVertex",
                        "desc": "Returns device handle from fabric vertex handle.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "48861d8bf149f5ca741df5e1bd9aae1b92287efaf56573366d6788ab60ef7043",
                        "name": "GetDeviceExp",
                        "params": [
                            {
                                "desc": "[in] handle of the fabric vertex",
                                "name": "hVertex",
                                "type": "$x_fabric_vertex_handle_t"
                            },
                            {
                                "desc": "[out] device handle corresponding to fabric vertex",
                                "name": "phDevice",
                                "type": "$x_device_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hVertex`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_EXP_ERROR_VERTEX_IS_NOT_DEVICE": [
                                    "Provided fabric vertex handle does not correspond to a device or subdevice."
                                ]
                            },
                            {
                                "$X_RESULT_EXP_ERROR_REMOTE_DEVICE": [
                                    "Provided fabric vertex handle corresponds to remote device or subdevice."
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.4"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Returns fabric vertex handle from device handle.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "6a63ee8ccb8f52e0b4fe869619bd1dbf6b8817f2b0d61e8b6acff07a81334135",
                        "name": "GetFabricVertexExp",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[out] fabric vertex handle corresponding to device",
                                "name": "phVertex",
                                "type": "$x_fabric_vertex_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phVertex`"
                                ]
                            },
                            {
                                "$X_RESULT_EXP_ERROR_DEVICE_IS_NOT_VERTEX": [
                                    "Provided device handle does not correspond to a fabric vertex."
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.4"
                    },
                    {
                        "class": "$xFabricEdge",
                        "decl": "static",
                        "desc": "Retrieves all fabric edges between provided pair of fabric vertices",
                        "details": [
                            "A fabric edge represents one or more physical links between two fabric vertices.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "49c8b5bf1db998a1e71e1f5cbd3960b2389a55e949acf172171586c40d5bdc14",
                        "name": "GetExp",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of first fabric vertex instance",
                                "name": "hVertexA",
                                "type": "$x_fabric_vertex_handle_t"
                            },
                            {
                                "desc": "[in] handle of second fabric vertex instance",
                                "name": "hVertexB",
                                "type": "$x_fabric_vertex_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of fabric edges.\nif count is zero, then the driver shall update the value with the total number of fabric edges available.\nif count is greater than the number of fabric edges available, then the driver shall update the value with the correct number of fabric edges available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of fabric edges.\nif count is less than the number of fabric edges available, then driver shall only retrieve that number of fabric edges.\n",
                                "name": "phEdges",
                                "type": "$x_fabric_edge_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hVertexA`",
                                    "`nullptr == hVertexB`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.4"
                    },
                    {
                        "class": "$xFabricEdge",
                        "decl": "static",
                        "desc": "Retrieves fabric vertices connected by a fabric edge",
                        "details": [
                            "A fabric vertex represents either a device or a switch connected to other fabric vertices via a fabric edge.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "d124cc6c609daf4e248dde72e0ef67facc7ddc419f4feb4ea6f29e5f347ec2f6",
                        "name": "GetVerticesExp",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the fabric edge instance",
                                "name": "hEdge",
                                "type": "$x_fabric_edge_handle_t"
                            },
                            {
                                "desc": "[out] fabric vertex connected to one end of the given fabric edge.",
                                "name": "phVertexA",
                                "type": "$x_fabric_vertex_handle_t*"
                            },
                            {
                                "desc": "[out] fabric vertex connected to other end of the given fabric edge.",
                                "name": "phVertexB",
                                "type": "$x_fabric_vertex_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEdge`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phVertexA`",
                                    "`nullptr == phVertexB`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.4"
                    },
                    {
                        "class": "$xFabricEdge",
                        "desc": "Retrieves properties of the fabric edge.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "8fc98d018771faed5ab0f16d91fbb55b48f2466a944e107067d5d64ab631f21e",
                        "name": "GetPropertiesExp",
                        "ordinal": "1",
                        "params": [
                            {
                                "desc": "[in] handle of the fabric edge",
                                "name": "hEdge",
                                "type": "$x_fabric_edge_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for fabric edge properties",
                                "name": "pEdgeProperties",
                                "type": "$x_fabric_edge_exp_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEdge`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pEdgeProperties`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.4"
                    },
                    {
                        "desc": "C++ wrapper for fabric vertex",
                        "members": [
                            {
                                "desc": "[in] handle of fabric vertex object",
                                "name": "handle",
                                "type": "$x_fabric_vertex_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDriver",
                                "type": "$xDriver*"
                            }
                        ],
                        "name": "$xFabricVertex",
                        "owner": "$xDriver",
                        "type": "class"
                    },
                    {
                        "desc": "C++ wrapper for fabric edge",
                        "members": [
                            {
                                "desc": "[in] handle of fabric edge object",
                                "name": "handle",
                                "type": "$x_fabric_edge_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDriver",
                                "type": "$xDriver*"
                            }
                        ],
                        "name": "$xFabricEdge",
                        "owner": "$xDriver",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for Device Memory Properties",
                    "ordinal": 1400,
                    "type": "header",
                    "version": "1.4"
                },
                "name": "memoryProperties",
                "objects": [
                    {
                        "desc": "Device Memory Properties Extension Name",
                        "name": "$X_DEVICE_MEMORY_PROPERTIES_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_device_memory_properties\"",
                        "version": "1.4"
                    },
                    {
                        "desc": "Device Memory Properties Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_DEVICE_MEMORY_PROPERTIES_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_DEVICE_MEMORY_PROPERTIES_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_device_memory_properties_ext_version_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Memory module types",
                        "etors": [
                            {
                                "desc": "HBM memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_HBM",
                                "value": "0"
                            },
                            {
                                "desc": "HBM2 memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_HBM2",
                                "value": "1"
                            },
                            {
                                "desc": "DDR memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_DDR",
                                "value": "2"
                            },
                            {
                                "desc": "DDR2 memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_DDR2",
                                "value": "3"
                            },
                            {
                                "desc": "DDR3 memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_DDR3",
                                "value": "4"
                            },
                            {
                                "desc": "DDR4 memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_DDR4",
                                "value": "5"
                            },
                            {
                                "desc": "DDR5 memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_DDR5",
                                "value": "6"
                            },
                            {
                                "desc": "LPDDR memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_LPDDR",
                                "value": "7"
                            },
                            {
                                "desc": "LPDDR3 memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_LPDDR3",
                                "value": "8"
                            },
                            {
                                "desc": "LPDDR4 memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_LPDDR4",
                                "value": "9"
                            },
                            {
                                "desc": "LPDDR5 memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_LPDDR5",
                                "value": "10"
                            },
                            {
                                "desc": "SRAM memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_SRAM",
                                "value": "11"
                            },
                            {
                                "desc": "L1 cache",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_L1",
                                "value": "12"
                            },
                            {
                                "desc": "L3 cache",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_L3",
                                "value": "13"
                            },
                            {
                                "desc": "Execution unit register file",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_GRF",
                                "value": "14"
                            },
                            {
                                "desc": "Execution unit shared local memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_SLM",
                                "value": "15"
                            },
                            {
                                "desc": "GDDR4 memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_GDDR4",
                                "value": "16"
                            },
                            {
                                "desc": "GDDR5 memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_GDDR5",
                                "value": "17"
                            },
                            {
                                "desc": "GDDR5X memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_GDDR5X",
                                "value": "18"
                            },
                            {
                                "desc": "GDDR6 memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_GDDR6",
                                "value": "19"
                            },
                            {
                                "desc": "GDDR6X memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_GDDR6X",
                                "value": "20"
                            },
                            {
                                "desc": "GDDR7 memory",
                                "name": "$X_DEVICE_MEMORY_EXT_TYPE_GDDR7",
                                "value": "21"
                            }
                        ],
                        "name": "$x_device_memory_ext_type_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Memory properties",
                        "details": [
                            "This structure may be returned from $xDeviceGetMemoryProperties via the `pNext` member of $x_device_memory_properties_t"
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_MEMORY_EXT_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] The memory type",
                                "name": "type",
                                "type": "$x_device_memory_ext_type_t"
                            },
                            {
                                "desc": "[out] Physical memory size in bytes. A value of 0 indicates that this property is not known. However, a call to $sMemoryGetState() will correctly return the total size of usable memory.",
                                "name": "physicalSize",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Design bandwidth for reads",
                                "name": "readBandwidth",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Design bandwidth for writes",
                                "name": "writeBandwidth",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] bandwidth unit",
                                "name": "bandwidthUnit",
                                "type": "$x_bandwidth_unit_t"
                            }
                        ],
                        "name": "$x_device_memory_ext_properties_t",
                        "type": "struct",
                        "version": "1.4"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for Bfloat16 Conversions",
                    "ordinal": 1500,
                    "type": "header",
                    "version": "1.5"
                },
                "name": "bfloat16conversions",
                "objects": [
                    {
                        "desc": "Bfloat16 Conversions Extension Name",
                        "name": "$X_BFLOAT16_CONVERSIONS_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_bfloat16_conversions\"",
                        "version": "1.5"
                    },
                    {
                        "desc": "Bfloat16 Conversions Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_BFLOAT16_CONVERSIONS_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_BFLOAT16_CONVERSIONS_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_bfloat16_conversions_ext_version_t",
                        "type": "enum",
                        "version": "1.5"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension APIs for Device IP Version",
                    "ordinal": 1500,
                    "type": "header",
                    "version": "1.5"
                },
                "name": "deviceipversion",
                "objects": [
                    {
                        "desc": "Device IP Version Extension Name",
                        "name": "$X_DEVICE_IP_VERSION_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_device_ip_version\"",
                        "version": "1.5"
                    },
                    {
                        "desc": "Device IP Version Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_DEVICE_IP_VERSION_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_DEVICE_IP_VERSION_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_device_ip_version_version_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xDevice",
                        "desc": "Device IP version queried using $xDeviceGetProperties",
                        "details": [
                            "This structure may be returned from $xDeviceGetProperties via the `pNext` member of $x_device_properties_t"
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_DEVICE_IP_VERSION_EXT",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] Device IP version. The meaning of the device IP version is\nimplementation-defined, but newer devices should have a higher\nversion than older devices.\n",
                                "name": "ipVersion",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_device_ip_version_ext_t",
                        "type": "struct",
                        "version": "1.5"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for querying kernel max group size properties.",
                    "ordinal": 1500,
                    "type": "header",
                    "version": "1.5"
                },
                "name": "kernelMaxGroupSizeProperties",
                "objects": [
                    {
                        "desc": "Kernel Max Group Size Properties Extension Name",
                        "name": "$X_KERNEL_MAX_GROUP_SIZE_PROPERTIES_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_kernel_max_group_size_properties\"",
                        "version": "1.5"
                    },
                    {
                        "desc": "Kernel Max Group Size Properties Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_KERNEL_MAX_GROUP_SIZE_PROPERTIES_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_KERNEL_MAX_GROUP_SIZE_PROPERTIES_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_kernel_max_group_size_properties_ext_version_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xKernel",
                        "desc": "Additional kernel max group size properties",
                        "details": [
                            "This structure may be passed to $xKernelGetProperties, via the `pNext` member of $x_kernel_properties_t, to query additional kernel max group size properties."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_KERNEL_MAX_GROUP_SIZE_PROPERTIES_EXT",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] maximum group size that can be used to execute the kernel. This value may be less than or equal to the `maxTotalGroupSize` member of $x_device_compute_properties_t.",
                                "name": "maxGroupSize",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_kernel_max_group_size_properties_ext_t",
                        "type": "struct",
                        "version": "1.5"
                    },
                    {
                        "desc": "compiler-independent type",
                        "name": "$x_kernel_max_group_size_ext_properties_t",
                        "type": "typedef",
                        "value": "$x_kernel_max_group_size_properties_ext_t",
                        "version": "1.7"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for querying sub-allocations properties.",
                    "ordinal": 1500,
                    "type": "header",
                    "version": "1.5"
                },
                "name": "subAllocationsProperties",
                "objects": [
                    {
                        "desc": "Sub-Allocations Properties Extension Name",
                        "name": "$X_SUB_ALLOCATIONS_EXP_NAME",
                        "type": "macro",
                        "value": "\"$X_experimental_sub_allocations\"",
                        "version": "1.5"
                    },
                    {
                        "desc": "Sub-Allocations Properties Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_SUB_ALLOCATIONS_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_SUB_ALLOCATIONS_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_sub_allocations_exp_version_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "class": "$xMem",
                        "desc": "Properties returned for a sub-allocation",
                        "members": [
                            {
                                "desc": "[in,out][optional] base address of the sub-allocation",
                                "name": "base",
                                "type": "void*"
                            },
                            {
                                "desc": "[in,out][optional] size of the allocation",
                                "name": "size",
                                "type": "size_t"
                            }
                        ],
                        "name": "$x_sub_allocation_t",
                        "type": "struct",
                        "version": "1.5"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xMem",
                        "desc": "Sub-Allocations Properties",
                        "details": [
                            "This structure may be passed to $xMemGetAllocProperties, via the `pNext` member of $x_memory_allocation_properties_t."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_MEMORY_SUB_ALLOCATIONS_EXP_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[in,out] pointer to the number of sub-allocations.\nif count is zero, then the driver shall update the value with the total number of sub-allocations on which the allocation has been divided.\nif count is greater than the number of sub-allocations, then the driver shall update the value with the correct number of sub-allocations.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of properties for sub-allocations.\nif count is less than the number of sub-allocations available, then driver shall only retrieve properties for that number of sub-allocations.\n",
                                "name": "pSubAllocations",
                                "type": "$x_sub_allocation_t*"
                            }
                        ],
                        "name": "$x_memory_sub_allocations_exp_properties_t",
                        "type": "struct",
                        "version": "1.5"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for supporting the querying of synchronized event timestamps.",
                    "ordinal": 1600,
                    "type": "header",
                    "version": "1.6"
                },
                "name": "eventQueryKernelTimestamps",
                "objects": [
                    {
                        "desc": "Event Query Kernel Timestamps Extension Name",
                        "name": "$X_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_NAME",
                        "type": "macro",
                        "value": "\"$X_extension_event_query_kernel_timestamps\"",
                        "version": "1.6"
                    },
                    {
                        "desc": "Event Query Kernel Timestamps Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_event_query_kernel_timestamps_ext_version_t",
                        "type": "enum",
                        "version": "1.6"
                    },
                    {
                        "class": "$xEvent",
                        "desc": "Event query kernel timestamps flags",
                        "etors": [
                            {
                                "desc": "Kernel timestamp results",
                                "name": "$X_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_FLAG_KERNEL",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Device event timestamps synchronized to the host time domain",
                                "name": "$X_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_FLAG_SYNCHRONIZED",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$x_event_query_kernel_timestamps_ext_flags_t",
                        "type": "enum",
                        "version": "1.6"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "desc": "Event query kernel timestamps properties",
                        "details": [
                            "This structure may be returned from $xDeviceGetProperties, via the `pNext` member of $x_device_properties_t."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_EVENT_QUERY_KERNEL_TIMESTAMPS_EXT_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] 0 or some combination of $x_event_query_kernel_timestamps_ext_flag_t flags",
                                "name": "flags",
                                "type": "$x_event_query_kernel_timestamps_ext_flags_t"
                            }
                        ],
                        "name": "$x_event_query_kernel_timestamps_ext_properties_t",
                        "type": "struct",
                        "version": "1.6"
                    },
                    {
                        "class": "$xEvent",
                        "desc": "Kernel timestamp clock data synchronized to the host time domain",
                        "members": [
                            {
                                "desc": "[out] synchronized clock at start of kernel execution",
                                "name": "kernelStart",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] synchronized clock at end of kernel execution",
                                "name": "kernelEnd",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$x_synchronized_timestamp_data_ext_t",
                        "type": "struct",
                        "version": "1.6"
                    },
                    {
                        "class": "$xEvent",
                        "desc": "Synchronized kernel timestamp result",
                        "members": [
                            {
                                "desc": "[out] wall-clock data",
                                "name": "global",
                                "type": "$x_synchronized_timestamp_data_ext_t"
                            },
                            {
                                "desc": "[out] context-active data; only includes clocks while device context was actively executing.",
                                "name": "context",
                                "type": "$x_synchronized_timestamp_data_ext_t"
                            }
                        ],
                        "name": "$x_synchronized_timestamp_result_ext_t",
                        "type": "struct",
                        "version": "1.6"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "desc": "Event query kernel timestamps results properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_EVENT_QUERY_KERNEL_TIMESTAMPS_RESULTS_EXT_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] pointer to destination buffer of kernel timestamp results",
                                "init": "nullptr",
                                "name": "pKernelTimestampsBuffer",
                                "type": "$x_kernel_timestamp_result_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] pointer to destination buffer of synchronized timestamp results",
                                "init": "nullptr",
                                "name": "pSynchronizedTimestampsBuffer",
                                "type": "$x_synchronized_timestamp_result_ext_t*"
                            }
                        ],
                        "name": "$x_event_query_kernel_timestamps_results_ext_properties_t",
                        "type": "struct",
                        "version": "1.6"
                    },
                    {
                        "class": "$xEvent",
                        "desc": "Query an event's timestamp value on the host, with domain preference.",
                        "details": [
                            "For collecting *only* kernel timestamps, the application must ensure the event was created from an event pool that was created using $X_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag.",
                            "For collecting synchronized timestamps, the application must ensure the event was created from an event pool that was created using $X_EVENT_POOL_FLAG_KERNEL_MAPPED_TIMESTAMP flag. Kernel timestamps are also available from this type of event pool, but there is a performance cost.",
                            "The destination memory will be unmodified if the event has not been signaled.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe.",
                            "The implementation must support $X_extension_event_query_kernel_timestamps.",
                            "The implementation must return all timestamps for the specified event and device pair.",
                            "The implementation must return all timestamps for all sub-devices when device handle is parent device.",
                            "The implementation may return all timestamps for sub-devices when device handle is sub-device or may return 0 for count."
                        ],
                        "hash": "1fd7be75405b56820b9d681d430d712ad8c789c74a5cd4e3332d20245e9694c0",
                        "name": "QueryKernelTimestampsExt",
                        "params": [
                            {
                                "desc": "[in] handle of the event",
                                "name": "hEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device to query",
                                "name": "hDevice",
                                "type": "$x_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of event packets available.\n    - This value is implementation specific.\n    - if `*pCount` is zero, then the driver shall update the value with the total number of event packets available.\n    - if `*pCount` is greater than the number of event packets available, the driver shall update the value with the correct value.\n    - Buffer(s) for query results must be sized by the application to accommodate a minimum of `*pCount` elements.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] pointer to event query properties structure(s).\n    - This parameter may be null when `*pCount` is zero.\n    - if `*pCount` is less than the number of event packets available, the driver may only update `*pCount` elements, starting at element zero.\n    - if `*pCount` is greater than the number of event packets available, the driver may only update the valid elements.\n",
                                "name": "pResults",
                                "type": "$x_event_query_kernel_timestamps_results_ext_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEvent`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.6"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Extension for supporting ray tracing acceleration structure builder.",
                    "ordinal": 1700,
                    "type": "header",
                    "version": "1.7"
                },
                "name": "RTASBuilder",
                "objects": [
                    {
                        "desc": "Ray Tracing Acceleration Structure Builder Extension Name",
                        "name": "$X_RTAS_BUILDER_EXP_NAME",
                        "type": "macro",
                        "value": "\"$X_experimental_rtas_builder\"",
                        "version": "1.7"
                    },
                    {
                        "desc": "Ray Tracing Acceleration Structure Builder Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_RTAS_BUILDER_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_RTAS_BUILDER_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_rtas_builder_exp_version_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Ray tracing acceleration structure device flags",
                        "etors": [
                            {
                                "desc": "reserved for future use",
                                "name": "$X_RTAS_DEVICE_EXP_FLAG_RESERVED",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$x_rtas_device_exp_flags_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$xDevice",
                        "desc": "Ray tracing acceleration structure format",
                        "details": [
                            "This is an opaque ray tracing acceleration structure format identifier."
                        ],
                        "etors": [
                            {
                                "desc": "Invalid acceleration structure format",
                                "name": "$X_RTAS_FORMAT_EXP_INVALID",
                                "value": "0"
                            }
                        ],
                        "name": "$x_rtas_format_exp_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure builder flags",
                        "etors": [
                            {
                                "desc": "Reserved for future use",
                                "name": "$X_RTAS_BUILDER_EXP_FLAG_RESERVED",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$x_rtas_builder_exp_flags_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASParallelOperation",
                        "desc": "Ray tracing acceleration structure builder parallel operation flags",
                        "etors": [
                            {
                                "desc": "Reserved for future use",
                                "name": "$X_RTAS_PARALLEL_OPERATION_EXP_FLAG_RESERVED",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$x_rtas_parallel_operation_exp_flags_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure builder geometry flags",
                        "etors": [
                            {
                                "desc": "non-opaque geometries invoke an any-hit shader",
                                "name": "$X_RTAS_BUILDER_GEOMETRY_EXP_FLAG_NON_OPAQUE",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$x_rtas_builder_geometry_exp_flags_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Packed ray tracing acceleration structure builder geometry flags (see $x_rtas_builder_geometry_exp_flags_t)",
                        "name": "$x_rtas_builder_packed_geometry_exp_flags_t",
                        "type": "typedef",
                        "value": "uint8_t",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure builder instance flags",
                        "etors": [
                            {
                                "desc": "disables culling of front-facing and back-facing triangles",
                                "name": "$X_RTAS_BUILDER_INSTANCE_EXP_FLAG_TRIANGLE_CULL_DISABLE",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "reverses front and back face of triangles",
                                "name": "$X_RTAS_BUILDER_INSTANCE_EXP_FLAG_TRIANGLE_FRONT_COUNTERCLOCKWISE",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "forces instanced geometry to be opaque, unless ray flag forces it to be non-opaque",
                                "name": "$X_RTAS_BUILDER_INSTANCE_EXP_FLAG_TRIANGLE_FORCE_OPAQUE",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "forces instanced geometry to be non-opaque, unless ray flag forces it to be opaque",
                                "name": "$X_RTAS_BUILDER_INSTANCE_EXP_FLAG_TRIANGLE_FORCE_NON_OPAQUE",
                                "value": "$X_BIT(3)"
                            }
                        ],
                        "name": "$x_rtas_builder_instance_exp_flags_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Packed ray tracing acceleration structure builder instance flags (see $x_rtas_builder_instance_exp_flags_t)",
                        "name": "$x_rtas_builder_packed_instance_exp_flags_t",
                        "type": "typedef",
                        "value": "uint8_t",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure builder build operation flags",
                        "details": [
                            "These flags allow the application to tune the acceleration structure build operation.",
                            "The acceleration structure builder implementation might choose to use spatial splitting to split large or long primitives into smaller pieces. This may result in any-hit shaders being invoked multiple times for non-opaque primitives, unless $X_RTAS_BUILDER_BUILD_OP_EXP_FLAG_NO_DUPLICATE_ANYHIT_INVOCATION is specified.\n",
                            "Usage of any of these flags may reduce ray tracing performance."
                        ],
                        "etors": [
                            {
                                "desc": "build more compact acceleration structure",
                                "name": "$X_RTAS_BUILDER_BUILD_OP_EXP_FLAG_COMPACT",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "guarantees single any-hit shader invocation per primitive",
                                "name": "$X_RTAS_BUILDER_BUILD_OP_EXP_FLAG_NO_DUPLICATE_ANYHIT_INVOCATION",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$x_rtas_builder_build_op_exp_flags_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure builder build quality hint",
                        "details": [
                            "Depending on use case different quality modes for acceleration structure build are supported.",
                            "A low-quality build builds an acceleration structure fast, but at the cost of some reduction in ray tracing performance. This mode is recommended for dynamic content, such as animated characters.\n",
                            "A medium-quality build uses a compromise between build quality and ray tracing performance. This mode should be used by default.\n",
                            "Higher ray tracing performance can be achieved by using a high-quality build, but acceleration structure build performance might be significantly reduced.\n"
                        ],
                        "etors": [
                            {
                                "desc": "build low-quality acceleration structure (fast)",
                                "name": "$X_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_LOW",
                                "value": "0"
                            },
                            {
                                "desc": "build medium-quality acceleration structure (slower)",
                                "name": "$X_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_MEDIUM",
                                "value": "1"
                            },
                            {
                                "desc": "build high-quality acceleration structure (slow)",
                                "name": "$X_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_HIGH",
                                "value": "2"
                            }
                        ],
                        "name": "$x_rtas_builder_build_quality_hint_exp_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure builder geometry type",
                        "etors": [
                            {
                                "desc": "triangle mesh geometry type",
                                "name": "$X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_TRIANGLES",
                                "value": "0"
                            },
                            {
                                "desc": "quad mesh geometry type",
                                "name": "$X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_QUADS",
                                "value": "1"
                            },
                            {
                                "desc": "procedural geometry type",
                                "name": "$X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_PROCEDURAL",
                                "value": "2"
                            },
                            {
                                "desc": "instance geometry type",
                                "name": "$X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_INSTANCE",
                                "value": "3"
                            }
                        ],
                        "name": "$x_rtas_builder_geometry_type_exp_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Packed ray tracing acceleration structure builder geometry type (see $x_rtas_builder_geometry_type_exp_t)",
                        "name": "$x_rtas_builder_packed_geometry_type_exp_t",
                        "type": "typedef",
                        "value": "uint8_t",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure data buffer element format",
                        "details": [
                            "Specifies the format of data buffer elements.",
                            "Data buffers may contain instancing transform matrices, triangle/quad vertex indices, etc..."
                        ],
                        "etors": [
                            {
                                "desc": "3-component float vector (see $x_rtas_float3_exp_t)",
                                "name": "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3",
                                "value": "0"
                            },
                            {
                                "desc": "3x4 affine transformation in column-major format (see $x_rtas_transform_float3x4_column_major_exp_t)",
                                "name": "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3X4_COLUMN_MAJOR",
                                "value": "1"
                            },
                            {
                                "desc": "3x4 affine transformation in column-major format (see $x_rtas_transform_float3x4_aligned_column_major_exp_t)",
                                "name": "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3X4_ALIGNED_COLUMN_MAJOR",
                                "value": "2"
                            },
                            {
                                "desc": "3x4 affine transformation in row-major format (see $x_rtas_transform_float3x4_row_major_exp_t)",
                                "name": "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3X4_ROW_MAJOR",
                                "value": "3"
                            },
                            {
                                "desc": "3-dimensional axis-aligned bounding-box (see $x_rtas_aabb_exp_t)",
                                "name": "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_AABB",
                                "value": "4"
                            },
                            {
                                "desc": "Unsigned 32-bit triangle indices (see $x_rtas_triangle_indices_uint32_exp_t)",
                                "name": "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_TRIANGLE_INDICES_UINT32",
                                "value": "5"
                            },
                            {
                                "desc": "Unsigned 32-bit quad indices (see $x_rtas_quad_indices_uint32_exp_t)",
                                "name": "$X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_QUAD_INDICES_UINT32",
                                "value": "6"
                            }
                        ],
                        "name": "$x_rtas_builder_input_data_format_exp_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Packed ray tracing acceleration structure data buffer element format (see $x_rtas_builder_input_data_format_exp_t)",
                        "name": "$x_rtas_builder_packed_input_data_format_exp_t",
                        "type": "typedef",
                        "value": "uint8_t",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Handle of ray tracing acceleration structure builder object",
                        "name": "$x_rtas_builder_exp_handle_t",
                        "type": "handle",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASParallelOperation",
                        "desc": "Handle of ray tracing acceleration structure builder parallel operation object",
                        "name": "$x_rtas_parallel_operation_exp_handle_t",
                        "type": "handle",
                        "version": "1.7"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure builder descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_RTAS_BUILDER_EXP_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] ray tracing acceleration structure builder version",
                                "name": "builderVersion",
                                "type": "$x_rtas_builder_exp_version_t"
                            }
                        ],
                        "name": "$x_rtas_builder_exp_desc_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure builder properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_RTAS_BUILDER_EXP_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] ray tracing acceleration structure builder flags",
                                "name": "flags",
                                "type": "$x_rtas_builder_exp_flags_t"
                            },
                            {
                                "desc": "[out] expected size (in bytes) required for acceleration structure buffer\n    - When using an acceleration structure buffer of this size, the build is expected to succeed; however, it is possible that the build may fail with $X_RESULT_EXP_RTAS_BUILD_RETRY\n",
                                "name": "rtasBufferSizeBytesExpected",
                                "type": "size_t"
                            },
                            {
                                "desc": "[out] worst-case size (in bytes) required for acceleration structure buffer\n    - When using an acceleration structure buffer of this size, the build is guaranteed to not run out of memory.\n",
                                "name": "rtasBufferSizeBytesMaxRequired",
                                "type": "size_t"
                            },
                            {
                                "desc": "[out] scratch buffer size (in bytes) required for acceleration structure build.",
                                "name": "scratchBufferSizeBytes",
                                "type": "size_t"
                            }
                        ],
                        "name": "$x_rtas_builder_exp_properties_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xRTASParallelOperation",
                        "desc": "Ray tracing acceleration structure builder parallel operation properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_RTAS_PARALLEL_OPERATION_EXP_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] ray tracing acceleration structure builder parallel operation flags",
                                "name": "flags",
                                "type": "$x_rtas_parallel_operation_exp_flags_t"
                            },
                            {
                                "desc": "[out] maximum number of threads that may join the parallel operation",
                                "name": "maxConcurrency",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_rtas_parallel_operation_exp_properties_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "base": "$x_base_properties_t",
                        "class": "$xDevice",
                        "desc": "Ray tracing acceleration structure device properties",
                        "details": [
                            "This structure may be passed to $xDeviceGetProperties, via `pNext` member of $x_device_properties_t.",
                            "The implementation shall populate `format` with a value other than $X_RTAS_FORMAT_EXP_INVALID when the device supports ray tracing."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_RTAS_DEVICE_EXP_PROPERTIES",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] ray tracing acceleration structure device flags",
                                "name": "flags",
                                "type": "$x_rtas_device_exp_flags_t"
                            },
                            {
                                "desc": "[out] ray tracing acceleration structure format",
                                "name": "rtasFormat",
                                "type": "$x_rtas_format_exp_t"
                            },
                            {
                                "desc": "[out] required alignment of acceleration structure buffer",
                                "name": "rtasBufferAlignment",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_rtas_device_exp_properties_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "desc": "A 3-component vector type",
                        "members": [
                            {
                                "desc": "[in] x-coordinate of float3 vector",
                                "name": "x",
                                "type": "float"
                            },
                            {
                                "desc": "[in] y-coordinate of float3 vector",
                                "name": "y",
                                "type": "float"
                            },
                            {
                                "desc": "[in] z-coordinate of float3 vector",
                                "name": "z",
                                "type": "float"
                            }
                        ],
                        "name": "$x_rtas_float3_exp_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "desc": "3x4 affine transformation in column-major layout",
                        "details": [
                            "A 3x4 affine transformation in column major layout, consisting of vectors\n    - vx=(vx_x, vx_y, vx_z),\n    - vy=(vy_x, vy_y, vy_z),\n    - vz=(vz_x, vz_y, vz_z), and\n    - p=(p_x, p_y, p_z)\n",
                            "The transformation transforms a point (x, y, z) to: `x*vx + y*vy + z*vz + p`."
                        ],
                        "members": [
                            {
                                "desc": "[in] element 0 of column 0 of 3x4 matrix",
                                "name": "vx_x",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 1 of column 0 of 3x4 matrix",
                                "name": "vx_y",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 2 of column 0 of 3x4 matrix",
                                "name": "vx_z",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 0 of column 1 of 3x4 matrix",
                                "name": "vy_x",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 1 of column 1 of 3x4 matrix",
                                "name": "vy_y",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 2 of column 1 of 3x4 matrix",
                                "name": "vy_z",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 0 of column 2 of 3x4 matrix",
                                "name": "vz_x",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 1 of column 2 of 3x4 matrix",
                                "name": "vz_y",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 2 of column 2 of 3x4 matrix",
                                "name": "vz_z",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 0 of column 3 of 3x4 matrix",
                                "name": "p_x",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 1 of column 3 of 3x4 matrix",
                                "name": "p_y",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 2 of column 3 of 3x4 matrix",
                                "name": "p_z",
                                "type": "float"
                            }
                        ],
                        "name": "$x_rtas_transform_float3x4_column_major_exp_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "desc": "3x4 affine transformation in column-major layout with aligned column vectors",
                        "details": [
                            "A 3x4 affine transformation in column major layout, consisting of vectors\n  - vx=(vx_x, vx_y, vx_z),\n  - vy=(vy_x, vy_y, vy_z),\n  - vz=(vz_x, vz_y, vz_z), and\n  - p=(p_x, p_y, p_z)\n",
                            "The transformation transforms a point (x, y, z) to: `x*vx + y*vy + z*vz + p`.",
                            "The column vectors are aligned to 16-bytes and pad members are ignored."
                        ],
                        "members": [
                            {
                                "desc": "[in] element 0 of column 0 of 3x4 matrix",
                                "name": "vx_x",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 1 of column 0 of 3x4 matrix",
                                "name": "vx_y",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 2 of column 0 of 3x4 matrix",
                                "name": "vx_z",
                                "type": "float"
                            },
                            {
                                "desc": "[in] ignored padding",
                                "name": "pad0",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 0 of column 1 of 3x4 matrix",
                                "name": "vy_x",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 1 of column 1 of 3x4 matrix",
                                "name": "vy_y",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 2 of column 1 of 3x4 matrix",
                                "name": "vy_z",
                                "type": "float"
                            },
                            {
                                "desc": "[in] ignored padding",
                                "name": "pad1",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 0 of column 2 of 3x4 matrix",
                                "name": "vz_x",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 1 of column 2 of 3x4 matrix",
                                "name": "vz_y",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 2 of column 2 of 3x4 matrix",
                                "name": "vz_z",
                                "type": "float"
                            },
                            {
                                "desc": "[in] ignored padding",
                                "name": "pad2",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 0 of column 3 of 3x4 matrix",
                                "name": "p_x",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 1 of column 3 of 3x4 matrix",
                                "name": "p_y",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 2 of column 3 of 3x4 matrix",
                                "name": "p_z",
                                "type": "float"
                            },
                            {
                                "desc": "[in] ignored padding",
                                "name": "pad3",
                                "type": "float"
                            }
                        ],
                        "name": "$x_rtas_transform_float3x4_aligned_column_major_exp_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "desc": "3x4 affine transformation in row-major layout",
                        "details": [
                            "A 3x4 affine transformation in row-major layout, consisting of vectors\n    - vx=(vx_x, vx_y, vx_z),\n    - vy=(vy_x, vy_y, vy_z),\n    - vz=(vz_x, vz_y, vz_z), and\n    - p=(p_x, p_y, p_z)\n",
                            "The transformation transforms a point (x, y, z) to: `x*vx + y*vy + z*vz + p`."
                        ],
                        "members": [
                            {
                                "desc": "[in] element 0 of row 0 of 3x4 matrix",
                                "name": "vx_x",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 1 of row 0 of 3x4 matrix",
                                "name": "vy_x",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 2 of row 0 of 3x4 matrix",
                                "name": "vz_x",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 3 of row 0 of 3x4 matrix",
                                "name": "p_x",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 0 of row 1 of 3x4 matrix",
                                "name": "vx_y",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 1 of row 1 of 3x4 matrix",
                                "name": "vy_y",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 2 of row 1 of 3x4 matrix",
                                "name": "vz_y",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 3 of row 1 of 3x4 matrix",
                                "name": "p_y",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 0 of row 2 of 3x4 matrix",
                                "name": "vx_z",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 1 of row 2 of 3x4 matrix",
                                "name": "vy_z",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 2 of row 2 of 3x4 matrix",
                                "name": "vz_z",
                                "type": "float"
                            },
                            {
                                "desc": "[in] element 3 of row 2 of 3x4 matrix",
                                "name": "p_z",
                                "type": "float"
                            }
                        ],
                        "name": "$x_rtas_transform_float3x4_row_major_exp_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "desc": "A 3-dimensional axis-aligned bounding-box with lower and upper bounds in each dimension",
                        "members": [
                            {
                                "desc": "[in] lower bounds of AABB",
                                "name": "lower",
                                "type": "$x_rtas_float3_exp_t"
                            },
                            {
                                "desc": "[in] upper bounds of AABB",
                                "name": "upper",
                                "type": "$x_rtas_float3_exp_t"
                            }
                        ],
                        "name": "$x_rtas_aabb_exp_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "desc": "Triangle represented using 3 vertex indices",
                        "details": [
                            "Represents a triangle using 3 vertex indices that index into a vertex array that needs to be provided together with the index array.",
                            "The linear barycentric u/v parametrization of the triangle is defined as:\n    - (u=0, v=0) at v0,\n    - (u=1, v=0) at v1, and\n    - (u=0, v=1) at v2\n"
                        ],
                        "members": [
                            {
                                "desc": "[in] first index pointing to the first triangle vertex in vertex array",
                                "name": "v0",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] second index pointing to the second triangle vertex in vertex array",
                                "name": "v1",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] third index pointing to the third triangle vertex in vertex array",
                                "name": "v2",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_rtas_triangle_indices_uint32_exp_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "desc": "Quad represented using 4 vertex indices",
                        "details": [
                            "Represents a quad composed of 4 indices that index into a vertex array that needs to be provided together with the index array.",
                            "A quad is a triangle pair represented using 4 vertex indices v0, v1, v2, v3.\nThe first triangle is made out of indices v0, v1, v3 and the second triangle\nfrom indices v2, v3, v1. The piecewise linear barycentric u/v parametrization\nof the quad is defined as:\n    - (u=0, v=0) at v0,\n    - (u=1, v=0) at v1,\n    - (u=0, v=1) at v3, and\n    - (u=1, v=1) at v2\nThis is achieved by correcting the u'/v' coordinates of the second triangle by\n*u = 1-u'* and *v = 1-v'*, yielding a piecewise linear parametrization.\n"
                        ],
                        "members": [
                            {
                                "desc": "[in] first index pointing to the first quad vertex in vertex array",
                                "name": "v0",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] second index pointing to the second quad vertex in vertex array",
                                "name": "v1",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] third index pointing to the third quad vertex in vertex array",
                                "name": "v2",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] fourth index pointing to the fourth quad vertex in vertex array",
                                "name": "v3",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_rtas_quad_indices_uint32_exp_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure builder geometry info",
                        "members": [
                            {
                                "desc": "[in] geometry type",
                                "name": "geometryType",
                                "type": "$x_rtas_builder_packed_geometry_type_exp_t"
                            }
                        ],
                        "name": "$x_rtas_builder_geometry_info_exp_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure builder triangle mesh geometry info",
                        "details": [
                            "The linear barycentric u/v parametrization of the triangle is defined as:\n    - (u=0, v=0) at v0,\n    - (u=1, v=0) at v1, and\n    - (u=0, v=1) at v2\n"
                        ],
                        "members": [
                            {
                                "desc": "[in] geometry type, must be $X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_TRIANGLES",
                                "name": "geometryType",
                                "type": "$x_rtas_builder_packed_geometry_type_exp_t"
                            },
                            {
                                "desc": "[in] 0 or some combination of $x_rtas_builder_geometry_exp_flag_t bits representing the geometry flags for all primitives of this geometry",
                                "name": "geometryFlags",
                                "type": "$x_rtas_builder_packed_geometry_exp_flags_t"
                            },
                            {
                                "desc": "[in] 8-bit geometry mask for ray masking",
                                "name": "geometryMask",
                                "type": "uint8_t"
                            },
                            {
                                "desc": "[in] format of triangle buffer data, must be $X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_TRIANGLE_INDICES_UINT32",
                                "name": "triangleFormat",
                                "type": "$x_rtas_builder_packed_input_data_format_exp_t"
                            },
                            {
                                "desc": "[in] format of vertex buffer data, must be $X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3",
                                "name": "vertexFormat",
                                "type": "$x_rtas_builder_packed_input_data_format_exp_t"
                            },
                            {
                                "desc": "[in] number of triangles in triangle buffer",
                                "name": "triangleCount",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] number of vertices in vertex buffer",
                                "name": "vertexCount",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] stride (in bytes) of triangles in triangle buffer",
                                "name": "triangleStride",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] stride (in bytes) of vertices in vertex buffer",
                                "name": "vertexStride",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] pointer to array of triangle indices in specified format",
                                "name": "pTriangleBuffer",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] pointer to array of triangle vertices in specified format",
                                "name": "pVertexBuffer",
                                "type": "void*"
                            }
                        ],
                        "name": "$x_rtas_builder_triangles_geometry_info_exp_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure builder quad mesh geometry info",
                        "details": [
                            "A quad is a triangle pair represented using 4 vertex indices v0, v1, v2, v3.\nThe first triangle is made out of indices v0, v1, v3 and the second triangle\nfrom indices v2, v3, v1. The piecewise linear barycentric u/v parametrization\nof the quad is defined as:\n    - (u=0, v=0) at v0,\n    - (u=1, v=0) at v1,\n    - (u=0, v=1) at v3, and\n    - (u=1, v=1) at v2\nThis is achieved by correcting the u'/v' coordinates of the second triangle by\n*u = 1-u'* and *v = 1-v'*, yielding a piecewise linear parametrization.\n"
                        ],
                        "members": [
                            {
                                "desc": "[in] geometry type, must be $X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_QUADS",
                                "name": "geometryType",
                                "type": "$x_rtas_builder_packed_geometry_type_exp_t"
                            },
                            {
                                "desc": "[in] 0 or some combination of $x_rtas_builder_geometry_exp_flag_t bits representing the geometry flags for all primitives of this geometry",
                                "name": "geometryFlags",
                                "type": "$x_rtas_builder_packed_geometry_exp_flags_t"
                            },
                            {
                                "desc": "[in] 8-bit geometry mask for ray masking",
                                "name": "geometryMask",
                                "type": "uint8_t"
                            },
                            {
                                "desc": "[in] format of quad buffer data, must be $X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_QUAD_INDICES_UINT32",
                                "name": "quadFormat",
                                "type": "$x_rtas_builder_packed_input_data_format_exp_t"
                            },
                            {
                                "desc": "[in] format of vertex buffer data, must be $X_RTAS_BUILDER_INPUT_DATA_FORMAT_EXP_FLOAT3",
                                "name": "vertexFormat",
                                "type": "$x_rtas_builder_packed_input_data_format_exp_t"
                            },
                            {
                                "desc": "[in] number of quads in quad buffer",
                                "name": "quadCount",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] number of vertices in vertex buffer",
                                "name": "vertexCount",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] stride (in bytes) of quads in quad buffer",
                                "name": "quadStride",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] stride (in bytes) of vertices in vertex buffer",
                                "name": "vertexStride",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] pointer to array of quad indices in specified format",
                                "name": "pQuadBuffer",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] pointer to array of quad vertices in specified format",
                                "name": "pVertexBuffer",
                                "type": "void*"
                            }
                        ],
                        "name": "$x_rtas_builder_quads_geometry_info_exp_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "base": "$x_base_cb_params_t",
                        "desc": "AABB callback function parameters",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_RTAS_GEOMETRY_AABBS_EXP_CB_PARAMS",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] first primitive to return bounds for",
                                "name": "primID",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] number of primitives to return bounds for",
                                "name": "primIDCount",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] pointer provided through geometry descriptor",
                                "name": "pGeomUserPtr",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] pointer provided through $xRTASBuilderBuildExp function",
                                "name": "pBuildUserPtr",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] destination buffer to write AABB bounds to",
                                "name": "pBoundsOut",
                                "type": "$x_rtas_aabb_exp_t*"
                            }
                        ],
                        "name": "$x_rtas_geometry_aabbs_exp_cb_params_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "desc": "Callback function pointer type to return AABBs for a range of procedural primitives",
                        "name": "$x_rtas_geometry_aabbs_cb_exp_t",
                        "params": [
                            {
                                "desc": "[in] callback function parameters structure",
                                "name": "params",
                                "type": "$x_rtas_geometry_aabbs_exp_cb_params_t*"
                            }
                        ],
                        "returntype": "void",
                        "type": "callback",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure builder procedural primitives geometry info",
                        "details": [
                            "A host-side bounds callback function is invoked by the acceleration structure builder to query the bounds of procedural primitives on demand. The callback is passed some `pGeomUserPtr` that can point to an application-side representation of the procedural primitives. Further, a second `pBuildUserPtr`, which is set by a parameter to $xRTASBuilderBuildExp, is passed to the callback. This allows the build to change the bounds of the procedural geometry, for example, to build a BVH only over a short time range to implement multi-segment motion blur.\n"
                        ],
                        "members": [
                            {
                                "desc": "[in] geometry type, must be $X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_PROCEDURAL",
                                "name": "geometryType",
                                "type": "$x_rtas_builder_packed_geometry_type_exp_t"
                            },
                            {
                                "desc": "[in] 0 or some combination of $x_rtas_builder_geometry_exp_flag_t bits representing the geometry flags for all primitives of this geometry",
                                "name": "geometryFlags",
                                "type": "$x_rtas_builder_packed_geometry_exp_flags_t"
                            },
                            {
                                "desc": "[in] 8-bit geometry mask for ray masking",
                                "name": "geometryMask",
                                "type": "uint8_t"
                            },
                            {
                                "desc": "[in] reserved for future use",
                                "name": "reserved",
                                "type": "uint8_t"
                            },
                            {
                                "desc": "[in] number of primitives in geometry",
                                "name": "primCount",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] pointer to callback function to get the axis-aligned bounding-box for a range of primitives",
                                "name": "pfnGetBoundsCb",
                                "type": "$x_rtas_geometry_aabbs_cb_exp_t"
                            },
                            {
                                "desc": "[in] user data pointer passed to callback",
                                "name": "pGeomUserPtr",
                                "type": "void*"
                            }
                        ],
                        "name": "$x_rtas_builder_procedural_geometry_info_exp_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Ray tracing acceleration structure builder instance geometry info",
                        "members": [
                            {
                                "desc": "[in] geometry type, must be $X_RTAS_BUILDER_GEOMETRY_TYPE_EXP_INSTANCE",
                                "name": "geometryType",
                                "type": "$x_rtas_builder_packed_geometry_type_exp_t"
                            },
                            {
                                "desc": "[in] 0 or some combination of $x_rtas_builder_geometry_exp_flag_t bits representing the geometry flags for all primitives of this geometry",
                                "name": "instanceFlags",
                                "type": "$x_rtas_builder_packed_instance_exp_flags_t"
                            },
                            {
                                "desc": "[in] 8-bit geometry mask for ray masking",
                                "name": "geometryMask",
                                "type": "uint8_t"
                            },
                            {
                                "desc": "[in] format of the specified transformation",
                                "name": "transformFormat",
                                "type": "$x_rtas_builder_packed_input_data_format_exp_t"
                            },
                            {
                                "desc": "[in] user-specified identifier for the instance",
                                "name": "instanceUserID",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] object-to-world instance transformation in specified format",
                                "name": "pTransform",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] object-space axis-aligned bounding-box of the instanced acceleration structure",
                                "name": "pBounds",
                                "type": "$x_rtas_aabb_exp_t*"
                            },
                            {
                                "desc": "[in] pointer to acceleration structure to instantiate",
                                "name": "pAccelerationStructure",
                                "type": "void*"
                            }
                        ],
                        "name": "$x_rtas_builder_instance_geometry_info_exp_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "base": "$x_base_desc_t",
                        "class": "$xRTASBuilder",
                        "desc": "",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$X_STRUCTURE_TYPE_RTAS_BUILDER_BUILD_OP_EXP_DESC",
                                "name": "stype",
                                "type": "$x_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] ray tracing acceleration structure format",
                                "name": "rtasFormat",
                                "type": "$x_rtas_format_exp_t"
                            },
                            {
                                "desc": "[in] acceleration structure build quality hint",
                                "name": "buildQuality",
                                "type": "$x_rtas_builder_build_quality_hint_exp_t"
                            },
                            {
                                "desc": "[in] 0 or some combination of $x_rtas_builder_build_op_exp_flag_t flags",
                                "name": "buildFlags",
                                "type": "$x_rtas_builder_build_op_exp_flags_t"
                            },
                            {
                                "desc": "[in][optional][range(0, `numGeometries`)] NULL or a valid array of pointers to geometry infos",
                                "name": "ppGeometries",
                                "type": "const $x_rtas_builder_geometry_info_exp_t**"
                            },
                            {
                                "desc": "[in] number of geometries in geometry infos array, can be zero when `ppGeometries` is NULL",
                                "name": "numGeometries",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$x_rtas_builder_build_op_exp_desc_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Creates a ray tracing acceleration structure builder object",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe.",
                            "The implementation must support $X_experimental_rtas_builder extension."
                        ],
                        "hash": "b9edbe7d1662437360cf8c34f86c7597cce02a9b16871169915c3f336590b5d2",
                        "name": "CreateExp",
                        "params": [
                            {
                                "desc": "[in] handle of driver object",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in] pointer to builder descriptor",
                                "name": "pDescriptor",
                                "type": "const $x_rtas_builder_exp_desc_t*"
                            },
                            {
                                "desc": "[out] handle of builder object",
                                "name": "phBuilder",
                                "type": "$x_rtas_builder_exp_handle_t*"
                            }
                        ],
                        "results": [
                            {
                                "$X_RESULT_ERROR_DEPENDENCY_UNAVAILABLE": [
                                    "Runtime dependency failed to load"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_VERSION": [
                                    "Requested version passed in via descriptor is unavailable or not supported by driver"
                                ]
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pDescriptor`",
                                    "`nullptr == phBuilder`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$X_RTAS_BUILDER_EXP_VERSION_CURRENT < pDescriptor->builderVersion`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Retrieves ray tracing acceleration structure builder properties",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "b29cb765e7e65f033b6c19af26626a6a8e39e8bb4f86361a8315f9c7c42c413a",
                        "name": "GetBuildPropertiesExp",
                        "params": [
                            {
                                "desc": "[in] handle of builder object",
                                "name": "hBuilder",
                                "type": "$x_rtas_builder_exp_handle_t"
                            },
                            {
                                "desc": "[in] pointer to build operation descriptor",
                                "name": "pBuildOpDescriptor",
                                "type": "const $x_rtas_builder_build_op_exp_desc_t*"
                            },
                            {
                                "desc": "[in,out] query result for builder properties",
                                "name": "pProperties",
                                "type": "$x_rtas_builder_exp_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hBuilder`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pBuildOpDescriptor`",
                                    "`nullptr == pProperties`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$X_RTAS_FORMAT_EXP_INVALID < pBuildOpDescriptor->rtasFormat`",
                                    "`$X_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_HIGH < pBuildOpDescriptor->buildQuality`",
                                    "`0x3 < pBuildOpDescriptor->buildFlags`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "class": "$xDriver",
                        "desc": "Checks ray tracing acceleration structure format compatibility",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "1bedf76c353eb5fb199eb3f1a0366cc5c376199b7f36771c72a08c54181d1a53",
                        "name": "RTASFormatCompatibilityCheckExp",
                        "params": [
                            {
                                "desc": "[in] handle of driver object",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in] operand A",
                                "name": "rtasFormatA",
                                "type": "$x_rtas_format_exp_t"
                            },
                            {
                                "desc": "[in] operand B",
                                "name": "rtasFormatB",
                                "type": "$x_rtas_format_exp_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$X_RTAS_FORMAT_EXP_INVALID < rtasFormatA`",
                                    "`$X_RTAS_FORMAT_EXP_INVALID < rtasFormatB`"
                                ]
                            },
                            {
                                "$X_RESULT_SUCCESS": [
                                    "An acceleration structure built with `rtasFormatA` is compatible with devices that report `rtasFormatB`."
                                ]
                            },
                            {
                                "$X_RESULT_EXP_ERROR_OPERANDS_INCOMPATIBLE": [
                                    "An acceleration structure built with `rtasFormatA` is **not** compatible with devices that report `rtasFormatB`."
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Build ray tracing acceleration structure",
                        "details": [
                            "This function builds an acceleration structure of the scene consisting of the specified geometry information and writes the acceleration structure to the provided destination buffer. All types of geometries can get freely mixed inside a scene.\n",
                            "It is the user's responsibility to manage the acceleration structure buffer allocation, de-allocation, and potential prefetching to the device memory. The required size of the acceleration structure buffer can be queried with the $xRTASBuilderGetBuildPropertiesExp function. The acceleration structure buffer must be a shared USM allocation and should be present on the host at build time. The referenced scene data (index- and vertex- buffers) can be standard host allocations, and will not be referenced into by the build acceleration structure.\n",
                            "Before an acceleration structure can be built, the user must allocate the memory for the acceleration structure buffer and scratch buffer using sizes based on a query for the estimated size properties.\n",
                            "When using the \"worst-case\" size for the acceleration structure buffer, the acceleration structure construction will never fail with $X_RESULT_EXP_RTAS_BUILD_RETRY.\n",
                            "When using the \"expected\" size for the acceleration structure buffer, the acceleration structure construction may fail with $X_RESULT_EXP_RTAS_BUILD_RETRY. If this happens, the user may resize their acceleration structure buffer using the returned `*pRtasBufferSizeBytes` value, which will be updated with an improved size estimate that will likely result in a successful build.\n",
                            "The acceleration structure construction is run on the host and is synchronous, thus after the function returns with a successful result, the acceleration structure may be used.\n",
                            "All provided data buffers must be host-accessible.\n",
                            "The acceleration structure buffer must be a USM allocation.\n",
                            "A successfully constructed acceleration structure is entirely self-contained. There is no requirement for input data to persist beyond build completion.\n",
                            "A successfully constructed acceleration structure is non-copyable.\n",
                            "Acceleration structure construction may be parallelized by passing a valid handle to a parallel operation object and joining that parallel operation using $xRTASParallelOperationJoinExp with user-provided worker threads.\n",
                            "**Additional Notes**\n  - \"The geometry infos array, geometry infos, and scratch buffer must all be standard host memory allocations.\"\n  - \"A pointer to a geometry info can be a null pointer, in which case the geometry is treated as empty.\"\n  - \"If no parallel operation handle is provided, the build is run sequentially on the current thread.\"\n  - \"A parallel operation object may only be associated with a single acceleration structure build at a time.\"\n"
                        ],
                        "hash": "1af60f3a2043a55be18e8aa51ba5f1c4728144ab861978a1fbfd6dbe6b388b62",
                        "name": "BuildExp",
                        "params": [
                            {
                                "desc": "[in] handle of builder object",
                                "name": "hBuilder",
                                "type": "$x_rtas_builder_exp_handle_t"
                            },
                            {
                                "desc": "[in] pointer to build operation descriptor",
                                "name": "pBuildOpDescriptor",
                                "type": "const $x_rtas_builder_build_op_exp_desc_t*"
                            },
                            {
                                "desc": "[in][range(0, `scratchBufferSizeBytes`)] scratch buffer to be used during acceleration structure construction",
                                "name": "pScratchBuffer",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] size of scratch buffer, in bytes",
                                "name": "scratchBufferSizeBytes",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] pointer to destination buffer",
                                "name": "pRtasBuffer",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] destination buffer size, in bytes",
                                "name": "rtasBufferSizeBytes",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in][optional] handle to parallel operation object",
                                "name": "hParallelOperation",
                                "type": "$x_rtas_parallel_operation_exp_handle_t"
                            },
                            {
                                "desc": "[in][optional] pointer passed to callbacks",
                                "name": "pBuildUserPtr",
                                "type": "void*"
                            },
                            {
                                "desc": "[in,out][optional] pointer to destination address for acceleration structure bounds",
                                "name": "pBounds",
                                "type": "$x_rtas_aabb_exp_t*"
                            },
                            {
                                "desc": "[out][optional] updated acceleration structure size requirement, in bytes",
                                "name": "pRtasBufferSizeBytes",
                                "type": "size_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hBuilder`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pBuildOpDescriptor`",
                                    "`nullptr == pScratchBuffer`",
                                    "`nullptr == pRtasBuffer`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$X_RTAS_FORMAT_EXP_INVALID < pBuildOpDescriptor->rtasFormat`",
                                    "`$X_RTAS_BUILDER_BUILD_QUALITY_HINT_EXP_HIGH < pBuildOpDescriptor->buildQuality`",
                                    "`0x3 < pBuildOpDescriptor->buildFlags`"
                                ]
                            },
                            {
                                "$X_RESULT_EXP_RTAS_BUILD_DEFERRED": [
                                    "Acceleration structure build completion is deferred to parallel operation join."
                                ]
                            },
                            {
                                "$X_RESULT_EXP_RTAS_BUILD_RETRY": [
                                    "Acceleration structure build failed due to insufficient resources, retry the build operation with a larger acceleration structure buffer allocation."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": [
                                    "Acceleration structure build failed due to parallel operation object participation in another build operation."
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASBuilder",
                        "desc": "Destroys a ray tracing acceleration structure builder object",
                        "details": [
                            "The implementation of this function may immediately release any internal Host and Device resources associated with this builder.",
                            "The application must **not** call this function from simultaneous threads with the same builder handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "6ae198a578d0ee18651112d3f40623128f3c3fb5d5dcab898bf842204fb1f86d",
                        "name": "DestroyExp",
                        "params": [
                            {
                                "desc": "[in][release] handle of builder object to destroy",
                                "name": "hBuilder",
                                "type": "$x_rtas_builder_exp_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hBuilder`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASParallelOperation",
                        "desc": "Creates a ray tracing acceleration structure builder parallel operation object",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe.",
                            "The implementation must support $X_experimental_rtas_builder extension."
                        ],
                        "hash": "324930a8492161bf3d335c6e360038a06bea8600cf15aec51610993fedc165e4",
                        "name": "CreateExp",
                        "params": [
                            {
                                "desc": "[in] handle of driver object",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[out] handle of parallel operation object",
                                "name": "phParallelOperation",
                                "type": "$x_rtas_parallel_operation_exp_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phParallelOperation`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASParallelOperation",
                        "desc": "Retrieves ray tracing acceleration structure builder parallel operation properties",
                        "details": [
                            "The application must first bind the parallel operation object to a build operation before it may query the parallel operation properties. In other words, the application must first call $xRTASBuilderBuildExp with **hParallelOperation** before calling this function.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "7f52d48c631cdad4d5d9f6e9bfa9ba6bf2567c0d9f00637d921a927df1e0b279",
                        "name": "GetPropertiesExp",
                        "params": [
                            {
                                "desc": "[in] handle of parallel operation object",
                                "name": "hParallelOperation",
                                "type": "$x_rtas_parallel_operation_exp_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for parallel operation properties",
                                "name": "pProperties",
                                "type": "$x_rtas_parallel_operation_exp_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hParallelOperation`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASParallelOperation",
                        "desc": "Joins a parallel build operation",
                        "details": [
                            "All worker threads return the same error code for the parallel build operation upon build completion"
                        ],
                        "hash": "9af290b29e7178a88fb88802c8ba03e7259de678f3b672f657f522c70bad9cc1",
                        "name": "JoinExp",
                        "params": [
                            {
                                "desc": "[in] handle of parallel operation object",
                                "name": "hParallelOperation",
                                "type": "$x_rtas_parallel_operation_exp_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hParallelOperation`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "class": "$xRTASParallelOperation",
                        "desc": "Destroys a ray tracing acceleration structure builder parallel operation object",
                        "details": [
                            "The implementation of this function may immediately release any internal Host and Device resources associated with this parallel operation.",
                            "The application must **not** call this function from simultaneous threads with the same parallel operation handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "1371aca73bc98168b52b7ef394df4034d67304927b620cd3199fda16fcf3082b",
                        "name": "DestroyExp",
                        "params": [
                            {
                                "desc": "[in][release] handle of parallel operation object to destroy",
                                "name": "hParallelOperation",
                                "type": "$x_rtas_parallel_operation_exp_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hParallelOperation`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    }
                ]
            }
        ],
        [
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool API common types",
                    "ordinal": 0,
                    "type": "header"
                },
                "name": "common",
                "objects": [
                    {
                        "alias": "$x_driver_handle_t",
                        "class": "$tDriver",
                        "desc": "Handle to a driver instance",
                        "name": "$t_driver_handle_t",
                        "type": "handle"
                    },
                    {
                        "alias": "$x_device_handle_t",
                        "class": "$tDevice",
                        "desc": "Handle of device object",
                        "name": "$t_device_handle_t",
                        "type": "handle"
                    },
                    {
                        "alias": "$x_context_handle_t",
                        "class": "$tContext",
                        "desc": "Handle of context object",
                        "name": "$t_context_handle_t",
                        "type": "handle"
                    },
                    {
                        "alias": "$x_command_list_handle_t",
                        "class": "$tCommandList",
                        "desc": "Handle of command list object",
                        "name": "$t_command_list_handle_t",
                        "type": "handle"
                    },
                    {
                        "alias": "$x_module_handle_t",
                        "class": "$tModule",
                        "desc": "Handle of module object",
                        "name": "$t_module_handle_t",
                        "type": "handle"
                    },
                    {
                        "alias": "$x_kernel_handle_t",
                        "class": "$tKernel",
                        "desc": "Handle of function object",
                        "name": "$t_kernel_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$tMetricGroup",
                        "desc": "Handle of metric group's object",
                        "name": "$t_metric_group_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$tMetric",
                        "desc": "Handle of metric's object",
                        "name": "$t_metric_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$tMetricStreamer",
                        "desc": "Handle of metric streamer's object",
                        "name": "$t_metric_streamer_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$tMetricQueryPool",
                        "desc": "Handle of metric query pool's object",
                        "name": "$t_metric_query_pool_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$tMetricQuery",
                        "desc": "Handle of metric query's object",
                        "name": "$t_metric_query_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$tTracerExp",
                        "desc": "Handle of tracer object",
                        "name": "$t_tracer_exp_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Debug session handle",
                        "name": "$t_debug_session_handle_t",
                        "type": "handle"
                    },
                    {
                        "desc": "Defines structure types",
                        "etors": [
                            {
                                "desc": "$t_metric_group_properties_t",
                                "name": "$T_STRUCTURE_TYPE_METRIC_GROUP_PROPERTIES",
                                "value": "0x1"
                            },
                            {
                                "desc": "$t_metric_properties_t",
                                "name": "$T_STRUCTURE_TYPE_METRIC_PROPERTIES",
                                "value": "0x2"
                            },
                            {
                                "desc": "$t_metric_streamer_desc_t",
                                "name": "$T_STRUCTURE_TYPE_METRIC_STREAMER_DESC",
                                "value": "0x3"
                            },
                            {
                                "desc": "$t_metric_query_pool_desc_t",
                                "name": "$T_STRUCTURE_TYPE_METRIC_QUERY_POOL_DESC",
                                "value": "0x4"
                            },
                            {
                                "desc": "$t_profile_properties_t",
                                "name": "$T_STRUCTURE_TYPE_PROFILE_PROPERTIES",
                                "value": "0x5"
                            },
                            {
                                "desc": "$t_device_debug_properties_t",
                                "name": "$T_STRUCTURE_TYPE_DEVICE_DEBUG_PROPERTIES",
                                "value": "0x6"
                            },
                            {
                                "desc": "$t_debug_memory_space_desc_t",
                                "name": "$T_STRUCTURE_TYPE_DEBUG_MEMORY_SPACE_DESC",
                                "value": "0x7"
                            },
                            {
                                "desc": "$t_debug_regset_properties_t",
                                "name": "$T_STRUCTURE_TYPE_DEBUG_REGSET_PROPERTIES",
                                "value": "0x8"
                            },
                            {
                                "desc": "$t_metric_global_timestamps_resolution_exp_t. Deprecated, use $T_STRUCTURE_TYPE_METRIC_GLOBAL_TIMESTAMPS_RESOLUTION_EXP.",
                                "name": "$T_STRUCTURE_TYPE_GLOBAL_METRICS_TIMESTAMPS_EXP_PROPERTIES",
                                "value": "0x9",
                                "version": "1.5"
                            },
                            {
                                "desc": "$t_metric_global_timestamps_resolution_exp_t",
                                "name": "$T_STRUCTURE_TYPE_METRIC_GLOBAL_TIMESTAMPS_RESOLUTION_EXP",
                                "value": "0x9",
                                "version": "1.7"
                            },
                            {
                                "desc": "$t_tracer_exp_desc_t",
                                "name": "$T_STRUCTURE_TYPE_TRACER_EXP_DESC",
                                "value": "0x00010001"
                            },
                            {
                                "desc": "$t_metric_calculate_exp_desc_t. Deprecated, use $T_STRUCTURE_TYPE_METRIC_CALCULATE_EXP_DESC.",
                                "name": "$T_STRUCTURE_TYPE_METRICS_CALCULATE_EXP_DESC",
                                "value": "0x00010002",
                                "version": "1.6"
                            },
                            {
                                "desc": "$t_metric_calculate_exp_desc_t",
                                "name": "$T_STRUCTURE_TYPE_METRIC_CALCULATE_EXP_DESC",
                                "value": "0x00010002",
                                "version": "1.7"
                            }
                        ],
                        "name": "$t_structure_type_t",
                        "type": "enum"
                    },
                    {
                        "desc": "Base for all properties types",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "name": "stype",
                                "type": "$t_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            }
                        ],
                        "name": "$t_base_properties_t",
                        "type": "struct"
                    },
                    {
                        "desc": "Base for all descriptor types",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "name": "stype",
                                "type": "$t_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            }
                        ],
                        "name": "$t_base_desc_t",
                        "type": "struct"
                    },
                    {
                        "desc": "Supported value types",
                        "etors": [
                            {
                                "desc": "32-bit unsigned-integer",
                                "name": "$T_VALUE_TYPE_UINT32",
                                "value": "0"
                            },
                            {
                                "desc": "64-bit unsigned-integer",
                                "name": "$T_VALUE_TYPE_UINT64",
                                "value": "1"
                            },
                            {
                                "desc": "32-bit floating-point",
                                "name": "$T_VALUE_TYPE_FLOAT32",
                                "value": "2"
                            },
                            {
                                "desc": "64-bit floating-point",
                                "name": "$T_VALUE_TYPE_FLOAT64",
                                "value": "3"
                            },
                            {
                                "desc": "8-bit boolean",
                                "name": "$T_VALUE_TYPE_BOOL8",
                                "value": "4"
                            },
                            {
                                "desc": "C string",
                                "name": "$T_VALUE_TYPE_STRING",
                                "value": "5"
                            },
                            {
                                "desc": "8-bit unsigned-integer",
                                "name": "$T_VALUE_TYPE_UINT8",
                                "value": "6"
                            },
                            {
                                "desc": "16-bit unsigned-integer",
                                "name": "$T_VALUE_TYPE_UINT16",
                                "value": "7"
                            }
                        ],
                        "name": "$t_value_type_t",
                        "type": "enum"
                    },
                    {
                        "desc": "Union of values",
                        "members": [
                            {
                                "desc": "[out] 32-bit unsigned-integer",
                                "name": "ui32",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] 32-bit unsigned-integer",
                                "name": "ui64",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] 32-bit floating-point",
                                "name": "fp32",
                                "type": "float"
                            },
                            {
                                "desc": "[out] 64-bit floating-point",
                                "name": "fp64",
                                "type": "double"
                            },
                            {
                                "desc": "[out] 8-bit boolean",
                                "name": "b8",
                                "type": "$x_bool_t"
                            }
                        ],
                        "name": "$t_value_t",
                        "type": "union"
                    },
                    {
                        "desc": "Typed value",
                        "members": [
                            {
                                "desc": "[out] type of value",
                                "name": "type",
                                "type": "$t_value_type_t"
                            },
                            {
                                "desc": "[out] value",
                                "name": "value",
                                "type": "$t_value_t"
                            }
                        ],
                        "name": "$t_typed_value_t",
                        "type": "struct"
                    },
                    {
                        "category": "Driver",
                        "desc": "Enables driver instrumentation and dependencies for device metrics",
                        "name": "$T_ENABLE_METRICS",
                        "type": "env",
                        "values": "0, 1"
                    },
                    {
                        "category": "Driver",
                        "desc": "Enables driver instrumentation and dependencies for program instrumentation",
                        "name": "$T_ENABLE_PROGRAM_INSTRUMENTATION",
                        "type": "env",
                        "values": "0, 1"
                    },
                    {
                        "category": "Driver",
                        "desc": "Enables driver instrumentation and dependencies for program debugging",
                        "name": "$T_ENABLE_PROGRAM_DEBUGGING",
                        "type": "env",
                        "values": "0, 1"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for Device",
                    "ordinal": 2,
                    "type": "header"
                },
                "name": "device",
                "objects": [
                    {
                        "base": "$xDriver",
                        "desc": "C++ wrapper for driver instance",
                        "members": [],
                        "name": "$tDriver",
                        "type": "class"
                    },
                    {
                        "base": "$xDevice",
                        "desc": "C++ wrapper for device",
                        "members": [],
                        "name": "$tDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for Context",
                    "ordinal": 3,
                    "type": "header"
                },
                "name": "context",
                "objects": [
                    {
                        "base": "$xContext",
                        "desc": "C++ wrapper for context",
                        "members": [],
                        "name": "$tContext",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for Command List",
                    "ordinal": 5,
                    "type": "header"
                },
                "name": "cmdlist",
                "objects": [
                    {
                        "base": "$xCommandList",
                        "desc": "C++ wrapper for command list",
                        "members": [],
                        "name": "$tCommandList",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for Module",
                    "ordinal": 6,
                    "type": "header"
                },
                "name": "module",
                "objects": [
                    {
                        "class": "$tModule",
                        "desc": "Supported module debug info formats.",
                        "etors": [
                            {
                                "desc": "Format is ELF/DWARF",
                                "name": "$T_MODULE_DEBUG_INFO_FORMAT_ELF_DWARF",
                                "value": "0"
                            }
                        ],
                        "name": "$t_module_debug_info_format_t",
                        "type": "enum"
                    },
                    {
                        "class": "$tModule",
                        "desc": "Retrieve debug info from module.",
                        "details": [
                            "The caller can pass nullptr for pDebugInfo when querying only for size.",
                            "The implementation will copy the native binary into a buffer supplied by the caller.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "8cd9f86cd846e4d9733e3bc32027b2def4b4376df1cb35f5521f692a1ee88ecc",
                        "name": "GetDebugInfo",
                        "params": [
                            {
                                "desc": "[in] handle of the module",
                                "name": "hModule",
                                "type": "$t_module_handle_t"
                            },
                            {
                                "desc": "[in] debug info format requested",
                                "name": "format",
                                "type": "$t_module_debug_info_format_t"
                            },
                            {
                                "desc": "[in,out] size of debug info in bytes",
                                "name": "pSize",
                                "type": "size_t*"
                            },
                            {
                                "desc": "[in,out][optional] byte pointer to debug info",
                                "name": "pDebugInfo",
                                "type": "uint8_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hModule`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$T_MODULE_DEBUG_INFO_FORMAT_ELF_DWARF < format`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pSize`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "base": "$xModule",
                        "desc": "C++ wrapper for module",
                        "members": [],
                        "name": "$tModule",
                        "type": "class"
                    },
                    {
                        "base": "$xKernel",
                        "desc": "C++ wrapper for kernel",
                        "members": [],
                        "name": "$tKernel",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for Program Debug",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "debug",
                "objects": [
                    {
                        "class": "$tDevice",
                        "desc": "Supported device debug property flags",
                        "etors": [
                            {
                                "desc": "the device supports attaching for debug",
                                "name": "$T_DEVICE_DEBUG_PROPERTY_FLAG_ATTACH",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$t_device_debug_property_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$t_base_properties_t",
                        "class": "$tDevice",
                        "desc": "Device debug properties queried using $tDeviceGetDebugProperties.",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$T_STRUCTURE_TYPE_DEVICE_DEBUG_PROPERTIES",
                                "name": "stype",
                                "type": "$t_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] returns 0 (none) or a valid combination of $t_device_debug_property_flag_t",
                                "name": "flags",
                                "type": "$t_device_debug_property_flags_t"
                            }
                        ],
                        "name": "$t_device_debug_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tDevice",
                        "desc": "Retrieves debug properties of the device.",
                        "hash": "c3d026b82778fe2460ab811b9c2e883dd0be74d7bdcb48098e3fe0d9be5ea054",
                        "name": "GetDebugProperties",
                        "params": [
                            {
                                "desc": "[in] device handle",
                                "name": "hDevice",
                                "type": "$t_device_handle_t"
                            },
                            {
                                "desc": "[in,out] query result for debug properties",
                                "name": "pDebugProperties",
                                "type": "$t_device_debug_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pDebugProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Debug configuration provided to $tDebugAttach",
                        "members": [
                            {
                                "desc": "[in] the host process identifier",
                                "name": "pid",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$t_debug_config_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tDebug",
                        "decl": "static",
                        "desc": "Attach to a device.",
                        "details": [
                            "The device must be enabled for debug; see $xsSchedulerSetComputeUnitDebugMode."
                        ],
                        "hash": "74b0dd833de78ddc67ac82d65994001fac9a4efcc3faf3db5862b8824404bfe6",
                        "name": "Attach",
                        "params": [
                            {
                                "desc": "[in] device handle",
                                "name": "hDevice",
                                "type": "$t_device_handle_t"
                            },
                            {
                                "desc": "[in] the debug configuration",
                                "name": "config",
                                "type": "const $t_debug_config_t*"
                            },
                            {
                                "desc": "[out] debug session handle",
                                "name": "phDebug",
                                "type": "$t_debug_session_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == config`",
                                    "`nullptr == phDebug`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "attaching to this device is not supported"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "caller does not have sufficient permissions"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "a debugger is already attached"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Close a debug session.",
                        "hash": "93beca3b9d167f52e7252bb79962171d25e1face643e2fdc0b256ce88cfd1500",
                        "name": "Detach",
                        "params": [
                            {
                                "desc": "[in][release] debug session handle",
                                "name": "hDebug",
                                "type": "$t_debug_session_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDebug`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Supported debug event flags.",
                        "etors": [
                            {
                                "desc": "The event needs to be acknowledged by calling $tDebugAcknowledgeEvent.",
                                "name": "$T_DEBUG_EVENT_FLAG_NEED_ACK",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$t_debug_event_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Supported debug event types.",
                        "etors": [
                            {
                                "desc": "The event is invalid",
                                "name": "$T_DEBUG_EVENT_TYPE_INVALID",
                                "value": "0"
                            },
                            {
                                "desc": "The tool was detached",
                                "name": "$T_DEBUG_EVENT_TYPE_DETACHED",
                                "value": "1"
                            },
                            {
                                "desc": "The debuggee process created command queues on the device",
                                "name": "$T_DEBUG_EVENT_TYPE_PROCESS_ENTRY",
                                "value": "2"
                            },
                            {
                                "desc": "The debuggee process destroyed all command queues on the device",
                                "name": "$T_DEBUG_EVENT_TYPE_PROCESS_EXIT",
                                "value": "3"
                            },
                            {
                                "desc": "An in-memory module was loaded onto the device",
                                "name": "$T_DEBUG_EVENT_TYPE_MODULE_LOAD",
                                "value": "4"
                            },
                            {
                                "desc": "An in-memory module is about to get unloaded from the device",
                                "name": "$T_DEBUG_EVENT_TYPE_MODULE_UNLOAD",
                                "value": "5"
                            },
                            {
                                "desc": "The thread stopped due to a device exception",
                                "name": "$T_DEBUG_EVENT_TYPE_THREAD_STOPPED",
                                "value": "6"
                            },
                            {
                                "desc": "The thread is not available to be stopped",
                                "name": "$T_DEBUG_EVENT_TYPE_THREAD_UNAVAILABLE",
                                "value": "7"
                            },
                            {
                                "desc": "A page request could not be completed on the device",
                                "name": "$T_DEBUG_EVENT_TYPE_PAGE_FAULT",
                                "value": "8",
                                "version": "1.1"
                            }
                        ],
                        "name": "$t_debug_event_type_t",
                        "type": "enum"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Supported debug detach reasons.",
                        "etors": [
                            {
                                "desc": "The detach reason is not valid",
                                "name": "$T_DEBUG_DETACH_REASON_INVALID",
                                "value": "0"
                            },
                            {
                                "desc": "The host process exited",
                                "name": "$T_DEBUG_DETACH_REASON_HOST_EXIT",
                                "value": "1"
                            }
                        ],
                        "name": "$t_debug_detach_reason_t",
                        "type": "enum"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Event information for $T_DEBUG_EVENT_TYPE_DETACHED",
                        "members": [
                            {
                                "desc": "[out] the detach reason",
                                "name": "reason",
                                "type": "$t_debug_detach_reason_t"
                            }
                        ],
                        "name": "$t_debug_event_info_detached_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Event information for $T_DEBUG_EVENT_TYPE_MODULE_LOAD and $T_DEBUG_EVENT_TYPE_MODULE_UNLOAD",
                        "members": [
                            {
                                "desc": "[out] the module format",
                                "name": "format",
                                "type": "$t_module_debug_info_format_t"
                            },
                            {
                                "desc": "[out] the begin address of the in-memory module (inclusive)",
                                "name": "moduleBegin",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] the end address of the in-memory module (exclusive)",
                                "name": "moduleEnd",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] the load address of the module on the device",
                                "name": "load",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$t_debug_event_info_module_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Event information for $T_DEBUG_EVENT_TYPE_THREAD_STOPPED and $T_DEBUG_EVENT_TYPE_THREAD_UNAVAILABLE",
                        "members": [
                            {
                                "desc": "[out] the stopped/unavailable thread",
                                "name": "thread",
                                "type": "$x_device_thread_t"
                            }
                        ],
                        "name": "$t_debug_event_info_thread_stopped_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Page fault reasons.",
                        "etors": [
                            {
                                "desc": "The page fault reason is not valid",
                                "name": "$T_DEBUG_PAGE_FAULT_REASON_INVALID",
                                "value": "0"
                            },
                            {
                                "desc": "The address is not mapped",
                                "name": "$T_DEBUG_PAGE_FAULT_REASON_MAPPING_ERROR",
                                "value": "1"
                            },
                            {
                                "desc": "Invalid access permissions",
                                "name": "$T_DEBUG_PAGE_FAULT_REASON_PERMISSION_ERROR",
                                "value": "2"
                            }
                        ],
                        "name": "$t_debug_page_fault_reason_t",
                        "type": "enum",
                        "version": "1.1"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Event information for $T_DEBUG_EVENT_TYPE_PAGE_FAULT",
                        "members": [
                            {
                                "desc": "[out] the faulting address",
                                "name": "address",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] the alignment mask",
                                "name": "mask",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] the page fault reason",
                                "name": "reason",
                                "type": "$t_debug_page_fault_reason_t"
                            }
                        ],
                        "name": "$t_debug_event_info_page_fault_t",
                        "type": "struct",
                        "version": "1.1"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Event type-specific information",
                        "members": [
                            {
                                "desc": "[out] type == $T_DEBUG_EVENT_TYPE_DETACHED",
                                "name": "detached",
                                "type": "$t_debug_event_info_detached_t"
                            },
                            {
                                "desc": "[out] type == $T_DEBUG_EVENT_TYPE_MODULE_LOAD or $T_DEBUG_EVENT_TYPE_MODULE_UNLOAD",
                                "name": "module",
                                "type": "$t_debug_event_info_module_t"
                            },
                            {
                                "desc": "[out] type == $T_DEBUG_EVENT_TYPE_THREAD_STOPPED or $T_DEBUG_EVENT_TYPE_THREAD_UNAVAILABLE",
                                "name": "thread",
                                "type": "$t_debug_event_info_thread_stopped_t"
                            },
                            {
                                "desc": "[out] type == $T_DEBUG_EVENT_TYPE_PAGE_FAULT",
                                "name": "page_fault",
                                "type": "$t_debug_event_info_page_fault_t",
                                "version": "1.1"
                            }
                        ],
                        "name": "$t_debug_event_info_t",
                        "type": "union"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "A debug event on the device.",
                        "members": [
                            {
                                "desc": "[out] the event type",
                                "name": "type",
                                "type": "$t_debug_event_type_t"
                            },
                            {
                                "desc": "[out] returns 0 (none) or a combination of $t_debug_event_flag_t",
                                "name": "flags",
                                "type": "$t_debug_event_flags_t"
                            },
                            {
                                "desc": "[out] event type specific information",
                                "name": "info",
                                "type": "$t_debug_event_info_t"
                            }
                        ],
                        "name": "$t_debug_event_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Read the topmost debug event.",
                        "hash": "fd2eafa037418a5cbc68fa5bf7a0fe66ada619637cd7ce2a926e5a71032fc51b",
                        "name": "ReadEvent",
                        "params": [
                            {
                                "desc": "[in] debug session handle",
                                "name": "hDebug",
                                "type": "$t_debug_session_handle_t"
                            },
                            {
                                "desc": "[in] if non-zero, then indicates the maximum time (in milliseconds) to yield before returning $X_RESULT_SUCCESS or $X_RESULT_NOT_READY;\nif zero, then immediately returns the status of the event;\nif `UINT64_MAX`, then function will not return until complete or device is lost.\nDue to external dependencies, timeout may be rounded to the closest value allowed by the accuracy of those dependencies.\n",
                                "name": "timeout",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[in,out] a pointer to a $t_debug_event_t.",
                                "name": "event",
                                "type": "$t_debug_event_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDebug`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == event`"
                                ]
                            },
                            {
                                "$X_RESULT_NOT_READY": [
                                    "the timeout expired"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Acknowledge a debug event.",
                        "hash": "2dbda584161c89afdaa2f2d7e25811fa56eb13db68b335e167373e2d1db654a2",
                        "name": "AcknowledgeEvent",
                        "params": [
                            {
                                "desc": "[in] debug session handle",
                                "name": "hDebug",
                                "type": "$t_debug_session_handle_t"
                            },
                            {
                                "desc": "[in] a pointer to a $t_debug_event_t.",
                                "name": "event",
                                "type": "const $t_debug_event_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDebug`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == event`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Interrupt device threads.",
                        "hash": "97d57d2337376beea4fcf5647996d6a695c408b43c4402bc50cb7f1f849100c8",
                        "name": "Interrupt",
                        "params": [
                            {
                                "desc": "[in] debug session handle",
                                "name": "hDebug",
                                "type": "$t_debug_session_handle_t"
                            },
                            {
                                "desc": "[in] the thread to interrupt",
                                "name": "thread",
                                "type": "$x_device_thread_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDebug`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "the thread is already stopped or unavailable"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Resume device threads.",
                        "hash": "55072197ef54909f2ff6ecbf176fccb95dbad2a2266b806d585e46715fb65173",
                        "name": "Resume",
                        "params": [
                            {
                                "desc": "[in] debug session handle",
                                "name": "hDebug",
                                "type": "$t_debug_session_handle_t"
                            },
                            {
                                "desc": "[in] the thread to resume",
                                "name": "thread",
                                "type": "$x_device_thread_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDebug`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "the thread is already running or unavailable"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Supported device memory space types.",
                        "etors": [
                            {
                                "desc": "default memory space (attribute may be omitted)",
                                "name": "$T_DEBUG_MEMORY_SPACE_TYPE_DEFAULT",
                                "value": "0"
                            },
                            {
                                "desc": "shared local memory space (GPU-only)",
                                "name": "$T_DEBUG_MEMORY_SPACE_TYPE_SLM",
                                "value": "1"
                            }
                        ],
                        "name": "$t_debug_memory_space_type_t",
                        "type": "enum"
                    },
                    {
                        "base": "$t_base_desc_t",
                        "class": "$tDebug",
                        "desc": "Device memory space descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$T_STRUCTURE_TYPE_DEBUG_MEMORY_SPACE_DESC",
                                "name": "stype",
                                "type": "$t_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] type of memory space",
                                "name": "type",
                                "type": "$t_debug_memory_space_type_t"
                            },
                            {
                                "desc": "[in] the virtual address within the memory space",
                                "name": "address",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$t_debug_memory_space_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Read memory.",
                        "details": [
                            "The thread identifier 'all' can be used for accessing the default memory space, e.g. for setting breakpoints."
                        ],
                        "hash": "32d1103937128d0fdc73b46974a88ff0502d29fdd3bdbe361a6819eea9e2af36",
                        "name": "ReadMemory",
                        "params": [
                            {
                                "desc": "[in] debug session handle",
                                "name": "hDebug",
                                "type": "$t_debug_session_handle_t"
                            },
                            {
                                "desc": "[in] the thread identifier.",
                                "name": "thread",
                                "type": "$x_device_thread_t"
                            },
                            {
                                "desc": "[in] memory space descriptor",
                                "name": "desc",
                                "type": "const $t_debug_memory_space_desc_t*"
                            },
                            {
                                "desc": "[in] the number of bytes to read",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in,out] a buffer to hold a copy of the memory",
                                "name": "buffer",
                                "type": "void*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDebug`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == buffer`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$T_DEBUG_MEMORY_SPACE_TYPE_SLM < desc->type`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "the thread is running or unavailable",
                                    "the memory cannot be accessed from the supplied thread"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Write memory.",
                        "details": [
                            "The thread identifier 'all' can be used for accessing the default memory space, e.g. for setting breakpoints."
                        ],
                        "hash": "9f56cdf99c4ac640421569f841d86c1e915a0929508bb7afe8a44b4a221a93a1",
                        "name": "WriteMemory",
                        "params": [
                            {
                                "desc": "[in] debug session handle",
                                "name": "hDebug",
                                "type": "$t_debug_session_handle_t"
                            },
                            {
                                "desc": "[in] the thread identifier.",
                                "name": "thread",
                                "type": "$x_device_thread_t"
                            },
                            {
                                "desc": "[in] memory space descriptor",
                                "name": "desc",
                                "type": "const $t_debug_memory_space_desc_t*"
                            },
                            {
                                "desc": "[in] the number of bytes to write",
                                "name": "size",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in] a buffer holding the pattern to write",
                                "name": "buffer",
                                "type": "const void*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDebug`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == buffer`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$T_DEBUG_MEMORY_SPACE_TYPE_SLM < desc->type`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "the thread is running or unavailable",
                                    "the memory cannot be accessed from the supplied thread"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Supported general register set flags.",
                        "etors": [
                            {
                                "desc": "register set is readable",
                                "name": "$T_DEBUG_REGSET_FLAG_READABLE",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "register set is writeable",
                                "name": "$T_DEBUG_REGSET_FLAG_WRITEABLE",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$t_debug_regset_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$t_base_properties_t",
                        "class": "$tDebug",
                        "desc": "Device register set properties queried using $tDebugGetRegisterSetProperties.",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$T_STRUCTURE_TYPE_DEBUG_REGSET_PROPERTIES",
                                "name": "stype",
                                "type": "$t_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] device-specific register set type",
                                "name": "type",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] device-specific version of this register set",
                                "name": "version",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] general register set flags",
                                "name": "generalFlags",
                                "type": "$t_debug_regset_flags_t"
                            },
                            {
                                "desc": "[out] device-specific register set flags",
                                "name": "deviceFlags",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] number of registers in the set",
                                "name": "count",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] the size of a register in bits",
                                "name": "bitSize",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] the size required for reading or writing a register in bytes",
                                "name": "byteSize",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$t_debug_regset_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tDebug",
                        "decl": "static",
                        "desc": "Retrieves debug register set properties.",
                        "hash": "66c8f10d019ad513b3749bc9486eacb1dbc5934eb24fdd59ce915c1de01f6fa9",
                        "name": "GetRegisterSetProperties",
                        "params": [
                            {
                                "desc": "[in] device handle",
                                "name": "hDevice",
                                "type": "$t_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of register set properties.\nif count is zero, then the driver shall update the value with the total number of register set properties available.\nif count is greater than the number of register set properties available, then the driver shall update the value with the correct number of registry set properties available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of query results for register set properties.\nif count is less than the number of register set properties available, then driver shall only retrieve that number of register set properties.\n",
                                "name": "pRegisterSetProperties",
                                "type": "$t_debug_regset_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tDebug",
                        "decl": "static",
                        "desc": "Retrieves debug register set properties for a given thread.",
                        "hash": "96f5ab4fe190013dfe748f26ae4db3b9d95a62f88dcb7a7e9468b00d94945169",
                        "name": "GetThreadRegisterSetProperties",
                        "params": [
                            {
                                "desc": "[in] debug session handle",
                                "name": "hDebug",
                                "type": "$t_debug_session_handle_t"
                            },
                            {
                                "desc": "[in] the thread identifier specifying a single stopped thread",
                                "name": "thread",
                                "type": "$x_device_thread_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of register set properties.\nif count is zero, then the driver shall update the value with the total number of register set properties available.\nif count is greater than the number of register set properties available, then the driver shall update the value with the correct number of registry set properties available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of query results for register set properties.\nif count is less than the number of register set properties available, then driver shall only retrieve that number of register set properties.\n",
                                "name": "pRegisterSetProperties",
                                "type": "$t_debug_regset_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDebug`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "the thread is running or unavailable"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ARGUMENT": [
                                    "the thread argument specifies more than one or a non-existant thread"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Read register state.",
                        "hash": "4971ff5ff86f5c20fda571c8540832b90f68b99ff6b2c72527ae590fb92ecd13",
                        "name": "ReadRegisters",
                        "params": [
                            {
                                "desc": "[in] debug session handle",
                                "name": "hDebug",
                                "type": "$t_debug_session_handle_t"
                            },
                            {
                                "desc": "[in] the thread identifier",
                                "name": "thread",
                                "type": "$x_device_thread_t"
                            },
                            {
                                "desc": "[in] register set type",
                                "name": "type",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] the starting offset into the register state area; must be less than the `count` member of $t_debug_regset_properties_t for the type",
                                "name": "start",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] the number of registers to read; start+count must be less than or equal to the `count` member of $t_debug_register_group_properties_t for the type",
                                "name": "count",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in,out][optional][range(0, count)] buffer of register values",
                                "name": "pRegisterValues",
                                "type": "void*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDebug`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "the thread is running or unavailable"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tDebug",
                        "desc": "Write register state.",
                        "hash": "a7e5e8a068e13a51cbe0643ad035cb7b9c043f5a050593e66978ede75b49023c",
                        "name": "WriteRegisters",
                        "params": [
                            {
                                "desc": "[in] debug session handle",
                                "name": "hDebug",
                                "type": "$t_debug_session_handle_t"
                            },
                            {
                                "desc": "[in] the thread identifier",
                                "name": "thread",
                                "type": "$x_device_thread_t"
                            },
                            {
                                "desc": "[in] register set type",
                                "name": "type",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] the starting offset into the register state area; must be less than the `count` member of $t_debug_regset_properties_t for the type",
                                "name": "start",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] the number of registers to write; start+count must be less than or equal to the `count` member of $t_debug_register_group_properties_t for the type",
                                "name": "count",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in,out][optional][range(0, count)] buffer of register values",
                                "name": "pRegisterValues",
                                "type": "void*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDebug`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "the thread is running or unavailable"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for Debug API",
                        "members": [
                            {
                                "desc": "[in] debug session handle",
                                "name": "handle",
                                "type": "$t_debug_session_handle_t"
                            }
                        ],
                        "name": "$tDebug",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for Metric",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "metric",
                "objects": [
                    {
                        "class": "$tMetricGroup",
                        "decl": "static",
                        "desc": "Retrieves metric group for a device.",
                        "details": [
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "3c1168f00cd21001f959d5f66f20559a4bf5e396bb1cb1d34116e7729a4f4fc8",
                        "name": "Get",
                        "params": [
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$t_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of metric groups.\nif count is zero, then the driver shall update the value with the total number of metric groups available.\nif count is greater than the number of metric groups available, then the driver shall update the value with the correct number of metric groups available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of metric groups.\nif count is less than the number of metric groups available, then driver shall only retrieve that number of metric groups.\n",
                                "name": "phMetricGroups",
                                "type": "$t_metric_group_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "Maximum metric group name string size",
                        "name": "$T_MAX_METRIC_GROUP_NAME",
                        "type": "macro",
                        "value": "256"
                    },
                    {
                        "desc": "Maximum metric group description string size",
                        "name": "$T_MAX_METRIC_GROUP_DESCRIPTION",
                        "type": "macro",
                        "value": "256"
                    },
                    {
                        "class": "$tMetricGroup",
                        "desc": "Metric group sampling type",
                        "etors": [
                            {
                                "desc": "Event based sampling",
                                "name": "$T_METRIC_GROUP_SAMPLING_TYPE_FLAG_EVENT_BASED",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Time based sampling",
                                "name": "$T_METRIC_GROUP_SAMPLING_TYPE_FLAG_TIME_BASED",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$t_metric_group_sampling_type_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$t_base_properties_t",
                        "class": "$tMetricGroup",
                        "desc": "Metric group properties queried using $tMetricGroupGetProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$T_STRUCTURE_TYPE_METRIC_GROUP_PROPERTIES",
                                "name": "stype",
                                "type": "$t_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] metric group name",
                                "name": "name[$T_MAX_METRIC_GROUP_NAME]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] metric group description",
                                "name": "description[$T_MAX_METRIC_GROUP_DESCRIPTION]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] metric group sampling type.\nreturns a combination of $t_metric_group_sampling_type_flag_t.\n",
                                "name": "samplingType",
                                "type": "$t_metric_group_sampling_type_flags_t"
                            },
                            {
                                "desc": "[out] metric group domain number. Cannot use multiple, simultaneous metric groups from the same domain.",
                                "name": "domain",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] metric count belonging to this group",
                                "name": "metricCount",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$t_metric_group_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tMetricGroup",
                        "desc": "Retrieves attributes of a metric group.",
                        "details": [
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "78240eaf21bff68383fe29f14362cb160f3ebbb609b183920ba33af1d0792bb9",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] handle of the metric group",
                                "name": "hMetricGroup",
                                "type": "$t_metric_group_handle_t"
                            },
                            {
                                "desc": "[in,out] metric group properties",
                                "name": "pProperties",
                                "type": "$t_metric_group_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetricGroup`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tMetric",
                        "desc": "Metric types",
                        "etors": [
                            {
                                "desc": "Metric type: duration",
                                "name": "$T_METRIC_TYPE_DURATION",
                                "value": "0"
                            },
                            {
                                "desc": "Metric type: event",
                                "name": "$T_METRIC_TYPE_EVENT",
                                "value": "1"
                            },
                            {
                                "desc": "Metric type: event with range",
                                "name": "$T_METRIC_TYPE_EVENT_WITH_RANGE",
                                "value": "2"
                            },
                            {
                                "desc": "Metric type: throughput",
                                "name": "$T_METRIC_TYPE_THROUGHPUT",
                                "value": "3"
                            },
                            {
                                "desc": "Metric type: timestamp",
                                "name": "$T_METRIC_TYPE_TIMESTAMP",
                                "value": "4"
                            },
                            {
                                "desc": "Metric type: flag",
                                "name": "$T_METRIC_TYPE_FLAG",
                                "value": "5"
                            },
                            {
                                "desc": "Metric type: ratio",
                                "name": "$T_METRIC_TYPE_RATIO",
                                "value": "6"
                            },
                            {
                                "desc": "Metric type: raw",
                                "name": "$T_METRIC_TYPE_RAW",
                                "value": "7"
                            },
                            {
                                "desc": "Metric type: instruction pointer. Deprecated, use $T_METRIC_TYPE_IP.",
                                "name": "$T_METRIC_TYPE_IP_EXP",
                                "value": "0x7ffffffe"
                            },
                            {
                                "desc": "Metric type: instruction pointer",
                                "name": "$T_METRIC_TYPE_IP",
                                "value": "0x7ffffffe",
                                "version": "1.7"
                            }
                        ],
                        "name": "$t_metric_type_t",
                        "type": "enum"
                    },
                    {
                        "class": "$tMetricGroup",
                        "desc": "Metric group calculation type",
                        "etors": [
                            {
                                "desc": "Calculated metric values from raw data.",
                                "name": "$T_METRIC_GROUP_CALCULATION_TYPE_METRIC_VALUES",
                                "value": "0"
                            },
                            {
                                "desc": "Maximum metric values.",
                                "name": "$T_METRIC_GROUP_CALCULATION_TYPE_MAX_METRIC_VALUES",
                                "value": "1"
                            }
                        ],
                        "name": "$t_metric_group_calculation_type_t",
                        "type": "enum"
                    },
                    {
                        "class": "$tMetricGroup",
                        "decl": "static",
                        "desc": "Calculates metric values from raw data.",
                        "details": [
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "cb6e20cd2535530f4def46834390547217f8eba6eeba1dc0a902555c40af9028",
                        "name": "CalculateMetricValues",
                        "params": [
                            {
                                "desc": "[in] handle of the metric group",
                                "name": "hMetricGroup",
                                "type": "$t_metric_group_handle_t"
                            },
                            {
                                "desc": "[in] calculation type to be applied on raw data",
                                "name": "type",
                                "type": "$t_metric_group_calculation_type_t"
                            },
                            {
                                "desc": "[in] size in bytes of raw data buffer",
                                "name": "rawDataSize",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in][range(0, rawDataSize)] buffer of raw data to calculate",
                                "name": "pRawData",
                                "type": "const uint8_t*"
                            },
                            {
                                "desc": "[in,out] pointer to number of metric values calculated.\nif count is zero, then the driver shall update the value with the total number of metric values to be calculated.\nif count is greater than the number available in the raw data buffer, then the driver shall update the value with the actual number of metric values to be calculated.\n",
                                "name": "pMetricValueCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pMetricValueCount)] buffer of calculated metrics.\nif count is less than the number available in the raw data buffer, then driver shall only calculate that number of metric values.\n",
                                "name": "pMetricValues",
                                "type": "$t_typed_value_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetricGroup`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$T_METRIC_GROUP_CALCULATION_TYPE_MAX_METRIC_VALUES < type`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pRawData`",
                                    "`nullptr == pMetricValueCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tMetric",
                        "decl": "static",
                        "desc": "Retrieves metric from a metric group.",
                        "details": [
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "23f30faaba53d0a7e0aae5ccd4a7f28d12c9e6c4cdccce6dfa8f8d6b3bc606df",
                        "name": "Get",
                        "params": [
                            {
                                "desc": "[in] handle of the metric group",
                                "name": "hMetricGroup",
                                "type": "$t_metric_group_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of metrics.\nif count is zero, then the driver shall update the value with the total number of metrics available.\nif count is greater than the number of metrics available, then the driver shall update the value with the correct number of metrics available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of metrics.\nif count is less than the number of metrics available, then driver shall only retrieve that number of metrics.\n",
                                "name": "phMetrics",
                                "type": "$t_metric_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetricGroup`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "Maximum metric name string size",
                        "name": "$T_MAX_METRIC_NAME",
                        "type": "macro",
                        "value": "256"
                    },
                    {
                        "desc": "Maximum metric description string size",
                        "name": "$T_MAX_METRIC_DESCRIPTION",
                        "type": "macro",
                        "value": "256"
                    },
                    {
                        "desc": "Maximum metric component string size",
                        "name": "$T_MAX_METRIC_COMPONENT",
                        "type": "macro",
                        "value": "256"
                    },
                    {
                        "desc": "Maximum metric result units string size",
                        "name": "$T_MAX_METRIC_RESULT_UNITS",
                        "type": "macro",
                        "value": "256"
                    },
                    {
                        "base": "$t_base_properties_t",
                        "class": "$tMetric",
                        "desc": "Metric properties queried using $tMetricGetProperties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$T_STRUCTURE_TYPE_METRIC_PROPERTIES",
                                "name": "stype",
                                "type": "$t_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] metric name",
                                "name": "name[$T_MAX_METRIC_NAME]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] metric description",
                                "name": "description[$T_MAX_METRIC_DESCRIPTION]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] metric component",
                                "name": "component[$T_MAX_METRIC_COMPONENT]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] number of tier",
                                "name": "tierNumber",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] metric type",
                                "name": "metricType",
                                "type": "$t_metric_type_t"
                            },
                            {
                                "desc": "[out] metric result type",
                                "name": "resultType",
                                "type": "$t_value_type_t"
                            },
                            {
                                "desc": "[out] metric result units",
                                "name": "resultUnits[$T_MAX_METRIC_RESULT_UNITS]",
                                "type": "char"
                            }
                        ],
                        "name": "$t_metric_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tMetric",
                        "desc": "Retrieves attributes of a metric.",
                        "details": [
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "aef6333271f2a5fdf7ab89c275d95405139496cb21c67904139bad5bc9dd0730",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] handle of the metric",
                                "name": "hMetric",
                                "type": "$t_metric_handle_t"
                            },
                            {
                                "desc": "[in,out] metric properties",
                                "name": "pProperties",
                                "type": "$t_metric_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetric`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tContext",
                        "desc": "Activates metric groups.",
                        "details": [
                            "Immediately reconfigures the device to activate only those metric groups provided.",
                            "Any metric groups previously activated but not provided will be deactivated.",
                            "Deactivating metric groups that are still in-use will result in undefined behavior.",
                            "All metric groups must have different domains, see $t_metric_group_properties_t.",
                            "The application must **not** call this function from simultaneous threads with the same device handle."
                        ],
                        "hash": "34c932ade11f77be736543eb44b6cf7cebfde09ac71f5b67362519b27f763e96",
                        "name": "ActivateMetricGroups",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$t_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$t_device_handle_t"
                            },
                            {
                                "desc": "[in] metric group count to activate; must be 0 if `nullptr == phMetricGroups`",
                                "name": "count",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][optional][range(0, count)] handles of the metric groups to activate.\nnullptr deactivates all previously used metric groups.\nall metrics groups must come from a different domains.\nmetric query and metric stream must use activated metric groups.\n",
                                "name": "phMetricGroups",
                                "type": "$t_metric_group_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phMetricGroups) && (0 < count)`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ARGUMENT": [
                                    "Multiple metric groups share the same domain"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "base": "$t_base_desc_t",
                        "class": "$tMetricStreamer",
                        "desc": "Metric streamer descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$T_STRUCTURE_TYPE_METRIC_STREAMER_DESC",
                                "name": "stype",
                                "type": "$t_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in,out] number of collected reports after which notification event will be signaled. If the requested value is not supported exactly, then the driver may use a value that is the closest supported approximation and shall update this member during $tMetricStreamerOpen.\n",
                                "name": "notifyEveryNReports",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in,out] streamer sampling period in nanoseconds. If the requested value is not supported exactly, then the driver may use a value that is the closest supported approximation and shall update this member during $tMetricStreamerOpen.\n",
                                "name": "samplingPeriod",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$t_metric_streamer_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tMetricStreamer",
                        "decl": "static",
                        "desc": "Opens metric streamer for a device.",
                        "details": [
                            "The notification event must have been created from an event pool that was created using $X_EVENT_POOL_FLAG_HOST_VISIBLE flag.",
                            "The duration of the signal event created from an event pool that was created using $X_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag is undefined. However, for consistency and orthogonality the event will report correctly as signaled when used by other event API functionality.",
                            "The application must **not** call this function from simultaneous threads with the same device handle."
                        ],
                        "hash": "fd476dcac868ee20bbfeaa63a804477465714e4b754e0d863151f3f5f39ffc23",
                        "name": "Open",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$t_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$t_device_handle_t"
                            },
                            {
                                "desc": "[in] handle of the metric group",
                                "name": "hMetricGroup",
                                "type": "$t_metric_group_handle_t"
                            },
                            {
                                "desc": "[in,out] metric streamer descriptor",
                                "name": "desc",
                                "type": "$t_metric_streamer_desc_t*"
                            },
                            {
                                "desc": "[in][optional] event used for report availability notification",
                                "name": "hNotificationEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[out] handle of metric streamer",
                                "name": "phMetricStreamer",
                                "type": "$t_metric_streamer_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`",
                                    "`nullptr == hMetricGroup`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phMetricStreamer`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tCommandList",
                        "desc": "Append metric streamer marker into a command list.",
                        "details": [
                            "The application must ensure the metric streamer is accessible by the device on which the command list was created.",
                            "The application must ensure the command list and metric streamer were created on the same context.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle.",
                            "Allow to associate metric stream time based metrics with executed workload."
                        ],
                        "hash": "442249fcbae3e728493309e244e058e9b58dbcd35d8a6e08a27fc30e787152fa",
                        "name": "AppendMetricStreamerMarker",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$t_command_list_handle_t"
                            },
                            {
                                "desc": "[in] handle of the metric streamer",
                                "name": "hMetricStreamer",
                                "type": "$t_metric_streamer_handle_t"
                            },
                            {
                                "desc": "[in] streamer marker value",
                                "name": "value",
                                "type": "uint32_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hMetricStreamer`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tMetricStreamer",
                        "desc": "Closes metric streamer.",
                        "details": [
                            "The application must **not** call this function from simultaneous threads with the same metric streamer handle."
                        ],
                        "hash": "f4cbb10d86bc48d25d8daf58501a6a5f561fad25962e1174cdbe30f1a912e97a",
                        "name": "Close",
                        "params": [
                            {
                                "desc": "[in][release] handle of the metric streamer",
                                "name": "hMetricStreamer",
                                "type": "$t_metric_streamer_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetricStreamer`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tMetricStreamer",
                        "desc": "Reads data from metric streamer.",
                        "details": [
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "46f3a51dca41a6993577fdad58dc258e362bc98c7ffac1bdc6f6000b327acd2b",
                        "name": "ReadData",
                        "params": [
                            {
                                "desc": "[in] handle of the metric streamer",
                                "name": "hMetricStreamer",
                                "type": "$t_metric_streamer_handle_t"
                            },
                            {
                                "desc": "[in] the maximum number of reports the application wants to receive.\nif `UINT32_MAX`, then function will retrieve all reports available\n",
                                "name": "maxReportCount",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in,out] pointer to size in bytes of raw data requested to read.\nif size is zero, then the driver will update the value with the total size in bytes needed for all reports available.\nif size is non-zero, then driver will only retrieve the number of reports that fit into the buffer.\nif size is larger than size needed for all reports, then driver will update the value with the actual size needed.\n",
                                "name": "pRawDataSize",
                                "type": "size_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pRawDataSize)] buffer containing streamer reports in raw format",
                                "name": "pRawData",
                                "type": "uint8_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetricStreamer`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pRawDataSize`"
                                ]
                            },
                            {
                                "$X_RESULT_WARNING_DROPPED_DATA": [
                                    "Metric streamer data may have been dropped. Reduce sampling period."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tMetricQueryPool",
                        "desc": "Metric query pool types",
                        "etors": [
                            {
                                "desc": "Performance metric query pool.",
                                "name": "$T_METRIC_QUERY_POOL_TYPE_PERFORMANCE",
                                "value": "0"
                            },
                            {
                                "desc": "Skips workload execution between begin/end calls.",
                                "name": "$T_METRIC_QUERY_POOL_TYPE_EXECUTION",
                                "value": "1"
                            }
                        ],
                        "name": "$t_metric_query_pool_type_t",
                        "type": "enum"
                    },
                    {
                        "base": "$t_base_desc_t",
                        "class": "$tMetricQueryPool",
                        "desc": "Metric query pool description",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$T_STRUCTURE_TYPE_METRIC_QUERY_POOL_DESC",
                                "name": "stype",
                                "type": "$t_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] Query pool type.",
                                "init": "$T_METRIC_QUERY_POOL_TYPE_PERFORMANCE",
                                "name": "type",
                                "type": "$t_metric_query_pool_type_t"
                            },
                            {
                                "desc": "[in] Internal slots count within query pool object.",
                                "name": "count",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$t_metric_query_pool_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tMetricQueryPool",
                        "decl": "static",
                        "desc": "Creates a pool of metric queries on the context.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "9727a2898e91512de28ffbf2c09ad780be377d517d6dfe36cf34e27eaa723885",
                        "name": "Create",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$t_context_handle_t"
                            },
                            {
                                "desc": "[in] handle of the device",
                                "name": "hDevice",
                                "type": "$t_device_handle_t"
                            },
                            {
                                "desc": "[in] metric group associated with the query object.",
                                "name": "hMetricGroup",
                                "type": "$t_metric_group_handle_t"
                            },
                            {
                                "desc": "[in] metric query pool descriptor",
                                "name": "desc",
                                "type": "const $t_metric_query_pool_desc_t*"
                            },
                            {
                                "desc": "[out] handle of metric query pool",
                                "name": "phMetricQueryPool",
                                "type": "$t_metric_query_pool_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`",
                                    "`nullptr == hDevice`",
                                    "`nullptr == hMetricGroup`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == phMetricQueryPool`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$T_METRIC_QUERY_POOL_TYPE_EXECUTION < desc->type`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tMetricQueryPool",
                        "decl": "static",
                        "desc": "Deletes a query pool object.",
                        "details": [
                            "The application must destroy all query handles created from the pool before destroying the pool itself.",
                            "The application must ensure the device is not currently referencing the any query within the pool before it is deleted.",
                            "The application must **not** call this function from simultaneous threads with the same query pool handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "b26d02c53519d670c87cb7b785b5df2a25f8a4fcbe931f5ecd168e5730641c6e",
                        "name": "Destroy",
                        "params": [
                            {
                                "desc": "[in][release] handle of the metric query pool",
                                "name": "hMetricQueryPool",
                                "type": "$t_metric_query_pool_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetricQueryPool`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tMetricQuery",
                        "decl": "static",
                        "desc": "Creates metric query from the pool.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "8644abb74b401f86e5b41611bb4a50a1514db5c88349292c1713315229a8ab50",
                        "name": "Create",
                        "params": [
                            {
                                "desc": "[in] handle of the metric query pool",
                                "name": "hMetricQueryPool",
                                "type": "$t_metric_query_pool_handle_t"
                            },
                            {
                                "desc": "[in] index of the query within the pool",
                                "name": "index",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] handle of metric query",
                                "name": "phMetricQuery",
                                "type": "$t_metric_query_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetricQueryPool`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phMetricQuery`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tMetricQuery",
                        "decl": "static",
                        "desc": "Deletes a metric query object.",
                        "details": [
                            "The application must ensure the device is not currently referencing the query before it is deleted.",
                            "The application must **not** call this function from simultaneous threads with the same query handle.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "e383c2dd1db9330485352b7dc38681e70be0e44436e2872d7681c5727576c407",
                        "name": "Destroy",
                        "params": [
                            {
                                "desc": "[in][release] handle of metric query",
                                "name": "hMetricQuery",
                                "type": "$t_metric_query_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetricQuery`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tMetricQuery",
                        "desc": "Resets a metric query object back to initial state.",
                        "details": [
                            "The application must ensure the device is not currently referencing the query before it is reset",
                            "The application must **not** call this function from simultaneous threads with the same query handle."
                        ],
                        "hash": "bd549c068b921a3b4d5be8147c1668f747c8b30d5794d06e24821c0531a38cb6",
                        "name": "Reset",
                        "params": [
                            {
                                "desc": "[in] handle of metric query",
                                "name": "hMetricQuery",
                                "type": "$t_metric_query_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetricQuery`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tCommandList",
                        "desc": "Appends metric query begin into a command list.",
                        "details": [
                            "The application must ensure the metric query is accessible by the device on which the command list was created.",
                            "The application must ensure the command list and metric query were created on the same context.",
                            "This command blocks all following commands from beginning until the execution of the query completes.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle."
                        ],
                        "hash": "84fe1ebe23db5e8ef6eea4d147307ac6af09f6df489af8613329efb938d59e2e",
                        "name": "AppendMetricQueryBegin",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$t_command_list_handle_t"
                            },
                            {
                                "desc": "[in] handle of the metric query",
                                "name": "hMetricQuery",
                                "type": "$t_metric_query_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hMetricQuery`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tCommandList",
                        "desc": "Appends metric query end into a command list.",
                        "details": [
                            "The application must ensure the metric query and events are accessible by the device on which the command list was created.",
                            "The application must ensure the command list, events and metric query were created on the same context.",
                            "The duration of the signal event created from an event pool that was created using $X_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag is undefined. However, for consistency and orthogonality the event will report correctly as signaled when used by other event API functionality.",
                            "If numWaitEvents is zero, then all previous commands are completed prior to the execution of the query.",
                            "If numWaitEvents is non-zero, then all phWaitEvents must be signaled prior to the execution of the query.",
                            "This command blocks all following commands from beginning until the execution of the query completes.",
                            "The application must **not** call this function from simultaneous threads with the same command list handle."
                        ],
                        "hash": "20793bcbc2a57cd3cd64765ed31236e03d78c596d549679ccb5733f2829ff01e",
                        "name": "AppendMetricQueryEnd",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$t_command_list_handle_t"
                            },
                            {
                                "desc": "[in] handle of the metric query",
                                "name": "hMetricQuery",
                                "type": "$t_metric_query_handle_t"
                            },
                            {
                                "desc": "[in][optional] handle of the event to signal on completion",
                                "name": "hSignalEvent",
                                "type": "$x_event_handle_t"
                            },
                            {
                                "desc": "[in] must be zero",
                                "name": "numWaitEvents",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][mbz] must be nullptr",
                                "name": "phWaitEvents",
                                "type": "$x_event_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`",
                                    "`nullptr == hMetricQuery`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "`(nullptr == phWaitEvents) && (0 < numWaitEvents)`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tCommandList",
                        "desc": "Appends metric query commands to flush all caches.",
                        "details": [
                            "The application must **not** call this function from simultaneous threads with the same command list handle."
                        ],
                        "hash": "9f3cba9f6f40a91263c007a1f597465b2b96639756498cbd3a1f6a034e4b6f3a",
                        "name": "AppendMetricMemoryBarrier",
                        "params": [
                            {
                                "desc": "[in] handle of the command list",
                                "name": "hCommandList",
                                "type": "$t_command_list_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hCommandList`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tMetricQuery",
                        "desc": "Retrieves raw data for a given metric query.",
                        "details": [
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "80cdaba4fc2a26a2427d93307cd9bf45b900a795ffb6f1f21eb0c74ccfd23ba6",
                        "name": "GetData",
                        "params": [
                            {
                                "desc": "[in] handle of the metric query",
                                "name": "hMetricQuery",
                                "type": "$t_metric_query_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to size in bytes of raw data requested to read.\nif size is zero, then the driver will update the value with the total size in bytes needed for all reports available.\nif size is non-zero, then driver will only retrieve the number of reports that fit into the buffer.\nif size is larger than size needed for all reports, then driver will update the value with the actual size needed.\n",
                                "name": "pRawDataSize",
                                "type": "size_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pRawDataSize)] buffer containing query reports in raw format",
                                "name": "pRawData",
                                "type": "uint8_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetricQuery`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pRawDataSize`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "attribute": "singleton",
                        "desc": "C++ wrapper for metric group",
                        "members": [
                            {
                                "desc": "[in] handle of metric group object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$t_metric_group_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$tDevice*"
                            }
                        ],
                        "name": "$tMetricGroup",
                        "owner": "$tDevice",
                        "type": "class"
                    },
                    {
                        "attribute": "singleton",
                        "desc": "C++ wrapper for metric",
                        "members": [
                            {
                                "desc": "[in] handle of metric object",
                                "name": "handle",
                                "type": "$t_metric_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pMetricGroup",
                                "type": "$tMetricGroup*"
                            }
                        ],
                        "name": "$tMetric",
                        "owner": "$tMetricGroup",
                        "type": "class"
                    },
                    {
                        "desc": "C++ wrapper for metric streamer",
                        "members": [
                            {
                                "desc": "[in] handle of metric streamer object",
                                "name": "handle",
                                "type": "$t_metric_streamer_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$tDevice*"
                            },
                            {
                                "desc": "[in] descriptor of the metric streamer",
                                "name": "desc",
                                "type": "$t_metric_streamer_desc_t"
                            }
                        ],
                        "name": "$tMetricStreamer",
                        "owner": "$tDevice",
                        "type": "class"
                    },
                    {
                        "desc": "C++ wrapper for metric query pool",
                        "members": [
                            {
                                "desc": "[in] handle of metric query pool object",
                                "name": "handle",
                                "type": "$t_metric_query_pool_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$tDevice*"
                            },
                            {
                                "desc": "[in] descriptor of the metric query pool",
                                "name": "desc",
                                "type": "$t_metric_query_pool_desc_t"
                            }
                        ],
                        "name": "$tMetricQueryPool",
                        "owner": "$tDevice",
                        "type": "class"
                    },
                    {
                        "desc": "C++ wrapper for metric query",
                        "members": [
                            {
                                "desc": "[in] handle of metric query object",
                                "name": "handle",
                                "type": "$t_metric_query_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$tDevice*"
                            }
                        ],
                        "name": "$tMetricQuery",
                        "owner": "$tDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for Program Instrumentation (PIN)",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "pin",
                "objects": [
                    {
                        "class": "$tKernel",
                        "desc": "Supportted profile features",
                        "etors": [
                            {
                                "desc": "request the compiler attempt to minimize register usage as much as possible to allow for instrumentation",
                                "name": "$T_PROFILE_FLAG_REGISTER_REALLOCATION",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "request the compiler generate free register info",
                                "name": "$T_PROFILE_FLAG_FREE_REGISTER_INFO",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$t_profile_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$t_base_properties_t",
                        "class": "$tKernel",
                        "desc": "Profiling meta-data for instrumentation",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$T_STRUCTURE_TYPE_PROFILE_PROPERTIES",
                                "name": "stype",
                                "type": "$t_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] indicates which flags were enabled during compilation.\nreturns 0 (none) or a combination of $t_profile_flag_t\n",
                                "name": "flags",
                                "type": "$t_profile_flags_t"
                            },
                            {
                                "desc": "[out] number of tokens immediately following this structure",
                                "name": "numTokens",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$t_profile_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tKernel",
                        "desc": "Supported profile token types",
                        "etors": [
                            {
                                "desc": "GRF info",
                                "name": "$T_PROFILE_TOKEN_TYPE_FREE_REGISTER",
                                "value": "0"
                            }
                        ],
                        "name": "$t_profile_token_type_t",
                        "type": "enum"
                    },
                    {
                        "class": "$tKernel",
                        "desc": "Profile free register token detailing unused registers in the current function",
                        "members": [
                            {
                                "desc": "[out] type of token",
                                "name": "type",
                                "type": "$t_profile_token_type_t"
                            },
                            {
                                "desc": "[out] total size of the token, in bytes",
                                "name": "size",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] number of register sequences immediately following this structure",
                                "name": "count",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$t_profile_free_register_token_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tKernel",
                        "desc": "Profile register sequence detailing consecutive bytes, all of which are unused",
                        "members": [
                            {
                                "desc": "[out] starting byte in the register table, representing the start of unused bytes in the current function",
                                "name": "start",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] number of consecutive bytes in the sequence, starting from start",
                                "name": "count",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$t_profile_register_sequence_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tKernel",
                        "desc": "Retrieve profiling information generated for the kernel.",
                        "details": [
                            {
                                "Module must be created using the following build option:": [
                                    "\"-$t-profile-flags <n>\" - enable generation of profile information",
                                    "\"<n>\" must be a combination of $t_profile_flag_t, in hex"
                                ]
                            },
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "daba304e8f1cfd945f7fcfe506ff1f93db38b2e14d5ec6326ce09a0180dbff9d",
                        "name": "GetProfileInfo",
                        "params": [
                            {
                                "desc": "[in] handle to kernel",
                                "name": "hKernel",
                                "type": "$t_kernel_handle_t"
                            },
                            {
                                "desc": "[out] pointer to profile properties",
                                "name": "pProfileProperties",
                                "type": "$t_profile_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hKernel`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProfileProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool Experimental Extension APIs for API Tracing",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "tracing",
                "objects": [
                    {
                        "desc": "API Tracing Experimental Extension Name",
                        "name": "$T_API_TRACING_EXP_NAME",
                        "type": "macro",
                        "value": "\"$XT_experimental_api_tracing\""
                    },
                    {
                        "desc": "API Tracing Experimental Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$T_API_TRACING_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$T_API_TRACING_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$t_api_tracing_exp_version_t",
                        "type": "enum"
                    },
                    {
                        "class": "$tTracerExp",
                        "desc": "Alias the existing callbacks definition for 'core' callbacks",
                        "name": "$t_core_callbacks_t",
                        "type": "typedef",
                        "value": "$x_callbacks_t"
                    },
                    {
                        "base": "$t_base_desc_t",
                        "class": "$tTracerExp",
                        "desc": "Tracer descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$T_STRUCTURE_TYPE_TRACER_EXP_DESC",
                                "name": "stype",
                                "type": "$t_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] pointer passed to every tracer's callbacks",
                                "name": "pUserData",
                                "type": "void*"
                            }
                        ],
                        "name": "$t_tracer_exp_desc_t",
                        "type": "struct"
                    },
                    {
                        "class": "$tTracerExp",
                        "decl": "static",
                        "desc": "Creates a tracer on the context.",
                        "details": [
                            "The application must only use the tracer for the context which was provided during creation.",
                            "The tracer is created in the disabled state.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe."
                        ],
                        "hash": "99654d158628fa6f80a407f4c6dd5fc582fec9bef666d5e4e841639ff3ddf90b",
                        "name": "Create",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the context object",
                                "name": "hContext",
                                "type": "$t_context_handle_t"
                            },
                            {
                                "desc": "[in] pointer to tracer descriptor",
                                "name": "desc",
                                "type": "const $t_tracer_exp_desc_t*"
                            },
                            {
                                "desc": "[out] pointer to handle of tracer object created",
                                "name": "phTracer",
                                "type": "$t_tracer_exp_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hContext`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == desc`",
                                    "`nullptr == desc->pUserData`",
                                    "`nullptr == phTracer`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tTracerExp",
                        "decl": "static",
                        "desc": "Destroys a tracer.",
                        "details": [
                            "The application must **not** call this function from simultaneous threads with the same tracer handle.",
                            "The implementation of this function must be thread-safe.",
                            "The implementation of this function will stall and wait on any outstanding threads executing callbacks before freeing any Host allocations associated with this tracer."
                        ],
                        "hash": "93988865d3b59785a30efbb5b38fea9024972b775e1ec2b82b52cfcd53e0fac2",
                        "name": "Destroy",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in][release] handle of tracer object to destroy",
                                "name": "hTracer",
                                "type": "$t_tracer_exp_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hTracer`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": []
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tTracerExp",
                        "desc": "Sets the collection of callbacks to be executed **before** driver execution.",
                        "details": [
                            "The application only needs to set the function pointers it is interested in receiving; all others should be 'nullptr'",
                            "The application must ensure that no other threads are executing functions for which the tracing functions are changing.",
                            "The application must **not** call this function from simultaneous threads with the same tracer handle."
                        ],
                        "hash": "3757c0ce726200f3b8edc93579a5460a058c240b7c52a06ff74e4756ebfc3eb0",
                        "name": "SetPrologues",
                        "params": [
                            {
                                "desc": "[in] handle of the tracer",
                                "name": "hTracer",
                                "type": "$t_tracer_exp_handle_t"
                            },
                            {
                                "desc": "[in] pointer to table of 'core' callback function pointers",
                                "name": "pCoreCbs",
                                "type": "$t_core_callbacks_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hTracer`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCoreCbs`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tTracerExp",
                        "desc": "Sets the collection of callbacks to be executed **after** driver execution.",
                        "details": [
                            "The application only needs to set the function pointers it is interested in receiving; all others should be 'nullptr'",
                            "The application must ensure that no other threads are executing functions for which the tracing functions are changing.",
                            "The application must **not** call this function from simultaneous threads with the same tracer handle."
                        ],
                        "hash": "fe64ecc4c3782cee737bb511673becc83b0a86f22604887853b751fe9ce897df",
                        "name": "SetEpilogues",
                        "params": [
                            {
                                "desc": "[in] handle of the tracer",
                                "name": "hTracer",
                                "type": "$t_tracer_exp_handle_t"
                            },
                            {
                                "desc": "[in] pointer to table of 'core' callback function pointers",
                                "name": "pCoreCbs",
                                "type": "$t_core_callbacks_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hTracer`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCoreCbs`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$tTracerExp",
                        "desc": "Enables (or disables) the tracer",
                        "details": [
                            "The application must **not** call this function from simultaneous threads with the same tracer handle."
                        ],
                        "hash": "60691e67f575e8b84d93b29f94642fafd9b9a302bc05b5f0d45340e335804de9",
                        "name": "SetEnabled",
                        "params": [
                            {
                                "desc": "[in] handle of the tracer",
                                "name": "hTracer",
                                "type": "$t_tracer_exp_handle_t"
                            },
                            {
                                "desc": "[in] enable the tracer if true; disable if false",
                                "name": "enable",
                                "type": "$x_bool_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hTracer`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for tracer",
                        "members": [
                            {
                                "desc": "[in] handle of tracer object",
                                "name": "handle",
                                "type": "$t_tracer_exp_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDriver",
                                "type": "$tDriver*"
                            },
                            {
                                "desc": "[in] descriptor of the tracer object",
                                "name": "desc",
                                "type": "$t_tracer_exp_desc_t"
                            }
                        ],
                        "name": "$tTracerExp",
                        "owner": "$tDriver",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool Experimental Extension for Calculating Multiple Metrics",
                    "ordinal": 1200,
                    "type": "header",
                    "version": "1.2"
                },
                "name": "multiMetricValues",
                "objects": [
                    {
                        "desc": "Calculating Multiple Metrics Experimental Extension Name",
                        "name": "$T_MULTI_METRICS_EXP_NAME",
                        "type": "macro",
                        "value": "\"$XT_experimental_calculate_multiple_metrics\"",
                        "version": "1.2"
                    },
                    {
                        "desc": "Calculating Multiple Metrics Experimental Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_CALCULATE_MULTIPLE_METRICS_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_CALCULATE_MULTIPLE_METRICS_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_calculate_multiple_metrics_exp_version_t",
                        "type": "enum",
                        "version": "1.2"
                    },
                    {
                        "class": "$tMetricGroup",
                        "decl": "static",
                        "desc": "Calculate one or more sets of metric values from raw data.",
                        "details": [
                            "This function is similar to $tMetricGroupCalculateMetricValues except it may calculate more than one set of metric values from a single data buffer.  There may be one set of metric values for each sub-device, for example.",
                            "Each set of metric values may consist of a different number of metric values, returned as the metric value count.",
                            "All metric values are calculated into a single buffer; use the metric counts to determine which metric values belong to which set.",
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "e2074d5e3c7ddbf7f7bd4a5a71cdb32afce7fdf407b420ee8e22d44c84e0bb83",
                        "name": "CalculateMultipleMetricValuesExp",
                        "params": [
                            {
                                "desc": "[in] handle of the metric group",
                                "name": "hMetricGroup",
                                "type": "$t_metric_group_handle_t"
                            },
                            {
                                "desc": "[in] calculation type to be applied on raw data",
                                "name": "type",
                                "type": "$t_metric_group_calculation_type_t"
                            },
                            {
                                "desc": "[in] size in bytes of raw data buffer",
                                "name": "rawDataSize",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in][range(0, rawDataSize)] buffer of raw data to calculate",
                                "name": "pRawData",
                                "type": "const uint8_t*"
                            },
                            {
                                "desc": "[in,out] pointer to number of metric sets.\nif count is zero, then the driver shall update the value with the total number of metric sets to be calculated.\nif count is greater than the number available in the raw data buffer, then the driver shall update the value with the actual number of metric sets to be calculated.\n",
                                "name": "pSetCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out] pointer to number of the total number of metric values calculated, for all metric sets.\nif count is zero, then the driver shall update the value with the total number of metric values to be calculated.\nif count is greater than the number available in the raw data buffer, then the driver shall update the value with the actual number of metric values to be calculated.\n",
                                "name": "pTotalMetricValueCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pSetCount)] buffer of metric counts per metric set.\n",
                                "name": "pMetricCounts",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pTotalMetricValueCount)] buffer of calculated metrics.\nif count is less than the number available in the raw data buffer, then driver shall only calculate that number of metric values.\n",
                                "name": "pMetricValues",
                                "type": "$t_typed_value_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetricGroup`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$T_METRIC_GROUP_CALCULATION_TYPE_MAX_METRIC_VALUES < type`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pRawData`",
                                    "`nullptr == pSetCount`",
                                    "`nullptr == pTotalMetricValueCount`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.2"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool Experimental Extension for Global Metric Timestamps",
                    "ordinal": 1500,
                    "type": "header",
                    "version": "1.5"
                },
                "name": "GlobalTimestamps",
                "objects": [
                    {
                        "desc": "Global Metric Timestamps Experimental Extension Name",
                        "name": "$T_GLOBAL_METRICS_TIMESTAMPS_EXP_NAME",
                        "type": "macro",
                        "value": "\"$XT_experimental_global_metric_timestamps\"",
                        "version": "1.5"
                    },
                    {
                        "desc": "Global Metric Timestamps Experimental Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$X_METRIC_GLOBAL_TIMESTAMPS_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$X_METRIC_GLOBAL_TIMESTAMPS_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$x_metric_global_timestamps_exp_version_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "base": "$t_base_desc_t",
                        "class": "$tMetric",
                        "desc": "Metric timestamps resolution",
                        "details": [
                            "This structure may be returned from $tMetricGroupGetProperties via the `pNext` member of $t_metric_group_properties_t.",
                            "Used for mapping metric timestamps to other timers."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$T_STRUCTURE_TYPE_METRIC_GLOBAL_TIMESTAMPS_RESOLUTION_EXP",
                                "name": "stype",
                                "type": "$t_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] Returns the resolution of metrics timer (used for timestamps) in cycles/sec.",
                                "name": "timerResolution",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Returns the number of valid bits in the timestamp value.",
                                "name": "timestampValidBits",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$t_metric_global_timestamps_resolution_exp_t",
                        "type": "struct",
                        "version": "1.5"
                    },
                    {
                        "class": "$tMetricGroup",
                        "decl": "static",
                        "desc": "Returns metric timestamps synchronized with global device timestamps, optionally synchronized with host",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "By default, the global and metrics timestamps are synchronized to the device."
                        ],
                        "hash": "223592fae768685fbaf678e7be2615d9d155a4f4c8d4e984da32b75707c71394",
                        "name": "GetGlobalTimestampsExp",
                        "params": [
                            {
                                "desc": "[in] handle of the metric group",
                                "name": "hMetricGroup",
                                "type": "$t_metric_group_handle_t"
                            },
                            {
                                "desc": "[in] Returns the timestamps synchronized to the host or the device.",
                                "init": "false",
                                "name": "synchronizedWithHost",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Device timestamp.\n",
                                "name": "globalTimestamp",
                                "type": "uint64_t*"
                            },
                            {
                                "desc": "[out] Metric timestamp.\n",
                                "name": "metricTimestamp",
                                "type": "uint64_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetricGroup`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == globalTimestamp`",
                                    "`nullptr == metricTimestamp`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool Experimental Extension for Exporting Metrics Data",
                    "ordinal": 1600,
                    "type": "header",
                    "version": "1.6"
                },
                "name": "metricExportData",
                "objects": [
                    {
                        "desc": "Exporting Metrics Data Experimental Extension Name",
                        "name": "$T_EXPORT_METRICS_DATA_EXP_NAME",
                        "type": "macro",
                        "value": "\"$XT_experimental_metric_export_data\"",
                        "version": "1.6"
                    },
                    {
                        "desc": "Exporting Metrics Data Experimental Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$T_EXPORT_METRIC_DATA_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$T_EXPORT_METRIC_DATA_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$t_export_metric_data_exp_version_t",
                        "type": "enum",
                        "version": "1.6"
                    },
                    {
                        "desc": "Maximum count of characters in export data element name",
                        "name": "$T_MAX_METRIC_EXPORT_DATA_ELEMENT_NAME_EXP",
                        "type": "macro",
                        "value": "256",
                        "version": "1.6"
                    },
                    {
                        "desc": "Maximum export data element description string size",
                        "name": "$T_MAX_METRIC_EXPORT_DATA_ELEMENT_DESCRIPTION_EXP",
                        "type": "macro",
                        "value": "256",
                        "version": "1.6"
                    },
                    {
                        "base": "$t_base_desc_t",
                        "class": "$tMetric",
                        "desc": "Metrics calculation descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$T_STRUCTURE_TYPE_METRIC_CALCULATE_EXP_DESC",
                                "name": "stype",
                                "type": "$t_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in] number of reports to skip during calculation",
                                "name": "rawReportSkipCount",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$t_metric_calculate_exp_desc_t",
                        "type": "struct",
                        "version": "1.6"
                    },
                    {
                        "class": "$tMetricGroup",
                        "decl": "static",
                        "desc": "Export Metrics Data for system independent calculation.",
                        "details": [
                            "This function exports raw data and necessary information to perform metrics calculation of collected data in a different system than where data was collected, which may or may not have accelerators.",
                            "Implementations can choose to describe the data arrangement of the exported data, using any mechanism which allows users to read and process them.",
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "499db6354496cf5b11624cc913efa9de29684492f7c073d1b6a55a7015e2e9c5",
                        "name": "GetExportDataExp",
                        "params": [
                            {
                                "desc": "[in] handle of the metric group",
                                "name": "hMetricGroup",
                                "type": "$t_metric_group_handle_t"
                            },
                            {
                                "desc": "[in] buffer of raw data",
                                "name": "pRawData",
                                "type": "const uint8_t*"
                            },
                            {
                                "desc": "[in] size in bytes of raw data buffer",
                                "name": "rawDataSize",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in,out] size in bytes of export data buffer\nif size is zero, then the driver shall update the value with the number of bytes necessary to store the exported data.\nif size is greater than required, then the driver shall update the value with the actual number of bytes necessary to store the exported data.\n",
                                "name": "pExportDataSize",
                                "type": "size_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pExportDataSize)] buffer of exported data.\n",
                                "name": "pExportData",
                                "type": "uint8_t *"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMetricGroup`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pRawData`",
                                    "`nullptr == pExportDataSize`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.6"
                    },
                    {
                        "class": "$tMetricGroup",
                        "decl": "static",
                        "desc": "Calculate one or more sets of metric values from exported raw data.",
                        "details": [
                            "Calculate metrics values using exported data returned by $tMetricGroupGetExportDataExp.",
                            "This function is similar to $tMetricGroupCalculateMultipleMetricValuesExp except it would calculate from exported metric data.",
                            "This function could be used to calculate metrics on a system different from where the metric raw data was collected.",
                            "The application may call this function from simultaneous threads."
                        ],
                        "hash": "45b7016f0a5f68adeb96524bb980cfdbf317c31a6a579e8be8dff30f93df6085",
                        "name": "CalculateMetricExportDataExp",
                        "params": [
                            {
                                "desc": "[in] handle of the driver instance",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in] calculation type to be applied on raw data",
                                "name": "type",
                                "type": "$t_metric_group_calculation_type_t"
                            },
                            {
                                "desc": "[in] size in bytes of exported data buffer",
                                "name": "exportDataSize",
                                "type": "size_t"
                            },
                            {
                                "desc": "[in][range(0, exportDataSize)] buffer of exported data to calculate",
                                "name": "pExportData",
                                "type": "const uint8_t*"
                            },
                            {
                                "desc": "[in] descriptor specifying calculation specific parameters",
                                "name": "pCalculateDescriptor",
                                "type": "$t_metric_calculate_exp_desc_t*"
                            },
                            {
                                "desc": "[in,out] pointer to number of metric sets.\nif count is zero, then the driver shall update the value with the total number of metric sets to be calculated.\nif count is greater than the number available in the raw data buffer, then the driver shall update the value with the actual number of metric sets to be calculated.\n",
                                "name": "pSetCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out] pointer to number of the total number of metric values calculated, for all metric sets.\nif count is zero, then the driver shall update the value with the total number of metric values to be calculated.\nif count is greater than the number available in the raw data buffer, then the driver shall update the value with the actual number of metric values to be calculated.\n",
                                "name": "pTotalMetricValueCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pSetCount)] buffer of metric counts per metric set.\n",
                                "name": "pMetricCounts",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pTotalMetricValueCount)] buffer of calculated metrics.\nif count is less than the number available in the raw data buffer, then driver shall only calculate that number of metric values.\n",
                                "name": "pMetricValues",
                                "type": "$t_typed_value_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$T_METRIC_GROUP_CALCULATION_TYPE_MAX_METRIC_VALUES < type`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pExportData`",
                                    "`nullptr == pCalculateDescriptor`",
                                    "`nullptr == pSetCount`",
                                    "`nullptr == pTotalMetricValueCount`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.6"
                    }
                ]
            }
        ],
        [
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Sysman API common types",
                    "ordinal": 0,
                    "type": "header"
                },
                "name": "common",
                "objects": [
                    {
                        "alias": "$x_driver_handle_t",
                        "class": "$sDriver",
                        "desc": "Handle to a driver instance",
                        "name": "$s_driver_handle_t",
                        "type": "handle"
                    },
                    {
                        "alias": "$x_device_handle_t",
                        "class": "$sDevice",
                        "desc": "Handle of device object",
                        "name": "$s_device_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sScheduler",
                        "desc": "Handle for a Sysman device scheduler queue",
                        "name": "$s_sched_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sPerformanceFactor",
                        "desc": "Handle for a Sysman device performance factors",
                        "name": "$s_perf_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Handle for a Sysman device power domain",
                        "name": "$s_pwr_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Handle for a Sysman device frequency domain",
                        "name": "$s_freq_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sEngine",
                        "desc": "Handle for a Sysman device engine group",
                        "name": "$s_engine_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sStandby",
                        "desc": "Handle for a Sysman device standby control",
                        "name": "$s_standby_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sFirmware",
                        "desc": "Handle for a Sysman device firmware",
                        "name": "$s_firmware_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sMemory",
                        "desc": "Handle for a Sysman device memory module",
                        "name": "$s_mem_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Handle for a Sysman fabric port",
                        "name": "$s_fabric_port_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sTemperature",
                        "desc": "Handle for a Sysman device temperature sensor",
                        "name": "$s_temp_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sPsu",
                        "desc": "Handle for a Sysman device power supply",
                        "name": "$s_psu_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sFan",
                        "desc": "Handle for a Sysman device fan",
                        "name": "$s_fan_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sLed",
                        "desc": "Handle for a Sysman device LED",
                        "name": "$s_led_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sRas",
                        "desc": "Handle for a Sysman device RAS error set",
                        "name": "$s_ras_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sDiagnostics",
                        "desc": "Handle for a Sysman device diagnostics test suite",
                        "name": "$s_diag_handle_t",
                        "type": "handle"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Handle for a Sysman device overclock domain",
                        "name": "$s_overclock_handle_t",
                        "type": "handle",
                        "version": "1.5"
                    },
                    {
                        "desc": "Defines structure types",
                        "etors": [
                            {
                                "desc": "$s_device_properties_t",
                                "name": "$S_STRUCTURE_TYPE_DEVICE_PROPERTIES",
                                "value": "0x1"
                            },
                            {
                                "desc": "$s_pci_properties_t",
                                "name": "$S_STRUCTURE_TYPE_PCI_PROPERTIES",
                                "value": "0x2"
                            },
                            {
                                "desc": "$s_pci_bar_properties_t",
                                "name": "$S_STRUCTURE_TYPE_PCI_BAR_PROPERTIES",
                                "value": "0x3"
                            },
                            {
                                "desc": "$s_diag_properties_t",
                                "name": "$S_STRUCTURE_TYPE_DIAG_PROPERTIES",
                                "value": "0x4"
                            },
                            {
                                "desc": "$s_engine_properties_t",
                                "name": "$S_STRUCTURE_TYPE_ENGINE_PROPERTIES",
                                "value": "0x5"
                            },
                            {
                                "desc": "$s_fabric_port_properties_t",
                                "name": "$S_STRUCTURE_TYPE_FABRIC_PORT_PROPERTIES",
                                "value": "0x6"
                            },
                            {
                                "desc": "$s_fan_properties_t",
                                "name": "$S_STRUCTURE_TYPE_FAN_PROPERTIES",
                                "value": "0x7"
                            },
                            {
                                "desc": "$s_firmware_properties_t",
                                "name": "$S_STRUCTURE_TYPE_FIRMWARE_PROPERTIES",
                                "value": "0x8"
                            },
                            {
                                "desc": "$s_freq_properties_t",
                                "name": "$S_STRUCTURE_TYPE_FREQ_PROPERTIES",
                                "value": "0x9"
                            },
                            {
                                "desc": "$s_led_properties_t",
                                "name": "$S_STRUCTURE_TYPE_LED_PROPERTIES",
                                "value": "0xa"
                            },
                            {
                                "desc": "$s_mem_properties_t",
                                "name": "$S_STRUCTURE_TYPE_MEM_PROPERTIES",
                                "value": "0xb"
                            },
                            {
                                "desc": "$s_perf_properties_t",
                                "name": "$S_STRUCTURE_TYPE_PERF_PROPERTIES",
                                "value": "0xc"
                            },
                            {
                                "desc": "$s_power_properties_t",
                                "name": "$S_STRUCTURE_TYPE_POWER_PROPERTIES",
                                "value": "0xd"
                            },
                            {
                                "desc": "$s_psu_properties_t",
                                "name": "$S_STRUCTURE_TYPE_PSU_PROPERTIES",
                                "value": "0xe"
                            },
                            {
                                "desc": "$s_ras_properties_t",
                                "name": "$S_STRUCTURE_TYPE_RAS_PROPERTIES",
                                "value": "0xf"
                            },
                            {
                                "desc": "$s_sched_properties_t",
                                "name": "$S_STRUCTURE_TYPE_SCHED_PROPERTIES",
                                "value": "0x10"
                            },
                            {
                                "desc": "$s_sched_timeout_properties_t",
                                "name": "$S_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES",
                                "value": "0x11"
                            },
                            {
                                "desc": "$s_sched_timeslice_properties_t",
                                "name": "$S_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES",
                                "value": "0x12"
                            },
                            {
                                "desc": "$s_standby_properties_t",
                                "name": "$S_STRUCTURE_TYPE_STANDBY_PROPERTIES",
                                "value": "0x13"
                            },
                            {
                                "desc": "$s_temp_properties_t",
                                "name": "$S_STRUCTURE_TYPE_TEMP_PROPERTIES",
                                "value": "0x14"
                            },
                            {
                                "desc": "$s_device_state_t",
                                "name": "$S_STRUCTURE_TYPE_DEVICE_STATE",
                                "value": "0x15"
                            },
                            {
                                "desc": "$s_process_state_t",
                                "name": "$S_STRUCTURE_TYPE_PROCESS_STATE",
                                "value": "0x16"
                            },
                            {
                                "desc": "$s_pci_state_t",
                                "name": "$S_STRUCTURE_TYPE_PCI_STATE",
                                "value": "0x17"
                            },
                            {
                                "desc": "$s_fabric_port_config_t",
                                "name": "$S_STRUCTURE_TYPE_FABRIC_PORT_CONFIG",
                                "value": "0x18"
                            },
                            {
                                "desc": "$s_fabric_port_state_t",
                                "name": "$S_STRUCTURE_TYPE_FABRIC_PORT_STATE",
                                "value": "0x19"
                            },
                            {
                                "desc": "$s_fan_config_t",
                                "name": "$S_STRUCTURE_TYPE_FAN_CONFIG",
                                "value": "0x1a"
                            },
                            {
                                "desc": "$s_freq_state_t",
                                "name": "$S_STRUCTURE_TYPE_FREQ_STATE",
                                "value": "0x1b"
                            },
                            {
                                "desc": "$s_oc_capabilities_t",
                                "name": "$S_STRUCTURE_TYPE_OC_CAPABILITIES",
                                "value": "0x1c"
                            },
                            {
                                "desc": "$s_led_state_t",
                                "name": "$S_STRUCTURE_TYPE_LED_STATE",
                                "value": "0x1d"
                            },
                            {
                                "desc": "$s_mem_state_t",
                                "name": "$S_STRUCTURE_TYPE_MEM_STATE",
                                "value": "0x1e"
                            },
                            {
                                "desc": "$s_psu_state_t",
                                "name": "$S_STRUCTURE_TYPE_PSU_STATE",
                                "value": "0x1f"
                            },
                            {
                                "desc": "$s_base_state_t",
                                "name": "$S_STRUCTURE_TYPE_BASE_STATE",
                                "value": "0x20"
                            },
                            {
                                "desc": "$s_ras_config_t",
                                "name": "$S_STRUCTURE_TYPE_RAS_CONFIG",
                                "value": "0x21"
                            },
                            {
                                "desc": "$s_ras_state_t",
                                "name": "$S_STRUCTURE_TYPE_RAS_STATE",
                                "value": "0x22"
                            },
                            {
                                "desc": "$s_temp_config_t",
                                "name": "$S_STRUCTURE_TYPE_TEMP_CONFIG",
                                "value": "0x23"
                            },
                            {
                                "desc": "$s_pci_bar_properties_1_2_t",
                                "name": "$S_STRUCTURE_TYPE_PCI_BAR_PROPERTIES_1_2",
                                "value": "0x24",
                                "version": "1.2"
                            },
                            {
                                "desc": "$s_device_ecc_desc_t",
                                "name": "$S_STRUCTURE_TYPE_DEVICE_ECC_DESC",
                                "value": "0x25",
                                "version": "1.4"
                            },
                            {
                                "desc": "$s_device_ecc_properties_t",
                                "name": "$S_STRUCTURE_TYPE_DEVICE_ECC_PROPERTIES",
                                "value": "0x26",
                                "version": "1.4"
                            },
                            {
                                "desc": "$s_power_limit_ext_desc_t",
                                "name": "$S_STRUCTURE_TYPE_POWER_LIMIT_EXT_DESC",
                                "value": "0x27",
                                "version": "1.4"
                            },
                            {
                                "desc": "$s_power_ext_properties_t",
                                "name": "$S_STRUCTURE_TYPE_POWER_EXT_PROPERTIES",
                                "value": "0x28",
                                "version": "1.4"
                            },
                            {
                                "desc": "$s_overclock_properties_t",
                                "name": "$S_STRUCTURE_TYPE_OVERCLOCK_PROPERTIES",
                                "value": "0x29",
                                "version": "1.5"
                            },
                            {
                                "desc": "$s_fabric_port_error_counters_t",
                                "name": "$S_STRUCTURE_TYPE_FABRIC_PORT_ERROR_COUNTERS",
                                "value": "0x2a",
                                "version": "1.7"
                            },
                            {
                                "desc": "$s_engine_ext_properties_t",
                                "name": "$S_STRUCTURE_TYPE_ENGINE_EXT_PROPERTIES",
                                "value": "0x2b",
                                "version": "1.7"
                            },
                            {
                                "desc": "$s_reset_properties_t",
                                "name": "$S_STRUCTURE_TYPE_RESET_PROPERTIES",
                                "value": "0x2c",
                                "version": "1.7"
                            },
                            {
                                "desc": "$s_device_ext_properties_t",
                                "name": "$S_STRUCTURE_TYPE_DEVICE_EXT_PROPERTIES",
                                "value": "0x2d",
                                "version": "1.7"
                            },
                            {
                                "desc": "$s_uuid_t",
                                "name": "$S_STRUCTURE_TYPE_DEVICE_UUID",
                                "value": "0x2e",
                                "version": "1.7"
                            }
                        ],
                        "name": "$s_structure_type_t",
                        "type": "enum"
                    },
                    {
                        "desc": "Base for all properties types",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            }
                        ],
                        "name": "$s_base_properties_t",
                        "type": "struct"
                    },
                    {
                        "desc": "Base for all descriptor types",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            }
                        ],
                        "name": "$s_base_desc_t",
                        "type": "struct"
                    },
                    {
                        "desc": "Base for all state types",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            }
                        ],
                        "name": "$s_base_state_t",
                        "type": "struct"
                    },
                    {
                        "desc": "Base for all config types",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            }
                        ],
                        "name": "$s_base_config_t",
                        "type": "struct"
                    },
                    {
                        "desc": "Base for all capability types",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            }
                        ],
                        "name": "$s_base_capability_t",
                        "type": "struct"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman)",
                    "ordinal": 1,
                    "type": "header"
                },
                "name": "driver",
                "objects": [
                    {
                        "class": "$s",
                        "desc": "Supported sysman initialization flags",
                        "etors": [
                            {
                                "desc": "placeholder for future use",
                                "name": "$S_INIT_FLAG_PLACEHOLDER",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$s_init_flags_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "class": "$s",
                        "decl": "static",
                        "desc": "Initialize $OneApi System Resource Management (sysman)",
                        "details": [
                            "The application must call this function or $xInit with the $S_ENABLE_SYSMAN environment variable set before calling any other sysman function.",
                            "If this function is not called then all other sysman functions will return $X_RESULT_ERROR_UNINITIALIZED.",
                            "This function will only initialize sysman. To initialize other functions, call $xInit.",
                            "There is no requirement to call this function before or after $xInit.",
                            "Only one instance of sysman will be initialized per process.",
                            "The application must call this function after forking new processes. Each forked process must call this function.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function must be thread-safe for scenarios where multiple libraries may initialize sysman simultaneously."
                        ],
                        "hash": "1bbd5be40cc583c65df6085755af48c663f466a9fc324f6a5c43a9f9c4cb3b97",
                        "name": "Init",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] initialization flags.\ncurrently unused, must be 0 (default).\n",
                                "init": "0",
                                "name": "flags",
                                "type": "$s_init_flags_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x1 < flags`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sDriver",
                        "decl": "static",
                        "desc": "Retrieves sysman driver instances",
                        "details": [
                            "A sysman driver represents a collection of physical devices.",
                            "Multiple calls to this function will return identical sysman driver handles, in the same order.",
                            "The application may pass nullptr for pDrivers when only querying the number of sysman drivers.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "25a93e8621b2de9d5cdea1eb8414add47e38defc9e270b7c6759ed52b55ec6d0",
                        "name": "Get",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in,out] pointer to the number of sysman driver instances.\nif count is zero, then the loader shall update the value with the total number of sysman drivers available.\nif count is greater than the number of sysman drivers available, then the loader shall update the value with the correct number of sysman drivers available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of sysman driver instance handles.\nif count is less than the number of sysman drivers available, then the loader shall only retrieve that number of sysman drivers.\n",
                                "name": "phDrivers",
                                "type": "$s_driver_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Device management",
                    "ordinal": 2,
                    "type": "header"
                },
                "name": "device",
                "objects": [
                    {
                        "class": "$sDevice",
                        "decl": "static",
                        "desc": "Retrieves sysman devices within a sysman driver",
                        "details": [
                            "Multiple calls to this function will return identical sysman device handles, in the same order.",
                            "The number and order of handles returned from this function is NOT affected by the $X_AFFINITY_MASK, $X_ENABLE_PCI_ID_DEVICE_ORDER, or $X_FLAT_DEVICE_HIERARCHY environment variables.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "39d581ecb601676e1aeb2d414243171941d470b923f87b7356eaa9b784c14cfa",
                        "name": "Get",
                        "ordinal": "0",
                        "params": [
                            {
                                "desc": "[in] handle of the sysman driver instance",
                                "name": "hDriver",
                                "type": "$s_driver_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of sysman devices.\nif count is zero, then the driver shall update the value with the total number of sysman devices available.\nif count is greater than the number of sysman devices available, then the driver shall update the value with the correct number of sysman devices available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of sysman devices.\nif count is less than the number of sysman devices available, then driver shall only retrieve that number of sysman devices.\n",
                                "name": "phDevices",
                                "type": "$s_device_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "desc": "Maximum number of characters in string properties.",
                        "name": "$S_STRING_PROPERTY_SIZE",
                        "type": "macro",
                        "value": "64"
                    },
                    {
                        "desc": "Maximum device universal unique id (UUID) size in bytes.",
                        "name": "$S_MAX_UUID_SIZE",
                        "type": "macro",
                        "value": "16"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Types of accelerator engines",
                        "etors": [
                            {
                                "desc": "Undefined types of accelerators.",
                                "name": "$S_ENGINE_TYPE_FLAG_OTHER",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Engines that process compute kernels only (no 3D content).",
                                "name": "$S_ENGINE_TYPE_FLAG_COMPUTE",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Engines that process 3D content only (no compute kernels).",
                                "name": "$S_ENGINE_TYPE_FLAG_3D",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "Engines that process media workloads.",
                                "name": "$S_ENGINE_TYPE_FLAG_MEDIA",
                                "value": "$X_BIT(3)"
                            },
                            {
                                "desc": "Engines that copy blocks of data.",
                                "name": "$S_ENGINE_TYPE_FLAG_DMA",
                                "value": "$X_BIT(4)"
                            },
                            {
                                "desc": "Engines that can process both 3D content and compute kernels.",
                                "name": "$S_ENGINE_TYPE_FLAG_RENDER",
                                "value": "$X_BIT(5)"
                            }
                        ],
                        "name": "$s_engine_type_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Device repair status",
                        "etors": [
                            {
                                "desc": "The device does not support in-field repairs.",
                                "name": "$S_REPAIR_STATUS_UNSUPPORTED",
                                "value": "0"
                            },
                            {
                                "desc": "The device has never been repaired.",
                                "name": "$S_REPAIR_STATUS_NOT_PERFORMED",
                                "value": "1"
                            },
                            {
                                "desc": "The device has been repaired.",
                                "name": "$S_REPAIR_STATUS_PERFORMED",
                                "value": "2"
                            }
                        ],
                        "name": "$s_repair_status_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Device reset reasons",
                        "etors": [
                            {
                                "desc": "The device needs to be reset because one or more parts of the hardware is wedged",
                                "name": "$S_RESET_REASON_FLAG_WEDGED",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "The device needs to be reset in order to complete in-field repairs",
                                "name": "$S_RESET_REASON_FLAG_REPAIR",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$s_reset_reason_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Device reset type",
                        "etors": [
                            {
                                "desc": "Apply warm reset",
                                "name": "$S_RESET_TYPE_WARM",
                                "value": "0"
                            },
                            {
                                "desc": "Apply cold reset",
                                "name": "$S_RESET_TYPE_COLD",
                                "value": "1"
                            },
                            {
                                "desc": "Apply FLR reset",
                                "name": "$S_RESET_TYPE_FLR",
                                "value": "2"
                            }
                        ],
                        "name": "$s_reset_type_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "base": "$s_base_state_t",
                        "class": "$sDevice",
                        "desc": "Device state",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_DEVICE_STATE",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] Indicates if the device needs to be reset and for what reasons.\nreturns 0 (none) or combination of $s_reset_reason_flag_t\n",
                                "name": "reset",
                                "type": "$s_reset_reason_flags_t"
                            },
                            {
                                "desc": "[out] Indicates if the device has been repaired",
                                "name": "repaired",
                                "type": "$s_repair_status_t"
                            }
                        ],
                        "name": "$s_device_state_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sDevice",
                        "desc": "Device reset properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_RESET_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] If set to true, all applications that are currently using the device will be forcibly killed.\n",
                                "name": "force",
                                "type": "ze_bool_t"
                            },
                            {
                                "desc": "[in] Type of reset needs to be performed",
                                "name": "resetType",
                                "type": "$s_reset_type_t"
                            }
                        ],
                        "name": "$s_reset_properties_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Device universal unique id (UUID)",
                        "members": [
                            {
                                "desc": "[out] opaque data representing a device UUID",
                                "name": "id[$S_MAX_UUID_SIZE]",
                                "type": "uint8_t"
                            }
                        ],
                        "name": "$s_uuid_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Supported device types",
                        "etors": [
                            {
                                "desc": "Graphics Processing Unit",
                                "name": "$S_DEVICE_TYPE_GPU",
                                "value": "1"
                            },
                            {
                                "desc": "Central Processing Unit",
                                "name": "$S_DEVICE_TYPE_CPU",
                                "value": "2"
                            },
                            {
                                "desc": "Field Programmable Gate Array",
                                "name": "$S_DEVICE_TYPE_FPGA",
                                "value": "3"
                            },
                            {
                                "desc": "Memory Copy Accelerator",
                                "name": "$S_DEVICE_TYPE_MCA",
                                "value": "4"
                            },
                            {
                                "desc": "Vision Processing Unit",
                                "name": "$S_DEVICE_TYPE_VPU",
                                "value": "5"
                            }
                        ],
                        "name": "$s_device_type_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Supported device property flags",
                        "etors": [
                            {
                                "desc": "Device is integrated with the Host.",
                                "name": "$S_DEVICE_PROPERTY_FLAG_INTEGRATED",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Device handle used for query represents a sub-device.",
                                "name": "$S_DEVICE_PROPERTY_FLAG_SUBDEVICE",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Device supports error correction memory access.",
                                "name": "$S_DEVICE_PROPERTY_FLAG_ECC",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "Device supports on-demand page-faulting.",
                                "name": "$S_DEVICE_PROPERTY_FLAG_ONDEMANDPAGING",
                                "value": "$X_BIT(3)"
                            }
                        ],
                        "name": "$s_device_property_flags_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sDevice",
                        "desc": "Device properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_DEVICE_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] (Deprecated, use $s_uuid_t in the extended structure) Core device properties",
                                "name": "core",
                                "type": "$x_device_properties_t"
                            },
                            {
                                "desc": "[out] Number of sub-devices. A value of 0 indicates that this device doesn't have sub-devices.",
                                "name": "numSubdevices",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Manufacturing serial number (NULL terminated string value). This value is intended to reflect the Part ID/SoC ID assigned by manufacturer that is unique for a SoC. Will be set to the string \"unknown\" if this cannot be determined for the device.",
                                "name": "serialNumber[$S_STRING_PROPERTY_SIZE]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] Manufacturing board number (NULL terminated string value). Alternatively \"boardSerialNumber\", this value is intended to reflect the string printed on board label by manufacturer. Will be set to the string \"unknown\" if this cannot be determined for the device.",
                                "name": "boardNumber[$S_STRING_PROPERTY_SIZE]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] Brand name of the device (NULL terminated string value). Will be set to the string \"unknown\" if this cannot be determined for the device.",
                                "name": "brandName[$S_STRING_PROPERTY_SIZE]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] Model name of the device (NULL terminated string value). Will be set to the string \"unknown\" if this cannot be determined for the device.",
                                "name": "modelName[$S_STRING_PROPERTY_SIZE]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] Vendor name of the device (NULL terminated string value). Will be set to the string \"unknown\" if this cannot be determined for the device.",
                                "name": "vendorName[$S_STRING_PROPERTY_SIZE]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] Installed driver version (NULL terminated string value). Will be set to the string \"unknown\" if this cannot be determined for the device.",
                                "name": "driverVersion[$S_STRING_PROPERTY_SIZE]",
                                "type": "char"
                            }
                        ],
                        "name": "$s_device_properties_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sDevice",
                        "desc": "Device properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_DEVICE_EXT_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] universal unique identifier. Note: uuid obtained from Sysman API is the same as from core API. Subdevices will have their own uuid.",
                                "name": "uuid",
                                "type": "$s_uuid_t"
                            },
                            {
                                "desc": "[out] generic device type",
                                "name": "type",
                                "type": "$s_device_type_t"
                            },
                            {
                                "desc": "[out] 0 (none) or a valid combination of $s_device_property_flag_t",
                                "name": "flags",
                                "type": "$s_device_property_flags_t"
                            }
                        ],
                        "name": "$s_device_ext_properties_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get properties about the device",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "c558d1b867032600d877bf98f17dfab339d27cf77a33bb46c846981ac08d0fd0",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] Structure that will contain information about the device.",
                                "name": "pProperties",
                                "type": "$s_device_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get information about the state of the device - if a reset is required, reasons for the reset and if the device has been repaired",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "28bd626c19e2bd6d9240511ec845060f705570df8951af52c71be55b50515edd",
                        "name": "GetState",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] Structure that will contain information about the device.",
                                "name": "pState",
                                "type": "$s_device_state_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pState`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Reset device",
                        "details": [
                            "Performs a PCI bus reset of the device. This will result in all current device state being lost.",
                            "All applications using the device should be stopped before calling this function.",
                            "If the force argument is specified, all applications using the device will be forcibly killed.",
                            "The function will block until the device has restarted or an implementation defined timeout occurred waiting for the reset to complete."
                        ],
                        "hash": "67b1841611f9320f42b40fbca89a7d36fe40df9eb3f266d1eaa2b10d345bf9dd",
                        "name": "Reset",
                        "params": [
                            {
                                "desc": "[in] Sysman handle for the device",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in] If set to true, all applications that are currently using the device will be forcibly killed.",
                                "name": "force",
                                "type": "$x_bool_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to perform this operation."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": [
                                    "Reset cannot be performed because applications are using this device."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNKNOWN": [
                                    "There were problems unloading the device driver, performing a bus reset or reloading the device driver."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Reset device extension",
                        "details": [
                            "Performs a PCI bus reset of the device. This will result in all current device state being lost.",
                            "Prior to calling this function, user is responsible for closing applications using the device unless force argument is specified.",
                            "If the force argument is specified, all applications using the device will be forcibly killed.",
                            "The function will block until the device has restarted or a implementation specific timeout occurred waiting for the reset to complete."
                        ],
                        "hash": "483a18c10d33993940d82a433a1d1315e607f86845f02ea1cb32d9f41b225fb3",
                        "name": "ResetExt",
                        "params": [
                            {
                                "desc": "[in] Sysman handle for the device",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in] Device reset properties to apply",
                                "name": "pProperties",
                                "type": "$s_reset_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to perform this operation."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_HANDLE_OBJECT_IN_USE": [
                                    "Reset cannot be performed because applications are using this device."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNKNOWN": [
                                    "There were problems unloading the device driver, performing a bus reset or reloading the device driver."
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "base": "$s_base_state_t",
                        "class": "$sDevice",
                        "desc": "Contains information about a process that has an open connection with this device",
                        "details": [
                            "The application can use the process ID to query the OS for the owner and the path to the executable."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_PROCESS_STATE",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] Host OS process ID.",
                                "name": "processId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Device memory size in bytes allocated by this process (may not necessarily be resident on the device at the time of reading).",
                                "name": "memSize",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] The size of shared device memory mapped into this process (may not necessarily be resident on the device at the time of reading).",
                                "name": "sharedSize",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Bitfield of accelerator engine types being used by this process.",
                                "name": "engines",
                                "type": "$s_engine_type_flags_t"
                            }
                        ],
                        "name": "$s_process_state_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get information about host processes using the device",
                        "details": [
                            "The number of processes connected to the device is dynamic. This means that between a call to determine the value of pCount and the subsequent call, the number of processes may have increased or decreased. It is recommended that a large array be passed in so as to avoid receiving the error $X_RESULT_ERROR_INVALID_SIZE. Also, always check the returned value in pCount since it may be less than the earlier call to get the required array size.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "e0532e5c68d72d06053786f30f98e8586a9f97e4123742ec00b31bd1190d67b0",
                        "name": "ProcessesGetState",
                        "params": [
                            {
                                "desc": "[in] Sysman handle for the device",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of processes.\nif count is zero, then the driver shall update the value with the total number of processes currently attached to the device.\nif count is greater than the number of processes currently attached to the device, then the driver shall update the value with the correct number of processes.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of process information.\nif count is less than the number of processes currently attached to the device, then the driver shall only retrieve information about that number of processes. In this case, the return code will $X_RESULT_ERROR_INVALID_SIZE.\n",
                                "name": "pProcesses",
                                "type": "$s_process_state_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_SIZE": [
                                    "The provided value of pCount is not big enough to store information about all the processes currently attached to the device."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "PCI address",
                        "members": [
                            {
                                "desc": "[out] BDF domain",
                                "name": "domain",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] BDF bus",
                                "name": "bus",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] BDF device",
                                "name": "device",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] BDF function",
                                "name": "function",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$s_pci_address_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "PCI speed",
                        "members": [
                            {
                                "desc": "[out] The link generation. A value of -1 means that this property is unknown.",
                                "name": "gen",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[out] The number of lanes. A value of -1 means that this property is unknown.",
                                "name": "width",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[out] The maximum bandwidth in bytes/sec (sum of all lanes). A value of -1 means that this property is unknown.",
                                "name": "maxBandwidth",
                                "type": "int64_t"
                            }
                        ],
                        "name": "$s_pci_speed_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sDevice",
                        "desc": "Static PCI properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_PCI_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] The BDF address",
                                "name": "address",
                                "type": "$s_pci_address_t"
                            },
                            {
                                "desc": "[out] Fastest port configuration supported by the device (sum of all lanes)",
                                "name": "maxSpeed",
                                "type": "$s_pci_speed_t"
                            },
                            {
                                "desc": "[out] Indicates whether the `rxCounter` and `txCounter` members of $s_pci_stats_t will have valid values",
                                "name": "haveBandwidthCounters",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Indicates whether the `packetCounter` member of $s_pci_stats_t will have a valid value",
                                "name": "havePacketCounters",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Indicates whether the `replayCounter` member of $s_pci_stats_t will have a valid value",
                                "name": "haveReplayCounters",
                                "type": "$x_bool_t"
                            }
                        ],
                        "name": "$s_pci_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "PCI link status",
                        "etors": [
                            {
                                "desc": "The link status could not be determined",
                                "name": "$S_PCI_LINK_STATUS_UNKNOWN",
                                "value": "0"
                            },
                            {
                                "desc": "The link is up and operating as expected",
                                "name": "$S_PCI_LINK_STATUS_GOOD",
                                "value": "1"
                            },
                            {
                                "desc": "The link is up but has quality and/or bandwidth degradation",
                                "name": "$S_PCI_LINK_STATUS_QUALITY_ISSUES",
                                "value": "2"
                            },
                            {
                                "desc": "The link has stability issues and preventing workloads making forward progress",
                                "name": "$S_PCI_LINK_STATUS_STABILITY_ISSUES",
                                "value": "3"
                            }
                        ],
                        "name": "$s_pci_link_status_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "PCI link quality degradation reasons",
                        "etors": [
                            {
                                "desc": "A significant number of replays are occurring",
                                "name": "$S_PCI_LINK_QUAL_ISSUE_FLAG_REPLAYS",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "There is a degradation in the maximum bandwidth of the link",
                                "name": "$S_PCI_LINK_QUAL_ISSUE_FLAG_SPEED",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$s_pci_link_qual_issue_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "PCI link stability issues",
                        "etors": [
                            {
                                "desc": "Link retraining has occurred to deal with quality issues",
                                "name": "$S_PCI_LINK_STAB_ISSUE_FLAG_RETRAINING",
                                "value": "$X_BIT(0)"
                            }
                        ],
                        "name": "$s_pci_link_stab_issue_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$s_base_state_t",
                        "class": "$sDevice",
                        "desc": "Dynamic PCI state",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_PCI_STATE",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] The current status of the port",
                                "name": "status",
                                "type": "$s_pci_link_status_t"
                            },
                            {
                                "desc": "[out] If status is $S_PCI_LINK_STATUS_QUALITY_ISSUES, \nthen this gives a combination of $s_pci_link_qual_issue_flag_t for quality issues that have been detected;\notherwise, 0 indicates there are no quality issues with the link at this time.\"\n",
                                "name": "qualityIssues",
                                "type": "$s_pci_link_qual_issue_flags_t"
                            },
                            {
                                "desc": "[out] If status is $S_PCI_LINK_STATUS_STABILITY_ISSUES, \nthen this gives a combination of $s_pci_link_stab_issue_flag_t for reasons for the connection instability;\notherwise, 0 indicates there are no connection stability issues at this time.\"\n",
                                "name": "stabilityIssues",
                                "type": "$s_pci_link_stab_issue_flags_t"
                            },
                            {
                                "desc": "[out] The current port configure speed",
                                "name": "speed",
                                "type": "$s_pci_speed_t"
                            }
                        ],
                        "name": "$s_pci_state_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "PCI bar types",
                        "etors": [
                            {
                                "desc": "MMIO registers",
                                "name": "$S_PCI_BAR_TYPE_MMIO",
                                "value": "0"
                            },
                            {
                                "desc": "ROM aperture",
                                "name": "$S_PCI_BAR_TYPE_ROM",
                                "value": "1"
                            },
                            {
                                "desc": "Device memory",
                                "name": "$S_PCI_BAR_TYPE_MEM",
                                "value": "2"
                            }
                        ],
                        "name": "$s_pci_bar_type_t",
                        "type": "enum"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sDevice",
                        "desc": "Properties of a pci bar",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_PCI_BAR_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] The type of bar",
                                "name": "type",
                                "type": "$s_pci_bar_type_t"
                            },
                            {
                                "desc": "[out] The index of the bar",
                                "name": "index",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Base address of the bar.",
                                "name": "base",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Size of the bar.",
                                "name": "size",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$s_pci_bar_properties_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sDevice",
                        "desc": "Properties of a pci bar, including the resizable bar.",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_PCI_BAR_PROPERTIES_1_2",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] The type of bar",
                                "name": "type",
                                "type": "$s_pci_bar_type_t"
                            },
                            {
                                "desc": "[out] The index of the bar",
                                "name": "index",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Base address of the bar.",
                                "name": "base",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Size of the bar.",
                                "name": "size",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Support for Resizable Bar on this device.",
                                "name": "resizableBarSupported",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Resizable Bar enabled on this device",
                                "name": "resizableBarEnabled",
                                "type": "$x_bool_t"
                            }
                        ],
                        "name": "$s_pci_bar_properties_1_2_t",
                        "type": "struct",
                        "version": "1.2"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "PCI stats counters",
                        "details": [
                            "Percent replays is calculated by taking two snapshots (s1, s2) and using the equation: %replay = 10^6 * (s2.replayCounter - s1.replayCounter) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))",
                            "Percent throughput is calculated by taking two snapshots (s1, s2) and using the equation: %bw = 10^6 * ((s2.rxCounter - s1.rxCounter) + (s2.txCounter - s1.txCounter)) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))"
                        ],
                        "members": [
                            {
                                "desc": "[out] Monotonic timestamp counter in microseconds when the measurement was made.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                                "name": "timestamp",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Monotonic counter for the number of replay packets (sum of all lanes). Will always be 0 when the `haveReplayCounters` member of $s_pci_properties_t is FALSE.",
                                "name": "replayCounter",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Monotonic counter for the number of packets (sum of all lanes). Will always be 0 when the `havePacketCounters` member of $s_pci_properties_t is FALSE.",
                                "name": "packetCounter",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Monotonic counter for the number of bytes received (sum of all lanes). Will always be 0 when the `haveBandwidthCounters` member of $s_pci_properties_t is FALSE.",
                                "name": "rxCounter",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Monotonic counter for the number of bytes transmitted (including replays) (sum of all lanes). Will always be 0 when the `haveBandwidthCounters` member of $s_pci_properties_t is FALSE.",
                                "name": "txCounter",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] The current speed of the link (sum of all lanes)",
                                "name": "speed",
                                "type": "$s_pci_speed_t"
                            }
                        ],
                        "name": "$s_pci_stats_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get PCI properties - address, max speed",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "e87d7976293d00d44adf69bd42f1430f154f7bf820abeda534a7330211550eec",
                        "name": "PciGetProperties",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the PCI properties.",
                                "name": "pProperties",
                                "type": "$s_pci_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get current PCI state - current speed",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "84dc8436ca5d1cfcdace8795f05b6fff03f037f9e33c0871a68a7df0c4919ac9",
                        "name": "PciGetState",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the PCI properties.",
                                "name": "pState",
                                "type": "$s_pci_state_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pState`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get information about each configured bar",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "88ba4b62a295f7ab057dac57aabd8ab6e46cd95e29f99e9c4c094d837c6d141d",
                        "name": "PciGetBars",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of PCI bars.\nif count is zero, then the driver shall update the value with the total number of PCI bars that are setup.\nif count is greater than the number of PCI bars that are setup, then the driver shall update the value with the correct number of PCI bars.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of information about setup PCI bars.\nif count is less than the number of PCI bars that are setup, then the driver shall only retrieve information about that number of PCI bars.\n",
                                "name": "pProperties",
                                "type": "$s_pci_bar_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get PCI stats - bandwidth, number of packets, number of replays",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "a4510a9789e8a79b17f288aee861954692b2662324b154bcb479f977c08e0e08",
                        "name": "PciGetStats",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain a snapshot of the latest stats.",
                                "name": "pStats",
                                "type": "$s_pci_stats_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pStats`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to query this telemetry."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "base": "$xDriver",
                        "desc": "C++ wrapper for driver instance",
                        "members": [],
                        "name": "$sDriver",
                        "type": "class"
                    },
                    {
                        "base": "$xDevice",
                        "desc": "C++ wrapper for device",
                        "members": [],
                        "name": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Overclock controls, VF curve manipulation",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "Overclock",
                "objects": [
                    {
                        "class": "$sDevice",
                        "desc": "Overclock domains.",
                        "etors": [
                            {
                                "desc": "Overclocking card level properties such as temperature limits.",
                                "name": "$S_OVERCLOCK_DOMAIN_CARD",
                                "value": "1"
                            },
                            {
                                "desc": "Overclocking package level properties such as power limits.",
                                "name": "$S_OVERCLOCK_DOMAIN_PACKAGE",
                                "value": "2"
                            },
                            {
                                "desc": "Overclocking a GPU that has all accelerator assets on the same PLL/VR.",
                                "name": "$S_OVERCLOCK_DOMAIN_GPU_ALL",
                                "value": "4"
                            },
                            {
                                "desc": "Overclocking a GPU with render and compute assets on the same PLL/VR.",
                                "name": "$S_OVERCLOCK_DOMAIN_GPU_RENDER_COMPUTE",
                                "value": "8"
                            },
                            {
                                "desc": "Overclocking a GPU with render assets on its own PLL/VR.",
                                "name": "$S_OVERCLOCK_DOMAIN_GPU_RENDER",
                                "value": "16"
                            },
                            {
                                "desc": "Overclocking a GPU with compute assets on its own PLL/VR.",
                                "name": "$S_OVERCLOCK_DOMAIN_GPU_COMPUTE",
                                "value": "32"
                            },
                            {
                                "desc": "Overclocking a GPU with media assets on its own PLL/VR.",
                                "name": "$S_OVERCLOCK_DOMAIN_GPU_MEDIA",
                                "value": "64"
                            },
                            {
                                "desc": "Overclocking device local memory.",
                                "name": "$S_OVERCLOCK_DOMAIN_VRAM",
                                "value": "128"
                            },
                            {
                                "desc": "Overclocking LLC/L4 cache.",
                                "name": "$S_OVERCLOCK_DOMAIN_ADM",
                                "value": "256"
                            }
                        ],
                        "name": "$s_overclock_domain_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Overclock controls.",
                        "etors": [
                            {
                                "desc": "This control permits setting a custom V-F curve.",
                                "name": "$S_OVERCLOCK_CONTROL_VF",
                                "value": "1"
                            },
                            {
                                "desc": "The V-F curve of the overclock domain can be shifted up or down using this control.",
                                "name": "$S_OVERCLOCK_CONTROL_FREQ_OFFSET",
                                "value": "2"
                            },
                            {
                                "desc": "This control is used to increase the permitted voltage above the shipped voltage maximum.",
                                "name": "$S_OVERCLOCK_CONTROL_VMAX_OFFSET",
                                "value": "4"
                            },
                            {
                                "desc": "This control permits direct changes to the operating frequency.",
                                "name": "$S_OVERCLOCK_CONTROL_FREQ",
                                "value": "8"
                            },
                            {
                                "desc": "This control prevents frequencies that would push the voltage above this value, typically used by V-F scanners.",
                                "name": "$S_OVERCLOCK_CONTROL_VOLT_LIMIT",
                                "value": "16"
                            },
                            {
                                "desc": "This control changes the sustained power limit (PL1).",
                                "name": "$S_OVERCLOCK_CONTROL_POWER_SUSTAINED_LIMIT",
                                "value": "32"
                            },
                            {
                                "desc": "This control changes the burst power limit (PL2).",
                                "name": "$S_OVERCLOCK_CONTROL_POWER_BURST_LIMIT",
                                "value": "64"
                            },
                            {
                                "desc": "his control changes the peak power limit (PL4).",
                                "name": "$S_OVERCLOCK_CONTROL_POWER_PEAK_LIMIT",
                                "value": "128"
                            },
                            {
                                "desc": "This control changes the value of IccMax..",
                                "name": "$S_OVERCLOCK_CONTROL_ICCMAX_LIMIT",
                                "value": "256"
                            },
                            {
                                "desc": "This control changes the value of TjMax.",
                                "name": "$S_OVERCLOCK_CONTROL_TEMP_LIMIT",
                                "value": "512"
                            },
                            {
                                "desc": "This control permits disabling the adaptive voltage feature ITD",
                                "name": "$S_OVERCLOCK_CONTROL_ITD_DISABLE",
                                "value": "1024"
                            },
                            {
                                "desc": "This control permits disabling the adaptive voltage feature ACM.",
                                "name": "$S_OVERCLOCK_CONTROL_ACM_DISABLE",
                                "value": "2048"
                            }
                        ],
                        "name": "$s_overclock_control_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Overclock modes.",
                        "etors": [
                            {
                                "desc": "Overclock mode is off",
                                "name": "$S_OVERCLOCK_MODE_MODE_OFF",
                                "value": "0"
                            },
                            {
                                "desc": "Stock (manufacturing settings) are being used.",
                                "name": "$S_OVERCLOCK_MODE_MODE_STOCK",
                                "value": "2"
                            },
                            {
                                "desc": "Overclock mode is on.",
                                "name": "$S_OVERCLOCK_MODE_MODE_ON",
                                "value": "3"
                            },
                            {
                                "desc": "Overclocking is unavailable at this time since the system is running on battery.",
                                "name": "$S_OVERCLOCK_MODE_MODE_UNAVAILABLE",
                                "value": "4"
                            },
                            {
                                "desc": "Overclock mode is disabled.",
                                "name": "$S_OVERCLOCK_MODE_MODE_DISABLED",
                                "value": "5"
                            }
                        ],
                        "name": "$s_overclock_mode_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Overclock control states.",
                        "etors": [
                            {
                                "desc": "No overclock control has not been changed by the driver since the last boot/reset.",
                                "name": "$S_CONTROL_STATE_STATE_UNSET",
                                "value": "0"
                            },
                            {
                                "desc": "The overclock control has been set and it is active.",
                                "name": "$S_CONTROL_STATE_STATE_ACTIVE",
                                "value": "2"
                            },
                            {
                                "desc": "The overclock control value has been disabled due to the current power configuration (typically when running on DC).",
                                "name": "$S_CONTROL_STATE_STATE_DISABLED",
                                "value": "3"
                            }
                        ],
                        "name": "$s_control_state_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Overclock pending actions.",
                        "etors": [
                            {
                                "desc": "There no pending actions. .",
                                "name": "$S_PENDING_ACTION_PENDING_NONE",
                                "value": "0"
                            },
                            {
                                "desc": "The requested change is in progress and should complete soon.",
                                "name": "$S_PENDING_ACTION_PENDING_IMMINENT",
                                "value": "1"
                            },
                            {
                                "desc": "The requested change requires a device cold reset (hotplug, system boot).",
                                "name": "$S_PENDING_ACTION_PENDING_COLD_RESET",
                                "value": "2"
                            },
                            {
                                "desc": "The requested change requires a device warm reset (PCIe FLR).",
                                "name": "$S_PENDING_ACTION_PENDING_WARM_RESET",
                                "value": "3"
                            }
                        ],
                        "name": "$s_pending_action_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Overclock V-F curve programing.",
                        "etors": [
                            {
                                "desc": "Can program an arbitrary number of V-F points up to the maximum number and each point can have arbitrary voltage and frequency values within the min/max/step limits",
                                "name": "$S_VF_PROGRAM_TYPE_VF_ARBITRARY",
                                "value": "0"
                            },
                            {
                                "desc": "Can only program the voltage for the V-F points that it reads back - the frequency of those points cannot be changed",
                                "name": "$S_VF_PROGRAM_TYPE_VF_FREQ_FIXED",
                                "value": "1"
                            },
                            {
                                "desc": "Can only program the frequency for the V-F points that is reads back - the voltage of each point cannot be changed.",
                                "name": "$S_VF_PROGRAM_TYPE_VF_VOLT_FIXED",
                                "value": "2"
                            }
                        ],
                        "name": "$s_vf_program_type_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "VF type",
                        "etors": [
                            {
                                "desc": "VF Voltage point",
                                "name": "$S_VF_TYPE_VOLT",
                                "value": "0"
                            },
                            {
                                "desc": "VF Frequency point",
                                "name": "$S_VF_TYPE_FREQ",
                                "value": "1"
                            }
                        ],
                        "name": "$s_vf_type_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "VF type",
                        "etors": [
                            {
                                "desc": "User V-F array",
                                "name": "$S_VF_ARRAY_TYPE_USER_VF_ARRAY",
                                "value": "0"
                            },
                            {
                                "desc": "Default V-F array",
                                "name": "$S_VF_ARRAY_TYPE_DEFAULT_VF_ARRAY",
                                "value": "1"
                            },
                            {
                                "desc": "Live V-F array",
                                "name": "$S_VF_ARRAY_TYPE_LIVE_VF_ARRAY",
                                "value": "2"
                            }
                        ],
                        "name": "$s_vf_array_type_t",
                        "type": "enum",
                        "version": "1.5"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sOverclock",
                        "desc": "Overclock properties",
                        "details": [
                            "Information on the overclock domain type and all the contols that are part of the domain."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_OVERCLOCK_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] The hardware block that this overclock domain controls (GPU, VRAM, ...)",
                                "name": "domainType",
                                "type": "$s_overclock_domain_t"
                            },
                            {
                                "desc": "[out] Returns the overclock controls that are supported (a bit for each of enum $s_overclock_control_t). If no bits are set, the domain doesn't support overclocking.",
                                "name": "AvailableControls",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Type of V-F curve programming that is permitted:.",
                                "name": "VFProgramType",
                                "type": "$s_vf_program_type_t"
                            },
                            {
                                "desc": "[out] Number of VF points that can be programmed - max_num_points",
                                "name": "NumberOfVFPoints",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$s_overclock_properties_t",
                        "type": "struct",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Overclock Control properties",
                        "details": [
                            "Provides all the control capabilities supported by the device for the overclock domain."
                        ],
                        "members": [
                            {
                                "desc": "[out]  This provides information about the limits of the control value so that the driver can calculate the set of valid values.",
                                "name": "MinValue",
                                "type": "double"
                            },
                            {
                                "desc": "[out]  This provides information about the limits of the control value so that the driver can calculate the set of valid values.",
                                "name": "MaxValue",
                                "type": "double"
                            },
                            {
                                "desc": "[out]  This provides information about the limits of the control value so that the driver can calculate the set of valid values.",
                                "name": "StepValue",
                                "type": "double"
                            },
                            {
                                "desc": "[out] The reference value provides the anchor point, UIs can combine this with the user offset request to show the anticipated improvement.",
                                "name": "RefValue",
                                "type": "double"
                            },
                            {
                                "desc": "[out] The shipped out-of-box position of this control. Driver can request this value at any time to return to the out-of-box behavior.",
                                "name": "DefaultValue",
                                "type": "double"
                            }
                        ],
                        "name": "$s_control_property_t",
                        "type": "struct",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Overclock VF properties",
                        "details": [
                            "Provides all the VF capabilities supported by the device for the overclock domain."
                        ],
                        "members": [
                            {
                                "desc": "[out] Read the minimum frequency that can be be programmed in the custom V-F point..",
                                "name": "MinFreq",
                                "type": "double"
                            },
                            {
                                "desc": "[out] Read the maximum frequency that can be be programmed in the custom V-F point..",
                                "name": "MaxFreq",
                                "type": "double"
                            },
                            {
                                "desc": "[out] Read the frequency step that can be be programmed in the custom V-F point..",
                                "name": "StepFreq",
                                "type": "double"
                            },
                            {
                                "desc": "[out] Read the minimum voltage that can be be programmed in the custom V-F point..",
                                "name": "MinVolt",
                                "type": "double"
                            },
                            {
                                "desc": "[out] Read the maximum voltage that can be be programmed in the custom V-F point..",
                                "name": "MaxVolt",
                                "type": "double"
                            },
                            {
                                "desc": "[out] Read the voltage step that can be be programmed in the custom V-F point.",
                                "name": "StepVolt",
                                "type": "double"
                            }
                        ],
                        "name": "$s_vf_property_t",
                        "type": "struct",
                        "version": "1.5"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Set the overclock waiver.The overclock waiver setting is persistent until the next pcode boot",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "55c493e98932c5d36afcb11a3c43d6ac222932f5e4d8f125bcc5106787e4a320",
                        "name": "SetOverclockWaiver",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "This product does not support overclocking"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get the list of supported overclock domains for this device",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "0d9d47c012a59f1376b1664e436a9a25f3aece1c27faa5827e7e521c9066e5f7",
                        "name": "GetOverclockDomains",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] Returns the overclock domains that are supported (a bit for each of enum $s_overclock_domain_t). If no bits are set, the device doesn't support overclocking.",
                                "name": "pOverclockDomains",
                                "type": "uint32_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pOverclockDomains`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this control domain"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get the list of supported overclock controls available for one of the supported overclock domains on the device",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "4377753972c5b509120ab9c0d528b6c7428abbbaa4b0eb1c0704a51a7d8c351c",
                        "name": "GetOverclockControls",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in] Domain type.",
                                "name": "domainType",
                                "type": "$s_overclock_domain_t"
                            },
                            {
                                "desc": "[in,out] Returns the overclock controls that are supported for the specified overclock domain (a bit for each of enum $s_overclock_control_t).",
                                "name": "pAvailableControls",
                                "type": "uint32_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$S_OVERCLOCK_DOMAIN_ADM < domainType`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pAvailableControls`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this control domain"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Reset all overclock settings to default values (shipped = 1 or manufacturing =0)",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "7318489a5a2134bc3f0789ac6ae8a5f1712f4d71314cbb846d6d0260eae1b474",
                        "name": "ResetOverclockSettings",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in] True will reset to shipped state; false will reset to manufacturing state",
                                "name": "onShippedState",
                                "type": "$x_bool_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this control domain"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Determine the state of overclocking",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "bf83d33d94f9f7a4212f5acf692aa525675b4ae890259e8e179069c1a95c83e2",
                        "name": "ReadOverclockState",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[out] One of overclock mode.",
                                "name": "pOverclockMode",
                                "type": "$s_overclock_mode_t*"
                            },
                            {
                                "desc": "[out] Waiver setting: 0 = Waiver not set, 1 = waiver has been set.",
                                "name": "pWaiverSetting",
                                "type": "$x_bool_t*"
                            },
                            {
                                "desc": "[out] Current settings 0 =manufacturing state, 1= shipped state)..",
                                "name": "pOverclockState",
                                "type": "$x_bool_t*"
                            },
                            {
                                "desc": "[out] This enum is returned when the driver attempts to set an overclock control or reset overclock settings.",
                                "name": "pPendingAction",
                                "type": "$s_pending_action_t*"
                            },
                            {
                                "desc": "[out] Pending reset 0 =manufacturing state, 1= shipped state)..",
                                "name": "pPendingReset",
                                "type": "$x_bool_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pOverclockMode`",
                                    "`nullptr == pWaiverSetting`",
                                    "`nullptr == pOverclockState`",
                                    "`nullptr == pPendingAction`",
                                    "`nullptr == pPendingReset`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this control domain"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of overclock domains",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "4b879a76b3b04fde6760e7c52a1df27690607bd6f77d8eefa431bfe0bde261db",
                        "name": "EnumOverclockDomains",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phDomainHandle",
                                "type": "$s_overclock_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Get overclock domain control properties",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "416c9b4d0a45ce8cef79a8367a0d9e5a23de228774dbf59a5c06a7af0ce6e325",
                        "name": "GetDomainProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component domain.",
                                "name": "hDomainHandle",
                                "type": "$s_overclock_handle_t"
                            },
                            {
                                "desc": "[in,out] The overclock properties for the specified domain.",
                                "name": "pDomainProperties",
                                "type": "$s_overclock_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDomainHandle`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pDomainProperties`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this control domain"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Read overclock VF min,max and step values",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "899c590948448590df0ce9f6d0767f769d4f1480b939a30cc769cc07f80315c4",
                        "name": "GetDomainVFProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component domain.",
                                "name": "hDomainHandle",
                                "type": "$s_overclock_handle_t"
                            },
                            {
                                "desc": "[in,out] The VF min,max,step for a specified domain.",
                                "name": "pVFProperties",
                                "type": "$s_vf_property_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDomainHandle`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pVFProperties`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this control domain"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Read overclock control values - min/max/step/default/ref",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "cade6249e729096d63ce08310fd878151a968afa8abc580980d5c258a9ec48fb",
                        "name": "GetDomainControlProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component domain.",
                                "name": "hDomainHandle",
                                "type": "$s_overclock_handle_t"
                            },
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "DomainControl",
                                "type": "$s_overclock_control_t"
                            },
                            {
                                "desc": "[in,out] overclock control values.",
                                "name": "pControlProperties",
                                "type": "$s_control_property_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDomainHandle`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$S_OVERCLOCK_CONTROL_ACM_DISABLE < DomainControl`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pControlProperties`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this control domain"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Read the current value for a given overclock control",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "d9b4cc3a89e0a244a5748ef773a56340b963b51a15ff79e6e84a53598a2a8e06",
                        "name": "GetControlCurrentValue",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hDomainHandle",
                                "type": "$s_overclock_handle_t"
                            },
                            {
                                "desc": "[in] Overclock Control.",
                                "name": "DomainControl",
                                "type": "$s_overclock_control_t"
                            },
                            {
                                "desc": "[in,out] Getting overclock control value for the specified control.",
                                "name": "pValue",
                                "type": "double*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDomainHandle`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$S_OVERCLOCK_CONTROL_ACM_DISABLE < DomainControl`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pValue`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this control domain"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Read the the reset pending value for a given overclock control",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "9ba2bc75c2454afb04fa795e698945acb130400573382ae99ebf3105a50b4f27",
                        "name": "GetControlPendingValue",
                        "params": [
                            {
                                "desc": "[in] Handle for the component domain.",
                                "name": "hDomainHandle",
                                "type": "$s_overclock_handle_t"
                            },
                            {
                                "desc": "[in] Overclock Control.",
                                "name": "DomainControl",
                                "type": "$s_overclock_control_t"
                            },
                            {
                                "desc": "[out] Returns the pending value for a given control. The units and format of the value depend on the control type.",
                                "name": "pValue",
                                "type": "double*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDomainHandle`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$S_OVERCLOCK_CONTROL_ACM_DISABLE < DomainControl`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pValue`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this control domain"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Set the value for a given overclock control",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "dfbb3911b91acb313aa7d4bb72ebd08d0183a56b5663f5f44ea114b83270ac10",
                        "name": "SetControlUserValue",
                        "params": [
                            {
                                "desc": "[in] Handle for the component domain.",
                                "name": "hDomainHandle",
                                "type": "$s_overclock_handle_t"
                            },
                            {
                                "desc": "[in] Domain Control.",
                                "name": "DomainControl",
                                "type": "$s_overclock_control_t"
                            },
                            {
                                "desc": "[in] The new value of the control. The units and format of the value depend on the control type.",
                                "name": "pValue",
                                "type": "double"
                            },
                            {
                                "desc": "[out] Pending overclock setting.",
                                "name": "pPendingAction",
                                "type": "$s_pending_action_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDomainHandle`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$S_OVERCLOCK_CONTROL_ACM_DISABLE < DomainControl`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pPendingAction`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this control domain"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Determine the state of an overclock control",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "f6955ca25e09f286e83af378e9b44a83ee85177ef351898262df6df3bf834e58",
                        "name": "GetControlState",
                        "params": [
                            {
                                "desc": "[in] Handle for the component domain.",
                                "name": "hDomainHandle",
                                "type": "$s_overclock_handle_t"
                            },
                            {
                                "desc": "[in] Domain Control.",
                                "name": "DomainControl",
                                "type": "$s_overclock_control_t"
                            },
                            {
                                "desc": "[out] Current overclock control state.",
                                "name": "pControlState",
                                "type": "$s_control_state_t*"
                            },
                            {
                                "desc": "[out] Pending overclock setting.",
                                "name": "pPendingAction",
                                "type": "$s_pending_action_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDomainHandle`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$S_OVERCLOCK_CONTROL_ACM_DISABLE < DomainControl`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pControlState`",
                                    "`nullptr == pPendingAction`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this control domain"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Read the frequency or voltage of a V-F point from the default or custom V-F curve.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "8b56f4fb8f854cf65406481cf251f0a09fd6ab09ae35df9a0d8a7362529153a8",
                        "name": "GetVFPointValues",
                        "params": [
                            {
                                "desc": "[in] Handle for the component domain.",
                                "name": "hDomainHandle",
                                "type": "$s_overclock_handle_t"
                            },
                            {
                                "desc": "[in] Voltage or Freqency point to read.",
                                "name": "VFType",
                                "type": "$s_vf_type_t"
                            },
                            {
                                "desc": "[in] User,Default or Live VF array to read from",
                                "name": "VFArrayType",
                                "type": "$s_vf_array_type_t"
                            },
                            {
                                "desc": "[in] Point index - number between (0, max_num_points - 1).",
                                "name": "PointIndex",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Returns the frequency in 1kHz units or voltage in millivolt units from the custom V-F curve at the specified zero-based index ",
                                "name": "PointValue",
                                "type": "uint32_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDomainHandle`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$S_VF_TYPE_FREQ < VFType`",
                                    "`$S_VF_ARRAY_TYPE_LIVE_VF_ARRAY < VFArrayType`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == PointValue`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this control domain"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "class": "$sOverclock",
                        "desc": "Write the frequency or voltage of a V-F point to custom V-F curve.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "8bb361cef11696f36f541cac2d919f200cf453261bc940ec647786681f425e9c",
                        "name": "SetVFPointValues",
                        "params": [
                            {
                                "desc": "[in] Handle for the component domain.",
                                "name": "hDomainHandle",
                                "type": "$s_overclock_handle_t"
                            },
                            {
                                "desc": "[in] Voltage or Freqency point to read.",
                                "name": "VFType",
                                "type": "$s_vf_type_t"
                            },
                            {
                                "desc": "[in] Point index - number between (0, max_num_points - 1).",
                                "name": "PointIndex",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] Writes frequency in 1kHz units or voltage in millivolt units to custom V-F curve at the specified zero-based index ",
                                "name": "PointValue",
                                "type": "uint32_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDomainHandle`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$S_VF_TYPE_FREQ < VFType`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this control domain"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.5"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device overclock domain",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_overclock_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sOverclock",
                        "owner": "$sDevice",
                        "type": "class",
                        "version": "1.5"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Firmware management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "diagnostics",
                "objects": [
                    {
                        "class": "$sDiagnostics",
                        "desc": "Diagnostic results",
                        "etors": [
                            {
                                "desc": "Diagnostic completed without finding errors to repair",
                                "name": "$S_DIAG_RESULT_NO_ERRORS",
                                "value": "0"
                            },
                            {
                                "desc": "Diagnostic had problems running tests",
                                "name": "$S_DIAG_RESULT_ABORT",
                                "value": "1"
                            },
                            {
                                "desc": "Diagnostic had problems setting up repairs",
                                "name": "$S_DIAG_RESULT_FAIL_CANT_REPAIR",
                                "value": "2"
                            },
                            {
                                "desc": "Diagnostics found errors, setup for repair and reboot is required to complete the process",
                                "name": "$S_DIAG_RESULT_REBOOT_FOR_REPAIR",
                                "value": "3"
                            }
                        ],
                        "name": "$s_diag_result_t",
                        "type": "enum"
                    },
                    {
                        "desc": "Diagnostic test index to use for the very first test.",
                        "name": "$S_DIAG_FIRST_TEST_INDEX",
                        "type": "macro",
                        "value": "0x0"
                    },
                    {
                        "desc": "Diagnostic test index to use for the very last test.",
                        "name": "$S_DIAG_LAST_TEST_INDEX",
                        "type": "macro",
                        "value": "0xFFFFFFFF"
                    },
                    {
                        "class": "$sDiagnostics",
                        "desc": "Diagnostic test",
                        "members": [
                            {
                                "desc": "[out] Index of the test",
                                "name": "index",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Name of the test",
                                "name": "name[$S_STRING_PROPERTY_SIZE]",
                                "type": "char"
                            }
                        ],
                        "name": "$s_diag_test_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sDiagnostics",
                        "desc": "Diagnostics test suite properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_DIAG_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Name of the diagnostics test suite",
                                "name": "name[$S_STRING_PROPERTY_SIZE]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] Indicates if this test suite has individual tests which can be run separately (use the function $sDiagnosticsGetTests() to get the list of these tests)",
                                "name": "haveTests",
                                "type": "$x_bool_t"
                            }
                        ],
                        "name": "$s_diag_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of diagnostics test suites",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "59ed350ef7e70b37e52550c3ab609f5379d8b887c910db4babc51892f01acaed",
                        "name": "EnumDiagnosticTestSuites",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phDiagnostics",
                                "type": "$s_diag_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sDiagnostics",
                        "desc": "Get properties of a diagnostics test suite",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "3388b8e374bf55f17c6ed5c46ec293e7e127397ad28a759037eb3865c8c4021c",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hDiagnostics",
                                "type": "$s_diag_handle_t"
                            },
                            {
                                "desc": "[in,out] Structure describing the properties of a diagnostics test suite",
                                "name": "pProperties",
                                "type": "$s_diag_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDiagnostics`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sDiagnostics",
                        "desc": "Get individual tests that can be run separately. Not all test suites permit running individual tests, check the `haveTests` member of $s_diag_properties_t.",
                        "details": [
                            "The list of available tests is returned in order of increasing test index (see the `index` member of $s_diag_test_t).",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "4219d4ef7697f5b2b7b20571adf1350eeb3e20d96f93c37d10e86d05b8faed06",
                        "name": "GetTests",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hDiagnostics",
                                "type": "$s_diag_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of tests.\nif count is zero, then the driver shall update the value with the total number of tests that are available.\nif count is greater than the number of tests that are available, then the driver shall update the value with the correct number of tests.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of information about individual tests sorted by increasing value of the `index` member of $s_diag_test_t.\nif count is less than the number of tests that are available, then the driver shall only retrieve that number of tests.\n",
                                "name": "pTests",
                                "type": "$s_diag_test_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDiagnostics`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sDiagnostics",
                        "desc": "Run a diagnostics test suite, either all tests or a subset of tests.",
                        "details": [
                            "WARNING: Running diagnostics may destroy current device state information. Gracefully close any running workloads before initiating.",
                            "To run all tests in a test suite, set start = $S_DIAG_FIRST_TEST_INDEX and end = $S_DIAG_LAST_TEST_INDEX.",
                            "If the test suite permits running individual tests, the `haveTests` member of $s_diag_properties_t will be true. In this case, the function $sDiagnosticsGetTests() can be called to get the list of tests and corresponding indices that can be supplied to the arguments start and end in this function.",
                            "This function will block until the diagnostics have completed and force reset based on result"
                        ],
                        "hash": "349d2006c7ca8ec132f2c6eb5efdabdcbb4c439f9905517fd0fb216f63671c28",
                        "name": "RunTests",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hDiagnostics",
                                "type": "$s_diag_handle_t"
                            },
                            {
                                "desc": "[in] The index of the first test to run. Set to $S_DIAG_FIRST_TEST_INDEX to start from the beginning.",
                                "name": "startIndex",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] The index of the last test to run. Set to $S_DIAG_LAST_TEST_INDEX to complete all tests after the start test.",
                                "name": "endIndex",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in,out] The result of the diagnostics",
                                "name": "pResult",
                                "type": "$s_diag_result_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDiagnostics`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pResult`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to perform diagnostics."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device diagnostic test suite",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_diag_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sDiagnostics",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - ECC management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "ecc",
                "objects": [
                    {
                        "class": "$sDevice",
                        "desc": "ECC State",
                        "etors": [
                            {
                                "desc": "None",
                                "name": "$S_DEVICE_ECC_STATE_UNAVAILABLE",
                                "value": "0"
                            },
                            {
                                "desc": "ECC enabled.",
                                "name": "$S_DEVICE_ECC_STATE_ENABLED",
                                "value": "1"
                            },
                            {
                                "desc": "ECC disabled.",
                                "name": "$S_DEVICE_ECC_STATE_DISABLED",
                                "value": "2"
                            }
                        ],
                        "name": "$s_device_ecc_state_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "State Change Requirements",
                        "etors": [
                            {
                                "desc": "No action.",
                                "name": "$S_DEVICE_ACTION_NONE",
                                "value": "0"
                            },
                            {
                                "desc": "Warm reset of the card.",
                                "name": "$S_DEVICE_ACTION_WARM_CARD_RESET",
                                "value": "1"
                            },
                            {
                                "desc": "Cold reset of the card.",
                                "name": "$S_DEVICE_ACTION_COLD_CARD_RESET",
                                "value": "2"
                            },
                            {
                                "desc": "Cold reboot of the system.",
                                "name": "$S_DEVICE_ACTION_COLD_SYSTEM_REBOOT",
                                "value": "3"
                            }
                        ],
                        "name": "$s_device_action_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "base": "$s_base_desc_t",
                        "class": "$sDevice",
                        "desc": "ECC State Descriptor",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_DEVICE_ECC_DESC",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] ECC state",
                                "name": "state",
                                "type": "$s_device_ecc_state_t"
                            }
                        ],
                        "name": "$s_device_ecc_desc_t",
                        "type": "struct",
                        "version": "1.4"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sDevice",
                        "desc": "ECC State",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_DEVICE_ECC_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] Current ECC state",
                                "name": "currentState",
                                "type": "$s_device_ecc_state_t"
                            },
                            {
                                "desc": "[out] Pending ECC state",
                                "name": "pendingState",
                                "type": "$s_device_ecc_state_t"
                            },
                            {
                                "desc": "[out] Pending action",
                                "name": "pendingAction",
                                "type": "$s_device_action_t"
                            }
                        ],
                        "name": "$s_device_ecc_properties_t",
                        "type": "struct",
                        "version": "1.4"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Is ECC functionality available - true or false?",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "264b6e89d9b7c9216eab024643025dc409bda4982818418314482dbb1724ff12",
                        "name": "EccAvailable",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[out] ECC functionality is available (true)/unavailable (false).",
                                "name": "pAvailable",
                                "type": "$x_bool_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pAvailable`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.4"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Is ECC support configurable - true or false?",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "0f8ff49a7a8abe8cde740b8234ca60bae96be561699e0a742338476b52a94218",
                        "name": "EccConfigurable",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[out] ECC can be enabled/disabled (true)/enabled/disabled (false).",
                                "name": "pConfigurable",
                                "type": "$x_bool_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pConfigurable`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.4"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get current ECC state, pending state, and pending action",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "6c8f13b7f3cc21e39963799875b4651b8a7bc0d3790f8cfec04d2a216d242634",
                        "name": "GetEccState",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[out] ECC state, pending state, and pending action for state change.",
                                "name": "pState",
                                "type": "$s_device_ecc_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pState`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.4"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Set new ECC state",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free.",
                            "$sDeviceGetState should be called to determine pending action required to implement state change."
                        ],
                        "hash": "5170246117a72b8ffc924046f9ebe857e8e0da6f5e41829c7029a7d8eb4b280e",
                        "name": "SetEccState",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in] Pointer to desired ECC state.",
                                "name": "newState",
                                "type": "const $s_device_ecc_desc_t*"
                            },
                            {
                                "desc": "[out] ECC state, pending state, and pending action for state change.",
                                "name": "pState",
                                "type": "$s_device_ecc_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == newState`",
                                    "`nullptr == pState`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$S_DEVICE_ECC_STATE_DISABLED < newState->state`"
                                ]
                            },
                            {
                                "$X_RESULT_WARNING_ACTION_REQUIRED": [
                                    "User must look at the pendingAction attribute of pState & perform the action required to complete the ECC state change."
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.4"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Engine groups",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "engine",
                "objects": [
                    {
                        "class": "$sEngine",
                        "desc": "Accelerator engine groups",
                        "etors": [
                            {
                                "desc": "Access information about all engines combined.",
                                "name": "$S_ENGINE_GROUP_ALL",
                                "value": "0"
                            },
                            {
                                "desc": "Access information about all compute engines combined. Compute engines can only process compute kernels (no 3D content).",
                                "name": "$S_ENGINE_GROUP_COMPUTE_ALL",
                                "value": "1"
                            },
                            {
                                "desc": "Access information about all media engines combined.",
                                "name": "$S_ENGINE_GROUP_MEDIA_ALL",
                                "value": "2"
                            },
                            {
                                "desc": "Access information about all copy (blitter) engines combined.",
                                "name": "$S_ENGINE_GROUP_COPY_ALL",
                                "value": "3"
                            },
                            {
                                "desc": "Access information about a single compute engine - this is an engine that can process compute kernels. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use $S_ENGINE_GROUP_3D_RENDER_COMPUTE_ALL for that.",
                                "name": "$S_ENGINE_GROUP_COMPUTE_SINGLE",
                                "value": "4"
                            },
                            {
                                "desc": "Access information about a single render engine - this is an engine that can process both 3D content and compute kernels. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use $S_ENGINE_GROUP_3D_RENDER_COMPUTE_ALL for that.",
                                "name": "$S_ENGINE_GROUP_RENDER_SINGLE",
                                "value": "5"
                            },
                            {
                                "desc": "Access information about a single media decode engine. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use $S_ENGINE_GROUP_MEDIA_ALL for that.",
                                "name": "$S_ENGINE_GROUP_MEDIA_DECODE_SINGLE",
                                "value": "6"
                            },
                            {
                                "desc": "Access information about a single media encode engine. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use $S_ENGINE_GROUP_MEDIA_ALL for that.",
                                "name": "$S_ENGINE_GROUP_MEDIA_ENCODE_SINGLE",
                                "value": "7"
                            },
                            {
                                "desc": "Access information about a single media encode engine. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use $S_ENGINE_GROUP_COPY_ALL for that.",
                                "name": "$S_ENGINE_GROUP_COPY_SINGLE",
                                "value": "8"
                            },
                            {
                                "desc": "Access information about a single media enhancement engine. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use $S_ENGINE_GROUP_MEDIA_ALL for that.",
                                "name": "$S_ENGINE_GROUP_MEDIA_ENHANCEMENT_SINGLE",
                                "value": "9"
                            },
                            {
                                "desc": "Access information about a single 3D engine - this is an engine that can process 3D content only. Note that single engines may share the same underlying accelerator resources as other engines so activity of such an engine may not be indicative of the underlying resource utilization - use $S_ENGINE_GROUP_3D_RENDER_COMPUTE_ALL for that.",
                                "name": "$S_ENGINE_GROUP_3D_SINGLE",
                                "value": "10"
                            },
                            {
                                "desc": "Access information about all 3D/render/compute engines combined.",
                                "name": "$S_ENGINE_GROUP_3D_RENDER_COMPUTE_ALL",
                                "value": "11"
                            },
                            {
                                "desc": "Access information about all render engines combined. Render engines are those than process both 3D content and compute kernels.",
                                "name": "$S_ENGINE_GROUP_RENDER_ALL",
                                "value": "12"
                            },
                            {
                                "desc": "Access information about all 3D engines combined. 3D engines can process 3D content only (no compute kernels).",
                                "name": "$S_ENGINE_GROUP_3D_ALL",
                                "value": "13"
                            }
                        ],
                        "name": "$s_engine_group_t",
                        "type": "enum"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sEngine",
                        "desc": "Engine group properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_ENGINE_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] The engine group",
                                "name": "type",
                                "type": "$s_engine_group_t"
                            },
                            {
                                "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$s_engine_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sEngine",
                        "desc": "Engine activity counters",
                        "details": [
                            "Percent utilization is calculated by taking two snapshots (s1, s2) and using the equation: %util = (s2.activeTime - s1.activeTime) / (s2.timestamp - s1.timestamp)"
                        ],
                        "members": [
                            {
                                "desc": "[out] Monotonic counter for time in microseconds that this resource is actively running workloads.",
                                "name": "activeTime",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Monotonic timestamp counter in microseconds when activeTime counter was sampled.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                                "name": "timestamp",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$s_engine_stats_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of engine groups",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "25e6a47559c32a64fa8b2e4c45eae905a6ec1127530dcbbeb65637befa658e26",
                        "name": "EnumEngineGroups",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phEngine",
                                "type": "$s_engine_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sEngine",
                        "desc": "Get engine group properties",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "df26d108743e24d58025aaf75554da14e82d69ca34bcebf1578440f7d360d5a6",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hEngine",
                                "type": "$s_engine_handle_t"
                            },
                            {
                                "desc": "[in,out] The properties for the specified engine group.",
                                "name": "pProperties",
                                "type": "$s_engine_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEngine`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sEngine",
                        "desc": "Get the activity stats for an engine group.",
                        "details": [
                            "This function also returns the engine activity inside a Virtual Machine (VM), in the presence of hardware virtualization (SRIOV)",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "b4c7b2006754814930556a754b21e2fd5ee2df9dcbf6aef7521d44488a217f5e",
                        "name": "GetActivity",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hEngine",
                                "type": "$s_engine_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain a snapshot of the engine group activity counters.",
                                "name": "pStats",
                                "type": "$s_engine_stats_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEngine`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pStats`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device engine group",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_engine_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sEngine",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Event management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "events",
                "objects": [
                    {
                        "class": "$sDriver",
                        "desc": "Event types",
                        "etors": [
                            {
                                "desc": "Event is triggered when the device is no longer available (due to a reset or being disabled).",
                                "name": "$S_EVENT_TYPE_FLAG_DEVICE_DETACH",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "Event is triggered after the device is available again.",
                                "name": "$S_EVENT_TYPE_FLAG_DEVICE_ATTACH",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Event is triggered when the driver is about to put the device into a deep sleep state",
                                "name": "$S_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_ENTER",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "Event is triggered when the driver is waking the device up from a deep sleep state",
                                "name": "$S_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_EXIT",
                                "value": "$X_BIT(3)"
                            },
                            {
                                "desc": "Event is triggered when the frequency starts being throttled",
                                "name": "$S_EVENT_TYPE_FLAG_FREQ_THROTTLED",
                                "value": "$X_BIT(4)"
                            },
                            {
                                "desc": "Event is triggered when the energy consumption threshold is reached (use $sPowerSetEnergyThreshold() to configure).",
                                "name": "$S_EVENT_TYPE_FLAG_ENERGY_THRESHOLD_CROSSED",
                                "value": "$X_BIT(5)"
                            },
                            {
                                "desc": "Event is triggered when the critical temperature is reached (use $sTemperatureSetConfig() to configure - disabled by default).",
                                "name": "$S_EVENT_TYPE_FLAG_TEMP_CRITICAL",
                                "value": "$X_BIT(6)"
                            },
                            {
                                "desc": "Event is triggered when the temperature crosses threshold 1 (use $sTemperatureSetConfig() to configure - disabled by default).",
                                "name": "$S_EVENT_TYPE_FLAG_TEMP_THRESHOLD1",
                                "value": "$X_BIT(7)"
                            },
                            {
                                "desc": "Event is triggered when the temperature crosses threshold 2 (use $sTemperatureSetConfig() to configure - disabled by default).",
                                "name": "$S_EVENT_TYPE_FLAG_TEMP_THRESHOLD2",
                                "value": "$X_BIT(8)"
                            },
                            {
                                "desc": "Event is triggered when the health of device memory changes.",
                                "name": "$S_EVENT_TYPE_FLAG_MEM_HEALTH",
                                "value": "$X_BIT(9)"
                            },
                            {
                                "desc": "Event is triggered when the health of fabric ports change.",
                                "name": "$S_EVENT_TYPE_FLAG_FABRIC_PORT_HEALTH",
                                "value": "$X_BIT(10)"
                            },
                            {
                                "desc": "Event is triggered when the health of the PCI link changes.",
                                "name": "$S_EVENT_TYPE_FLAG_PCI_LINK_HEALTH",
                                "value": "$X_BIT(11)"
                            },
                            {
                                "desc": "Event is triggered when accelerator RAS correctable errors cross thresholds (use $sRasSetConfig() to configure - disabled by default).",
                                "name": "$S_EVENT_TYPE_FLAG_RAS_CORRECTABLE_ERRORS",
                                "value": "$X_BIT(12)"
                            },
                            {
                                "desc": "Event is triggered when accelerator RAS uncorrectable errors cross thresholds (use $sRasSetConfig() to configure - disabled by default).",
                                "name": "$S_EVENT_TYPE_FLAG_RAS_UNCORRECTABLE_ERRORS",
                                "value": "$X_BIT(13)"
                            },
                            {
                                "desc": "Event is triggered when the device needs to be reset (use $sDeviceGetState() to determine the reasons for the reset).",
                                "name": "$S_EVENT_TYPE_FLAG_DEVICE_RESET_REQUIRED",
                                "value": "$X_BIT(14)"
                            }
                        ],
                        "name": "$s_event_type_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Specify the list of events to listen to for a given device",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "26fc8939c3a29505329de969535a2946e59d9e03b312a2da336655b503bc9f28",
                        "name": "EventRegister",
                        "params": [
                            {
                                "desc": "[in] The device handle.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in] List of events to listen to.",
                                "name": "events",
                                "type": "$s_event_type_flags_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`0x7fff < events`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sDriver",
                        "decl": "static",
                        "desc": "Wait for events to be received from a one or more devices.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "b00de872443c97d166cd17f0042a606d264fb05f1b2ce96a3203bef5552dc652",
                        "name": "EventListen",
                        "params": [
                            {
                                "desc": "[in] handle of the driver instance",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in] if non-zero, then indicates the maximum time (in milliseconds) to yield before returning $X_RESULT_SUCCESS or $X_RESULT_NOT_READY;\nif zero, then will check status and return immediately;\nif `UINT32_MAX`, then function will not return until events arrive.\n",
                                "name": "timeout",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in] Number of device handles in phDevices.",
                                "name": "count",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][range(0, count)] Device handles to listen to for events. Only devices from the provided driver handle can be specified in this list.",
                                "name": "phDevices",
                                "type": "$s_device_handle_t*"
                            },
                            {
                                "desc": "[in,out] Will contain the actual number of devices in phDevices that generated events. If non-zero, check pEvents to determine the devices and events that were received.",
                                "name": "pNumDeviceEvents",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out] An array that will continue the list of events for each device listened in phDevices.\nThis array must be at least as big as count.\nFor every device handle in phDevices, this will provide the events that occurred for that device at the same position in this array. If no event was received for a given device, the corresponding array entry will be zero.\n",
                                "name": "pEvents",
                                "type": "$s_event_type_flags_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phDevices`",
                                    "`nullptr == pNumDeviceEvents`",
                                    "`nullptr == pEvents`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to listen to events."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ARGUMENT": [
                                    "One or more of the supplied device handles belongs to a different driver."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sDriver",
                        "decl": "static",
                        "desc": "Wait for events to be received from a one or more devices.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "60aaa2b499d532b22ccc6b5ce05ee5e7008c45c69550bd6c1f6e3010e6cffc01",
                        "name": "EventListenEx",
                        "params": [
                            {
                                "desc": "[in] handle of the driver instance",
                                "name": "hDriver",
                                "type": "$x_driver_handle_t"
                            },
                            {
                                "desc": "[in] if non-zero, then indicates the maximum time (in milliseconds) to yield before returning $X_RESULT_SUCCESS or $X_RESULT_NOT_READY;\nif zero, then will check status and return immediately;\nif `UINT64_MAX`, then function will not return until events arrive.\n",
                                "name": "timeout",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[in] Number of device handles in phDevices.",
                                "name": "count",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][range(0, count)] Device handles to listen to for events. Only devices from the provided driver handle can be specified in this list.",
                                "name": "phDevices",
                                "type": "$s_device_handle_t*"
                            },
                            {
                                "desc": "[in,out] Will contain the actual number of devices in phDevices that generated events. If non-zero, check pEvents to determine the devices and events that were received.",
                                "name": "pNumDeviceEvents",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out] An array that will continue the list of events for each device listened in phDevices.\nThis array must be at least as big as count.\nFor every device handle in phDevices, this will provide the events that occurred for that device at the same position in this array. If no event was received for a given device, the corresponding array entry will be zero.\n",
                                "name": "pEvents",
                                "type": "$s_event_type_flags_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDriver`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phDevices`",
                                    "`nullptr == pNumDeviceEvents`",
                                    "`nullptr == pEvents`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to listen to events."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ARGUMENT": [
                                    "One or more of the supplied device handles belongs to a different driver."
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.1"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Firmware management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "fabric",
                "objects": [
                    {
                        "desc": "Maximum Fabric port model string size",
                        "name": "$S_MAX_FABRIC_PORT_MODEL_SIZE",
                        "type": "macro",
                        "value": "256"
                    },
                    {
                        "desc": "Maximum size of the buffer that will return information about link types",
                        "name": "$S_MAX_FABRIC_LINK_TYPE_SIZE",
                        "type": "macro",
                        "value": "256"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Fabric port status",
                        "etors": [
                            {
                                "desc": "The port status cannot be determined",
                                "name": "$S_FABRIC_PORT_STATUS_UNKNOWN",
                                "value": "0"
                            },
                            {
                                "desc": "The port is up and operating as expected",
                                "name": "$S_FABRIC_PORT_STATUS_HEALTHY",
                                "value": "1"
                            },
                            {
                                "desc": "The port is up but has quality and/or speed degradation",
                                "name": "$S_FABRIC_PORT_STATUS_DEGRADED",
                                "value": "2"
                            },
                            {
                                "desc": "Port connection instabilities are preventing workloads making forward progress",
                                "name": "$S_FABRIC_PORT_STATUS_FAILED",
                                "value": "3"
                            },
                            {
                                "desc": "The port is configured down",
                                "name": "$S_FABRIC_PORT_STATUS_DISABLED",
                                "value": "4"
                            }
                        ],
                        "name": "$s_fabric_port_status_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Fabric port quality degradation reasons",
                        "etors": [
                            {
                                "desc": "Excessive link errors are occurring",
                                "name": "$S_FABRIC_PORT_QUAL_ISSUE_FLAG_LINK_ERRORS",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "There is a degradation in the bitrate and/or width of the link",
                                "name": "$S_FABRIC_PORT_QUAL_ISSUE_FLAG_SPEED",
                                "value": "$X_BIT(1)"
                            }
                        ],
                        "name": "$s_fabric_port_qual_issue_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Fabric port failure reasons",
                        "etors": [
                            {
                                "desc": "A previously operating link has failed. Hardware will automatically retrain this port. This state will persist until either the physical connection is removed or the link trains successfully.",
                                "name": "$S_FABRIC_PORT_FAILURE_FLAG_FAILED",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "A connection has not been established within an expected time. Hardware will continue to attempt port training. This status will persist until either the physical connection is removed or the link successfully trains.",
                                "name": "$S_FABRIC_PORT_FAILURE_FLAG_TRAINING_TIMEOUT",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "Port has excessively trained and then transitioned down for some period of time. Driver will allow port to continue to train, but will not enable the port for use until the port has been disabled and subsequently re-enabled using $sFabricPortSetConfig().",
                                "name": "$S_FABRIC_PORT_FAILURE_FLAG_FLAPPING",
                                "value": "$X_BIT(2)"
                            }
                        ],
                        "name": "$s_fabric_port_failure_flags_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Unique identifier for a fabric port",
                        "details": [
                            "This not a universal identifier. The identified is garanteed to be unique for the current hardware configuration of the system. Changes in the hardware may result in a different identifier for a given port.",
                            "The main purpose of this identifier to build up an instantaneous topology map of system connectivity. An application should enumerate all fabric ports and match the `remotePortId` member of $s_fabric_port_state_t to the `portId` member of $s_fabric_port_properties_t."
                        ],
                        "members": [
                            {
                                "desc": "[out] Unique identifier for the fabric end-point",
                                "name": "fabricId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Unique identifier for the device attachment point",
                                "name": "attachId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] The logical port number (this is typically marked somewhere on the physical device)",
                                "name": "portNumber",
                                "type": "uint8_t"
                            }
                        ],
                        "name": "$s_fabric_port_id_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Fabric port speed in one direction",
                        "members": [
                            {
                                "desc": "[out] Bits/sec that the link is operating at. A value of -1 means that this property is unknown.",
                                "name": "bitRate",
                                "type": "int64_t"
                            },
                            {
                                "desc": "[out] The number of lanes. A value of -1 means that this property is unknown.",
                                "name": "width",
                                "type": "int32_t"
                            }
                        ],
                        "name": "$s_fabric_port_speed_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sFabricPort",
                        "desc": "Fabric port properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_FABRIC_PORT_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] Description of port technology. Will be set to the string \"unkown\" if this cannot be determined for this port.",
                                "name": "model[$S_MAX_FABRIC_PORT_MODEL_SIZE]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] True if the port is located on a sub-device; false means that the port is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] The unique port identifier",
                                "name": "portId",
                                "type": "$s_fabric_port_id_t"
                            },
                            {
                                "desc": "[out] Maximum speed supported by the receive side of the port (sum of all lanes)",
                                "name": "maxRxSpeed",
                                "type": "$s_fabric_port_speed_t"
                            },
                            {
                                "desc": "[out] Maximum speed supported by the transmit side of the port (sum of all lanes)",
                                "name": "maxTxSpeed",
                                "type": "$s_fabric_port_speed_t"
                            }
                        ],
                        "name": "$s_fabric_port_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Provides information about the fabric link attached to a port",
                        "members": [
                            {
                                "desc": "[out] Description of link technology. Will be set to the string \"unkown\" if this cannot be determined for this link.",
                                "name": "desc[$S_MAX_FABRIC_LINK_TYPE_SIZE]",
                                "type": "char"
                            }
                        ],
                        "name": "$s_fabric_link_type_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_config_t",
                        "class": "$sFabricPort",
                        "desc": "Fabric port configuration",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_FABRIC_PORT_CONFIG",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in,out] Port is configured up/down",
                                "name": "enabled",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[in,out] Beaconing is configured on/off",
                                "name": "beaconing",
                                "type": "$x_bool_t"
                            }
                        ],
                        "name": "$s_fabric_port_config_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_state_t",
                        "class": "$sFabricPort",
                        "desc": "Fabric port state",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_FABRIC_PORT_STATE",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] The current status of the port",
                                "name": "status",
                                "type": "$s_fabric_port_status_t"
                            },
                            {
                                "desc": "[out] If status is $S_FABRIC_PORT_STATUS_DEGRADED,\nthen this gives a combination of $s_fabric_port_qual_issue_flag_t for quality issues that have been detected;\notherwise, 0 indicates there are no quality issues with the link at this time.\n",
                                "name": "qualityIssues",
                                "type": "$s_fabric_port_qual_issue_flags_t"
                            },
                            {
                                "desc": "[out] If status is $S_FABRIC_PORT_STATUS_FAILED,\nthen this gives a combination of $s_fabric_port_failure_flag_t for reasons for the connection instability;\notherwise, 0 indicates there are no connection stability issues at this time.\n",
                                "name": "failureReasons",
                                "type": "$s_fabric_port_failure_flags_t"
                            },
                            {
                                "desc": "[out] The unique port identifier for the remote connection point if status is $S_FABRIC_PORT_STATUS_HEALTHY, $S_FABRIC_PORT_STATUS_DEGRADED or $S_FABRIC_PORT_STATUS_FAILED",
                                "name": "remotePortId",
                                "type": "$s_fabric_port_id_t"
                            },
                            {
                                "desc": "[out] Current maximum receive speed (sum of all lanes)",
                                "name": "rxSpeed",
                                "type": "$s_fabric_port_speed_t"
                            },
                            {
                                "desc": "[out] Current maximum transmit speed (sum of all lanes)",
                                "name": "txSpeed",
                                "type": "$s_fabric_port_speed_t"
                            }
                        ],
                        "name": "$s_fabric_port_state_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Fabric port throughput.",
                        "members": [
                            {
                                "desc": "[out] Monotonic timestamp counter in microseconds when the measurement was made.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                                "name": "timestamp",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Monotonic counter for the number of bytes received (sum of all lanes). This includes all protocol overhead, not only the GPU traffic.",
                                "name": "rxCounter",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Monotonic counter for the number of bytes transmitted (sum of all lanes). This includes all protocol overhead, not only the GPU traffic.",
                                "name": "txCounter",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$s_fabric_port_throughput_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sFabricPort",
                        "desc": "Fabric Port Error Counters",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_FABRIC_PORT_ERROR_COUNTERS",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] Link Failure Error Count reported per port",
                                "name": "linkFailureCount",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Firmware Communication Error Count reported per device",
                                "name": "fwCommErrorCount",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Firmware reported Error Count reported per device",
                                "name": "fwErrorCount",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Link Degrade Error Count reported per port",
                                "name": "linkDegradeCount",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$s_fabric_port_error_counters_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of Fabric ports in a device",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "f8b22e29f845c563af633d8a69c44bcecceda14be9ca6c0151d348a192c5f7ff",
                        "name": "EnumFabricPorts",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phPort",
                                "type": "$s_fabric_port_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Get Fabric port properties",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "ea925c2484ecfb42a7ff5ac43d9d1d5317c3c0eac0b00b153eecbb1025a2a12f",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPort",
                                "type": "$s_fabric_port_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain properties of the Fabric Port.",
                                "name": "pProperties",
                                "type": "$s_fabric_port_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPort`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Get Fabric port link type",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "ded4dbd69e173ddcbb1a8dfa0aa5d9c019a40c71a09ab024e055ef4dbbad1ca0",
                        "name": "GetLinkType",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPort",
                                "type": "$s_fabric_port_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain details about the link attached to the Fabric port.",
                                "name": "pLinkType",
                                "type": "$s_fabric_link_type_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPort`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pLinkType`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Get Fabric port configuration",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "9b752ed8f8cb948b4bc79d6e0e9a013e741232e239086a6095d66f75aa1ff9ab",
                        "name": "GetConfig",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPort",
                                "type": "$s_fabric_port_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain configuration of the Fabric Port.",
                                "name": "pConfig",
                                "type": "$s_fabric_port_config_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPort`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pConfig`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Set Fabric port configuration",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "42192be3f94acb29b90f3c2405d35dc74ef538f272549e9127f112946a2a9884",
                        "name": "SetConfig",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPort",
                                "type": "$s_fabric_port_handle_t"
                            },
                            {
                                "desc": "[in] Contains new configuration of the Fabric Port.",
                                "name": "pConfig",
                                "type": "const $s_fabric_port_config_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPort`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pConfig`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Get Fabric port state - status (health/degraded/failed/disabled), reasons for link degradation or instability, current rx/tx speed",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "3739f03de8c9a2903fff758a13d5837ea02e4af8855c832f298fadb60c5b2924",
                        "name": "GetState",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPort",
                                "type": "$s_fabric_port_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the current state of the Fabric Port",
                                "name": "pState",
                                "type": "$s_fabric_port_state_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPort`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pState`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Get Fabric port throughput",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "b624dbb1f8e689bd83898f312af1283e0d67d3606e5440a6dbff6351ab6556b4",
                        "name": "GetThroughput",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPort",
                                "type": "$s_fabric_port_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the Fabric port throughput counters.",
                                "name": "pThroughput",
                                "type": "$s_fabric_port_throughput_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPort`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pThroughput`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to query this telemetry."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Get Fabric Port Error Counters",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free.",
                            "The memory backing the arrays for phPorts and ppThroughputs must be allocated in system memory by the user who is also responsible for releasing them when they are no longer needed."
                        ],
                        "hash": "67d5b753e3b6f42b1997d5d3db8f20671924a2eee917e7a8147cef40cc6dfeb0",
                        "name": "GetFabricErrorCounters",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPort",
                                "type": "$s_fabric_port_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the Fabric port Error counters.",
                                "name": "pErrors",
                                "type": "$s_fabric_port_error_counters_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPort`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pErrors`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to query this telemetry."
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "class": "$sFabricPort",
                        "desc": "Get Fabric port throughput from multiple ports in a single call",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "b19183e0e5208c1c5bac396db4c5d36d7334fbfdc1a7eedd01031666a174a232",
                        "name": "GetMultiPortThroughput",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in] Number of ports enumerated in function $sDeviceEnumFabricPorts",
                                "name": "numPorts",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in][range(0, numPorts)] array of fabric port handles provided by user to gather throughput values. \n",
                                "name": "phPort",
                                "type": "$s_fabric_port_handle_t*"
                            },
                            {
                                "desc": "[out][range(0, numPorts)] array of fabric port throughput counters from multiple ports of type $s_fabric_port_throughput_t.\n",
                                "name": "pThroughput",
                                "type": "$s_fabric_port_throughput_t**"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phPort`",
                                    "`nullptr == pThroughput`"
                                ]
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device Fabric port",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_fabric_port_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sFabricPort",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Firmware management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "fan",
                "objects": [
                    {
                        "class": "$sFan",
                        "desc": "Fan resource speed mode",
                        "etors": [
                            {
                                "desc": "The fan speed is operating using the hardware default settings",
                                "name": "$S_FAN_SPEED_MODE_DEFAULT",
                                "value": "0"
                            },
                            {
                                "desc": "The fan speed is currently set to a fixed value",
                                "name": "$S_FAN_SPEED_MODE_FIXED",
                                "value": "1"
                            },
                            {
                                "desc": "The fan speed is currently controlled dynamically by hardware based on a temp/speed table",
                                "name": "$S_FAN_SPEED_MODE_TABLE",
                                "value": "2"
                            }
                        ],
                        "name": "$s_fan_speed_mode_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sFan",
                        "desc": "Fan speed units",
                        "etors": [
                            {
                                "desc": "The fan speed is in units of revolutions per minute (rpm)",
                                "name": "$S_FAN_SPEED_UNITS_RPM",
                                "value": "0"
                            },
                            {
                                "desc": "The fan speed is a percentage of the maximum speed of the fan",
                                "name": "$S_FAN_SPEED_UNITS_PERCENT",
                                "value": "1"
                            }
                        ],
                        "name": "$s_fan_speed_units_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sFan",
                        "desc": "Fan speed",
                        "members": [
                            {
                                "desc": "[in,out] The speed of the fan. On output, a value of -1 indicates that there is no fixed fan speed setting.",
                                "name": "speed",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[in,out] The units that the fan speed is expressed in. On output, if fan speed is -1 then units should be ignored.",
                                "name": "units",
                                "type": "$s_fan_speed_units_t"
                            }
                        ],
                        "name": "$s_fan_speed_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sFan",
                        "desc": "Fan temperature/speed pair",
                        "members": [
                            {
                                "desc": "[in,out] Temperature in degrees Celsius.",
                                "name": "temperature",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[in,out] The speed of the fan",
                                "name": "speed",
                                "type": "$s_fan_speed_t"
                            }
                        ],
                        "name": "$s_fan_temp_speed_t",
                        "type": "struct"
                    },
                    {
                        "desc": "Maximum number of fan temperature/speed pairs in the fan speed table.",
                        "name": "$S_FAN_TEMP_SPEED_PAIR_COUNT",
                        "type": "macro",
                        "value": "32"
                    },
                    {
                        "class": "$sFan",
                        "desc": "Fan speed table",
                        "members": [
                            {
                                "desc": "[in,out] The number of valid points in the fan speed table. 0 means that there is no fan speed table configured. -1 means that a fan speed table is not supported by the hardware.",
                                "name": "numPoints",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[in,out] Array of temperature/fan speed pairs. The table is ordered based on temperature from lowest to highest.",
                                "name": "table[$S_FAN_TEMP_SPEED_PAIR_COUNT]",
                                "type": "$s_fan_temp_speed_t"
                            }
                        ],
                        "name": "$s_fan_speed_table_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sFan",
                        "desc": "Fan properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_FAN_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Indicates if software can control the fan speed assuming the user has permissions",
                                "name": "canControl",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Bitfield of supported fan configuration modes (1<<$s_fan_speed_mode_t)",
                                "name": "supportedModes",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Bitfield of supported fan speed units (1<<$s_fan_speed_units_t)",
                                "name": "supportedUnits",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] The maximum RPM of the fan. A value of -1 means that this property is unknown. ",
                                "name": "maxRPM",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[out] The maximum number of points in the fan temp/speed table. A value of -1 means that this fan doesn't support providing a temp/speed table.",
                                "name": "maxPoints",
                                "type": "int32_t"
                            }
                        ],
                        "name": "$s_fan_properties_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_config_t",
                        "class": "$sFan",
                        "desc": "Fan configuration",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_FAN_CONFIG",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in,out] The fan speed mode (fixed, temp-speed table)",
                                "name": "mode",
                                "type": "$s_fan_speed_mode_t"
                            },
                            {
                                "desc": "[in,out] The current fixed fan speed setting",
                                "name": "speedFixed",
                                "type": "$s_fan_speed_t"
                            },
                            {
                                "desc": "[out] A table containing temperature/speed pairs",
                                "name": "speedTable",
                                "type": "$s_fan_speed_table_t"
                            }
                        ],
                        "name": "$s_fan_config_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of fans",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "cd402f983e5dc2e1f226dccb0609064e6bd118037410019a20723a8a58c6c4a5",
                        "name": "EnumFans",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phFan",
                                "type": "$s_fan_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFan",
                        "desc": "Get fan properties",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "0e96fab12a31e4d2266ddf46d5810c1f16c5e021efe80d5aab57b063de11a434",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFan",
                                "type": "$s_fan_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the properties of the fan.",
                                "name": "pProperties",
                                "type": "$s_fan_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFan`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFan",
                        "desc": "Get fan configurations and the current fan speed mode (default, fixed, temp-speed table)",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "43951de8c82fdfc9dd54e3fe5219be6e9cca4baef47fa8dd07bef5e59840df82",
                        "name": "GetConfig",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFan",
                                "type": "$s_fan_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the current configuration of the fan.",
                                "name": "pConfig",
                                "type": "$s_fan_config_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFan`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pConfig`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFan",
                        "desc": "Configure the fan to run with hardware factory settings (set mode to $S_FAN_SPEED_MODE_DEFAULT)",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "3f32c8b4c13c29cd9a801fb9abdb42c1b1e96c76465506d70a3c9b0a234997c5",
                        "name": "SetDefaultMode",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFan",
                                "type": "$s_fan_handle_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFan`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFan",
                        "desc": "Configure the fan to rotate at a fixed speed (set mode to $S_FAN_SPEED_MODE_FIXED)",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "398f43a1f432602ccfac89afb43dfcb063e4d3b17e473a0e486fcfed9bae3945",
                        "name": "SetFixedSpeedMode",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFan",
                                "type": "$s_fan_handle_t"
                            },
                            {
                                "desc": "[in] The fixed fan speed setting",
                                "name": "speed",
                                "type": "const $s_fan_speed_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFan`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == speed`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Fixing the fan speed not supported by the hardware or the fan speed units are not supported. See the `supportedModes` and `supportedUnits` members of $s_fan_properties_t."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFan",
                        "desc": "Configure the fan to adjust speed based on a temperature/speed table (set mode to $S_FAN_SPEED_MODE_TABLE)",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "4a3133b6a3f27db154819ab2a6b881355cad632a0ef1c30235d89948bf2273c8",
                        "name": "SetSpeedTableMode",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFan",
                                "type": "$s_fan_handle_t"
                            },
                            {
                                "desc": "[in] A table containing temperature/speed pairs.",
                                "name": "speedTable",
                                "type": "const $s_fan_speed_table_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFan`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == speedTable`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ARGUMENT": [
                                    "The temperature/speed pairs in the array are not sorted on temperature from lowest to highest."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Fan speed table not supported by the hardware or the fan speed units are not supported. See the `supportedModes` and `supportedUnits` members of $s_fan_properties_t."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFan",
                        "desc": "Get current state of a fan - current mode and speed",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "337b9820995404b2f3e61231b0396074ccf89065c86f1e223fd07365483735f0",
                        "name": "GetState",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFan",
                                "type": "$s_fan_handle_t"
                            },
                            {
                                "desc": "[in] The units in which the fan speed should be returned.",
                                "name": "units",
                                "type": "$s_fan_speed_units_t"
                            },
                            {
                                "desc": "[in,out] Will contain the current speed of the fan in the units requested. A value of -1 indicates that the fan speed cannot be measured.",
                                "name": "pSpeed",
                                "type": "int32_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFan`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$S_FAN_SPEED_UNITS_PERCENT < units`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pSpeed`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "The requested fan speed units are not supported. See the `supportedUnits` member of $s_fan_properties_t."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device fan",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_fan_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sFan",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Firmware management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "firmware",
                "objects": [
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sFirmware",
                        "desc": "Firmware properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_FIRMWARE_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Indicates if software can flash the firmware assuming the user has permissions",
                                "name": "canControl",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] NULL terminated string value. The string \"unknown\" will be returned if this property cannot be determined.",
                                "name": "name[$S_STRING_PROPERTY_SIZE]",
                                "type": "char"
                            },
                            {
                                "desc": "[out] NULL terminated string value. The string \"unknown\" will be returned if this property cannot be determined.",
                                "name": "version[$S_STRING_PROPERTY_SIZE]",
                                "type": "char"
                            }
                        ],
                        "name": "$s_firmware_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of firmwares",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "9ba0753daddbd3a471d4b8ecb7290ed7990b77741e191e3498fd13a8961ca8bf",
                        "name": "EnumFirmwares",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phFirmware",
                                "type": "$s_firmware_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFirmware",
                        "desc": "Get firmware properties",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "11f91797bbbaac14954b82406293fb175c9081593e31494018c8487316177204",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFirmware",
                                "type": "$s_firmware_handle_t"
                            },
                            {
                                "desc": "[in,out] Pointer to an array that will hold the properties of the firmware",
                                "name": "pProperties",
                                "type": "$s_firmware_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFirmware`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFirmware",
                        "desc": "Flash a new firmware image",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "a6cc43172f030767262ce409a236ed03fd2f41a4abb336ece7e0e1bd642004b4",
                        "name": "Flash",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFirmware",
                                "type": "$s_firmware_handle_t"
                            },
                            {
                                "desc": "[in] Image of the new firmware to flash.",
                                "name": "pImage",
                                "type": "void*"
                            },
                            {
                                "desc": "[in] Size of the flash image.",
                                "name": "size",
                                "type": "uint32_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFirmware`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pImage`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to perform this operation."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device firmware",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_firmware_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sFirmware",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Frequency domains",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "frequency",
                "objects": [
                    {
                        "class": "$sDevice",
                        "desc": "Frequency domains.",
                        "etors": [
                            {
                                "desc": "GPU Core Domain.",
                                "name": "$S_FREQ_DOMAIN_GPU",
                                "value": "0"
                            },
                            {
                                "desc": "Local Memory Domain.",
                                "name": "$S_FREQ_DOMAIN_MEMORY",
                                "value": "1"
                            },
                            {
                                "desc": "GPU Media Domain.",
                                "name": "$S_FREQ_DOMAIN_MEDIA",
                                "value": "2",
                                "version": "1.6"
                            }
                        ],
                        "name": "$s_freq_domain_t",
                        "type": "enum"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sFrequency",
                        "desc": "Frequency properties",
                        "details": [
                            "Indicates if this frequency domain can be overclocked (if true, functions such as $sFrequencyOcSetFrequencyTarget() are supported).",
                            "The min/max hardware frequencies are specified for non-overclock configurations. For overclock configurations, use $sFrequencyOcGetFrequencyTarget() to determine the maximum frequency that can be requested."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_FREQ_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] The hardware block that this frequency domain controls (GPU, memory, ...)",
                                "name": "type",
                                "type": "$s_freq_domain_t"
                            },
                            {
                                "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Indicates if software can control the frequency of this domain assuming the user has permissions",
                                "name": "canControl",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Indicates if software can register to receive event $S_EVENT_TYPE_FLAG_FREQ_THROTTLED",
                                "name": "isThrottleEventSupported",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] The minimum hardware clock frequency in units of MHz.",
                                "name": "min",
                                "type": "double"
                            },
                            {
                                "desc": "[out] The maximum non-overclock hardware clock frequency in units of MHz.",
                                "name": "max",
                                "type": "double"
                            }
                        ],
                        "name": "$s_freq_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Frequency range between which the hardware can operate.",
                        "details": [
                            "When setting limits, they will be clamped to the hardware limits.",
                            "When setting limits, ensure that the max frequency is greater than or equal to the min frequency specified.",
                            "When setting limits to return to factory settings, specify -1 for both the min and max limit."
                        ],
                        "members": [
                            {
                                "desc": "[in,out] The min frequency in MHz below which hardware frequency management will not request frequencies. On input, setting to 0 will permit the frequency to go down to the hardware minimum while setting to -1 will return the min frequency limit to the factory value (can be larger than the hardware min). On output, a negative value indicates that no external minimum frequency limit is in effect.",
                                "name": "min",
                                "type": "double"
                            },
                            {
                                "desc": "[in,out] The max frequency in MHz above which hardware frequency management will not request frequencies. On input, setting to 0 or a very big number will permit the frequency to go all the way up to the hardware maximum while setting to -1 will return the max frequency to the factory value (which can be less than the hardware max). On output, a negative number indicates that no external maximum frequency limit is in effect.",
                                "name": "max",
                                "type": "double"
                            }
                        ],
                        "name": "$s_freq_range_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Frequency throttle reasons",
                        "etors": [
                            {
                                "desc": "frequency throttled due to average power excursion (PL1)",
                                "name": "$S_FREQ_THROTTLE_REASON_FLAG_AVE_PWR_CAP",
                                "value": "$X_BIT(0)"
                            },
                            {
                                "desc": "frequency throttled due to burst power excursion (PL2)",
                                "name": "$S_FREQ_THROTTLE_REASON_FLAG_BURST_PWR_CAP",
                                "value": "$X_BIT(1)"
                            },
                            {
                                "desc": "frequency throttled due to current excursion (PL4)",
                                "name": "$S_FREQ_THROTTLE_REASON_FLAG_CURRENT_LIMIT",
                                "value": "$X_BIT(2)"
                            },
                            {
                                "desc": "frequency throttled due to thermal excursion (T > TjMax)",
                                "name": "$S_FREQ_THROTTLE_REASON_FLAG_THERMAL_LIMIT",
                                "value": "$X_BIT(3)"
                            },
                            {
                                "desc": "frequency throttled due to power supply assertion",
                                "name": "$S_FREQ_THROTTLE_REASON_FLAG_PSU_ALERT",
                                "value": "$X_BIT(4)"
                            },
                            {
                                "desc": "frequency throttled due to software supplied frequency range",
                                "name": "$S_FREQ_THROTTLE_REASON_FLAG_SW_RANGE",
                                "value": "$X_BIT(5)"
                            },
                            {
                                "desc": "frequency throttled due to a sub block that has a lower frequency range when it receives clocks",
                                "name": "$S_FREQ_THROTTLE_REASON_FLAG_HW_RANGE",
                                "value": "$X_BIT(6)"
                            }
                        ],
                        "name": "$s_freq_throttle_reason_flags_t",
                        "type": "enum"
                    },
                    {
                        "base": "$s_base_state_t",
                        "class": "$sFrequency",
                        "desc": "Frequency state",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_FREQ_STATE",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] Current voltage in Volts. A negative value indicates that this property is not known.",
                                "name": "currentVoltage",
                                "type": "double"
                            },
                            {
                                "desc": "[out] The current frequency request in MHz. A negative value indicates that this property is not known.",
                                "name": "request",
                                "type": "double"
                            },
                            {
                                "desc": "[out] The maximum frequency in MHz supported under the current TDP conditions. This fluctuates dynamically based on the power and thermal limits of the part. A negative value indicates that this property is not known.",
                                "name": "tdp",
                                "type": "double"
                            },
                            {
                                "desc": "[out] The efficient minimum frequency in MHz. A negative value indicates that this property is not known.",
                                "name": "efficient",
                                "type": "double"
                            },
                            {
                                "desc": "[out] The resolved frequency in MHz. A negative value indicates that this property is not known.",
                                "name": "actual",
                                "type": "double"
                            },
                            {
                                "desc": "[out] The reasons that the frequency is being limited by the hardware.\nReturns 0 (frequency not throttled) or a combination of $s_freq_throttle_reason_flag_t.\n",
                                "name": "throttleReasons",
                                "type": "$s_freq_throttle_reason_flags_t"
                            }
                        ],
                        "name": "$s_freq_state_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Frequency throttle time snapshot",
                        "details": [
                            "Percent time throttled is calculated by taking two snapshots (s1, s2) and using the equation: %throttled = (s2.throttleTime - s1.throttleTime) / (s2.timestamp - s1.timestamp)"
                        ],
                        "members": [
                            {
                                "desc": "[out] The monotonic counter of time in microseconds that the frequency has been limited by the hardware.",
                                "name": "throttleTime",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Microsecond timestamp when throttleTime was captured.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                                "name": "timestamp",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$s_freq_throttle_time_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Overclocking modes",
                        "etors": [
                            {
                                "desc": "Overclocking if off - hardware is running using factory default voltages/frequencies.",
                                "name": "$S_OC_MODE_OFF",
                                "value": "0"
                            },
                            {
                                "desc": "Overclock override mode - In this mode, a fixed user-supplied voltage is applied independent of the frequency request. The maximum permitted frequency can also be increased. This mode disables INTERPOLATIVE and FIXED modes.",
                                "name": "$S_OC_MODE_OVERRIDE",
                                "value": "1"
                            },
                            {
                                "desc": "Overclock interpolative mode - In this mode, the voltage/frequency curve can be extended with a new voltage/frequency point that will be interpolated. The existing voltage/frequency points can also be offset (up or down) by a fixed voltage. This mode disables FIXED and OVERRIDE modes.",
                                "name": "$S_OC_MODE_INTERPOLATIVE",
                                "value": "2"
                            },
                            {
                                "desc": "Overclocking fixed Mode - In this mode, hardware will disable most frequency throttling and lock the frequency and voltage at the specified overclock values. This mode disables OVERRIDE and INTERPOLATIVE modes. This mode can damage the part, most of the protections are disabled on this mode.",
                                "name": "$S_OC_MODE_FIXED",
                                "value": "3"
                            }
                        ],
                        "name": "$s_oc_mode_t",
                        "type": "enum"
                    },
                    {
                        "base": "$s_base_capability_t",
                        "class": "$sFrequency",
                        "desc": "Overclocking properties",
                        "details": [
                            "Provides all the overclocking capabilities and properties supported by the device for the frequency domain."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_OC_CAPABILITIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] Indicates if any overclocking features are supported on this frequency domain.",
                                "name": "isOcSupported",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Factory default non-overclock maximum frequency in Mhz.",
                                "name": "maxFactoryDefaultFrequency",
                                "type": "double"
                            },
                            {
                                "desc": "[out] Factory default voltage used for the non-overclock maximum frequency in MHz.",
                                "name": "maxFactoryDefaultVoltage",
                                "type": "double"
                            },
                            {
                                "desc": "[out] Maximum hardware overclocking frequency limit in Mhz.",
                                "name": "maxOcFrequency",
                                "type": "double"
                            },
                            {
                                "desc": "[out] The minimum voltage offset that can be applied to the voltage/frequency curve. Note that this number can be negative.",
                                "name": "minOcVoltageOffset",
                                "type": "double"
                            },
                            {
                                "desc": "[out] The maximum voltage offset that can be applied to the voltage/frequency curve.",
                                "name": "maxOcVoltageOffset",
                                "type": "double"
                            },
                            {
                                "desc": "[out] The maximum overclock voltage that hardware supports.",
                                "name": "maxOcVoltage",
                                "type": "double"
                            },
                            {
                                "desc": "[out] Indicates if the maximum temperature limit (TjMax) can be changed for this frequency domain.",
                                "name": "isTjMaxSupported",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Indicates if the maximum current (IccMax) can be changed for this frequency domain.",
                                "name": "isIccMaxSupported",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Indicates if this frequency domains supports a feature to set very high voltages.",
                                "name": "isHighVoltModeCapable",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Indicates if very high voltages are permitted on this frequency domain.",
                                "name": "isHighVoltModeEnabled",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Indicates if the extended overclocking features are supported. If this is supported, increments are on 1 Mhz basis.",
                                "name": "isExtendedModeSupported",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Indicates if the fixed mode is supported. In this mode, hardware will disable most frequency throttling and lock the frequency and voltage at the specified overclock values.",
                                "name": "isFixedModeSupported",
                                "type": "$x_bool_t"
                            }
                        ],
                        "name": "$s_oc_capabilities_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of frequency domains",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "3a4d3adfa79bc56aef50d3cd79d36487a13688f3b3c2bf544441d95b1271691a",
                        "name": "EnumFrequencyDomains",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phFrequency",
                                "type": "$s_freq_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Get frequency properties - available frequencies",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "b210e5b5cec54e67a85b2332aea68467458e3b15a971322b850426200f3aa94d",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in,out] The frequency properties for the specified domain.",
                                "name": "pProperties",
                                "type": "$s_freq_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Get available non-overclocked hardware clock frequencies for the frequency domain",
                        "details": [
                            "The list of available frequencies is returned in order of slowest to fastest.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "1e3eebd0166a83daf2ae65a559bf765664cd393e3e131aa4e983f538ba8baf64",
                        "name": "GetAvailableClocks",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of frequencies.\nif count is zero, then the driver shall update the value with the total number of frequencies that are available.\nif count is greater than the number of frequencies that are available, then the driver shall update the value with the correct number of frequencies.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of frequencies in units of MHz and sorted from slowest to fastest.\nif count is less than the number of frequencies that are available, then the driver shall only retrieve that number of frequencies.\n",
                                "name": "phFrequency",
                                "type": "double*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Get current frequency limits",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "a9d1984f6ba89157405380e202cbd1031171726de90f2ed76f1c3ae3c1c5ec15",
                        "name": "GetRange",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in,out] The range between which the hardware can operate for the specified domain.",
                                "name": "pLimits",
                                "type": "$s_freq_range_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pLimits`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Set frequency range between which the hardware can operate.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "e510f70acdcb9a652fda8f2d444a9c7d0c4fcd724de88d78b34d1ef7c4248a2d",
                        "name": "SetRange",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in] The limits between which the hardware can operate for the specified domain.",
                                "name": "pLimits",
                                "type": "const $s_freq_range_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pLimits`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Get current frequency state - frequency request, actual frequency, TDP limits",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "0a8367760c6f7743ec27243e8d9f022854995115c9a64ee172fe0db821b462f9",
                        "name": "GetState",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in,out] Frequency state for the specified domain.",
                                "name": "pState",
                                "type": "$s_freq_state_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pState`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Get frequency throttle time",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "cd622002168430e88f48dce3e9b1fb51c92f6ef41c9d4fa64b18bb4274f8236d",
                        "name": "GetThrottleTime",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain a snapshot of the throttle time counters for the specified domain.",
                                "name": "pThrottleTime",
                                "type": "$s_freq_throttle_time_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pThrottleTime`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Get the overclocking capabilities.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "27bf6388e5923bdaa0967f8e74b1675ffd0e7c82980c7974dda6e82d24efc5c2",
                        "name": "OcGetCapabilities",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in,out] Pointer to the capabilities structure.",
                                "name": "pOcCapabilities",
                                "type": "$s_oc_capabilities_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pOcCapabilities`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Get the current overclocking frequency target, if extended moded is supported, will returned in 1 Mhz granularity.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "a1fee7e08b70a9ff9017be269ccba56a321c80f2a1bd0f08f4bf25b80edb8e87",
                        "name": "OcGetFrequencyTarget",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[out] Overclocking Frequency in MHz, if extended moded is supported, will returned in 1 Mhz granularity, else, in multiples of 50 Mhz. This cannot be greater than the `maxOcFrequency` member of $s_oc_capabilities_t.",
                                "name": "pCurrentOcFrequency",
                                "type": "double*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCurrentOcFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of $s_oc_capabilities_t).",
                                    "The specified voltage and/or frequency overclock settings exceed the hardware values (see the `maxOcFrequency`, `maxOcVoltage`, `minOcVoltageOffset` and `maxOcVoltageOffset` members of $s_oc_capabilities_t).",
                                    "Requested voltage overclock is very high but the `isHighVoltModeEnabled` member of $s_oc_capabilities_t is not enabled for the device."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "Overclocking feature is locked on this frequency domain."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Set the current overclocking frequency target, if extended moded is supported, can be set in 1 Mhz granularity.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "3a6b01a51f459abd4b5094093ec355d270545a80ddac2792d06d29aee7463e1b",
                        "name": "OcSetFrequencyTarget",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in] Overclocking Frequency in MHz, if extended moded is supported, it could be set in 1 Mhz granularity, else, in multiples of 50 Mhz. This cannot be greater than the `maxOcFrequency` member of $s_oc_capabilities_t.",
                                "name": "CurrentOcFrequency",
                                "type": "double"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of $s_oc_capabilities_t).",
                                    "The specified voltage and/or frequency overclock settings exceed the hardware values (see the `maxOcFrequency`, `maxOcVoltage`, `minOcVoltageOffset` and `maxOcVoltageOffset` members of $s_oc_capabilities_t).",
                                    "Requested voltage overclock is very high but the `isHighVoltModeEnabled` member of $s_oc_capabilities_t is not enabled for the device."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "Overclocking feature is locked on this frequency domain."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Get the current overclocking voltage settings.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "f6a3671ccc34ac2d3e6af12869ff5edfc85e3cc20db0d48b61cfe96781198c94",
                        "name": "OcGetVoltageTarget",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[out] Overclock voltage in Volts. This cannot be greater than the `maxOcVoltage` member of $s_oc_capabilities_t.",
                                "name": "pCurrentVoltageTarget",
                                "type": "double*"
                            },
                            {
                                "desc": "[out] This voltage offset is applied to all points on the voltage/frequency curve, including the new overclock voltageTarget. Valid range is between the `minOcVoltageOffset` and `maxOcVoltageOffset` members of $s_oc_capabilities_t.",
                                "name": "pCurrentVoltageOffset",
                                "type": "double*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCurrentVoltageTarget`",
                                    "`nullptr == pCurrentVoltageOffset`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of $s_oc_capabilities_t).",
                                    "The specified voltage and/or frequency overclock settings exceed the hardware values (see the `maxOcFrequency`, `maxOcVoltage`, `minOcVoltageOffset` and `maxOcVoltageOffset` members of $s_oc_capabilities_t).",
                                    "Requested voltage overclock is very high but the `isHighVoltModeEnabled` member of $s_oc_capabilities_t is not enabled for the device."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "Overclocking feature is locked on this frequency domain."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Set the current overclocking voltage settings.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "5f4c50d38e299212417f47798a74b4da436371eaee20c92098f13d3192b8b590",
                        "name": "OcSetVoltageTarget",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in] Overclock voltage in Volts. This cannot be greater than the `maxOcVoltage` member of $s_oc_capabilities_t.",
                                "name": "CurrentVoltageTarget",
                                "type": "double"
                            },
                            {
                                "desc": "[in] This voltage offset is applied to all points on the voltage/frequency curve, include the new overclock voltageTarget. Valid range is between the `minOcVoltageOffset` and `maxOcVoltageOffset` members of $s_oc_capabilities_t.",
                                "name": "CurrentVoltageOffset",
                                "type": "double"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of $s_oc_capabilities_t).",
                                    "The specified voltage and/or frequency overclock settings exceed the hardware values (see the `maxOcFrequency`, `maxOcVoltage`, `minOcVoltageOffset` and `maxOcVoltageOffset` members of $s_oc_capabilities_t).",
                                    "Requested voltage overclock is very high but the `isHighVoltModeEnabled` member of $s_oc_capabilities_t is not enabled for the device."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "Overclocking feature is locked on this frequency domain."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Set the current overclocking mode.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "309c17c47d975efe332fedbe4501950c7216615dbfaeec37f3de3576ee3d5407",
                        "name": "OcSetMode",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in] Current Overclocking Mode $s_oc_mode_t.",
                                "name": "CurrentOcMode",
                                "type": "$s_oc_mode_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$S_OC_MODE_FIXED < CurrentOcMode`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of $s_oc_capabilities_t).",
                                    "The specified voltage and/or frequency overclock settings exceed the hardware values (see the `maxOcFrequency`, `maxOcVoltage`, `minOcVoltageOffset` and `maxOcVoltageOffset` members of $s_oc_capabilities_t).",
                                    "Requested voltage overclock is very high but the `isHighVoltModeEnabled` member of $s_oc_capabilities_t is not enabled for the device."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "Overclocking feature is locked on this frequency domain."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Get the current overclocking mode.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "62c4575e249097bdec5d726201f5f1259da813d0d7c0045814a5b917ff6a1308",
                        "name": "OcGetMode",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[out] Current Overclocking Mode $s_oc_mode_t.",
                                "name": "pCurrentOcMode",
                                "type": "$s_oc_mode_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCurrentOcMode`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of $s_oc_capabilities_t).",
                                    "The specified voltage and/or frequency overclock settings exceed the hardware values (see the `maxOcFrequency`, `maxOcVoltage`, `minOcVoltageOffset` and `maxOcVoltageOffset` members of $s_oc_capabilities_t).",
                                    "Requested voltage overclock is very high but the `isHighVoltModeEnabled` member of $s_oc_capabilities_t is not enabled for the device."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "Overclocking feature is locked on this frequency domain."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Get the maximum current limit setting.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "dd3afa560c90667b89253d02e45759933e6ee6a5f4a4657c783e821f9b8d8660",
                        "name": "OcGetIccMax",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the maximum current limit in Amperes on successful return.",
                                "name": "pOcIccMax",
                                "type": "double*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pOcIccMax`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of $s_oc_capabilities_t).",
                                    "Capability the `isIccMaxSupported` member of $s_oc_capabilities_t is false for this frequency domain."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Change the maximum current limit setting.",
                        "details": [
                            "Setting ocIccMax to 0.0 will return the value to the factory default.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "e75fd6668d4a7b5f10fc95f5830293547df215abe25c798afb1b88def4360fe6",
                        "name": "OcSetIccMax",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in] The new maximum current limit in Amperes.",
                                "name": "ocIccMax",
                                "type": "double"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of $s_oc_capabilities_t).",
                                    "The `isIccMaxSupported` member of $s_oc_capabilities_t is false for this frequency domain."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "Overclocking feature is locked on this frequency domain."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ARGUMENT": [
                                    "The specified current limit is too low or too high."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Get the maximum temperature limit setting.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "c1758ddfd68bb1988d3753bb71636b3b666c3f011d35cd830c8d0434c777d5e3",
                        "name": "OcGetTjMax",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the maximum temperature limit in degrees Celsius on successful return.",
                                "name": "pOcTjMax",
                                "type": "double*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pOcTjMax`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of $s_oc_capabilities_t)."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sFrequency",
                        "desc": "Change the maximum temperature limit setting.",
                        "details": [
                            "Setting ocTjMax to 0.0 will return the value to the factory default.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "742e421c8ae9294b2993a07eab549a060b678d7a5c74c5c71ce6e012f22d50aa",
                        "name": "OcSetTjMax",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hFrequency",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in] The new maximum temperature limit in degrees Celsius.",
                                "name": "ocTjMax",
                                "type": "double"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hFrequency`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Overclocking is not supported on this frequency domain (see the `isOcSupported` member of $s_oc_capabilities_t).",
                                    "The `isTjMaxSupported` member of $s_oc_capabilities_t is false for this frequency domain."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "Overclocking feature is locked on this frequency domain."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ARGUMENT": [
                                    "The specified temperature limit is too high."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device frequency domain",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_freq_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sFrequency",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Firmware management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "led",
                "objects": [
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sLed",
                        "desc": "LED properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_LED_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Indicates if software can control the LED assuming the user has permissions",
                                "name": "canControl",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Indicates if the LED is RGB capable",
                                "name": "haveRGB",
                                "type": "$x_bool_t"
                            }
                        ],
                        "name": "$s_led_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sLed",
                        "desc": "LED color",
                        "members": [
                            {
                                "desc": "[in,out][range(0.0, 1.0)] The LED red value. On output, a value less than 0.0 indicates that the color is not known.",
                                "name": "red",
                                "type": "double"
                            },
                            {
                                "desc": "[in,out][range(0.0, 1.0)] The LED green value. On output, a value less than 0.0 indicates that the color is not known.",
                                "name": "green",
                                "type": "double"
                            },
                            {
                                "desc": "[in,out][range(0.0, 1.0)] The LED blue value. On output, a value less than 0.0 indicates that the color is not known.",
                                "name": "blue",
                                "type": "double"
                            }
                        ],
                        "name": "$s_led_color_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_state_t",
                        "class": "$sLed",
                        "desc": "LED state",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_LED_STATE",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] Indicates if the LED is on or off",
                                "name": "isOn",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Color of the LED",
                                "name": "color",
                                "type": "$s_led_color_t"
                            }
                        ],
                        "name": "$s_led_state_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of LEDs",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "8c338f22d1047a3079b9f4adf6b0598674b17ba06e0605b1aaa547b901ecae6a",
                        "name": "EnumLeds",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phLed",
                                "type": "$s_led_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sLed",
                        "desc": "Get LED properties",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "82a7ff7d95623a38fdcea5fc8c1de9b334a8ccf9c29c9e97328ab519e132c890",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hLed",
                                "type": "$s_led_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the properties of the LED.",
                                "name": "pProperties",
                                "type": "$s_led_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hLed`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sLed",
                        "desc": "Get current state of a LED - on/off, color",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "d66be9cc597cbc060f0cd3592d6e15bbccb1be0823781f22c5746d2e64c460f1",
                        "name": "GetState",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hLed",
                                "type": "$s_led_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the current state of the LED.",
                                "name": "pState",
                                "type": "$s_led_state_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hLed`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pState`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sLed",
                        "desc": "Turn the LED on/off",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "a227391f6b01ac4e31857dbfd585f48e43d9382186521f55039c197a6b6eb54e",
                        "name": "SetState",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hLed",
                                "type": "$s_led_handle_t"
                            },
                            {
                                "desc": "[in] Set to TRUE to turn the LED on, FALSE to turn off.",
                                "name": "enable",
                                "type": "$x_bool_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hLed`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sLed",
                        "desc": "Set the color of the LED",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "311a39222a3cb1343b3a126fb769defe80f38e4f6c2b3fe6bd438a3bad613a8e",
                        "name": "SetColor",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hLed",
                                "type": "$s_led_handle_t"
                            },
                            {
                                "desc": "[in] New color of the LED.",
                                "name": "pColor",
                                "type": "const $s_led_color_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hLed`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pColor`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "This LED doesn't not support color changes. See the `haveRGB` member of $s_led_properties_t."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device LED",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_led_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sLed",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Memory management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "memory",
                "objects": [
                    {
                        "class": "$sMemory",
                        "desc": "Memory module types",
                        "etors": [
                            {
                                "desc": "HBM memory",
                                "name": "$S_MEM_TYPE_HBM",
                                "value": "0"
                            },
                            {
                                "desc": "DDR memory",
                                "name": "$S_MEM_TYPE_DDR",
                                "value": "1"
                            },
                            {
                                "desc": "DDR3 memory",
                                "name": "$S_MEM_TYPE_DDR3",
                                "value": "2"
                            },
                            {
                                "desc": "DDR4 memory",
                                "name": "$S_MEM_TYPE_DDR4",
                                "value": "3"
                            },
                            {
                                "desc": "DDR5 memory",
                                "name": "$S_MEM_TYPE_DDR5",
                                "value": "4"
                            },
                            {
                                "desc": "LPDDR memory",
                                "name": "$S_MEM_TYPE_LPDDR",
                                "value": "5"
                            },
                            {
                                "desc": "LPDDR3 memory",
                                "name": "$S_MEM_TYPE_LPDDR3",
                                "value": "6"
                            },
                            {
                                "desc": "LPDDR4 memory",
                                "name": "$S_MEM_TYPE_LPDDR4",
                                "value": "7"
                            },
                            {
                                "desc": "LPDDR5 memory",
                                "name": "$S_MEM_TYPE_LPDDR5",
                                "value": "8"
                            },
                            {
                                "desc": "SRAM memory",
                                "name": "$S_MEM_TYPE_SRAM",
                                "value": "9"
                            },
                            {
                                "desc": "L1 cache",
                                "name": "$S_MEM_TYPE_L1",
                                "value": "10"
                            },
                            {
                                "desc": "L3 cache",
                                "name": "$S_MEM_TYPE_L3",
                                "value": "11"
                            },
                            {
                                "desc": "Execution unit register file",
                                "name": "$S_MEM_TYPE_GRF",
                                "value": "12"
                            },
                            {
                                "desc": "Execution unit shared local memory",
                                "name": "$S_MEM_TYPE_SLM",
                                "value": "13"
                            },
                            {
                                "desc": "GDDR4 memory",
                                "name": "$S_MEM_TYPE_GDDR4",
                                "value": "14"
                            },
                            {
                                "desc": "GDDR5 memory",
                                "name": "$S_MEM_TYPE_GDDR5",
                                "value": "15"
                            },
                            {
                                "desc": "GDDR5X memory",
                                "name": "$S_MEM_TYPE_GDDR5X",
                                "value": "16"
                            },
                            {
                                "desc": "GDDR6 memory",
                                "name": "$S_MEM_TYPE_GDDR6",
                                "value": "17"
                            },
                            {
                                "desc": "GDDR6X memory",
                                "name": "$S_MEM_TYPE_GDDR6X",
                                "value": "18"
                            },
                            {
                                "desc": "GDDR7 memory",
                                "name": "$S_MEM_TYPE_GDDR7",
                                "value": "19"
                            }
                        ],
                        "name": "$s_mem_type_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sMemory",
                        "desc": "Memory module location",
                        "etors": [
                            {
                                "desc": "System memory",
                                "name": "$S_MEM_LOC_SYSTEM",
                                "value": "0"
                            },
                            {
                                "desc": "On board local device memory",
                                "name": "$S_MEM_LOC_DEVICE",
                                "value": "1"
                            }
                        ],
                        "name": "$s_mem_loc_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sMemory",
                        "desc": "Memory health",
                        "etors": [
                            {
                                "desc": "The memory health cannot be determined.",
                                "name": "$S_MEM_HEALTH_UNKNOWN",
                                "value": "0"
                            },
                            {
                                "desc": "All memory channels are healthy.",
                                "name": "$S_MEM_HEALTH_OK",
                                "value": "1"
                            },
                            {
                                "desc": "Excessive correctable errors have been detected on one or more channels. Device should be reset.",
                                "name": "$S_MEM_HEALTH_DEGRADED",
                                "value": "2"
                            },
                            {
                                "desc": "Operating with reduced memory to cover banks with too many uncorrectable errors.",
                                "name": "$S_MEM_HEALTH_CRITICAL",
                                "value": "3"
                            },
                            {
                                "desc": "Device should be replaced due to excessive uncorrectable errors.",
                                "name": "$S_MEM_HEALTH_REPLACE",
                                "value": "4"
                            }
                        ],
                        "name": "$s_mem_health_t",
                        "type": "enum"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sMemory",
                        "desc": "Memory properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_MEM_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] The memory type",
                                "name": "type",
                                "type": "$s_mem_type_t"
                            },
                            {
                                "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Location of this memory (system, device)",
                                "name": "location",
                                "type": "$s_mem_loc_t"
                            },
                            {
                                "desc": "[out] Physical memory size in bytes. A value of 0 indicates that this property is not known. However, a call to $sMemoryGetState() will correctly return the total size of usable memory.",
                                "name": "physicalSize",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Width of the memory bus. A value of -1 means that this property is unknown.",
                                "name": "busWidth",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[out] The number of memory channels. A value of -1 means that this property is unknown.",
                                "name": "numChannels",
                                "type": "int32_t"
                            }
                        ],
                        "name": "$s_mem_properties_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_state_t",
                        "class": "$sMemory",
                        "desc": "Memory state - health, allocated",
                        "details": [
                            "Percent allocation is given by 100 * (size - free / size.",
                            "Percent free is given by 100 * free / size."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_MEM_STATE",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] Indicates the health of the memory",
                                "name": "health",
                                "type": "$s_mem_health_t"
                            },
                            {
                                "desc": "[out] The free memory in bytes",
                                "name": "free",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] The total allocatable memory in bytes (can be less than the `physicalSize` member of $s_mem_properties_t)",
                                "name": "size",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$s_mem_state_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sMemory",
                        "desc": "Memory bandwidth",
                        "details": [
                            "Percent bandwidth is calculated by taking two snapshots (s1, s2) and using the equation: %bw = 10^6 * ((s2.readCounter - s1.readCounter) + (s2.writeCounter - s1.writeCounter)) / (s2.maxBandwidth * (s2.timestamp - s1.timestamp))",
                            "Counter can roll over and rollover needs to be handled by comparing the current read against the previous read",
                            "Counter is a 32 byte transaction count, which means the calculated delta (delta = current_value - previous_value or delta = 2^32 - previous_value + current_value in case of rollover) needs to be multiplied by 32 to get delta between samples in actual byte count"
                        ],
                        "members": [
                            {
                                "desc": "[out] Total bytes read from memory",
                                "name": "readCounter",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Total bytes written to memory",
                                "name": "writeCounter",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Current maximum bandwidth in units of bytes/sec",
                                "name": "maxBandwidth",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] The timestamp in microseconds when these measurements were sampled.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                                "name": "timestamp",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$s_mem_bandwidth_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sMemory",
                        "desc": "Extension properties for Memory bandwidth",
                        "details": [
                            "Number of counter bits"
                        ],
                        "members": [
                            {
                                "desc": "[out] Returns the number of valid bits in the timestamp values",
                                "name": "memoryTimestampValidBits",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$s_mem_ext_bandwidth_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of memory modules",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "dfed3a82c29b73a59785c50f0149f1e08aa7664d6df89896aded435611614784",
                        "name": "EnumMemoryModules",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phMemory",
                                "type": "$s_mem_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sMemory",
                        "desc": "Get memory properties",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "2edc52add98a0827d5a70353b50c8f94609e0b73407dc2e4c3728c3c40d81171",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hMemory",
                                "type": "$s_mem_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain memory properties.",
                                "name": "pProperties",
                                "type": "$s_mem_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMemory`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sMemory",
                        "desc": "Get memory state - health, allocated",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "2e80e3e679d031450d2f08847fc0d6b6b1fdebb2dcf8981271258777d4d0e83c",
                        "name": "GetState",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hMemory",
                                "type": "$s_mem_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the current health and allocated memory.",
                                "name": "pState",
                                "type": "$s_mem_state_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMemory`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pState`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sMemory",
                        "desc": "Get memory bandwidth",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "659bc6516bf56722790d5d4dd35f93c8e4194e20157b93f6428bb63a2a1c71f5",
                        "name": "GetBandwidth",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hMemory",
                                "type": "$s_mem_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the total number of bytes read from and written to memory, as well as the current maximum bandwidth.",
                                "name": "pBandwidth",
                                "type": "$s_mem_bandwidth_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hMemory`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pBandwidth`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to query this telemetry."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device memory module",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_mem_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sMemory",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Performance factor",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "performance",
                "objects": [
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sPerformanceFactor",
                        "desc": "Static information about a Performance Factor domain",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_PERF_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] True if this Performance Factor affects accelerators located on a sub-device",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Bitfield of accelerator engine types that are affected by this Performance Factor.",
                                "name": "engines",
                                "type": "$s_engine_type_flags_t"
                            }
                        ],
                        "name": "$s_perf_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handles to accelerator domains whose performance can be optimized via a Performance Factor",
                        "details": [
                            "A Performance Factor should be tuned for each workload.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "5fa2bb283f8afdf882e8b81ff0c3eaf65ddf3aa1a473a6ec8e6d3a734f577a49",
                        "name": "EnumPerformanceFactorDomains",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phPerf",
                                "type": "$s_perf_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sPerformanceFactor",
                        "desc": "Get properties about a Performance Factor domain",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "7a0cdafa08fa973d82b00b017b910bc3eb5502945844c43b3172732f4c0fa849",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the Performance Factor domain.",
                                "name": "hPerf",
                                "type": "$s_perf_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain information about the specified Performance Factor domain.",
                                "name": "pProperties",
                                "type": "$s_perf_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPerf`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sPerformanceFactor",
                        "desc": "Get current Performance Factor for a given domain",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "15b340fe44c9a82cac4b502b676604cf2112dd781c8ffa759cfe2b6c60384b4f",
                        "name": "GetConfig",
                        "params": [
                            {
                                "desc": "[in] Handle for the Performance Factor domain.",
                                "name": "hPerf",
                                "type": "$s_perf_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the actual Performance Factor being used by the hardware (may not be the same as the requested Performance Factor).",
                                "name": "pFactor",
                                "type": "double*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPerf`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pFactor`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sPerformanceFactor",
                        "desc": "Change the performance factor for a domain",
                        "details": [
                            "The Performance Factor is a number between 0 and 100.",
                            "A Performance Factor is a hint to the hardware. Depending on the hardware, the request may not be granted. Follow up this function with a call to $sPerformanceFactorGetConfig() to determine the actual factor being used by the hardware.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "f48ab4af9334abc338efe7f1d6ce41a38029af7fe3dac0affe6c8849b3eeb013",
                        "name": "SetConfig",
                        "params": [
                            {
                                "desc": "[in] Handle for the Performance Factor domain.",
                                "name": "hPerf",
                                "type": "$s_perf_handle_t"
                            },
                            {
                                "desc": "[in] The new Performance Factor.",
                                "name": "factor",
                                "type": "double"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPerf`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device performance factor",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_perf_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sPerformanceFactor",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Scheduler management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "power",
                "objects": [
                    {
                        "class": "$sPower",
                        "desc": "Power Domain",
                        "etors": [
                            {
                                "desc": "The PUnit power domain level cannot be determined.",
                                "name": "$S_POWER_DOMAIN_UNKNOWN",
                                "value": "0"
                            },
                            {
                                "desc": "The PUnit power domain is a card-level power domain.",
                                "name": "$S_POWER_DOMAIN_CARD",
                                "value": "1"
                            },
                            {
                                "desc": "The PUnit power domain is a package-level power domain.",
                                "name": "$S_POWER_DOMAIN_PACKAGE",
                                "value": "2"
                            },
                            {
                                "desc": "The PUnit power domain is a stack-level power domain.",
                                "name": "$S_POWER_DOMAIN_STACK",
                                "value": "3"
                            }
                        ],
                        "name": "$s_power_domain_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Power Level Type",
                        "etors": [
                            {
                                "desc": "The PUnit power monitoring duration cannot be determined.",
                                "name": "$S_POWER_LEVEL_UNKNOWN",
                                "value": "0"
                            },
                            {
                                "desc": "The PUnit determines effective power draw by computing a moving average of the actual power draw over a time interval (longer than BURST).",
                                "name": "$S_POWER_LEVEL_SUSTAINED",
                                "value": "1"
                            },
                            {
                                "desc": "The PUnit determines effective power draw by computing a moving average of the actual power draw over a time interval (longer than PEAK).",
                                "name": "$S_POWER_LEVEL_BURST",
                                "value": "2"
                            },
                            {
                                "desc": "The PUnit determines effective power draw by computing a moving average of the actual power draw over a very short time interval.",
                                "name": "$S_POWER_LEVEL_PEAK",
                                "value": "3"
                            },
                            {
                                "desc": "The PUnit predicts effective power draw using the current device configuration (frequency, voltage, etc...) & throttles proactively to stay within the specified limit.",
                                "name": "$S_POWER_LEVEL_INSTANTANEOUS",
                                "value": "4"
                            }
                        ],
                        "name": "$s_power_level_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Power Source Type",
                        "etors": [
                            {
                                "desc": "Limit active no matter whether the power source is mains powered or battery powered.",
                                "name": "$S_POWER_SOURCE_ANY",
                                "value": "0"
                            },
                            {
                                "desc": "Limit active only when the device is mains powered.",
                                "name": "$S_POWER_SOURCE_MAINS",
                                "value": "1"
                            },
                            {
                                "desc": "Limit active only when the device is battery powered.",
                                "name": "$S_POWER_SOURCE_BATTERY",
                                "value": "2"
                            }
                        ],
                        "name": "$s_power_source_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Limit Unit",
                        "etors": [
                            {
                                "desc": "The PUnit power monitoring unit cannot be determined.",
                                "name": "$S_LIMIT_UNIT_UNKNOWN",
                                "value": "0"
                            },
                            {
                                "desc": "The limit is specified in milliamperes of current drawn.",
                                "name": "$S_LIMIT_UNIT_CURRENT",
                                "value": "1"
                            },
                            {
                                "desc": "The limit is specified in milliwatts of power generated.",
                                "name": "$S_LIMIT_UNIT_POWER",
                                "value": "2"
                            }
                        ],
                        "name": "$s_limit_unit_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sPower",
                        "desc": "Properties related to device power settings",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_POWER_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Software can change the power limits of this domain assuming the user has permissions.",
                                "name": "canControl",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Indicates if this power domain supports the energy threshold event ($S_EVENT_TYPE_FLAG_ENERGY_THRESHOLD_CROSSED).",
                                "name": "isEnergyThresholdSupported",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] (Deprecated) The factory default TDP power limit of the part in milliwatts. A value of -1 means that this is not known.",
                                "name": "defaultLimit",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[out] (Deprecated) The minimum power limit in milliwatts that can be requested. A value of -1 means that this is not known.",
                                "name": "minLimit",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[out] (Deprecated) The maximum power limit in milliwatts that can be requested. A value of -1 means that this is not known.",
                                "name": "maxLimit",
                                "type": "int32_t"
                            }
                        ],
                        "name": "$s_power_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Energy counter snapshot",
                        "details": [
                            "Average power is calculated by taking two snapshots (s1, s2) and using the equation: PowerWatts = (s2.energy - s1.energy) / (s2.timestamp - s1.timestamp)"
                        ],
                        "members": [
                            {
                                "desc": "[out] The monotonic energy counter in microjoules.",
                                "name": "energy",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[out] Microsecond timestamp when energy was captured.\nThis timestamp should only be used to calculate delta time between snapshots of this structure.\nNever take the delta of this timestamp with the timestamp from a different structure since they are not guaranteed to have the same base.\nThe absolute value of the timestamp is only valid during within the application and may be different on the next execution.\n",
                                "name": "timestamp",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$s_power_energy_counter_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Sustained power limits",
                        "details": [
                            "The power controller (Punit) will throttle the operating frequency if the power averaged over a window (typically seconds) exceeds this limit."
                        ],
                        "members": [
                            {
                                "desc": "[in,out] indicates if the limit is enabled (true) or ignored (false)",
                                "name": "enabled",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[in,out] power limit in milliwatts",
                                "name": "power",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[in,out] power averaging window (Tau) in milliseconds",
                                "name": "interval",
                                "type": "int32_t"
                            }
                        ],
                        "name": "$s_power_sustained_limit_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Burst power limit",
                        "details": [
                            "The power controller (Punit) will throttle the operating frequency of the device if the power averaged over a few milliseconds exceeds a limit known as PL2. Typically PL2 > PL1 so that it permits the frequency to burst higher for short periods than would be otherwise permitted by PL1."
                        ],
                        "members": [
                            {
                                "desc": "[in,out] indicates if the limit is enabled (true) or ignored (false)",
                                "name": "enabled",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[in,out] power limit in milliwatts",
                                "name": "power",
                                "type": "int32_t"
                            }
                        ],
                        "name": "$s_power_burst_limit_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Peak power limit",
                        "details": [
                            "The power controller (Punit) will reactively/proactively throttle the operating frequency of the device when the instantaneous/100usec power exceeds this limit. The limit is known as PL4 or Psys. It expresses the maximum power that can be drawn from the power supply.",
                            "If this power limit is removed or set too high, the power supply will generate an interrupt when it detects an overcurrent condition and the power controller will throttle the device frequencies down to min. It is thus better to tune the PL4 value in order to avoid such excursions."
                        ],
                        "members": [
                            {
                                "desc": "[in,out] power limit in milliwatts for the AC power source.",
                                "name": "powerAC",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[in,out] power limit in milliwatts for the DC power source. On input, this is ignored if the product does not have a battery. On output, this will be -1 if the product does not have a battery.",
                                "name": "powerDC",
                                "type": "int32_t"
                            }
                        ],
                        "name": "$s_power_peak_limit_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Energy threshold",
                        "details": [
                            "."
                        ],
                        "members": [
                            {
                                "desc": "[in,out] Indicates if the energy threshold is enabled.",
                                "name": "enable",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[in,out] The energy threshold in Joules. Will be 0.0 if no threshold has been set.",
                                "name": "threshold",
                                "type": "double"
                            },
                            {
                                "desc": "[in,out] The host process ID that set the energy threshold. Will be 0xFFFFFFFF if no threshold has been set.",
                                "name": "processId",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$s_energy_threshold_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of power domains",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "a162fab77909ff04da2e08eef1e2cf17487f31ae5a2f4c1a25555f6bf56bc60e",
                        "name": "EnumPowerDomains",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phPower",
                                "type": "$s_pwr_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of the PCIe card-level power",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "047ca99995666fe5cefd48dde4b5e5262fd4ac1916c75723f18649b25c4e6942",
                        "name": "GetCardPowerDomain",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] power domain handle for the entire PCIe card.",
                                "name": "phPower",
                                "type": "$s_pwr_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == phPower`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "The device does not provide access to card level power controls or telemetry. An invalid power domain handle will be returned in phPower."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Get properties related to a power domain",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "0ac3a4c1fa7cf470238a28cc3775ee610214b99c270555dca72f975199288995",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPower",
                                "type": "$s_pwr_handle_t"
                            },
                            {
                                "desc": "[in,out] Structure that will contain property data.",
                                "name": "pProperties",
                                "type": "$s_power_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPower`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Get energy counter",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "55238b643e181150dd35ae06a62b397c7488fdda9c500a0b999b95d00fa07311",
                        "name": "GetEnergyCounter",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPower",
                                "type": "$s_pwr_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the latest snapshot of the energy counter and timestamp when the last counter value was measured.",
                                "name": "pEnergy",
                                "type": "$s_power_energy_counter_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPower`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pEnergy`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Get power limits",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free.",
                            "Note: This function is deprecated and replaced by $sPowerGetLimitsExt."
                        ],
                        "hash": "ed0462ffcd8d44a95439a0ea86fbb1bc0e13e357c0d73fabd1d3322abd658e18",
                        "name": "GetLimits",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPower",
                                "type": "$s_pwr_handle_t"
                            },
                            {
                                "desc": "[in,out][optional] The sustained power limit. If this is null, the current sustained power limits will not be returned.",
                                "name": "pSustained",
                                "type": "$s_power_sustained_limit_t*"
                            },
                            {
                                "desc": "[in,out][optional] The burst power limit. If this is null, the current peak power limits will not be returned.",
                                "name": "pBurst",
                                "type": "$s_power_burst_limit_t*"
                            },
                            {
                                "desc": "[in,out][optional] The peak power limit. If this is null, the peak power limits will not be returned.",
                                "name": "pPeak",
                                "type": "$s_power_peak_limit_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPower`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Set power limits",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free.",
                            "Note: This function is deprecated and replaced by $sPowerSetLimitsExt."
                        ],
                        "hash": "adfce6f8e5ca88571ca8d3c876751c1de2ba0acca3d52639c128be64a18c4550",
                        "name": "SetLimits",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPower",
                                "type": "$s_pwr_handle_t"
                            },
                            {
                                "desc": "[in][optional] The sustained power limit. If this is null, no changes will be made to the sustained power limits.",
                                "name": "pSustained",
                                "type": "const $s_power_sustained_limit_t*"
                            },
                            {
                                "desc": "[in][optional] The burst power limit. If this is null, no changes will be made to the burst power limits.",
                                "name": "pBurst",
                                "type": "const $s_power_burst_limit_t*"
                            },
                            {
                                "desc": "[in][optional] The peak power limit. If this is null, no changes will be made to the peak power limits.",
                                "name": "pPeak",
                                "type": "const $s_power_peak_limit_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPower`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "The device is in use, meaning that the GPU is under Over clocking, applying power limits under overclocking is not supported."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Get energy threshold",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "11e5666d7a95676691c797e7d12570dba7a301c7b51b07fc5e6550764a071806",
                        "name": "GetEnergyThreshold",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPower",
                                "type": "$s_pwr_handle_t"
                            },
                            {
                                "desc": "[in,out] Returns information about the energy threshold setting - enabled/energy threshold/process ID.",
                                "name": "pThreshold",
                                "type": "$s_energy_threshold_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPower`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pThreshold`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Energy threshold not supported on this power domain (check the `isEnergyThresholdSupported` member of $s_power_properties_t)."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to request this feature."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Set energy threshold",
                        "details": [
                            "An event $S_EVENT_TYPE_FLAG_ENERGY_THRESHOLD_CROSSED will be generated when the delta energy consumed starting from this call exceeds the specified threshold. Use the function $sDeviceEventRegister() to start receiving the event.",
                            "Only one running process can control the energy threshold at a given time. If another process attempts to change the energy threshold, the error $X_RESULT_ERROR_NOT_AVAILABLE will be returned. The function $sPowerGetEnergyThreshold() to determine the process ID currently controlling this setting.",
                            "Calling this function will remove any pending energy thresholds and start counting from the time of this call.",
                            "Once the energy threshold has been reached and the event generated, the threshold is automatically removed. It is up to the application to request a new threshold.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "ef52d53f78f5e95a24faf530e9ee0bb353cff7d607cec5a27376f4dd4ebf2255",
                        "name": "SetEnergyThreshold",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPower",
                                "type": "$s_pwr_handle_t"
                            },
                            {
                                "desc": "[in] The energy threshold to be set in joules.",
                                "name": "threshold",
                                "type": "double"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPower`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Energy threshold not supported on this power domain (check the `isEnergyThresholdSupported` member of $s_power_properties_t)."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to request this feature."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "Another running process has set the energy threshold."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device power domain",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_pwr_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sPower",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Firmware management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "psu",
                "objects": [
                    {
                        "class": "$sPsu",
                        "desc": "PSU voltage status",
                        "etors": [
                            {
                                "desc": "The status of the power supply voltage controllers cannot be determined",
                                "name": "$S_PSU_VOLTAGE_STATUS_UNKNOWN",
                                "value": "0"
                            },
                            {
                                "desc": "No unusual voltages have been detected",
                                "name": "$S_PSU_VOLTAGE_STATUS_NORMAL",
                                "value": "1"
                            },
                            {
                                "desc": "Over-voltage has occurred",
                                "name": "$S_PSU_VOLTAGE_STATUS_OVER",
                                "value": "2"
                            },
                            {
                                "desc": "Under-voltage has occurred",
                                "name": "$S_PSU_VOLTAGE_STATUS_UNDER",
                                "value": "3"
                            }
                        ],
                        "name": "$s_psu_voltage_status_t",
                        "type": "enum"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sPsu",
                        "desc": "Static properties of the power supply",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_PSU_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] True if the power supply has a fan",
                                "name": "haveFan",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] The maximum electrical current in milliamperes that can be drawn. A value of -1 indicates that this property cannot be determined.",
                                "name": "ampLimit",
                                "type": "int32_t"
                            }
                        ],
                        "name": "$s_psu_properties_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_state_t",
                        "class": "$sPsu",
                        "desc": "Dynamic state of the power supply",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_PSU_STATE",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[out] The current PSU voltage status",
                                "name": "voltStatus",
                                "type": "$s_psu_voltage_status_t"
                            },
                            {
                                "desc": "[out] Indicates if the fan has failed",
                                "name": "fanFailed",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Read the current heatsink temperature in degrees Celsius. A value of -1 indicates that this property cannot be determined.",
                                "name": "temperature",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[out] The amps being drawn in milliamperes. A value of -1 indicates that this property cannot be determined.",
                                "name": "current",
                                "type": "int32_t"
                            }
                        ],
                        "name": "$s_psu_state_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of power supplies",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "3a4d1abb6eece0119fee707bcd6098ceb8c5cf4a72f955e268dde6b4e94a741c",
                        "name": "EnumPsus",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phPsu",
                                "type": "$s_psu_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sPsu",
                        "desc": "Get power supply properties",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "8d0cf92b0e7647a92d9edffb0a8076d51cd65838300a01acc786e379faf65d92",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPsu",
                                "type": "$s_psu_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the properties of the power supply.",
                                "name": "pProperties",
                                "type": "$s_psu_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPsu`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sPsu",
                        "desc": "Get current power supply state",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "453129fa23bfb6ed587d17b79b631cfe976944dabb190f60efb69d4f4bc7049d",
                        "name": "GetState",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPsu",
                                "type": "$s_psu_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the current state of the power supply.",
                                "name": "pState",
                                "type": "$s_psu_state_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPsu`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pState`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device power supply",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_psu_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sPsu",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Firmware management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "ras",
                "objects": [
                    {
                        "class": "$sRas",
                        "desc": "RAS error type",
                        "etors": [
                            {
                                "desc": "Errors were corrected by hardware",
                                "name": "$S_RAS_ERROR_TYPE_CORRECTABLE",
                                "value": "0"
                            },
                            {
                                "desc": "Error were not corrected",
                                "name": "$S_RAS_ERROR_TYPE_UNCORRECTABLE",
                                "value": "1"
                            }
                        ],
                        "name": "$s_ras_error_type_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sRas",
                        "desc": "RAS error categories",
                        "etors": [
                            {
                                "desc": "The number of accelerator engine resets attempted by the driver",
                                "name": "$S_RAS_ERROR_CAT_RESET",
                                "value": "0"
                            },
                            {
                                "desc": "The number of hardware exceptions generated by the way workloads have programmed the hardware",
                                "name": "$S_RAS_ERROR_CAT_PROGRAMMING_ERRORS",
                                "value": "1"
                            },
                            {
                                "desc": "The number of low level driver communication errors have occurred",
                                "name": "$S_RAS_ERROR_CAT_DRIVER_ERRORS",
                                "value": "2"
                            },
                            {
                                "desc": "The number of errors that have occurred in the compute accelerator hardware",
                                "name": "$S_RAS_ERROR_CAT_COMPUTE_ERRORS",
                                "value": "3"
                            },
                            {
                                "desc": "The number of errors that have occurred in the fixed-function accelerator hardware",
                                "name": "$S_RAS_ERROR_CAT_NON_COMPUTE_ERRORS",
                                "value": "4"
                            },
                            {
                                "desc": "The number of errors that have occurred in caches (L1/L3/register file/shared local memory/sampler)",
                                "name": "$S_RAS_ERROR_CAT_CACHE_ERRORS",
                                "value": "5"
                            },
                            {
                                "desc": "The number of errors that have occurred in the display",
                                "name": "$S_RAS_ERROR_CAT_DISPLAY_ERRORS",
                                "value": "6"
                            }
                        ],
                        "name": "$s_ras_error_cat_t",
                        "type": "enum"
                    },
                    {
                        "desc": "The maximum number of categories",
                        "name": "$S_MAX_RAS_ERROR_CATEGORY_COUNT",
                        "type": "macro",
                        "value": "7"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sRas",
                        "desc": "RAS properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_RAS_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] The type of RAS error",
                                "name": "type",
                                "type": "$s_ras_error_type_t"
                            },
                            {
                                "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$s_ras_properties_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_state_t",
                        "class": "$sRas",
                        "desc": "RAS error details",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_RAS_STATE",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in][out] Breakdown of error by category",
                                "name": "category[$S_MAX_RAS_ERROR_CATEGORY_COUNT]",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$s_ras_state_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_config_t",
                        "class": "$sRas",
                        "desc": "RAS error configuration - thresholds used for triggering RAS events ($S_EVENT_TYPE_FLAG_RAS_CORRECTABLE_ERRORS, $S_EVENT_TYPE_FLAG_RAS_UNCORRECTABLE_ERRORS)",
                        "details": [
                            "The driver maintains a total counter which is updated every time a hardware block covered by the corresponding RAS error set notifies that an error has occurred. When this total count goes above the totalThreshold specified below, a RAS event is triggered.",
                            "The driver also maintains a counter for each category of RAS error (see $s_ras_state_t for a breakdown). Each time a hardware block of that category notifies that an error has occurred, that corresponding category counter is updated. When it goes above the threshold specified in detailedThresholds, a RAS event is triggered."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_RAS_CONFIG",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in,out] If the total RAS errors exceeds this threshold, the event will be triggered. A value of 0ULL disables triggering the event based on the total counter.",
                                "name": "totalThreshold",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[in,out] If the RAS errors for each category exceed the threshold for that category, the event will be triggered. A value of 0ULL will disable an event being triggered for that category.",
                                "name": "detailedThresholds",
                                "type": "$s_ras_state_t"
                            }
                        ],
                        "name": "$s_ras_config_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of all RAS error sets on a device",
                        "details": [
                            "A RAS error set is a collection of RAS error counters of a given type (correctable/uncorrectable) from hardware blocks contained within a sub-device or within the device.",
                            "A device without sub-devices will typically return two handles, one for correctable errors sets and one for uncorrectable error sets.",
                            "A device with sub-devices will return RAS error sets for each sub-device and possibly RAS error sets for hardware blocks outside the sub-devices.",
                            "If the function completes successfully but pCount is set to 0, RAS features are not available/enabled on this device.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "937766bf395b256301368c368e0d399cb0aee34dfdd044da3c2cdb7b29be97a3",
                        "name": "EnumRasErrorSets",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phRas",
                                "type": "$s_ras_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sRas",
                        "desc": "Get RAS properties of a given RAS error set - this enables discovery of the type of RAS error set (correctable/uncorrectable) and if located on a sub-device",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "f30bca24c015dcc7e4609790f05e46643da44e1fa1c9b0341cf1d8078c6ed5e4",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hRas",
                                "type": "$s_ras_handle_t"
                            },
                            {
                                "desc": "[in,out] Structure describing RAS properties",
                                "name": "pProperties",
                                "type": "$s_ras_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hRas`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sRas",
                        "desc": "Get RAS error thresholds that control when RAS events are generated",
                        "details": [
                            "The driver maintains counters for all RAS error sets and error categories. Events are generated when errors occur. The configuration enables setting thresholds to limit when events are sent.",
                            "When a particular RAS correctable error counter exceeds the configured threshold, the event $S_EVENT_TYPE_FLAG_RAS_CORRECTABLE_ERRORS will be triggered.",
                            "When a particular RAS uncorrectable error counter exceeds the configured threshold, the event $S_EVENT_TYPE_FLAG_RAS_UNCORRECTABLE_ERRORS will be triggered.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "0086e397045debf8637442b51b3f13dfbb950573bb08e0fc20ab2473e5470355",
                        "name": "GetConfig",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hRas",
                                "type": "$s_ras_handle_t"
                            },
                            {
                                "desc": "[in,out] Will be populed with the current RAS configuration - thresholds used to trigger events",
                                "name": "pConfig",
                                "type": "$s_ras_config_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hRas`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pConfig`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sRas",
                        "desc": "Set RAS error thresholds that control when RAS events are generated",
                        "details": [
                            "The driver maintains counters for all RAS error sets and error categories. Events are generated when errors occur. The configuration enables setting thresholds to limit when events are sent.",
                            "When a particular RAS correctable error counter exceeds the specified threshold, the event $S_EVENT_TYPE_FLAG_RAS_CORRECTABLE_ERRORS will be generated.",
                            "When a particular RAS uncorrectable error counter exceeds the specified threshold, the event $S_EVENT_TYPE_FLAG_RAS_UNCORRECTABLE_ERRORS will be generated.",
                            "Call $sRasGetState() and set the clear flag to true to restart event generation once counters have exceeded thresholds.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "8d4a05aa119e4379d2b65308164870f616a1286d64c8a8e02580aa2ac4d673b5",
                        "name": "SetConfig",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hRas",
                                "type": "$s_ras_handle_t"
                            },
                            {
                                "desc": "[in] Change the RAS configuration - thresholds used to trigger events",
                                "name": "pConfig",
                                "type": "const $s_ras_config_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hRas`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pConfig`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "Another running process is controlling these settings."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "Don't have permissions to set thresholds."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sRas",
                        "desc": "Get the current value of RAS error counters for a particular error set",
                        "details": [
                            "Clearing errors will affect other threads/applications - the counter values will start from zero.",
                            "Clearing errors requires write permissions.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "99b4653180947ca4b2026e02bea89ec5916e928aae1c6b20016a07c3657bc134",
                        "name": "GetState",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hRas",
                                "type": "$s_ras_handle_t"
                            },
                            {
                                "desc": "[in] Set to 1 to clear the counters of this type",
                                "name": "clear",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[in,out] Breakdown of where errors have occurred",
                                "name": "pState",
                                "type": "$s_ras_state_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hRas`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pState`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "Don't have permissions to clear error counters."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device RAS error set",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_ras_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sRas",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Scheduler management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "scheduler",
                "objects": [
                    {
                        "class": "$sDevice",
                        "desc": "Scheduler mode",
                        "etors": [
                            {
                                "desc": "Multiple applications or contexts are submitting work to the hardware. When higher priority work arrives, the scheduler attempts to pause the current executing work within some timeout interval, then submits the other work.",
                                "name": "$S_SCHED_MODE_TIMEOUT",
                                "value": "0"
                            },
                            {
                                "desc": "The scheduler attempts to fairly timeslice hardware execution time between multiple contexts submitting work to the hardware concurrently.",
                                "name": "$S_SCHED_MODE_TIMESLICE",
                                "value": "1"
                            },
                            {
                                "desc": "Any application or context can run indefinitely on the hardware without being preempted or terminated. All pending work for other contexts must wait until the running context completes with no further submitted work.",
                                "name": "$S_SCHED_MODE_EXCLUSIVE",
                                "value": "2"
                            },
                            {
                                "desc": "This is a special mode that must ben enabled when debugging an application that uses this device e.g. using the Level0 Debug API. It has the effect of disabling any timeouts on workload execution time and will change workload scheduling to ensure debug accuracy.",
                                "name": "$S_SCHED_MODE_COMPUTE_UNIT_DEBUG",
                                "value": "3"
                            }
                        ],
                        "name": "$s_sched_mode_t",
                        "type": "enum"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sScheduler",
                        "desc": "Properties related to scheduler component",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_SCHED_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] True if this resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Software can change the scheduler component configuration assuming the user has permissions.",
                                "name": "canControl",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Bitfield of accelerator engine types that are managed by this scheduler component. Note that there can be more than one scheduler component for the same type of accelerator engine.",
                                "name": "engines",
                                "type": "$s_engine_type_flags_t"
                            },
                            {
                                "desc": "[out] Bitfield of scheduler modes that can be configured for this scheduler component (bitfield of 1<<$s_sched_mode_t).",
                                "name": "supportedModes",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$s_sched_properties_t",
                        "type": "struct"
                    },
                    {
                        "desc": "Disable forward progress guard timeout.",
                        "name": "$S_SCHED_WATCHDOG_DISABLE",
                        "type": "macro",
                        "value": "(~(0ULL))"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sDevice",
                        "desc": "Configuration for timeout scheduler mode ($S_SCHED_MODE_TIMEOUT)",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[in,out] The maximum time in microseconds that the scheduler will wait for a batch of work submitted to a hardware engine to complete or to be preempted so as to run another context.\nIf this time is exceeded, the hardware engine is reset and the context terminated.\nIf set to $S_SCHED_WATCHDOG_DISABLE, a running workload can run as long as it wants without being terminated, but preemption attempts to run other contexts are permitted but not enforced.\n",
                                "name": "watchdogTimeout",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$s_sched_timeout_properties_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sDevice",
                        "desc": "Configuration for timeslice scheduler mode ($S_SCHED_MODE_TIMESLICE)",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[in,out] The average interval in microseconds that a submission for a context will run on a hardware engine before being preempted out to run a pending submission for another context.",
                                "name": "interval",
                                "type": "uint64_t"
                            },
                            {
                                "desc": "[in,out] The maximum time in microseconds that the scheduler will wait to preempt a workload running on an engine before deciding to reset the hardware engine and terminating the associated context.",
                                "name": "yieldTimeout",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$s_sched_timeslice_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Returns handles to scheduler components.",
                        "details": [
                            "Each scheduler component manages the distribution of work across one or more accelerator engines.",
                            "If an application wishes to change the scheduler behavior for all accelerator engines of a specific type (e.g. compute), it should select all the handles where the `engines` member $s_sched_properties_t contains that type.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "fd37b138e4d455f525f8b29c80b71137e78d52c62615dfa008db1a0cc7b7d716",
                        "name": "EnumSchedulers",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phScheduler",
                                "type": "$s_sched_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sScheduler",
                        "desc": "Get properties related to a scheduler component",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "65a7c80ec9d728805fb964d7fd96801b62d577461484aa2498ed29bc45b71364",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hScheduler",
                                "type": "$s_sched_handle_t"
                            },
                            {
                                "desc": "[in,out] Structure that will contain property data.",
                                "name": "pProperties",
                                "type": "$s_sched_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hScheduler`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sScheduler",
                        "desc": "Get current scheduling mode in effect on a scheduler component.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "ff8efe1877bfdddb8ab4c8a3c626ef2f4e6dfca3e49a05ff48fe2c08dc0aa05b",
                        "name": "GetCurrentMode",
                        "params": [
                            {
                                "desc": "[in] Sysman handle for the component.",
                                "name": "hScheduler",
                                "type": "$s_sched_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the current scheduler mode.",
                                "name": "pMode",
                                "type": "$s_sched_mode_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hScheduler`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pMode`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "This scheduler component does not support scheduler modes."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sScheduler",
                        "desc": "Get scheduler config for mode $S_SCHED_MODE_TIMEOUT",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "15bf9620651387ae69552ff0dfacf3fd96d7cd553599e0f549414c62aa97938f",
                        "name": "GetTimeoutModeProperties",
                        "params": [
                            {
                                "desc": "[in] Sysman handle for the component.",
                                "name": "hScheduler",
                                "type": "$s_sched_handle_t"
                            },
                            {
                                "desc": "[in] If TRUE, the driver will return the system default properties for this mode, otherwise it will return the current properties.",
                                "name": "getDefaults",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[in,out] Will contain the current parameters for this mode.",
                                "name": "pConfig",
                                "type": "$s_sched_timeout_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hScheduler`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pConfig`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "This scheduler component does not support scheduler modes."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sScheduler",
                        "desc": "Get scheduler config for mode $S_SCHED_MODE_TIMESLICE",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "4cdaf9f11a323f15db5d9dfa4e9cc43cfc054832618dd32e37ca908c5ea1e348",
                        "name": "GetTimesliceModeProperties",
                        "params": [
                            {
                                "desc": "[in] Sysman handle for the component.",
                                "name": "hScheduler",
                                "type": "$s_sched_handle_t"
                            },
                            {
                                "desc": "[in] If TRUE, the driver will return the system default properties for this mode, otherwise it will return the current properties.",
                                "name": "getDefaults",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[in,out] Will contain the current parameters for this mode.",
                                "name": "pConfig",
                                "type": "$s_sched_timeslice_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hScheduler`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pConfig`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "This scheduler component does not support scheduler modes."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sScheduler",
                        "desc": "Change scheduler mode to $S_SCHED_MODE_TIMEOUT or update scheduler mode parameters if already running in this mode.",
                        "details": [
                            "This mode is optimized for multiple applications or contexts submitting work to the hardware. When higher priority work arrives, the scheduler attempts to pause the current executing work within some timeout interval, then submits the other work.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "3f9453cd11aa3272d37a2631c25d45a0f71a9ae27f29994148f76170753de50c",
                        "name": "SetTimeoutMode",
                        "params": [
                            {
                                "desc": "[in] Sysman handle for the component.",
                                "name": "hScheduler",
                                "type": "$s_sched_handle_t"
                            },
                            {
                                "desc": "[in] The properties to use when configurating this mode.",
                                "name": "pProperties",
                                "type": "$s_sched_timeout_properties_t*"
                            },
                            {
                                "desc": "[in,out] Will be set to TRUE if a device driver reload is needed to apply the new scheduler mode.",
                                "name": "pNeedReload",
                                "type": "$x_bool_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hScheduler`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`",
                                    "`nullptr == pNeedReload`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "This scheduler component does not support scheduler modes."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make this modification."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sScheduler",
                        "desc": "Change scheduler mode to $S_SCHED_MODE_TIMESLICE or update scheduler mode parameters if already running in this mode.",
                        "details": [
                            "This mode is optimized to provide fair sharing of hardware execution time between multiple contexts submitting work to the hardware concurrently.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "11dedcf5e86b6e8f766178a724293a56c52026ebe98f4de0a7501aaf3d6246c0",
                        "name": "SetTimesliceMode",
                        "params": [
                            {
                                "desc": "[in] Sysman handle for the component.",
                                "name": "hScheduler",
                                "type": "$s_sched_handle_t"
                            },
                            {
                                "desc": "[in] The properties to use when configurating this mode.",
                                "name": "pProperties",
                                "type": "$s_sched_timeslice_properties_t*"
                            },
                            {
                                "desc": "[in,out] Will be set to TRUE if a device driver reload is needed to apply the new scheduler mode.",
                                "name": "pNeedReload",
                                "type": "$x_bool_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hScheduler`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`",
                                    "`nullptr == pNeedReload`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "This scheduler component does not support scheduler modes."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make this modification."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sScheduler",
                        "desc": "Change scheduler mode to $S_SCHED_MODE_EXCLUSIVE",
                        "details": [
                            "This mode is optimized for single application/context use-cases. It permits a context to run indefinitely on the hardware without being preempted or terminated. All pending work for other contexts must wait until the running context completes with no further submitted work.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "b3ddcb66d6d358c372478f16c47c422e9b18e2acbd01923f385fd58f394c8a76",
                        "name": "SetExclusiveMode",
                        "params": [
                            {
                                "desc": "[in] Sysman handle for the component.",
                                "name": "hScheduler",
                                "type": "$s_sched_handle_t"
                            },
                            {
                                "desc": "[in,out] Will be set to TRUE if a device driver reload is needed to apply the new scheduler mode.",
                                "name": "pNeedReload",
                                "type": "$x_bool_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hScheduler`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pNeedReload`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "This scheduler component does not support scheduler modes."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make this modification."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sScheduler",
                        "desc": "Change scheduler mode to $S_SCHED_MODE_COMPUTE_UNIT_DEBUG",
                        "details": [
                            "This is a special mode that must ben enabled when debugging an application that uses this device e.g. using the Level0 Debug API.",
                            "It ensures that only one command queue can execute work on the hardware at a given time. Work is permitted to run as long as needed without enforcing any scheduler fairness policies.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "20f2f46d786180d013bcdd048e18fa11689f100439628591f3d4d26a33d3d071",
                        "name": "SetComputeUnitDebugMode",
                        "params": [
                            {
                                "desc": "[in] Sysman handle for the component.",
                                "name": "hScheduler",
                                "type": "$s_sched_handle_t"
                            },
                            {
                                "desc": "[in,out] Will be set to TRUE if a device driver reload is needed to apply the new scheduler mode.",
                                "name": "pNeedReload",
                                "type": "$x_bool_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hScheduler`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pNeedReload`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "This scheduler component does not support scheduler modes."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make this modification."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device scheduler queue",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_sched_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sScheduler",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Standby domains",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "standby",
                "objects": [
                    {
                        "class": "$sStandby",
                        "desc": "Standby hardware components",
                        "etors": [
                            {
                                "desc": "Control the overall standby policy of the device/sub-device",
                                "name": "$S_STANDBY_TYPE_GLOBAL",
                                "value": "0"
                            }
                        ],
                        "name": "$s_standby_type_t",
                        "type": "enum"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sStandby",
                        "desc": "Standby hardware component properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_STANDBY_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] Which standby hardware component this controls",
                                "name": "type",
                                "type": "$s_standby_type_t"
                            },
                            {
                                "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$s_standby_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sStandby",
                        "desc": "Standby promotion modes",
                        "etors": [
                            {
                                "desc": "Best compromise between performance and energy savings.",
                                "name": "$S_STANDBY_PROMO_MODE_DEFAULT",
                                "value": "0"
                            },
                            {
                                "desc": "The device/component will never shutdown. This can improve performance but uses more energy.",
                                "name": "$S_STANDBY_PROMO_MODE_NEVER",
                                "value": "1"
                            }
                        ],
                        "name": "$s_standby_promo_mode_t",
                        "type": "enum"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of standby controls",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "1321756521f332777fba5d6fd3fda68a156551a5378e0256522397b248e220f0",
                        "name": "EnumStandbyDomains",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phStandby",
                                "type": "$s_standby_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sStandby",
                        "desc": "Get standby hardware component properties",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "8c2ca72b71cb172ab9cf558824d44c9c1d0057532e84bc8b6d2ce9e3eedc7c10",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hStandby",
                                "type": "$s_standby_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the standby hardware properties.",
                                "name": "pProperties",
                                "type": "$s_standby_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hStandby`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sStandby",
                        "desc": "Get the current standby promotion mode",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "5b35e78c5cabe67779534fa696ed6b8e877734f8e052462b4e2f0f25c9625092",
                        "name": "GetMode",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hStandby",
                                "type": "$s_standby_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the current standby mode.",
                                "name": "pMode",
                                "type": "$s_standby_promo_mode_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hStandby`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pMode`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sStandby",
                        "desc": "Set standby promotion mode",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "c7ed048761bf7be69e42f0cd80d79177b513cc831bce3fbffb9774c9da950e43",
                        "name": "SetMode",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hStandby",
                                "type": "$s_standby_handle_t"
                            },
                            {
                                "desc": "[in] New standby mode.",
                                "name": "mode",
                                "type": "$s_standby_promo_mode_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hStandby`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$S_STANDBY_PROMO_MODE_NEVER < mode`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman standby control",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_standby_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sStandby",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Tool APIs for System Resource Management (Sysman) - Firmware management",
                    "ordinal": 1000,
                    "type": "header"
                },
                "name": "temperature",
                "objects": [
                    {
                        "class": "$sTemperature",
                        "desc": "Temperature sensors",
                        "etors": [
                            {
                                "desc": "The maximum temperature across all device sensors",
                                "name": "$S_TEMP_SENSORS_GLOBAL",
                                "value": "0"
                            },
                            {
                                "desc": "The maximum temperature across all sensors in the GPU",
                                "name": "$S_TEMP_SENSORS_GPU",
                                "value": "1"
                            },
                            {
                                "desc": "The maximum temperature across all sensors in the local memory",
                                "name": "$S_TEMP_SENSORS_MEMORY",
                                "value": "2"
                            },
                            {
                                "desc": "The minimum temperature across all device sensors",
                                "name": "$S_TEMP_SENSORS_GLOBAL_MIN",
                                "value": "3"
                            },
                            {
                                "desc": "The minimum temperature across all sensors in the GPU",
                                "name": "$S_TEMP_SENSORS_GPU_MIN",
                                "value": "4"
                            },
                            {
                                "desc": "The minimum temperature across all sensors in the local device memory",
                                "name": "$S_TEMP_SENSORS_MEMORY_MIN",
                                "value": "5"
                            }
                        ],
                        "name": "$s_temp_sensors_t",
                        "type": "enum"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sTemperature",
                        "desc": "Temperature sensor properties",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_TEMP_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] Which part of the device the temperature sensor measures",
                                "name": "type",
                                "type": "$s_temp_sensors_t"
                            },
                            {
                                "desc": "[out] True if the resource is located on a sub-device; false means that the resource is on the device of the calling Sysman handle",
                                "name": "onSubdevice",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] If onSubdevice is true, this gives the ID of the sub-device",
                                "name": "subdeviceId",
                                "type": "uint32_t"
                            },
                            {
                                "desc": "[out] Will contain the maximum temperature for the specific device in degrees Celsius.",
                                "name": "maxTemperature",
                                "type": "double"
                            },
                            {
                                "desc": "[out] Indicates if the critical temperature event $S_EVENT_TYPE_FLAG_TEMP_CRITICAL is supported",
                                "name": "isCriticalTempSupported",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Indicates if the temperature threshold 1 event $S_EVENT_TYPE_FLAG_TEMP_THRESHOLD1 is supported",
                                "name": "isThreshold1Supported",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[out] Indicates if the temperature threshold 2 event $S_EVENT_TYPE_FLAG_TEMP_THRESHOLD2 is supported",
                                "name": "isThreshold2Supported",
                                "type": "$x_bool_t"
                            }
                        ],
                        "name": "$s_temp_properties_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sTemperature",
                        "desc": "Temperature sensor threshold",
                        "members": [
                            {
                                "desc": "[in,out] Trigger an event when the temperature crosses from below the threshold to above.",
                                "name": "enableLowToHigh",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[in,out] Trigger an event when the temperature crosses from above the threshold to below.",
                                "name": "enableHighToLow",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[in,out] The threshold in degrees Celsius.",
                                "name": "threshold",
                                "type": "double"
                            }
                        ],
                        "name": "$s_temp_threshold_t",
                        "type": "struct"
                    },
                    {
                        "base": "$s_base_config_t",
                        "class": "$sTemperature",
                        "desc": "Temperature configuration - which events should be triggered and the trigger conditions.",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_TEMP_CONFIG",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in,out] Indicates if event $S_EVENT_TYPE_FLAG_TEMP_CRITICAL should be triggered by the driver.",
                                "name": "enableCritical",
                                "type": "$x_bool_t"
                            },
                            {
                                "desc": "[in,out] Configuration controlling if and when event $S_EVENT_TYPE_FLAG_TEMP_THRESHOLD1 should be triggered by the driver.",
                                "name": "threshold1",
                                "type": "$s_temp_threshold_t"
                            },
                            {
                                "desc": "[in,out] Configuration controlling if and when event $S_EVENT_TYPE_FLAG_TEMP_THRESHOLD2 should be triggered by the driver.",
                                "name": "threshold2",
                                "type": "$s_temp_threshold_t"
                            }
                        ],
                        "name": "$s_temp_config_t",
                        "type": "struct"
                    },
                    {
                        "class": "$sDevice",
                        "desc": "Get handle of temperature sensors",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "75a0cd6be102dba55222d44af450b6940f4bb4a186a27bc64844a76cbdbc39c6",
                        "name": "EnumTemperatureSensors",
                        "params": [
                            {
                                "desc": "[in] Sysman handle of the device.",
                                "name": "hDevice",
                                "type": "$s_device_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of components of this type.\nif count is zero, then the driver shall update the value with the total number of components of this type that are available.\nif count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of handle of components of this type.\nif count is less than the number of components of this type that are available, then the driver shall only retrieve that number of component handles.\n",
                                "name": "phTemperature",
                                "type": "$s_temp_handle_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hDevice`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sTemperature",
                        "desc": "Get temperature sensor properties",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "aed86f68f316999523ed898037cdc44bb6e1a9447b9aed0c17792c9af3b44fef",
                        "name": "GetProperties",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hTemperature",
                                "type": "$s_temp_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the temperature sensor properties.",
                                "name": "pProperties",
                                "type": "$s_temp_properties_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hTemperature`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pProperties`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sTemperature",
                        "desc": "Get temperature configuration for this sensor - which events are triggered and the trigger conditions",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "59b77f7353eacc0c25fea8df764d6ae44f6e0504dd349e8a92cb0db7c1003e9a",
                        "name": "GetConfig",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hTemperature",
                                "type": "$s_temp_handle_t"
                            },
                            {
                                "desc": "[in,out] Returns current configuration.",
                                "name": "pConfig",
                                "type": "$s_temp_config_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hTemperature`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pConfig`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Temperature thresholds are not supported on this temperature sensor. Generally this is only supported for temperature sensor $S_TEMP_SENSORS_GLOBAL.",
                                    "One or both of the thresholds is not supported. Check the `isThreshold1Supported` and `isThreshold2Supported` members of $s_temp_properties_t."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to request this feature."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sTemperature",
                        "desc": "Set temperature configuration for this sensor - indicates which events are triggered and the trigger conditions",
                        "details": [
                            "Events $S_EVENT_TYPE_FLAG_TEMP_CRITICAL will be triggered when temperature reaches the critical range. Use the function $sDeviceEventRegister() to start receiving this event.",
                            "Events $S_EVENT_TYPE_FLAG_TEMP_THRESHOLD1 and $S_EVENT_TYPE_FLAG_TEMP_THRESHOLD2 will be generated when temperature cross the thresholds set using this function. Use the function $sDeviceEventRegister() to start receiving these events.",
                            "Only one running process can set the temperature configuration at a time. If another process attempts to change the configuration, the error $X_RESULT_ERROR_NOT_AVAILABLE will be returned. The function $sTemperatureGetConfig() will return the process ID currently controlling these settings.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "e7c1c15a3b996c73398851cf8822ce99c876e9b834540276ccf63243785b7e69",
                        "name": "SetConfig",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hTemperature",
                                "type": "$s_temp_handle_t"
                            },
                            {
                                "desc": "[in] New configuration.",
                                "name": "pConfig",
                                "type": "const $s_temp_config_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hTemperature`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pConfig`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE": [
                                    "Temperature thresholds are not supported on this temperature sensor. Generally they are only supported for temperature sensor $S_TEMP_SENSORS_GLOBAL.",
                                    "Enabling the critical temperature event is not supported. Check the `isCriticalTempSupported` member of $s_temp_properties_t.",
                                    "One or both of the thresholds is not supported. Check the `isThreshold1Supported` and `isThreshold2Supported` members of $s_temp_properties_t."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to request this feature."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "Another running process is controlling these settings."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ARGUMENT": [
                                    "One or both the thresholds is above TjMax (see $sFrequencyOcGetTjMax()). Temperature thresholds must be below this value."
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sTemperature",
                        "desc": "Get the temperature from a specified sensor",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "6e03eadebfa90ec535691d9f5ee770f0838a4014177254ed824c0f9878e0c4d7",
                        "name": "GetState",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hTemperature",
                                "type": "$s_temp_handle_t"
                            },
                            {
                                "desc": "[in,out] Will contain the temperature read from the specified sensor in degrees Celsius.",
                                "name": "pTemperature",
                                "type": "double*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hTemperature`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pTemperature`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "desc": "C++ wrapper for a Sysman device temperature sensor",
                        "members": [
                            {
                                "desc": "[in] handle of Sysman object",
                                "init": "nullptr",
                                "name": "handle",
                                "type": "$s_temp_handle_t"
                            },
                            {
                                "desc": "[in] pointer to owner object",
                                "name": "pDevice",
                                "type": "$sDevice*"
                            }
                        ],
                        "name": "$sTemperature",
                        "owner": "$sDevice",
                        "type": "class"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Sysman Extension APIs for Power Limits",
                    "ordinal": 1400,
                    "type": "header",
                    "version": "1.4"
                },
                "name": "powerLimits",
                "objects": [
                    {
                        "desc": "Power Limits Extension Name",
                        "name": "$S_POWER_LIMITS_EXT_NAME",
                        "type": "macro",
                        "value": "\"$XS_extension_power_limits\"",
                        "version": "1.4"
                    },
                    {
                        "desc": "Power Limits Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$S_POWER_LIMITS_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$S_POWER_LIMITS_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$s_power_limits_ext_version_t",
                        "type": "enum",
                        "version": "1.4"
                    },
                    {
                        "base": "$s_base_desc_t",
                        "class": "$sPower",
                        "desc": "Device power/current limit descriptor.",
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_POWER_LIMIT_EXT_DESC",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "const void*"
                            },
                            {
                                "desc": "[in,out] duration type over which the power draw is measured, i.e. sustained, burst, peak, or critical.",
                                "name": "level",
                                "type": "$s_power_level_t"
                            },
                            {
                                "desc": "[out] source of power used by the system, i.e. AC or DC.",
                                "name": "source",
                                "type": "$s_power_source_t"
                            },
                            {
                                "desc": "[out] unit used for specifying limit, i.e. current units (milliamps) or power units (milliwatts).",
                                "name": "limitUnit",
                                "type": "$s_limit_unit_t"
                            },
                            {
                                "desc": "[out] indicates if the power limit state (enabled/ignored) can be set (false) or is locked (true).",
                                "name": "enabledStateLocked",
                                "type": "ze_bool_t"
                            },
                            {
                                "desc": "[in,out] indicates if the limit is enabled (true) or ignored (false). If enabledStateIsLocked is True, this value is ignored.",
                                "name": "enabled",
                                "type": "ze_bool_t"
                            },
                            {
                                "desc": "[out] indicates if the interval can be modified (false) or is fixed (true).",
                                "name": "intervalValueLocked",
                                "type": "ze_bool_t"
                            },
                            {
                                "desc": "[in,out] power averaging window in milliseconds. If intervalValueLocked is true, this value is ignored.",
                                "name": "interval",
                                "type": "int32_t"
                            },
                            {
                                "desc": "[out] indicates if the limit can be set (false) or if the limit is fixed (true).",
                                "name": "limitValueLocked",
                                "type": "ze_bool_t"
                            },
                            {
                                "desc": "[in,out] limit value. If limitValueLocked is true, this value is ignored. The value should be provided in the unit specified by limitUnit.",
                                "name": "limit",
                                "type": "int32_t"
                            }
                        ],
                        "name": "$s_power_limit_ext_desc_t",
                        "type": "struct",
                        "version": "1.4"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sPower",
                        "desc": "Extension properties related to device power settings",
                        "details": [
                            "This structure may be returned from $sPowerGetProperties via the `pNext` member of $s_power_properties_t.",
                            "This structure may also be returned from $sPowerGetProperties via the `pNext` member of $s_power_ext_properties_t",
                            "Used for determining the power domain level, i.e. card-level v/s package-level v/s stack-level & the factory default power limits."
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_POWER_EXT_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] domain that the power limit belongs to.",
                                "name": "domain",
                                "type": "$s_power_domain_t"
                            },
                            {
                                "desc": "[out] the factory default limit of the part.",
                                "name": "defaultLimit",
                                "type": "$s_power_limit_ext_desc_t*"
                            }
                        ],
                        "name": "$s_power_ext_properties_t",
                        "type": "struct",
                        "version": "1.4"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Get power limits",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free.",
                            "This function returns all the power limits associated with the supplied power domain."
                        ],
                        "hash": "68f318093a420db4811cba53835f34da4a4fa9ffb3b98d7793765842d0424b8c",
                        "name": "GetLimitsExt",
                        "params": [
                            {
                                "desc": "[in] Power domain handle instance.",
                                "name": "hPower",
                                "type": "$s_pwr_handle_t"
                            },
                            {
                                "desc": "[in,out] Pointer to the number of power limit descriptors. If count is zero, then the driver shall update the value with the total number of components of this type that are available. If count is greater than the number of components of this type that are available, then the driver shall update the value with the correct number of components.",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] Array of query results for power limit descriptors. If count is less than the number of components of this type that are available, then the driver shall only retrieve that number of components.",
                                "name": "pSustained",
                                "type": "$s_power_limit_ext_desc_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPower`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sPower",
                        "desc": "Set power limits",
                        "details": [
                            "The application can only modify unlocked members of the limit descriptors returned by $sPowerGetLimitsExt.",
                            "Not all the limits returned by $sPowerGetLimitsExt need to be supplied to this function.",
                            "Limits do not have to be supplied in the same order as returned by $sPowerGetLimitsExt.",
                            "The same limit can be supplied multiple times. Limits are applied in the order in which they are supplied.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "c3fd274f580f2e3476b92eaf271f4bb46b76ab91842dd1c8af90981870e5098c",
                        "name": "SetLimitsExt",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hPower",
                                "type": "$s_pwr_handle_t"
                            },
                            {
                                "desc": "[in] Pointer to the number of power limit descriptors.",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in][optional][range(0, *pCount)] Array of power limit descriptors.",
                                "name": "pSustained",
                                "type": "$s_power_limit_ext_desc_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hPower`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "User does not have permissions to make these modifications."
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_NOT_AVAILABLE": [
                                    "The device is in use, meaning that the GPU is under Over clocking, applying power limits under overclocking is not supported."
                                ]
                            }
                        ],
                        "type": "function"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Sysman Extension APIs for Engine Activity",
                    "ordinal": 1700,
                    "type": "header",
                    "version": "1.7"
                },
                "name": "engineActivity",
                "objects": [
                    {
                        "desc": "Engine Activity Extension Name",
                        "name": "$S_ENGINE_ACTIVITY_EXT_NAME",
                        "type": "macro",
                        "value": "\"$XS_extension_engine_activity\"",
                        "version": "1.7"
                    },
                    {
                        "desc": "Engine Activity Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$S_ENGINE_ACTIVITY_EXT_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$S_ENGINE_ACTIVITY_EXT_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$s_engine_activity_ext_version_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "base": "$s_base_properties_t",
                        "class": "$sEngine",
                        "desc": "Extension properties related to Engine Groups",
                        "details": [
                            "This structure may be passed to $sEngineGetProperties by having the pNext member of $s_engine_properties_t point at this struct.",
                            "Used for SRIOV per Virtual Function device utilization by $s_engine_group_t"
                        ],
                        "members": [
                            {
                                "desc": "[in] type of this structure",
                                "init": "$S_STRUCTURE_TYPE_ENGINE_EXT_PROPERTIES",
                                "name": "stype",
                                "type": "$s_structure_type_t"
                            },
                            {
                                "desc": "[in,out][optional] must be null or a pointer to an extension-specific structure (i.e. contains stype and pNext).",
                                "init": "nullptr",
                                "name": "pNext",
                                "type": "void*"
                            },
                            {
                                "desc": "[out] Number of Virtual Function(VF) instances associated with engine to monitor the utilization of hardware across all Virtual Function from a Physical Function (PF) instance.\nThese VF-by-VF views should provide engine group and individual engine level granularity.\nThis count represents the number of VF instances that are actively using the resource represented by the engine handle.\n",
                                "name": "countOfVirtualFunctionInstance",
                                "type": "uint32_t"
                            }
                        ],
                        "name": "$s_engine_ext_properties_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "class": "$sEngine",
                        "desc": "Get activity stats for Physical Function (PF) and each Virtual Function (VF) associated with engine group.",
                        "details": [
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "7c7eb1843ce9221ba257b856861d9929463cc144d7c4bbad5350c04491413ccd",
                        "name": "GetActivityExt",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hEngine",
                                "type": "$s_engine_handle_t"
                            },
                            {
                                "desc": "[in,out] Pointer to the number of VF engine stats descriptors.\n  - if count is zero, the driver shall update the value with the total number of engine stats available.\n  - if count is greater than the total number of engine stats available, the driver shall update the value with the correct number of engine stats available.\n  - The count returned is the sum of number of VF instances currently available and the PF instance.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of engine group activity counters.\n  - if count is less than the total number of engine stats available, then driver shall only retrieve that number of stats.\n  - the implementation shall populate the vector with engine stat for PF at index 0 of the vector followed by user provided pCount-1 number of VF engine stats.\n",
                                "name": "pStats",
                                "type": "$s_engine_stats_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hEngine`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_UNSUPPORTED_FEATURE - \"Engine activity extension is not supported in the environment.\"": []
                            }
                        ],
                        "type": "function",
                        "version": "1.7"
                    }
                ]
            },
            {
                "header": {
                    "desc": "Intel $OneApi Level-Zero Sysman Extension APIs for RAS Get State and Clear State",
                    "ordinal": 1700,
                    "type": "header",
                    "version": "1.7"
                },
                "name": "rasState",
                "objects": [
                    {
                        "desc": "RAS Get State Extension Name",
                        "name": "$S_RAS_GET_STATE_EXP_NAME",
                        "type": "macro",
                        "value": "\"$XS_extension_ras_state\"",
                        "version": "1.7"
                    },
                    {
                        "desc": "RAS Get State Extension Version(s)",
                        "etors": [
                            {
                                "desc": "version 1.0",
                                "name": "$S_RAS_STATE_EXP_VERSION_1_0",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            },
                            {
                                "desc": "latest known version",
                                "name": "$S_RAS_STATE_EXP_VERSION_CURRENT",
                                "value": "$X_MAKE_VERSION( 1, 0 )"
                            }
                        ],
                        "name": "$s_ras_state_exp_version_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$sRas",
                        "desc": "RAS error categories",
                        "etors": [
                            {
                                "desc": "The number of accelerator engine resets attempted by the driver",
                                "name": "$S_RAS_ERROR_CATEGORY_EXP_RESET",
                                "value": "0",
                                "version": "1.7"
                            },
                            {
                                "desc": "The number of hardware exceptions generated by the way workloads have programmed the hardware",
                                "name": "$S_RAS_ERROR_CATEGORY_EXP_PROGRAMMING_ERRORS",
                                "value": "1",
                                "version": "1.7"
                            },
                            {
                                "desc": "The number of low level driver communication errors have occurred",
                                "name": "$S_RAS_ERROR_CATEGORY_EXP_DRIVER_ERRORS",
                                "value": "2",
                                "version": "1.7"
                            },
                            {
                                "desc": "The number of errors that have occurred in the compute accelerator hardware",
                                "name": "$S_RAS_ERROR_CATEGORY_EXP_COMPUTE_ERRORS",
                                "value": "3",
                                "version": "1.7"
                            },
                            {
                                "desc": "The number of errors that have occurred in the fixed-function accelerator hardware",
                                "name": "$S_RAS_ERROR_CATEGORY_EXP_NON_COMPUTE_ERRORS",
                                "value": "4",
                                "version": "1.7"
                            },
                            {
                                "desc": "The number of errors that have occurred in caches (L1/L3/register file/shared local memory/sampler)",
                                "name": "$S_RAS_ERROR_CATEGORY_EXP_CACHE_ERRORS",
                                "value": "5",
                                "version": "1.7"
                            },
                            {
                                "desc": "The number of errors that have occurred in the display",
                                "name": "$S_RAS_ERROR_CATEGORY_EXP_DISPLAY_ERRORS",
                                "value": "6",
                                "version": "1.7"
                            },
                            {
                                "desc": "The number of errors that have occurred in Memory",
                                "name": "$S_RAS_ERROR_CATEGORY_EXP_MEMORY_ERRORS",
                                "value": "7",
                                "version": "1.7"
                            },
                            {
                                "desc": "The number of errors that have occurred in Scale Fabric",
                                "name": "$S_RAS_ERROR_CATEGORY_EXP_SCALE_ERRORS",
                                "value": "8",
                                "version": "1.7"
                            },
                            {
                                "desc": "The number of errors that have occurred in L3 Fabric",
                                "name": "$S_RAS_ERROR_CATEGORY_EXP_L3FABRIC_ERRORS",
                                "value": "9",
                                "version": "1.7"
                            }
                        ],
                        "name": "$s_ras_error_category_exp_t",
                        "type": "enum",
                        "version": "1.7"
                    },
                    {
                        "class": "$sRas",
                        "desc": "Extension structure for providing RAS error counters for different error sets",
                        "members": [
                            {
                                "desc": "[out] category for which error counter is provided.",
                                "name": "category",
                                "type": "$s_ras_error_category_exp_t"
                            },
                            {
                                "desc": "[out] Current value of RAS counter for specific error category.",
                                "name": "errorCounter",
                                "type": "uint64_t"
                            }
                        ],
                        "name": "$s_ras_state_exp_t",
                        "type": "struct",
                        "version": "1.7"
                    },
                    {
                        "class": "$sRas",
                        "desc": "Ras Get State",
                        "details": [
                            "This function retrieves error counters for different RAS error categories.",
                            "The application may call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "9e9e646c541c50da30308738da88832993b6df10556583499dff169f46e4b908",
                        "name": "GetStateExp",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hRas",
                                "type": "$s_ras_handle_t"
                            },
                            {
                                "desc": "[in,out] pointer to the number of RAS state structures that can be retrieved.\nif count is zero, then the driver shall update the value with the total number of error categories for which state can be retrieved.\nif count is greater than the number of RAS states available, then the driver shall update the value with the correct number of RAS states available.\n",
                                "name": "pCount",
                                "type": "uint32_t*"
                            },
                            {
                                "desc": "[in,out][optional][range(0, *pCount)] array of query results for RAS error states for different categories.\nif count is less than the number of RAS states available, then driver shall only retrieve that number of RAS states.\n",
                                "name": "pState",
                                "type": "$s_ras_state_exp_t*"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hRas`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_POINTER": [
                                    "`nullptr == pCount`"
                                ]
                            }
                        ],
                        "type": "function"
                    },
                    {
                        "class": "$sRas",
                        "desc": "Ras Clear State",
                        "details": [
                            "This function clears error counters for a RAS error category.",
                            "Clearing errors will affect other threads/applications - the counter values will start from zero.",
                            "Clearing errors requires write permissions.",
                            "The application should not call this function from simultaneous threads.",
                            "The implementation of this function should be lock-free."
                        ],
                        "hash": "94c31ad19460e9ec5a14b5d704aa570c4b03bf09d0a0c48838190b0a3e50f362",
                        "name": "ClearStateExp",
                        "params": [
                            {
                                "desc": "[in] Handle for the component.",
                                "name": "hRas",
                                "type": "$s_ras_handle_t"
                            },
                            {
                                "desc": "[in] category for which error counter is to be cleared.",
                                "name": "category",
                                "type": "$s_ras_error_category_exp_t"
                            }
                        ],
                        "returns": [
                            {
                                "$X_RESULT_SUCCESS": []
                            },
                            {
                                "$X_RESULT_ERROR_UNINITIALIZED": []
                            },
                            {
                                "$X_RESULT_ERROR_DEVICE_LOST": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_HOST_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_OUT_OF_DEVICE_MEMORY": []
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_NULL_HANDLE": [
                                    "`nullptr == hRas`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INVALID_ENUMERATION": [
                                    "`$S_RAS_ERROR_CATEGORY_EXP_L3FABRIC_ERRORS < category`"
                                ]
                            },
                            {
                                "$X_RESULT_ERROR_INSUFFICIENT_PERMISSIONS": [
                                    "Don't have permissions to clear error counters."
                                ]
                            }
                        ],
                        "type": "function"
                    }
                ]
            }
        ]
    ]
}